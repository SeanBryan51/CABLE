var tipuesearch = {"pages":[{"title":" POP ","text":"POP The Community Atmosphere Biosphere Land Exchange (CABLE) model is developed by a community of users under the CSIRO - MIT BSD license. In particular, CABLE is used as the land surface model for the ACCESS coupled climate model supported in Australia for the Australian research community. Developer Info CABLE community","tags":"home","loc":"index.html"},{"title":"casa_biome – POP ","text":"type, public :: casa_biome Contents Variables ivt2 xkleafcoldmax xkleafcoldexp xkleafdrymax xkleafdryexp glaimax glaimin sla ratiofrootleaf kroot krootlen rootdepth kuptake kminN kuplabP kclabrate xnpmax q10soil xkoptlitter xkoptsoil xkplab xkpsorb xkpocc prodptase costnpup maxfinelitter maxcwd nintercept nslope la_to_sa vcmax_scalar disturbance_interval DAMM_EnzPool DAMM_KMO2 DAMM_KMcp DAMM_Ea DAMM_alpha plantrate rmplant fracnpptoP fraclignin fraclabile ratioNCplantmin ratioNCplantmax ratioNPplantmin ratioNPplantmax fracLigninplant ftransNPtoL ftransPPtoL litterrate ratioPcplantmin ratioPcplantmax soilrate Components Type Visibility Attributes Name Initial integer, public, dimension(:), pointer :: ivt2 => null() real(kind=r_2), public, dimension(:), pointer :: xkleafcoldmax => null() real(kind=r_2), public, dimension(:), pointer :: xkleafcoldexp => null() real(kind=r_2), public, dimension(:), pointer :: xkleafdrymax => null() real(kind=r_2), public, dimension(:), pointer :: xkleafdryexp => null() real(kind=r_2), public, dimension(:), pointer :: glaimax => null() real(kind=r_2), public, dimension(:), pointer :: glaimin => null() real(kind=r_2), public, dimension(:), pointer :: sla => null() real(kind=r_2), public, dimension(:), pointer :: ratiofrootleaf => null() real(kind=r_2), public, dimension(:), pointer :: kroot => null() real(kind=r_2), public, dimension(:), pointer :: krootlen => null() real(kind=r_2), public, dimension(:), pointer :: rootdepth => null() real(kind=r_2), public, dimension(:), pointer :: kuptake => null() real(kind=r_2), public, dimension(:), pointer :: kminN => null() real(kind=r_2), public, dimension(:), pointer :: kuplabP => null() real(kind=r_2), public, dimension(:), pointer :: kclabrate => null() real(kind=r_2), public, dimension(:), pointer :: xnpmax => null() real(kind=r_2), public, dimension(:), pointer :: q10soil => null() real(kind=r_2), public, dimension(:), pointer :: xkoptlitter => null() real(kind=r_2), public, dimension(:), pointer :: xkoptsoil => null() real(kind=r_2), public, dimension(:), pointer :: xkplab => null() real(kind=r_2), public, dimension(:), pointer :: xkpsorb => null() real(kind=r_2), public, dimension(:), pointer :: xkpocc => null() real(kind=r_2), public, dimension(:), pointer :: prodptase => null() real(kind=r_2), public, dimension(:), pointer :: costnpup => null() real(kind=r_2), public, dimension(:), pointer :: maxfinelitter => null() real(kind=r_2), public, dimension(:), pointer :: maxcwd => null() real(kind=r_2), public, dimension(:), pointer :: nintercept => null() real(kind=r_2), public, dimension(:), pointer :: nslope => null() real(kind=r_2), public, dimension(:), pointer :: la_to_sa => null() real(kind=r_2), public, dimension(:), pointer :: vcmax_scalar => null() real(kind=r_2), public, dimension(:), pointer :: disturbance_interval => null() real(kind=r_2), public, dimension(:), pointer :: DAMM_EnzPool => null() real(kind=r_2), public, dimension(:), pointer :: DAMM_KMO2 => null() real(kind=r_2), public, dimension(:), pointer :: DAMM_KMcp => null() real(kind=r_2), public, dimension(:), pointer :: DAMM_Ea => null() real(kind=r_2), public, dimension(:), pointer :: DAMM_alpha => null() real(kind=r_2), public, dimension(:,:), pointer :: plantrate => null() real(kind=r_2), public, dimension(:,:), pointer :: rmplant => null() real(kind=r_2), public, dimension(:,:), pointer :: fracnpptoP => null() real(kind=r_2), public, dimension(:,:), pointer :: fraclignin => null() real(kind=r_2), public, dimension(:,:), pointer :: fraclabile => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNCplantmin => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNCplantmax => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNPplantmin => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNPplantmax => null() real(kind=r_2), public, dimension(:,:), pointer :: fracLigninplant => null() real(kind=r_2), public, dimension(:,:), pointer :: ftransNPtoL => null() real(kind=r_2), public, dimension(:,:), pointer :: ftransPPtoL => null() real(kind=r_2), public, dimension(:,:), pointer :: litterrate => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioPcplantmin => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioPcplantmax => null() real(kind=r_2), public, dimension(:,:), pointer :: soilrate => null()","tags":"","loc":"type/casa_biome.html"},{"title":"casa_pool – POP ","text":"type, public :: casa_pool Contents Variables Clabile dClabiledt Ctot Ctot_0 Cplant Nplant Pplant dCplantdt dNplantdt dPplantdt ratioNCplant ratioNPplant Nsoilmin Psoillab Psoilsorb Psoilocc dNsoilmindt dPsoillabdt dPsoilsorbdt dPsoiloccdt Clitter Nlitter Plitter dClitterdt dNlitterdt dPlitterdt ratioNClitter ratioNPlitter Csoil Nsoil Psoil dCsoildt dNsoildt dPsoildt ratioNCsoil ratioNCsoilnew ratioNPsoil ratioNCsoilmin ratioNCsoilmax ratioPCsoil ratioPCplant ratioPClitter Components Type Visibility Attributes Name Initial real(kind=r_2), public, dimension(:), pointer :: Clabile => null() vh_js !! real(kind=r_2), public, dimension(:), pointer :: dClabiledt => null() vh_js !! real(kind=r_2), public, dimension(:), pointer :: Ctot => null() vh_js !! real(kind=r_2), public, dimension(:), pointer :: Ctot_0 => null() vh_js !! real(kind=r_2), public, dimension(:,:), pointer :: Cplant => null() real(kind=r_2), public, dimension(:,:), pointer :: Nplant => null() real(kind=r_2), public, dimension(:,:), pointer :: Pplant => null() real(kind=r_2), public, dimension(:,:), pointer :: dCplantdt => null() real(kind=r_2), public, dimension(:,:), pointer :: dNplantdt => null() real(kind=r_2), public, dimension(:,:), pointer :: dPplantdt => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNCplant => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNPplant => null() real(kind=r_2), public, dimension(:), pointer :: Nsoilmin => null() real(kind=r_2), public, dimension(:), pointer :: Psoillab => null() real(kind=r_2), public, dimension(:), pointer :: Psoilsorb => null() real(kind=r_2), public, dimension(:), pointer :: Psoilocc => null() real(kind=r_2), public, dimension(:), pointer :: dNsoilmindt => null() real(kind=r_2), public, dimension(:), pointer :: dPsoillabdt => null() real(kind=r_2), public, dimension(:), pointer :: dPsoilsorbdt => null() real(kind=r_2), public, dimension(:), pointer :: dPsoiloccdt => null() real(kind=r_2), public, dimension(:,:), pointer :: Clitter => null() real(kind=r_2), public, dimension(:,:), pointer :: Nlitter => null() real(kind=r_2), public, dimension(:,:), pointer :: Plitter => null() real(kind=r_2), public, dimension(:,:), pointer :: dClitterdt => null() real(kind=r_2), public, dimension(:,:), pointer :: dNlitterdt => null() real(kind=r_2), public, dimension(:,:), pointer :: dPlitterdt => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNClitter => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNPlitter => null() real(kind=r_2), public, dimension(:,:), pointer :: Csoil => null() real(kind=r_2), public, dimension(:,:), pointer :: Nsoil => null() real(kind=r_2), public, dimension(:,:), pointer :: Psoil => null() real(kind=r_2), public, dimension(:,:), pointer :: dCsoildt => null() real(kind=r_2), public, dimension(:,:), pointer :: dNsoildt => null() real(kind=r_2), public, dimension(:,:), pointer :: dPsoildt => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNCsoil => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNCsoilnew => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNPsoil => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNCsoilmin => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNCsoilmax => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioPCsoil => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioPCplant => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioPClitter => null()","tags":"","loc":"type/casa_pool.html"},{"title":"casa_flux – POP ","text":"type, public :: casa_flux Contents Variables Cgpp Cnpp Crp Crgplant Nminfix Nminuptake Plabuptake Clabloss fracClabile stemnpp frac_sapwood sapwood_area Charvest Nharvest Pharvest fHarvest fcrop fracCalloc fracNalloc fracPalloc Crmplant kplant Cplant_turnover fromPtoL Cnep Crsoil Nmindep Nminloss Nminleach Nupland Nlittermin Nsmin Nsimm Nsnet fNminloss fNminleach Pdep Pwea Pleach Ploss Pupland Plittermin Psmin Psimm Psnet fPleach kplab kpsorb kpocc kmlabp Psorbmax Cplant_turnover_disturbance Cplant_turnover_crowding Cplant_turnover_resource_limitation klitter ksoil fromLtoS fromStoS fromLtoCO2 fromStoCO2 FluxCtolitter FluxNtolitter FluxPtolitter FluxCtosoil FluxNtosoil FluxPtosoil FluxCtoCO2 FluxCtohwp FluxNtohwp FluxPtohwp FluxCtoclear FluxNtoclear FluxPtoclear CtransferLUC fromPtoL_fire klitter_fire klitter_tot kplant_fire kplant_tot fluxCtoCO2_plant_fire fluxCtoCO2_litter_fire fluxfromPtoCO2_fire fluxfromLtoCO2_fire fluxNtoAtm_fire FluxFromPtoL FluxFromLtoS FluxFromStoS FluxFromPtoCO2 FluxFromLtoCO2 FluxFromStoCO2 FluxFromPtoHarvest Components Type Visibility Attributes Name Initial real(kind=r_2), public, dimension(:), pointer :: Cgpp => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Cnpp => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Crp => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Crgplant => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Nminfix => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Nminuptake => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Plabuptake => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Clabloss => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: fracClabile => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: stemnpp => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: frac_sapwood => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: sapwood_area => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Charvest => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Nharvest => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Pharvest => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: fHarvest => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: fcrop => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:,:), pointer :: fracCalloc => null() vh_js !! additional diagnostic real(kind=r_2), public, dimension(:,:), pointer :: fracNalloc => null() vh_js !! additional diagnostic real(kind=r_2), public, dimension(:,:), pointer :: fracPalloc => null() vh_js !! additional diagnostic real(kind=r_2), public, dimension(:,:), pointer :: Crmplant => null() vh_js !! additional diagnostic real(kind=r_2), public, dimension(:,:), pointer :: kplant => null() vh_js !! additional diagnostic real(kind=r_2), public, dimension(:,:), pointer :: Cplant_turnover => null() vh_js !! additional diagnostic real(kind=r_2), public, dimension(:,:,:), pointer :: fromPtoL => null() real(kind=r_2), public, dimension(:), pointer :: Cnep => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Crsoil => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nmindep => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nminloss => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nminleach => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nupland => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nlittermin => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nsmin => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nsimm => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nsnet => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: fNminloss => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: fNminleach => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Pdep => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Pwea => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Pleach => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Ploss => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Pupland => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Plittermin => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Psmin => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Psimm => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Psnet => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: fPleach => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: kplab => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: kpsorb => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: kpocc => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: kmlabp => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Psorbmax => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Cplant_turnover_disturbance => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Cplant_turnover_crowding => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Cplant_turnover_resource_limitation => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:,:), pointer :: klitter => null() real(kind=r_2), public, dimension(:,:), pointer :: ksoil => null() real(kind=r_2), public, dimension(:,:,:), pointer :: fromLtoS => null() real(kind=r_2), public, dimension(:,:,:), pointer :: fromStoS => null() real(kind=r_2), public, dimension(:,:), pointer :: fromLtoCO2 => null() real(kind=r_2), public, dimension(:,:), pointer :: fromStoCO2 => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxCtolitter => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxNtolitter => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxPtolitter => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxCtosoil => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxNtosoil => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxPtosoil => null() real(kind=r_2), public, dimension(:), pointer :: FluxCtoCO2 => null() real(kind=r_2), public, dimension(:), pointer :: FluxCtohwp => null() real(kind=r_2), public, dimension(:), pointer :: FluxNtohwp => null() real(kind=r_2), public, dimension(:), pointer :: FluxPtohwp => null() real(kind=r_2), public, dimension(:), pointer :: FluxCtoclear => null() real(kind=r_2), public, dimension(:), pointer :: FluxNtoclear => null() real(kind=r_2), public, dimension(:), pointer :: FluxPtoclear => null() real(kind=r_2), public, dimension(:), pointer :: CtransferLUC => null() real(kind=r_2), public, dimension(:,:,:), pointer :: fromPtoL_fire => null() real(kind=r_2), public, dimension(:,:), pointer :: klitter_fire => null() real(kind=r_2), public, dimension(:,:), pointer :: klitter_tot => null() real(kind=r_2), public, dimension(:,:), pointer :: kplant_fire => null() real(kind=r_2), public, dimension(:,:), pointer :: kplant_tot => null() real(kind=r_2), public, dimension(:), pointer :: fluxCtoCO2_plant_fire => null() real(kind=r_2), public, dimension(:), pointer :: fluxCtoCO2_litter_fire => null() real(kind=r_2), public, dimension(:,:), pointer :: fluxfromPtoCO2_fire => null() real(kind=r_2), public, dimension(:,:), pointer :: fluxfromLtoCO2_fire => null() real(kind=r_2), public, dimension(:), pointer :: fluxNtoAtm_fire => null() real(kind=r_2), public, dimension(:,:,:), pointer :: FluxFromPtoL => null() real(kind=r_2), public, dimension(:,:,:), pointer :: FluxFromLtoS => null() real(kind=r_2), public, dimension(:,:,:), pointer :: FluxFromStoS => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxFromPtoCO2 => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxFromLtoCO2 => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxFromStoCO2 => null() real(kind=r_2), public, dimension(:), pointer :: FluxFromPtoHarvest => null()","tags":"","loc":"type/casa_flux.html"},{"title":"casa_met – POP ","text":"type, public :: casa_met Contents Variables glai Tairk precip tsoilavg moistavg btran lnonwood Tsoil moist iveg2 ijgcm isorder lat lon areacell Tairkspin cgppspin crmplantspin_1 crmplantspin_2 crmplantspin_3 Tsoilspin_1 Tsoilspin_2 Tsoilspin_3 Tsoilspin_4 Tsoilspin_5 Tsoilspin_6 moistspin_1 moistspin_2 moistspin_3 moistspin_4 moistspin_5 moistspin_6 mtempspin frecspin cAn12spin cAn13spin dprecip_spin aprecip_av20_spin du10_max_spin drhum_spin dtemp_max_spin dtemp_min_spin KBDI_spin D_MacArthur_spin FFDI_spin last_precip_spin DSLR_spin Components Type Visibility Attributes Name Initial real(kind=r_2), public, dimension(:), pointer :: glai => null() real(kind=r_2), public, dimension(:), pointer :: Tairk => null() real(kind=r_2), public, dimension(:), pointer :: precip => null() real(kind=r_2), public, dimension(:), pointer :: tsoilavg => null() real(kind=r_2), public, dimension(:), pointer :: moistavg => null() real(kind=r_2), public, dimension(:), pointer :: btran => null() integer, public, dimension(:), pointer :: lnonwood => null() real(kind=r_2), public, dimension(:,:), pointer :: Tsoil => null() real(kind=r_2), public, dimension(:,:), pointer :: moist => null() integer, public, dimension(:), pointer :: iveg2 => null() integer, public, dimension(:), pointer :: ijgcm => null() integer, public, dimension(:), pointer :: isorder => null() real(kind=r_2), public, dimension(:), pointer :: lat => null() real(kind=r_2), public, dimension(:), pointer :: lon => null() real(kind=r_2), public, dimension(:), pointer :: areacell => null() real(kind=r_2), public, dimension(:,:), pointer :: Tairkspin => null() real(kind=r_2), public, dimension(:,:), pointer :: cgppspin => null() real(kind=r_2), public, dimension(:,:), pointer :: crmplantspin_1 => null() real(kind=r_2), public, dimension(:,:), pointer :: crmplantspin_2 => null() real(kind=r_2), public, dimension(:,:), pointer :: crmplantspin_3 => null() real(kind=r_2), public, dimension(:,:), pointer :: Tsoilspin_1 => null() real(kind=r_2), public, dimension(:,:), pointer :: Tsoilspin_2 => null() real(kind=r_2), public, dimension(:,:), pointer :: Tsoilspin_3 => null() real(kind=r_2), public, dimension(:,:), pointer :: Tsoilspin_4 => null() real(kind=r_2), public, dimension(:,:), pointer :: Tsoilspin_5 => null() real(kind=r_2), public, dimension(:,:), pointer :: Tsoilspin_6 => null() real(kind=r_2), public, dimension(:,:), pointer :: moistspin_1 => null() real(kind=r_2), public, dimension(:,:), pointer :: moistspin_2 => null() real(kind=r_2), public, dimension(:,:), pointer :: moistspin_3 => null() real(kind=r_2), public, dimension(:,:), pointer :: moistspin_4 => null() real(kind=r_2), public, dimension(:,:), pointer :: moistspin_5 => null() real(kind=r_2), public, dimension(:,:), pointer :: moistspin_6 => null() real(kind=r_2), public, dimension(:,:), pointer :: mtempspin => null() real(kind=r_2), public, dimension(:,:), pointer :: frecspin => null() real(kind=r_2), public, dimension(:,:), pointer :: cAn12spin => null() real(kind=r_2), public, dimension(:,:), pointer :: cAn13spin => null() real(kind=r_2), public, dimension(:,:), pointer :: dprecip_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: aprecip_av20_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: du10_max_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: drhum_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: dtemp_max_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: dtemp_min_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: KBDI_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: D_MacArthur_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: FFDI_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: last_precip_spin => null() integer, public, dimension(:,:), pointer :: DSLR_spin => null()","tags":"","loc":"type/casa_met.html"},{"title":"casa_balance – POP ","text":"type, public :: casa_balance Contents Variables FCgppyear FCnppyear FCrmleafyear FCrmwoodyear FCrmrootyear FCrgrowyear FCrpyear FCrsyear FCneeyear dCdtyear LAImax Cleafmean Crootmean FNdepyear FNfixyear FNsnetyear FNupyear FNleachyear FNlossyear FPweayear FPdustyear FPsnetyear FPupyear FPleachyear FPlossyear glaimon glaimonx cplantlast nplantlast pplantlast clitterlast nlitterlast plitterlast csoillast nsoillast psoillast nsoilminlast psoillablast psoilsorblast psoilocclast cbalance nbalance pbalance sumcbal sumnbal sumpbal clabilelast Components Type Visibility Attributes Name Initial real(kind=r_2), public, dimension(:), pointer :: FCgppyear => null() real(kind=r_2), public, dimension(:), pointer :: FCnppyear => null() real(kind=r_2), public, dimension(:), pointer :: FCrmleafyear => null() real(kind=r_2), public, dimension(:), pointer :: FCrmwoodyear => null() real(kind=r_2), public, dimension(:), pointer :: FCrmrootyear => null() real(kind=r_2), public, dimension(:), pointer :: FCrgrowyear => null() real(kind=r_2), public, dimension(:), pointer :: FCrpyear => null() real(kind=r_2), public, dimension(:), pointer :: FCrsyear => null() real(kind=r_2), public, dimension(:), pointer :: FCneeyear => null() real(kind=r_2), public, dimension(:), pointer :: dCdtyear => null() real(kind=r_2), public, dimension(:), pointer :: LAImax => null() real(kind=r_2), public, dimension(:), pointer :: Cleafmean => null() real(kind=r_2), public, dimension(:), pointer :: Crootmean => null() real(kind=r_2), public, dimension(:), pointer :: FNdepyear => null() real(kind=r_2), public, dimension(:), pointer :: FNfixyear => null() real(kind=r_2), public, dimension(:), pointer :: FNsnetyear => null() real(kind=r_2), public, dimension(:), pointer :: FNupyear => null() real(kind=r_2), public, dimension(:), pointer :: FNleachyear => null() real(kind=r_2), public, dimension(:), pointer :: FNlossyear => null() real(kind=r_2), public, dimension(:), pointer :: FPweayear => null() real(kind=r_2), public, dimension(:), pointer :: FPdustyear => null() real(kind=r_2), public, dimension(:), pointer :: FPsnetyear => null() real(kind=r_2), public, dimension(:), pointer :: FPupyear => null() real(kind=r_2), public, dimension(:), pointer :: FPleachyear => null() real(kind=r_2), public, dimension(:), pointer :: FPlossyear => null() real(kind=r_2), public, dimension(:,:), pointer :: glaimon => null() real(kind=r_2), public, dimension(:,:), pointer :: glaimonx => null() real(kind=r_2), public, dimension(:,:), pointer :: cplantlast => null() real(kind=r_2), public, dimension(:,:), pointer :: nplantlast => null() real(kind=r_2), public, dimension(:,:), pointer :: pplantlast => null() real(kind=r_2), public, dimension(:,:), pointer :: clitterlast => null() real(kind=r_2), public, dimension(:,:), pointer :: nlitterlast => null() real(kind=r_2), public, dimension(:,:), pointer :: plitterlast => null() real(kind=r_2), public, dimension(:,:), pointer :: csoillast => null() real(kind=r_2), public, dimension(:,:), pointer :: nsoillast => null() real(kind=r_2), public, dimension(:,:), pointer :: psoillast => null() real(kind=r_2), public, dimension(:), pointer :: nsoilminlast => null() real(kind=r_2), public, dimension(:), pointer :: psoillablast => null() real(kind=r_2), public, dimension(:), pointer :: psoilsorblast => null() real(kind=r_2), public, dimension(:), pointer :: psoilocclast => null() real(kind=r_2), public, dimension(:), pointer :: cbalance => null() real(kind=r_2), public, dimension(:), pointer :: nbalance => null() real(kind=r_2), public, dimension(:), pointer :: pbalance => null() real(kind=r_2), public, dimension(:), pointer :: sumcbal => null() real(kind=r_2), public, dimension(:), pointer :: sumnbal => null() real(kind=r_2), public, dimension(:), pointer :: sumpbal => null() real(kind=r_2), public, dimension(:), pointer :: clabilelast => null()","tags":"","loc":"type/casa_balance.html"},{"title":"casafiles_type – POP ","text":"type, public :: casafiles_type Contents Variables cnpbiome cnppoint cnpepool cnpipool cnpmetin cnpmetout ndep cnpspin dump_cnpspin phen cnpflux l_ndep c2cdumppath out Components Type Visibility Attributes Name Initial character(len=200), public :: cnpbiome character(len=200), public :: cnppoint character(len=200), public :: cnpepool character(len=200), public :: cnpipool = '' character(len=200), public :: cnpmetin character(len=200), public :: cnpmetout character(len=200), public :: ndep character(len=200), public :: cnpspin character(len=200), public :: dump_cnpspin character(len=200), public :: phen character(len=200), public :: cnpflux logical, public :: l_ndep character(len=200), public :: c2cdumppath = '' character(len=200), public :: out = ''","tags":"","loc":"type/casafiles_type.html"},{"title":"phen_variable – POP ","text":"type, public :: phen_variable Contents Variables phase TKshed doyphase phen aphen phasespin doyphasespin_1 doyphasespin_2 doyphasespin_3 doyphasespin_4 Components Type Visibility Attributes Name Initial integer, public, dimension(:), pointer :: phase => null() real(kind=r_2), public, dimension(:), pointer :: TKshed => null() integer, public, dimension(:,:), pointer :: doyphase => null() real, public, dimension(:), pointer :: phen => null() real, public, dimension(:), pointer :: aphen => null() integer, public, dimension(:,:), pointer :: phasespin => null() integer, public, dimension(:,:), pointer :: doyphasespin_1 => null() integer, public, dimension(:,:), pointer :: doyphasespin_2 => null() integer, public, dimension(:,:), pointer :: doyphasespin_3 => null() integer, public, dimension(:,:), pointer :: doyphasespin_4 => null()","tags":"","loc":"type/phen_variable.html"},{"title":"POPLUC_TYPE – POP ","text":"type, public :: POPLUC_TYPE Contents Variables it np firstyear thisyear n_event latitude longitude primf secdf grass ptos ptog stog gtop gtos frac_primf frac_forest crop past ptoc ptoq stoc stoq qtos ctos freq_age_primary freq_age_secondary biomass_age_primary biomass_age_secondary age_history_secdf area_history_secdf FNEP Clitt Csoil Cbiomass FHarvest FClearance FTransferNet FTransferGross pharv smharv syharv AgProd AgProdLoss FAg HarvProd ClearProd fracHarvProd fracClearProd HarvProdLoss ClearProdLoss fracHarvResid fracHarvSecResid fracClearResid kSecHarv kNatDist kExpand1 kExpand2 kClear cRelClear FluxPHarvResidtoLitter FluxSHarvResidtoLitter FluxPClearResidtoLitter FluxSClearResidtoLitter dcSHarvClear Components Type Visibility Attributes Name Initial integer(kind=i4b), public, POINTER :: it integer(kind=i4b), public, POINTER :: np integer(kind=i4b), public, POINTER :: firstyear integer(kind=i4b), public, POINTER :: thisyear integer(kind=i4b), public, DIMENSION(:), POINTER :: n_event => null() real(kind=dp), public, DIMENSION(:), POINTER :: latitude => null() real(kind=dp), public, DIMENSION(:), POINTER :: longitude => null() real(kind=dp), public, DIMENSION(:), POINTER :: primf => null() real(kind=dp), public, DIMENSION(:), POINTER :: secdf => null() real(kind=dp), public, DIMENSION(:), POINTER :: grass => null() real(kind=dp), public, DIMENSION(:), POINTER :: ptos => null() real(kind=dp), public, DIMENSION(:), POINTER :: ptog => null() real(kind=dp), public, DIMENSION(:), POINTER :: stog => null() real(kind=dp), public, DIMENSION(:), POINTER :: gtop => null() real(kind=dp), public, DIMENSION(:), POINTER :: gtos => null() real(kind=dp), public, DIMENSION(:), POINTER :: frac_primf => null() real(kind=dp), public, DIMENSION(:), POINTER :: frac_forest => null() real(kind=dp), public, DIMENSION(:), POINTER :: crop => null() real(kind=dp), public, DIMENSION(:), POINTER :: past => null() real(kind=dp), public, DIMENSION(:), POINTER :: ptoc => null() real(kind=dp), public, DIMENSION(:), POINTER :: ptoq => null() real(kind=dp), public, DIMENSION(:), POINTER :: stoc => null() real(kind=dp), public, DIMENSION(:), POINTER :: stoq => null() real(kind=dp), public, DIMENSION(:), POINTER :: qtos => null() real(kind=dp), public, DIMENSION(:), POINTER :: ctos => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: freq_age_primary => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: freq_age_secondary => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: biomass_age_primary => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: biomass_age_secondary => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: age_history_secdf => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: area_history_secdf => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: FNEP => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: Clitt => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: Csoil => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: Cbiomass => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: FHarvest => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: FClearance => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: FTransferNet => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: FTransferGross => null() real(kind=dp), public, DIMENSION(:), POINTER :: pharv => null() real(kind=dp), public, DIMENSION(:), POINTER :: smharv => null() real(kind=dp), public, DIMENSION(:), POINTER :: syharv => null() real(kind=dp), public, DIMENSION(:), POINTER :: AgProd => null() real(kind=dp), public, DIMENSION(:), POINTER :: AgProdLoss => null() real(kind=dp), public, DIMENSION(:), POINTER :: FAg => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: HarvProd => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: ClearProd => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: fracHarvProd => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: fracClearProd => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: HarvProdLoss => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: ClearProdLoss => null() real(kind=dp), public, DIMENSION(:), POINTER :: fracHarvResid => null() real(kind=dp), public, DIMENSION(:), POINTER :: fracHarvSecResid => null() real(kind=dp), public, DIMENSION(:), POINTER :: fracClearResid => null() real(kind=dp), public, DIMENSION(:), POINTER :: kSecHarv => null() real(kind=dp), public, DIMENSION(:), POINTER :: kNatDist => null() real(kind=dp), public, DIMENSION(:), POINTER :: kExpand1 => null() real(kind=dp), public, DIMENSION(:), POINTER :: kExpand2 => null() real(kind=dp), public, DIMENSION(:), POINTER :: kClear => null() real(kind=dp), public, DIMENSION(:), POINTER :: cRelClear => null() real(kind=dp), public, dimension(:), pointer :: FluxPHarvResidtoLitter => null() real(kind=dp), public, dimension(:), pointer :: FluxSHarvResidtoLitter => null() real(kind=dp), public, dimension(:), pointer :: FluxPClearResidtoLitter => null() real(kind=dp), public, dimension(:), pointer :: FluxSClearResidtoLitter => null() real(kind=dp), public, dimension(:), pointer :: dcSHarvClear => null()","tags":"","loc":"type/popluc_type.html"},{"title":"Cohort – POP ","text":"type, public :: Cohort Inherited by type~~cohort~~InheritedByGraph type~cohort Cohort type~layer Layer type~layer->type~cohort Cohort type~patch Patch type~patch->type~layer Layer type~landscape Landscape type~landscape->type~patch patch type~pop_type POP_TYPE type~pop_type->type~landscape pop_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables id age biomass density frac_resource_uptake frac_light_uptake frac_interception frac_respiration frac_NPP respiration_scalar crown_area Pgap height diameter sapwood heartwood sapwood_area basal_area LAI Cleaf Croot Components Type Visibility Attributes Name Initial integer(kind=i4b), public :: id integer(kind=i4b), public :: age real(kind=dp), public :: biomass real(kind=dp), public :: density real(kind=dp), public :: frac_resource_uptake real(kind=dp), public :: frac_light_uptake real(kind=dp), public :: frac_interception real(kind=dp), public :: frac_respiration real(kind=dp), public :: frac_NPP real(kind=dp), public :: respiration_scalar real(kind=dp), public :: crown_area real(kind=dp), public :: Pgap real(kind=dp), public :: height real(kind=dp), public :: diameter real(kind=dp), public :: sapwood real(kind=dp), public :: heartwood real(kind=dp), public :: sapwood_area real(kind=dp), public :: basal_area real(kind=dp), public :: LAI real(kind=dp), public :: Cleaf real(kind=dp), public :: Croot","tags":"","loc":"type/cohort.html"},{"title":"Layer – POP ","text":"type, public :: Layer Inherits type~~layer~~InheritsGraph type~layer Layer type~cohort Cohort type~layer->type~cohort Cohort Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~layer~~InheritedByGraph type~layer Layer type~patch Patch type~patch->type~layer Layer type~landscape Landscape type~landscape->type~patch patch type~pop_type POP_TYPE type~pop_type->type~landscape pop_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables Cohort ncohort biomass density hmean hmax Components Type Visibility Attributes Name Initial type( Cohort ), public, DIMENSION(NCOHORT_MAX) :: Cohort integer(kind=i4b), public :: ncohort real(kind=dp), public :: biomass real(kind=dp), public :: density real(kind=dp), public :: hmean real(kind=dp), public :: hmax","tags":"","loc":"type/layer.html"},{"title":"Patch – POP ","text":"type, public :: Patch Inherits type~~patch~~InheritsGraph type~patch Patch type~layer Layer type~patch->type~layer Layer type~cohort Cohort type~layer->type~cohort Cohort Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~patch~~InheritedByGraph type~patch Patch type~landscape Landscape type~landscape->type~patch patch type~pop_type POP_TYPE type~pop_type->type~landscape pop_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables Layer factor_recruit pgap lai biomass biomass_old sapwood heartwood sapwood_old sapwood_area sapwood_area_old stress_mortality fire_mortality cat_mortality crowding_mortality cpc mortality sapwood_loss sapwood_area_loss growth area_growth disturbance_interval first_disturbance_year age id frac_NPP frac_respiration frac_light_uptake fire_top_kill_density Components Type Visibility Attributes Name Initial type( Layer ), public, DIMENSION(NLAYER) :: Layer real(kind=dp), public :: factor_recruit real(kind=dp), public :: pgap real(kind=dp), public :: lai real(kind=dp), public :: biomass real(kind=dp), public :: biomass_old real(kind=dp), public :: sapwood real(kind=dp), public :: heartwood real(kind=dp), public :: sapwood_old real(kind=dp), public :: sapwood_area real(kind=dp), public :: sapwood_area_old real(kind=dp), public :: stress_mortality real(kind=dp), public :: fire_mortality real(kind=dp), public :: cat_mortality real(kind=dp), public :: crowding_mortality real(kind=dp), public :: cpc real(kind=dp), public :: mortality real(kind=dp), public :: sapwood_loss real(kind=dp), public :: sapwood_area_loss real(kind=dp), public :: growth real(kind=dp), public :: area_growth integer(kind=i4b), public :: disturbance_interval (NDISTURB) integer(kind=i4b), public :: first_disturbance_year (NDISTURB) integer(kind=i4b), public :: age (NDISTURB) integer(kind=i4b), public :: id real(kind=dp), public :: frac_NPP real(kind=dp), public :: frac_respiration real(kind=dp), public :: frac_light_uptake real(kind=dp), public :: fire_top_kill_density","tags":"","loc":"type/patch.html"},{"title":"Landscape – POP ","text":"type, public :: Landscape Inherits type~~landscape~~InheritsGraph type~landscape Landscape type~patch Patch type~landscape->type~patch patch type~layer Layer type~patch->type~layer Layer type~cohort Cohort type~layer->type~cohort Cohort Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~landscape~~InheritedByGraph type~landscape Landscape type~pop_type POP_TYPE type~pop_type->type~landscape pop_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables patch freq freq_old fire_freq fire_freq_old cat_freq cat_freq_old freq_ranked_age_unique ranked_age_unique n_age biomass density hmean hmax cmass_stem_bin densindiv_bin height_bin diameter_bin bin_labels cmass_sum cmass_sum_old cheartwood_sum csapwood_sum csapwood_sum_old densindiv height_mean height_max basal_area sapwood_loss sapwood_area_loss stress_mortality crowding_mortality fire_mortality cat_mortality res_mortality growth area_growth crown_cover crown_area crown_volume sapwood_area sapwood_area_old Kclump npatch_active LU smoothing_buffer smoothing_buffer_cat fire_mortality_smoothed cat_mortality_smoothed fire_mortality_history cat_mortality_history freq_age biomass_age Components Type Visibility Attributes Name Initial type( Patch ), public, DIMENSION(NPATCH2D) :: patch real(kind=dp), public, DIMENSION(NPATCH2D) :: freq real(kind=dp), public, DIMENSION(NPATCH2D) :: freq_old real(kind=dp), public, DIMENSION(NPATCH2D) :: fire_freq real(kind=dp), public, DIMENSION(NPATCH2D) :: fire_freq_old real(kind=dp), public, DIMENSION(NPATCH2D) :: cat_freq real(kind=dp), public, DIMENSION(NPATCH2D) :: cat_freq_old real(kind=dp), public, DIMENSION(NPATCH2D,NDISTURB) :: freq_ranked_age_unique integer(kind=i4b), public, DIMENSION(NPATCH2D, NDISTURB) :: ranked_age_unique integer(kind=i4b), public, DIMENSION(NDISTURB) :: n_age real(kind=dp), public, DIMENSION(NLAYER) :: biomass real(kind=dp), public, DIMENSION(NLAYER) :: density real(kind=dp), public, DIMENSION(NLAYER) :: hmean real(kind=dp), public, DIMENSION(NLAYER) :: hmax real(kind=dp), public, DIMENSION(HEIGHT_BINS) :: cmass_stem_bin real(kind=dp), public, DIMENSION(HEIGHT_BINS) :: densindiv_bin real(kind=dp), public, DIMENSION(HEIGHT_BINS) :: height_bin real(kind=dp), public, DIMENSION(HEIGHT_BINS) :: diameter_bin character(len=100), public, DIMENSION(HEIGHT_BINS) :: bin_labels real(kind=dp), public :: cmass_sum real(kind=dp), public :: cmass_sum_old real(kind=dp), public :: cheartwood_sum real(kind=dp), public :: csapwood_sum real(kind=dp), public :: csapwood_sum_old real(kind=dp), public :: densindiv real(kind=dp), public :: height_mean real(kind=dp), public :: height_max real(kind=dp), public :: basal_area real(kind=dp), public :: sapwood_loss real(kind=dp), public :: sapwood_area_loss real(kind=dp), public :: stress_mortality real(kind=dp), public :: crowding_mortality real(kind=dp), public :: fire_mortality real(kind=dp), public :: cat_mortality real(kind=dp), public :: res_mortality real(kind=dp), public :: growth real(kind=dp), public :: area_growth real(kind=dp), public :: crown_cover real(kind=dp), public :: crown_area real(kind=dp), public :: crown_volume real(kind=dp), public :: sapwood_area real(kind=dp), public :: sapwood_area_old real(kind=dp), public :: Kclump integer(kind=i4b), public :: npatch_active integer(kind=i4b), public :: LU real(kind=dp), public :: smoothing_buffer real(kind=dp), public :: smoothing_buffer_cat real(kind=dp), public :: fire_mortality_smoothed real(kind=dp), public :: cat_mortality_smoothed real(kind=dp), public, DIMENSION(NYEAR_HISTORY) :: fire_mortality_history real(kind=dp), public, DIMENSION(NYEAR_HISTORY) :: cat_mortality_history real(kind=dp), public, DIMENSION(AGEMAX) :: freq_age real(kind=dp), public, DIMENSION(AGEMAX) :: biomass_age","tags":"","loc":"type/landscape.html"},{"title":"POP_TYPE – POP ","text":"type, public :: POP_TYPE Inherits type~~pop_type~~InheritsGraph type~pop_type POP_TYPE type~landscape Landscape type~pop_type->type~landscape pop_grid type~patch Patch type~landscape->type~patch patch type~layer Layer type~patch->type~layer Layer type~cohort Cohort type~layer->type~cohort Cohort Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables pop_grid it_pop np Iwood Components Type Visibility Attributes Name Initial type( Landscape ), public, DIMENSION(:), ALLOCATABLE :: pop_grid integer, public, DIMENSION(:), Allocatable :: it_pop integer, public :: np integer, public, DIMENSION(:), Allocatable :: Iwood","tags":"","loc":"type/pop_type.html"},{"title":"create_cohort – POP","text":"public  subroutine create_cohort(cohort_t, comm) Uses mpi proc~~create_cohort~~UsesGraph proc~create_cohort pop_mpi::create_cohort mpi mpi proc~create_cohort->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(out) :: cohort_t integer, intent(in) :: comm Calls proc~~create_cohort~~CallsGraph proc~create_cohort pop_mpi::create_cohort mpi_abort mpi_abort proc~create_cohort->mpi_abort mpi_get_address mpi_get_address proc~create_cohort->mpi_get_address mpi_type_commit mpi_type_commit proc~create_cohort->mpi_type_commit mpi_type_create_resized mpi_type_create_resized proc~create_cohort->mpi_type_create_resized mpi_type_create_struct mpi_type_create_struct proc~create_cohort->mpi_type_create_struct Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_cohort~~CalledByGraph proc~create_cohort pop_mpi::create_cohort proc~create_layer pop_mpi::create_layer proc~create_layer->proc~create_cohort proc~create_patch pop_mpi::create_patch proc~create_patch->proc~create_layer proc~create_pop_gridcell_type pop_mpi::create_pop_gridcell_type proc~create_pop_gridcell_type->proc~create_patch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/create_cohort.html"},{"title":"create_layer – POP","text":"public  subroutine create_layer(layer_t, comm) Uses mpi proc~~create_layer~~UsesGraph proc~create_layer pop_mpi::create_layer mpi mpi proc~create_layer->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(out) :: layer_t integer, intent(in) :: comm Calls proc~~create_layer~~CallsGraph proc~create_layer pop_mpi::create_layer mpi_abort mpi_abort proc~create_layer->mpi_abort mpi_get_address mpi_get_address proc~create_layer->mpi_get_address mpi_type_commit mpi_type_commit proc~create_layer->mpi_type_commit mpi_type_create_resized mpi_type_create_resized proc~create_layer->mpi_type_create_resized mpi_type_create_struct mpi_type_create_struct proc~create_layer->mpi_type_create_struct proc~create_cohort pop_mpi::create_cohort proc~create_layer->proc~create_cohort proc~create_cohort->mpi_abort proc~create_cohort->mpi_get_address proc~create_cohort->mpi_type_commit proc~create_cohort->mpi_type_create_resized proc~create_cohort->mpi_type_create_struct Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_layer~~CalledByGraph proc~create_layer pop_mpi::create_layer proc~create_patch pop_mpi::create_patch proc~create_patch->proc~create_layer proc~create_pop_gridcell_type pop_mpi::create_pop_gridcell_type proc~create_pop_gridcell_type->proc~create_patch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/create_layer.html"},{"title":"create_patch – POP","text":"public  subroutine create_patch(patch_t, comm) Uses mpi proc~~create_patch~~UsesGraph proc~create_patch pop_mpi::create_patch mpi mpi proc~create_patch->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(out) :: patch_t integer, intent(in) :: comm Calls proc~~create_patch~~CallsGraph proc~create_patch pop_mpi::create_patch mpi_abort mpi_abort proc~create_patch->mpi_abort mpi_get_address mpi_get_address proc~create_patch->mpi_get_address mpi_type_commit mpi_type_commit proc~create_patch->mpi_type_commit mpi_type_create_resized mpi_type_create_resized proc~create_patch->mpi_type_create_resized mpi_type_create_struct mpi_type_create_struct proc~create_patch->mpi_type_create_struct proc~create_layer pop_mpi::create_layer proc~create_patch->proc~create_layer proc~create_layer->mpi_abort proc~create_layer->mpi_get_address proc~create_layer->mpi_type_commit proc~create_layer->mpi_type_create_resized proc~create_layer->mpi_type_create_struct proc~create_cohort pop_mpi::create_cohort proc~create_layer->proc~create_cohort proc~create_cohort->mpi_abort proc~create_cohort->mpi_get_address proc~create_cohort->mpi_type_commit proc~create_cohort->mpi_type_create_resized proc~create_cohort->mpi_type_create_struct Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_patch~~CalledByGraph proc~create_patch pop_mpi::create_patch proc~create_pop_gridcell_type pop_mpi::create_pop_gridcell_type proc~create_pop_gridcell_type->proc~create_patch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/create_patch.html"},{"title":"create_pop_gridcell_type – POP","text":"public  subroutine create_pop_gridcell_type(gcell_t, comm) Uses mpi proc~~create_pop_gridcell_type~~UsesGraph proc~create_pop_gridcell_type pop_mpi::create_pop_gridcell_type mpi mpi proc~create_pop_gridcell_type->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(out) :: gcell_t integer, intent(in) :: comm Calls proc~~create_pop_gridcell_type~~CallsGraph proc~create_pop_gridcell_type pop_mpi::create_pop_gridcell_type mpi_abort mpi_abort proc~create_pop_gridcell_type->mpi_abort mpi_get_address mpi_get_address proc~create_pop_gridcell_type->mpi_get_address mpi_type_commit mpi_type_commit proc~create_pop_gridcell_type->mpi_type_commit mpi_type_create_resized mpi_type_create_resized proc~create_pop_gridcell_type->mpi_type_create_resized mpi_type_create_struct mpi_type_create_struct proc~create_pop_gridcell_type->mpi_type_create_struct proc~create_patch pop_mpi::create_patch proc~create_pop_gridcell_type->proc~create_patch proc~create_patch->mpi_abort proc~create_patch->mpi_get_address proc~create_patch->mpi_type_commit proc~create_patch->mpi_type_create_resized proc~create_patch->mpi_type_create_struct proc~create_layer pop_mpi::create_layer proc~create_patch->proc~create_layer proc~create_layer->mpi_abort proc~create_layer->mpi_get_address proc~create_layer->mpi_type_commit proc~create_layer->mpi_type_create_resized proc~create_layer->mpi_type_create_struct proc~create_cohort pop_mpi::create_cohort proc~create_layer->proc~create_cohort proc~create_cohort->mpi_abort proc~create_cohort->mpi_get_address proc~create_cohort->mpi_type_commit proc~create_cohort->mpi_type_create_resized proc~create_cohort->mpi_type_create_struct Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/create_pop_gridcell_type.html"},{"title":"CASAONLY_LUC – POP","text":"public  subroutine CASAONLY_LUC(dels, kstart, kend, veg, soil, casabiome, casapool, casaflux, casamet, casabal, phen, POP, climate, LALLOC, LUC_EXPT, POPLUC, sum_casapool, sum_casaflux, c13o2flux, c13o2pools, sum_c13o2pools, c13o2luc) Uses cable_IO_vars_module cable_c13o2_def POP_Types mo_utils casaparm phenvariable POPLUC_Module casavariable CABLE_LUC_EXPT POPModule cable_common_module casadimension cable_c13o2 casa_cable TypeDef POPLUC_Types cable_def_types_mod cable_carbon_module casa_inout proc~~casaonly_luc~~UsesGraph proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC CABLE_LUC_EXPT CABLE_LUC_EXPT proc~casaonly_luc->CABLE_LUC_EXPT cable_IO_vars_module cable_IO_vars_module proc~casaonly_luc->cable_IO_vars_module cable_c13o2 cable_c13o2 proc~casaonly_luc->cable_c13o2 cable_c13o2_def cable_c13o2_def proc~casaonly_luc->cable_c13o2_def cable_carbon_module cable_carbon_module proc~casaonly_luc->cable_carbon_module cable_common_module cable_common_module proc~casaonly_luc->cable_common_module cable_def_types_mod cable_def_types_mod proc~casaonly_luc->cable_def_types_mod mo_utils mo_utils proc~casaonly_luc->mo_utils module~casa_cable casa_cable proc~casaonly_luc->module~casa_cable module~casa_inout casa_inout proc~casaonly_luc->module~casa_inout module~casadimension casadimension proc~casaonly_luc->module~casadimension module~casaparm casaparm proc~casaonly_luc->module~casaparm module~casavariable casavariable proc~casaonly_luc->module~casavariable module~phenvariable phenvariable proc~casaonly_luc->module~phenvariable module~pop_types POP_Types proc~casaonly_luc->module~pop_types module~popluc_module POPLUC_Module proc~casaonly_luc->module~popluc_module module~popluc_types POPLUC_Types proc~casaonly_luc->module~popluc_types module~popmodule POPModule proc~casaonly_luc->module~popmodule module~typedef TypeDef proc~casaonly_luc->module~typedef module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~phenvariable->module~casadimension module~pop_types->module~typedef module~pop_constants POP_Constants module~pop_types->module~pop_constants module~popluc_module->CABLE_LUC_EXPT module~popluc_module->cable_IO_vars_module module~popluc_module->cable_common_module module~popluc_module->module~casavariable module~popluc_module->module~pop_types module~popluc_module->module~popluc_types module~popluc_module->module~popmodule module~popluc_module->module~typedef module~popluc_constants POPLUC_CONSTANTS module~popluc_module->module~popluc_constants module~popluc_types->module~typedef module~popluc_types->module~popluc_constants module~popmodule->module~pop_types module~popmodule->module~typedef module~popmodule->module~pop_constants module~pop_constants->module~typedef module~popluc_constants->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. CLN  CHARACTER(LEN=99), INTENT(IN)  :: fcnpspin\n vh_js !!\nCLN901  format(A99) Arguments Type Intent Optional Attributes Name real, intent(in) :: dels integer, intent(in) :: kstart integer, intent(in) :: kend type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( casa_balance ), intent(inout) :: casabal type( phen_variable ), intent(inout) :: phen type( POP_TYPE ), intent(inout) :: POP type(climate_TYPE), intent(inout) :: climate integer, intent(in) :: LALLOC type(LUC_EXPT_TYPE), intent(inout) :: LUC_EXPT type( POPLUC_TYPE ), intent(inout) :: POPLUC type( casa_pool ), intent(inout) :: sum_casapool type( casa_flux ), intent(inout) :: sum_casaflux type(c13o2_flux), intent(inout) :: c13o2flux type(c13o2_pool), intent(inout) :: c13o2pools type(c13o2_pool), intent(inout) :: sum_c13o2pools type(c13o2_luc), intent(inout) :: c13o2luc Calls proc~~casaonly_luc~~CallsGraph proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC aprecip_av20_spin aprecip_av20_spin proc~casaonly_luc->aprecip_av20_spin c13o2_save_casapool c13o2_save_casapool proc~casaonly_luc->c13o2_save_casapool c13o2_save_luc c13o2_save_luc proc~casaonly_luc->c13o2_save_luc c13o2_update_luc c13o2_update_luc proc~casaonly_luc->c13o2_update_luc c13o2_update_pools c13o2_update_pools proc~casaonly_luc->c13o2_update_pools c13o2_update_sum_pools c13o2_update_sum_pools proc~casaonly_luc->c13o2_update_sum_pools c13o2_zero_sum_pools c13o2_zero_sum_pools proc~casaonly_luc->c13o2_zero_sum_pools can12spin can12spin proc~casaonly_luc->can12spin can13spin can13spin proc~casaonly_luc->can13spin cgppspin cgppspin proc~casaonly_luc->cgppspin cplant cplant proc~casaonly_luc->cplant crmplantspin_1 crmplantspin_1 proc~casaonly_luc->crmplantspin_1 crmplantspin_2 crmplantspin_2 proc~casaonly_luc->crmplantspin_2 crmplantspin_3 crmplantspin_3 proc~casaonly_luc->crmplantspin_3 d_macarthur_spin d_macarthur_spin proc~casaonly_luc->d_macarthur_spin doyphasespin_1 doyphasespin_1 proc~casaonly_luc->doyphasespin_1 doyphasespin_2 doyphasespin_2 proc~casaonly_luc->doyphasespin_2 doyphasespin_3 doyphasespin_3 proc~casaonly_luc->doyphasespin_3 doyphasespin_4 doyphasespin_4 proc~casaonly_luc->doyphasespin_4 dprecip_spin dprecip_spin proc~casaonly_luc->dprecip_spin drhum_spin drhum_spin proc~casaonly_luc->drhum_spin dslr_spin dslr_spin proc~casaonly_luc->dslr_spin dtemp_max_spin dtemp_max_spin proc~casaonly_luc->dtemp_max_spin du10_max_spin du10_max_spin proc~casaonly_luc->du10_max_spin eq eq proc~casaonly_luc->eq ffdi_spin ffdi_spin proc~casaonly_luc->ffdi_spin frac_forest frac_forest proc~casaonly_luc->frac_forest fraccalloc fraccalloc proc~casaonly_luc->fraccalloc frecspin frecspin proc~casaonly_luc->frecspin ilu ilu proc~casaonly_luc->ilu input input proc~casaonly_luc->input is_casa_time is_casa_time proc~casaonly_luc->is_casa_time iveg iveg proc~casaonly_luc->iveg iwood iwood proc~casaonly_luc->iwood kbdi_spin kbdi_spin proc~casaonly_luc->kbdi_spin landpt landpt proc~casaonly_luc->landpt last_precip_spin last_precip_spin proc~casaonly_luc->last_precip_spin moistspin_1 moistspin_1 proc~casaonly_luc->moistspin_1 moistspin_2 moistspin_2 proc~casaonly_luc->moistspin_2 moistspin_3 moistspin_3 proc~casaonly_luc->moistspin_3 moistspin_4 moistspin_4 proc~casaonly_luc->moistspin_4 moistspin_5 moistspin_5 proc~casaonly_luc->moistspin_5 moistspin_6 moistspin_6 proc~casaonly_luc->moistspin_6 mtempspin mtempspin proc~casaonly_luc->mtempspin phasespin phasespin proc~casaonly_luc->phasespin prim_only prim_only proc~casaonly_luc->prim_only primf primf proc~casaonly_luc->primf proc~biogeochem casa_inout::biogeochem proc~casaonly_luc->proc~biogeochem proc~pop_init_single POPModule::POP_init_single proc~casaonly_luc->proc~pop_init_single proc~pop_luc_casa_transfer POPLUC_Module::POP_LUC_CASA_transfer proc~casaonly_luc->proc~pop_luc_casa_transfer proc~popdriver casa_cable::POPdriver proc~casaonly_luc->proc~popdriver proc~popluc_set_patchfrac POPLUC_Module::POPLUC_set_patchfrac proc~casaonly_luc->proc~popluc_set_patchfrac proc~popluc_weights_transfer POPLUC_Module::POPLUC_weights_transfer proc~casaonly_luc->proc~popluc_weights_transfer proc~poplucstep POPLUC_Module::POPLUCStep proc~casaonly_luc->proc~poplucstep proc~read_casa_dump casa_cable::read_casa_dump proc~casaonly_luc->proc~read_casa_dump proc~update_sum_casa casavariable::update_sum_casa proc~casaonly_luc->proc~update_sum_casa proc~write_luc_restart_nc POPLUC_Module::WRITE_LUC_RESTART_NC proc~casaonly_luc->proc~write_luc_restart_nc proc~zero_sum_casa casavariable::zero_sum_casa proc~casaonly_luc->proc~zero_sum_casa rationcplantmin rationcplantmin proc~casaonly_luc->rationcplantmin ratiopcplantmin ratiopcplantmin proc~casaonly_luc->ratiopcplantmin read_luh2 read_luh2 proc~casaonly_luc->read_luh2 tairkspin tairkspin proc~casaonly_luc->tairkspin tsoilspin_1 tsoilspin_1 proc~casaonly_luc->tsoilspin_1 tsoilspin_2 tsoilspin_2 proc~casaonly_luc->tsoilspin_2 tsoilspin_3 tsoilspin_3 proc~casaonly_luc->tsoilspin_3 tsoilspin_4 tsoilspin_4 proc~casaonly_luc->tsoilspin_4 tsoilspin_5 tsoilspin_5 proc~casaonly_luc->tsoilspin_5 tsoilspin_6 tsoilspin_6 proc~casaonly_luc->tsoilspin_6 proc~biogeochem->iwood cplant_turnover cplant_turnover proc~biogeochem->cplant_turnover klitter klitter proc~biogeochem->klitter klitter_fire klitter_fire proc~biogeochem->klitter_fire kplant kplant proc~biogeochem->kplant kplant_fire kplant_fire proc~biogeochem->kplant_fire pop_grid pop_grid proc~biogeochem->pop_grid proc~avgsoil casa_cnp_module::avgsoil proc~biogeochem->proc~avgsoil proc~casa_allocation casa_cnp_module::casa_allocation proc~biogeochem->proc~casa_allocation proc~casa_cnpbal casa_cnp_module::casa_cnpbal proc~biogeochem->proc~casa_cnpbal proc~casa_cnpcycle casa_cnp_module::casa_cnpcycle proc~biogeochem->proc~casa_cnpcycle proc~casa_cnpflux casa_inout::casa_cnpflux proc~biogeochem->proc~casa_cnpflux proc~casa_coeffplant casa_cnp_module::casa_coeffplant proc~biogeochem->proc~casa_coeffplant proc~casa_coeffsoil casa_cnp_module::casa_coeffsoil proc~biogeochem->proc~casa_coeffsoil proc~casa_delplant casa_cnp_module::casa_delplant proc~biogeochem->proc~casa_delplant proc~casa_delsoil casa_cnp_module::casa_delsoil proc~biogeochem->proc~casa_delsoil proc~casa_ndummy casa_cnp_module::casa_ndummy proc~biogeochem->proc~casa_ndummy proc~casa_nuptake casa_cnp_module::casa_nuptake proc~biogeochem->proc~casa_nuptake proc~casa_pdummy casa_cnp_module::casa_pdummy proc~biogeochem->proc~casa_pdummy proc~casa_puptake casa_cnp_module::casa_puptake proc~biogeochem->proc~casa_puptake proc~casa_rplant casa_cnp_module::casa_rplant proc~biogeochem->proc~casa_rplant proc~casa_xkn casa_cnp_module::casa_xkN proc~biogeochem->proc~casa_xkn proc~casa_xnp casa_cnp_module::casa_xnp proc~biogeochem->proc~casa_xnp proc~casa_xrateplant casa_cnp_module::casa_xrateplant proc~biogeochem->proc~casa_xrateplant proc~casa_xratesoil casa_cnp_module::casa_xratesoil proc~biogeochem->proc~casa_xratesoil proc~phenology casa_cnp_module::phenology proc~biogeochem->proc~phenology proc~initpop2d_poisson POPModule::InitPOP2D_Poisson proc~pop_init_single->proc~initpop2d_poisson proc~layer_recruitment_single_patch POPModule::layer_recruitment_single_patch proc~pop_init_single->proc~layer_recruitment_single_patch proc~zeropop POPModule::ZeroPOP proc~pop_init_single->proc~zeropop proc~pop_luc_casa_transfer->cplant proc~pop_luc_casa_transfer->eq proc~pop_luc_casa_transfer->iwood proc~pop_luc_casa_transfer->landpt proc~pop_luc_casa_transfer->prim_only agprod agprod proc~pop_luc_casa_transfer->agprod agprodloss agprodloss proc~pop_luc_casa_transfer->agprodloss charvest charvest proc~pop_luc_casa_transfer->charvest clabile clabile proc~pop_luc_casa_transfer->clabile clearprod clearprod proc~pop_luc_casa_transfer->clearprod clearprodloss clearprodloss proc~pop_luc_casa_transfer->clearprodloss clitter clitter proc~pop_luc_casa_transfer->clitter crelclear crelclear proc~pop_luc_casa_transfer->crelclear crop crop proc~pop_luc_casa_transfer->crop csoil csoil proc~pop_luc_casa_transfer->csoil ctos ctos proc~pop_luc_casa_transfer->ctos ctransferluc ctransferluc proc~pop_luc_casa_transfer->ctransferluc fclearance fclearance proc~pop_luc_casa_transfer->fclearance fcneeyear fcneeyear proc~pop_luc_casa_transfer->fcneeyear fharvest fharvest proc~pop_luc_casa_transfer->fharvest fracclearprod fracclearprod proc~pop_luc_casa_transfer->fracclearprod fracclearresid fracclearresid proc~pop_luc_casa_transfer->fracclearresid fracharvprod fracharvprod proc~pop_luc_casa_transfer->fracharvprod fracharvresid fracharvresid proc~pop_luc_casa_transfer->fracharvresid fracharvsecresid fracharvsecresid proc~pop_luc_casa_transfer->fracharvsecresid grass grass proc~pop_luc_casa_transfer->grass gtos gtos proc~pop_luc_casa_transfer->gtos harvprod harvprod proc~pop_luc_casa_transfer->harvprod harvprodloss harvprodloss proc~pop_luc_casa_transfer->harvprodloss kclear kclear proc~pop_luc_casa_transfer->kclear knatdist knatdist proc~pop_luc_casa_transfer->knatdist ksecharv ksecharv proc~pop_luc_casa_transfer->ksecharv nlitter nlitter proc~pop_luc_casa_transfer->nlitter nplant nplant proc~pop_luc_casa_transfer->nplant nsoil nsoil proc~pop_luc_casa_transfer->nsoil nsoilmin nsoilmin proc~pop_luc_casa_transfer->nsoilmin past past proc~pop_luc_casa_transfer->past patch patch proc~pop_luc_casa_transfer->patch plitter plitter proc~pop_luc_casa_transfer->plitter proc~pop_luc_casa_transfer->pop_grid pplant pplant proc~pop_luc_casa_transfer->pplant psoil psoil proc~pop_luc_casa_transfer->psoil ptoc ptoc proc~pop_luc_casa_transfer->ptoc ptog ptog proc~pop_luc_casa_transfer->ptog ptoq ptoq proc~pop_luc_casa_transfer->ptoq ptos ptos proc~pop_luc_casa_transfer->ptos qtos qtos proc~pop_luc_casa_transfer->qtos secdf secdf proc~pop_luc_casa_transfer->secdf stoc stoc proc~pop_luc_casa_transfer->stoc stog stog proc~pop_luc_casa_transfer->stog stoq stoq proc~pop_luc_casa_transfer->stoq disturbance_intensity disturbance_intensity proc~popdriver->disturbance_intensity disturbance_interval disturbance_interval proc~popdriver->disturbance_interval proc~popstep POPModule::POPStep proc~popdriver->proc~popstep proc~popluc_set_patchfrac->landpt proc~popluc_set_patchfrac->prim_only proc~popluc_set_patchfrac->primf proc~popluc_set_patchfrac->grass proc~popluc_set_patchfrac->patch proc~popluc_weights_transfer->iwood proc~popluc_weights_transfer->landpt proc~popluc_weights_transfer->prim_only freq_age_secondary freq_age_secondary proc~popluc_weights_transfer->freq_age_secondary proc~poplucstep->primf proc~poplucstep->freq_age_secondary gtop gtop proc~poplucstep->gtop proc~poplucstep->gtos proc~execute_luc_event POPLUC_Module::execute_luc_event proc~poplucstep->proc~execute_luc_event proc~increment_age POPLUC_Module::INCREMENT_AGE proc~poplucstep->proc~increment_age proc~poplucstep->ptog proc~poplucstep->ptos proc~poplucstep->stog get_var_nc get_var_nc proc~read_casa_dump->get_var_nc nf90_close nf90_close proc~read_casa_dump->nf90_close nf90_open nf90_open proc~read_casa_dump->nf90_open stderr_nc stderr_nc proc~read_casa_dump->stderr_nc proc~update_sum_casa->fraccalloc handle_err handle_err proc~write_luc_restart_nc->handle_err proc~write_luc_restart_nc->nf90_close nf90_create nf90_create proc~write_luc_restart_nc->nf90_create nf90_def_dim nf90_def_dim proc~write_luc_restart_nc->nf90_def_dim nf90_def_var nf90_def_var proc~write_luc_restart_nc->nf90_def_var nf90_enddef nf90_enddef proc~write_luc_restart_nc->nf90_enddef nf90_put_att nf90_put_att proc~write_luc_restart_nc->nf90_put_att nf90_put_var nf90_put_var proc~write_luc_restart_nc->nf90_put_var nf90_redef nf90_redef proc~write_luc_restart_nc->nf90_redef proc~zero_casaflux casavariable::zero_casaflux proc~zero_sum_casa->proc~zero_casaflux proc~zero_casapool casavariable::zero_casapool proc~zero_sum_casa->proc~zero_casapool btran btran proc~avgsoil->btran moist moist proc~avgsoil->moist moistavg moistavg proc~avgsoil->moistavg tsoilavg tsoilavg proc~avgsoil->tsoilavg proc~casa_allocation->cplant proc~casa_allocation->fraccalloc proc~casa_allocation->iveg proc~casa_allocation->btran crmplant crmplant proc~casa_allocation->crmplant fracnpptop fracnpptop proc~casa_allocation->fracnpptop glai glai proc~casa_allocation->glai glaimax glaimax proc~casa_allocation->glaimax glaimin glaimin proc~casa_allocation->glaimin kplant_tot kplant_tot proc~casa_allocation->kplant_tot la_to_sa la_to_sa proc~casa_allocation->la_to_sa proc~casa_allocation->moistavg proc~casa_wolf casa_cnp_module::casa_wolf proc~casa_allocation->proc~casa_wolf sfc sfc proc~casa_allocation->sfc sla sla proc~casa_allocation->sla swilt swilt proc~casa_allocation->swilt proc~casa_allocation->tsoilavg proc~casa_cnpbal->cplant proc~casa_cnpbal->clabile proc~casa_cnpbal->fharvest proc~casa_cnpbal->klitter proc~casa_cnpbal->klitter_fire proc~casa_cnpbal->kplant proc~casa_cnpbal->kplant_fire proc~casa_cnpbal->nsoilmin clabilelast clabilelast proc~casa_cnpbal->clabilelast clitterlast clitterlast proc~casa_cnpbal->clitterlast cnpp cnpp proc~casa_cnpbal->cnpp cplantlast cplantlast proc~casa_cnpbal->cplantlast crsoil crsoil proc~casa_cnpbal->crsoil fluxctoco2_plant_fire fluxctoco2_plant_fire proc~casa_cnpbal->fluxctoco2_plant_fire fluxctolitter fluxctolitter proc~casa_cnpbal->fluxctolitter fluxfromptoco2 fluxfromptoco2 proc~casa_cnpbal->fluxfromptoco2 fromptol_fire fromptol_fire proc~casa_cnpbal->fromptol_fire klitter_tot klitter_tot proc~casa_cnpbal->klitter_tot proc~casa_cnpbal->kplant_tot nmindep nmindep proc~casa_cnpbal->nmindep nminfix nminfix proc~casa_cnpbal->nminfix nminleach nminleach proc~casa_cnpbal->nminleach nminloss nminloss proc~casa_cnpbal->nminloss nminuptake nminuptake proc~casa_cnpbal->nminuptake nsoilminlast nsoilminlast proc~casa_cnpbal->nsoilminlast nupland nupland proc~casa_cnpbal->nupland pdep pdep proc~casa_cnpbal->pdep plabuptake plabuptake proc~casa_cnpbal->plabuptake pleach pleach proc~casa_cnpbal->pleach ploss ploss proc~casa_cnpbal->ploss psoillab psoillab proc~casa_cnpbal->psoillab psoillablast psoillablast proc~casa_cnpbal->psoillablast psoilocc psoilocc proc~casa_cnpbal->psoilocc psoilocclast psoilocclast proc~casa_cnpbal->psoilocclast psoilsorb psoilsorb proc~casa_cnpbal->psoilsorb psoilsorblast psoilsorblast proc~casa_cnpbal->psoilsorblast pupland pupland proc~casa_cnpbal->pupland pwea pwea proc~casa_cnpbal->pwea proc~casa_cnpcycle->cplant proc~casa_cnpcycle->iveg proc~casa_cnpcycle->clabile proc~casa_cnpcycle->clitter proc~casa_cnpcycle->csoil proc~casa_cnpcycle->nlitter proc~casa_cnpcycle->nplant proc~casa_cnpcycle->nsoil proc~casa_cnpcycle->nsoilmin proc~casa_cnpcycle->plitter proc~casa_cnpcycle->pplant proc~casa_cnpcycle->psoil dclabiledt dclabiledt proc~casa_cnpcycle->dclabiledt dclitterdt dclitterdt proc~casa_cnpcycle->dclitterdt dcplantdt dcplantdt proc~casa_cnpcycle->dcplantdt dcsoildt dcsoildt proc~casa_cnpcycle->dcsoildt dnlitterdt dnlitterdt proc~casa_cnpcycle->dnlitterdt dnplantdt dnplantdt proc~casa_cnpcycle->dnplantdt dnsoildt dnsoildt proc~casa_cnpcycle->dnsoildt dnsoilmindt dnsoilmindt proc~casa_cnpcycle->dnsoilmindt dplitterdt dplitterdt proc~casa_cnpcycle->dplitterdt dpplantdt dpplantdt proc~casa_cnpcycle->dpplantdt dpsoildt dpsoildt proc~casa_cnpcycle->dpsoildt dpsoillabdt dpsoillabdt proc~casa_cnpcycle->dpsoillabdt dpsoiloccdt dpsoiloccdt proc~casa_cnpcycle->dpsoiloccdt proc~casa_cnpcycle->glai proc~casa_cnpcycle->glaimax proc~casa_cnpcycle->glaimin iveg2 iveg2 proc~casa_cnpcycle->iveg2 kmlabp kmlabp proc~casa_cnpcycle->kmlabp lat lat proc~casa_cnpcycle->lat lon lon proc~casa_cnpcycle->lon proc~casa_poolzero casa_cnp_module::casa_poolzero proc~casa_cnpcycle->proc~casa_poolzero proc~casa_cnpcycle->psoillab proc~casa_cnpcycle->psoilocc psorbmax psorbmax proc~casa_cnpcycle->psorbmax rationcplantmax rationcplantmax proc~casa_cnpcycle->rationcplantmax proc~casa_cnpcycle->sla proc~casa_cnpflux->crmplant fcrmleafyear fcrmleafyear proc~casa_cnpflux->fcrmleafyear fcrmrootyear fcrmrootyear proc~casa_cnpflux->fcrmrootyear fcrmwoodyear fcrmwoodyear proc~casa_cnpflux->fcrmwoodyear proc~casa_coeffplant->cplant proc~casa_coeffplant->iveg proc~casa_coeffplant->kplant proc~casa_coeffplant->kplant_fire proc~casa_coeffplant->nplant fracligninplant fracligninplant proc~casa_coeffplant->fracligninplant fromptol fromptol proc~casa_coeffplant->fromptol ftransnptol ftransnptol proc~casa_coeffplant->ftransnptol proc~casa_coeffplant->glai proc~casa_coeffplant->glaimin plantrate plantrate proc~casa_coeffplant->plantrate proc~casa_coeffsoil->iveg proc~casa_coeffsoil->klitter proc~casa_coeffsoil->klitter_fire clay clay proc~casa_coeffsoil->clay proc~casa_coeffsoil->fracligninplant fromltoco2 fromltoco2 proc~casa_coeffsoil->fromltoco2 fromltos fromltos proc~casa_coeffsoil->fromltos fromstoco2 fromstoco2 proc~casa_coeffsoil->fromstoco2 fromstos fromstos proc~casa_coeffsoil->fromstos isorder isorder proc~casa_coeffsoil->isorder proc~casa_coeffsoil->iveg2 ksoil ksoil proc~casa_coeffsoil->ksoil litterrate litterrate proc~casa_coeffsoil->litterrate silt silt proc~casa_coeffsoil->silt soilrate soilrate proc~casa_coeffsoil->soilrate xkplab xkplab proc~casa_coeffsoil->xkplab xkpocc xkpocc proc~casa_coeffsoil->xkpocc xkpsorb xkpsorb proc~casa_coeffsoil->xkpsorb proc~casa_delplant->cplant proc~casa_delplant->fraccalloc proc~casa_delplant->iveg proc~casa_delplant->charvest proc~casa_delplant->fharvest proc~casa_delplant->kplant proc~casa_delplant->kplant_fire proc~casa_delplant->nplant proc~casa_delplant->pplant cgpp cgpp proc~casa_delplant->cgpp clabloss clabloss proc~casa_delplant->clabloss proc~casa_delplant->cnpp crgplant crgplant proc~casa_delplant->crgplant proc~casa_delplant->crmplant proc~casa_delplant->dcplantdt proc~casa_delplant->dnplantdt proc~casa_delplant->dpplantdt proc~casa_delplant->fluxctoco2_plant_fire proc~casa_delplant->fluxctolitter proc~casa_delplant->fluxfromptoco2 fluxfromptoharvest fluxfromptoharvest proc~casa_delplant->fluxfromptoharvest fluxntolitter fluxntolitter proc~casa_delplant->fluxntolitter fluxptolitter fluxptolitter proc~casa_delplant->fluxptolitter fracclabile fracclabile proc~casa_delplant->fracclabile fracnalloc fracnalloc proc~casa_delplant->fracnalloc fracpalloc fracpalloc proc~casa_delplant->fracpalloc proc~casa_delplant->fromptol proc~casa_delplant->fromptol_fire proc~casa_delplant->ftransnptol ftranspptol ftranspptol proc~casa_delplant->ftranspptol proc~casa_delplant->iveg2 proc~casa_delplant->kplant_tot lnonwood lnonwood proc~casa_delplant->lnonwood nharvest nharvest proc~casa_delplant->nharvest proc~casa_delplant->nminuptake pharvest pharvest proc~casa_delplant->pharvest proc~casa_delplant->plabuptake proc~casa_delsoil->iveg proc~casa_delsoil->clitter proc~casa_delsoil->csoil proc~casa_delsoil->klitter proc~casa_delsoil->klitter_fire proc~casa_delsoil->nlitter proc~casa_delsoil->nsoil proc~casa_delsoil->nsoilmin proc~casa_delsoil->plitter proc~casa_delsoil->psoil proc~casa_delsoil->cnpp costnpup costnpup proc~casa_delsoil->costnpup proc~casa_delsoil->crsoil proc~casa_delsoil->dpsoillabdt fluxctoco2 fluxctoco2 proc~casa_delsoil->fluxctoco2 fluxctoco2_litter_fire fluxctoco2_litter_fire proc~casa_delsoil->fluxctoco2_litter_fire proc~casa_delsoil->fluxctolitter fluxctosoil fluxctosoil proc~casa_delsoil->fluxctosoil fluxfromltoco2 fluxfromltoco2 proc~casa_delsoil->fluxfromltoco2 fluxfromltos fluxfromltos proc~casa_delsoil->fluxfromltos fluxfromstoco2 fluxfromstoco2 proc~casa_delsoil->fluxfromstoco2 fluxfromstos fluxfromstos proc~casa_delsoil->fluxfromstos proc~casa_delsoil->fluxntolitter fluxntosoil fluxntosoil proc~casa_delsoil->fluxntosoil proc~casa_delsoil->fluxptolitter fluxptosoil fluxptosoil proc~casa_delsoil->fluxptosoil fnminleach fnminleach proc~casa_delsoil->fnminleach fnminloss fnminloss proc~casa_delsoil->fnminloss fpleach fpleach proc~casa_delsoil->fpleach proc~casa_delsoil->fromltoco2 proc~casa_delsoil->fromltos proc~casa_delsoil->fromstoco2 proc~casa_delsoil->fromstos proc~casa_delsoil->iveg2 proc~casa_delsoil->klitter_tot proc~casa_delsoil->kmlabp kpocc kpocc proc~casa_delsoil->kpocc kpsorb kpsorb proc~casa_delsoil->kpsorb proc~casa_delsoil->ksoil nlittermin nlittermin proc~casa_delsoil->nlittermin proc~casa_delsoil->nmindep proc~casa_delsoil->nminfix proc~casa_delsoil->nminleach proc~casa_delsoil->nminloss nsimm nsimm proc~casa_delsoil->nsimm nsmin nsmin proc~casa_delsoil->nsmin nsnet nsnet proc~casa_delsoil->nsnet proc~casa_delsoil->nupland proc~casa_delsoil->pdep proc~casa_delsoil->pleach plittermin plittermin proc~casa_delsoil->plittermin prodptase prodptase proc~casa_delsoil->prodptase psimm psimm proc~casa_delsoil->psimm psmin psmin proc~casa_delsoil->psmin psnet psnet proc~casa_delsoil->psnet proc~casa_delsoil->psoillab proc~casa_delsoil->psoilocc proc~casa_delsoil->psoilsorb proc~casa_delsoil->psorbmax proc~casa_delsoil->pupland proc~casa_delsoil->pwea rationcsoilnew rationcsoilnew proc~casa_delsoil->rationcsoilnew rationpsoil rationpsoil proc~casa_delsoil->rationpsoil proc~casa_delsoil->tsoilavg proc~casa_ndummy->cplant rationcplant rationcplant proc~casa_ndummy->rationcplant proc~casa_nuptake->iveg proc~casa_nuptake->nsoilmin proc~casa_nuptake->iveg2 kminn kminn proc~casa_nuptake->kminn proc~casa_nuptake->nminuptake proc~casa_nrequire casa_cnp_module::casa_Nrequire proc~casa_nuptake->proc~casa_nrequire proc~casa_pdummy->nplant rationpplant rationpplant proc~casa_pdummy->rationpplant proc~casa_puptake->iveg kuplabp kuplabp proc~casa_puptake->kuplabp proc~casa_puptake->plabuptake proc~casa_prequire casa_cnp_module::casa_Prequire proc~casa_puptake->proc~casa_prequire proc~casa_puptake->psoillab proc~casa_rplant->cplant proc~casa_rplant->iveg proc~casa_rplant->clabile proc~casa_rplant->nplant proc~casa_rplant->cgpp proc~casa_rplant->crgplant proc~casa_rplant->crmplant frac_sapwood frac_sapwood proc~casa_rplant->frac_sapwood frec frec proc~casa_rplant->frec kclabrate kclabrate proc~casa_rplant->kclabrate proc~vcmax_np casa_cnp_module::vcmax_np proc~casa_rplant->proc~vcmax_np qtemp_max_last_year qtemp_max_last_year proc~casa_rplant->qtemp_max_last_year proc~casa_rplant->rationcplantmax ratiopcplantmax ratiopcplantmax proc~casa_rplant->ratiopcplantmax rmplant rmplant proc~casa_rplant->rmplant proc~casa_rplant->sla tairk tairk proc~casa_rplant->tairk proc~casa_rplant->tsoilavg vcmax vcmax proc~casa_rplant->vcmax vcmax_scalar vcmax_scalar proc~casa_rplant->vcmax_scalar proc~casa_xkn->iveg proc~casa_xkn->clitter proc~casa_xkn->csoil proc~casa_xkn->klitter proc~casa_xkn->nlitter proc~casa_xkn->nsoil proc~casa_xkn->nsoilmin proc~casa_xkn->fromltos proc~casa_xkn->fromstos proc~casa_xkn->iveg2 proc~casa_xkn->ksoil maxcwd maxcwd proc~casa_xkn->maxcwd maxfinelitter maxfinelitter proc~casa_xkn->maxfinelitter rationcsoilmax rationcsoilmax proc~casa_xkn->rationcsoilmax rationcsoilmin rationcsoilmin proc~casa_xkn->rationcsoilmin proc~casa_xkn->rationcsoilnew proc~casa_xnp->cplant proc~casa_xnp->iveg proc~casa_xnp->fharvest proc~casa_xnp->nplant proc~casa_xnp->nsoilmin proc~casa_xnp->pplant proc~casa_xnp->cgpp proc~casa_xnp->cnpp proc~casa_xnp->fracclabile proc~casa_xnp->iveg2 proc~casa_xnp->proc~casa_nrequire proc~casa_xnp->proc~casa_prequire proc~casa_xnp->psoillab xnpmax xnpmax proc~casa_xnp->xnpmax proc~casa_xrateplant->iveg proc~casa_xrateplant->btran ge ge proc~casa_xrateplant->ge proc~casa_xrateplant->iveg2 le le proc~casa_xrateplant->le proc~casa_xrateplant->lnonwood phase phase proc~casa_xrateplant->phase proc~casa_xrateplant->tairk tkshed tkshed proc~casa_xrateplant->tkshed xkleafcoldexp xkleafcoldexp proc~casa_xrateplant->xkleafcoldexp xkleafcoldmax xkleafcoldmax proc~casa_xrateplant->xkleafcoldmax xkleafdryexp xkleafdryexp proc~casa_xrateplant->xkleafdryexp xkleafdrymax xkleafdrymax proc~casa_xrateplant->xkleafdrymax proc~casa_xratesoil->iveg damm_alpha damm_alpha proc~casa_xratesoil->damm_alpha damm_ea damm_ea proc~casa_xratesoil->damm_ea damm_enzpool damm_enzpool proc~casa_xratesoil->damm_enzpool damm_kmcp damm_kmcp proc~casa_xratesoil->damm_kmcp damm_kmo2 damm_kmo2 proc~casa_xratesoil->damm_kmo2 proc~casa_xratesoil->iveg2 proc~casa_xratesoil->moistavg q10soil q10soil proc~casa_xratesoil->q10soil ssat ssat proc~casa_xratesoil->ssat proc~casa_xratesoil->tsoilavg xkoptlitter xkoptlitter proc~casa_xratesoil->xkoptlitter xkoptsoil xkoptsoil proc~casa_xratesoil->xkoptsoil proc~execute_luc_event->primf proc~execute_luc_event->crelclear proc~execute_luc_event->freq_age_secondary proc~execute_luc_event->grass proc~execute_luc_event->ptog proc~execute_luc_event->ptos proc~execute_luc_event->stog biomass_age_secondary biomass_age_secondary proc~execute_luc_event->biomass_age_secondary n_event n_event proc~execute_luc_event->n_event proc~increment_age->freq_age_secondary proc~increment_age->biomass_age_secondary smharv smharv proc~increment_age->smharv syharv syharv proc~increment_age->syharv proc~initpop2d_poisson->pop_grid proc~cumexponential POPModule::CumExponential proc~initpop2d_poisson->proc~cumexponential proc~exponential POPModule::Exponential proc~initpop2d_poisson->proc~exponential proc~layer_recruitment_single_patch->pop_grid proc~get_allometry POPModule::GET_ALLOMETRY proc~layer_recruitment_single_patch->proc~get_allometry doyphase doyphase proc~phenology->doyphase proc~phenology->phase proc~popstep->pop_grid proc~getdiagnostics POPModule::GetDiagnostics proc~popstep->proc~getdiagnostics proc~getpatchfrequencies POPModule::GetPatchFrequencies proc~popstep->proc~getpatchfrequencies proc~getuniqueagefrequencies POPModule::GetUniqueAgeFrequencies proc~popstep->proc~getuniqueagefrequencies proc~patch_disturb POPModule::Patch_disturb proc~popstep->proc~patch_disturb proc~patch_partial_disturb POPModule::Patch_partial_disturb proc~popstep->proc~patch_partial_disturb proc~patch_partial_disturb2 POPModule::Patch_partial_disturb2 proc~popstep->proc~patch_partial_disturb2 proc~patchannualdynamics POPModule::PatchAnnualDynamics proc~popstep->proc~patchannualdynamics proc~casa_nrequire->cplant proc~casa_nrequire->fraccalloc proc~casa_nrequire->iveg proc~casa_nrequire->rationcplantmin proc~casa_nrequire->kplant proc~casa_nrequire->nplant proc~casa_nrequire->nsoilmin proc~casa_nrequire->ftransnptol proc~casa_nrequire->iveg2 proc~casa_nrequire->rationcplantmax proc~casa_poolzero->cplant proc~casa_poolzero->clitter proc~casa_poolzero->csoil proc~casa_poolzero->nlitter proc~casa_poolzero->nplant proc~casa_poolzero->nsoil proc~casa_prequire->cplant proc~casa_prequire->fraccalloc proc~casa_prequire->iveg proc~casa_prequire->kplant proc~casa_prequire->nplant proc~casa_prequire->pplant proc~casa_prequire->ftranspptol proc~casa_prequire->iveg2 rationpplantmax rationpplantmax proc~casa_prequire->rationpplantmax rationpplantmin rationpplantmin proc~casa_prequire->rationpplantmin proc~casa_wolf->cplant proc~casa_wolf->iveg proc~casa_wolf->cnpp proc~casa_wolf->fracnpptop proc~casa_wolf->iveg2 proc~allometry POPModule::Allometry proc~get_allometry->proc~allometry proc~getheight POPModule::GetHeight proc~get_allometry->proc~getheight proc~williams_allometry POPModule::Williams_Allometry proc~get_allometry->proc~williams_allometry proc~getdiagnostics->pop_grid proc~getdiagnostics->proc~get_allometry proc~interpolate_biomass_1d POPModule::INTERPOLATE_BIOMASS_1D proc~getdiagnostics->proc~interpolate_biomass_1d proc~interpolate_biomass_2d POPModule::INTERPOLATE_BIOMASS_2D proc~getdiagnostics->proc~interpolate_biomass_2d proc~smooth_flux POPModule::SMOOTH_FLUX proc~getdiagnostics->proc~smooth_flux proc~getpatchfrequencies->pop_grid proc~getuniqueagefrequencies->pop_grid proc~getuniqueagefrequencies->proc~cumexponential proc~realexponential POPModule::REALExponential proc~getuniqueagefrequencies->proc~realexponential proc~patch_disturb->pop_grid proc~patch_disturb->proc~layer_recruitment_single_patch proc~patch_partial_disturb->pop_grid proc~patch_partial_disturb2->pop_grid proc~patchannualdynamics->pop_grid proc~patchannualdynamics->proc~get_allometry proc~layer_recruitment POPModule::layer_recruitment proc~patchannualdynamics->proc~layer_recruitment proc~interpolate_biomass_1d->pop_grid proc~interpolate_biomass_1d->proc~realexponential proc~interpolate_biomass_2d->eq proc~interpolate_biomass_2d->pop_grid proc~interpolate_biomass_2d->proc~realexponential proc~area_triangle POPModule::Area_Triangle proc~interpolate_biomass_2d->proc~area_triangle proc~layer_recruitment->pop_grid proc~layer_recruitment->proc~get_allometry proc~smooth_flux->pop_grid proc~regress POPModule::REGRESS proc~smooth_flux->proc~regress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casaonly_luc.html"},{"title":"spincasacnp – POP","text":"public  subroutine spincasacnp(dels, kstart, kend, mloop, veg, soil, casabiome, casapool, casaflux, casamet, casabal, phen, pop, climate, lalloc, c13o2flux, c13o2pools, BLAZE, SIMFIRE) Uses casavariable casa_inout mo_isotope SIMFIRE_MOD TypeDef cable_c13o2_def casaparm POP_Types POP_Constants BLAZE_MOD phenvariable cable_def_types_mod cable_common_module casadimension blaze_drv cable_c13o2 cable_carbon_module casa_cable proc~~spincasacnp~~UsesGraph proc~spincasacnp cable_spincasacnp::spincasacnp BLAZE_MOD BLAZE_MOD proc~spincasacnp->BLAZE_MOD SIMFIRE_MOD SIMFIRE_MOD proc~spincasacnp->SIMFIRE_MOD blaze_drv blaze_drv proc~spincasacnp->blaze_drv cable_c13o2 cable_c13o2 proc~spincasacnp->cable_c13o2 cable_c13o2_def cable_c13o2_def proc~spincasacnp->cable_c13o2_def cable_carbon_module cable_carbon_module proc~spincasacnp->cable_carbon_module cable_common_module cable_common_module proc~spincasacnp->cable_common_module cable_def_types_mod cable_def_types_mod proc~spincasacnp->cable_def_types_mod mo_isotope mo_isotope proc~spincasacnp->mo_isotope module~casa_cable casa_cable proc~spincasacnp->module~casa_cable module~casa_inout casa_inout proc~spincasacnp->module~casa_inout module~casadimension casadimension proc~spincasacnp->module~casadimension module~casaparm casaparm proc~spincasacnp->module~casaparm module~casavariable casavariable proc~spincasacnp->module~casavariable module~phenvariable phenvariable proc~spincasacnp->module~phenvariable module~pop_constants POP_Constants proc~spincasacnp->module~pop_constants module~pop_types POP_Types proc~spincasacnp->module~pop_types module~typedef TypeDef proc~spincasacnp->module~typedef module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~phenvariable->module~casadimension module~pop_constants->module~typedef module~pop_types->module~pop_constants module~pop_types->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. CLN  character(len=99), intent(in)  :: fcnpspin\n vh_js !!\nCLN  OPEN(91, file=fcnpspin)\nCLN  read(91,*) myearspin\nCLN    CLOSE(91) CLN  OPEN(91,file=fcnpspin)\nCLN  read(91,*)\nCLN      read(91,901) ncfile Arguments Type Intent Optional Attributes Name real, intent(in) :: dels integer, intent(in) :: kstart integer, intent(in) :: kend integer, intent(in) :: mloop type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( casa_balance ), intent(inout) :: casabal type( phen_variable ), intent(inout) :: phen type( POP_TYPE ), intent(inout) :: pop type(climate_type), intent(inout) :: climate integer, intent(in) :: lalloc type(c13o2_flux), intent(inout) :: c13o2flux type(c13o2_pool), intent(inout) :: c13o2pools type(TYPE_BLAZE), intent(inout) :: BLAZE type(TYPE_SIMFIRE), intent(inout) :: SIMFIRE Calls proc~~spincasacnp~~CallsGraph proc~spincasacnp cable_spincasacnp::spincasacnp aprecip_av20_spin aprecip_av20_spin proc~spincasacnp->aprecip_av20_spin blaze_accounting blaze_accounting proc~spincasacnp->blaze_accounting blaze_driver blaze_driver proc~spincasacnp->blaze_driver c13o2_close_output c13o2_close_output proc~spincasacnp->c13o2_close_output c13o2_create_output c13o2_create_output proc~spincasacnp->c13o2_create_output c13o2_sanity_pools c13o2_sanity_pools proc~spincasacnp->c13o2_sanity_pools c13o2_save_casapool c13o2_save_casapool proc~spincasacnp->c13o2_save_casapool c13o2_update_pools c13o2_update_pools proc~spincasacnp->c13o2_update_pools c13o2_write_output c13o2_write_output proc~spincasacnp->c13o2_write_output can12spin can12spin proc~spincasacnp->can12spin can13spin can13spin proc~spincasacnp->can13spin cgppspin cgppspin proc~spincasacnp->cgppspin cplant cplant proc~spincasacnp->cplant crmplantspin_1 crmplantspin_1 proc~spincasacnp->crmplantspin_1 crmplantspin_2 crmplantspin_2 proc~spincasacnp->crmplantspin_2 crmplantspin_3 crmplantspin_3 proc~spincasacnp->crmplantspin_3 d_macarthur_spin d_macarthur_spin proc~spincasacnp->d_macarthur_spin doyphasespin_1 doyphasespin_1 proc~spincasacnp->doyphasespin_1 doyphasespin_2 doyphasespin_2 proc~spincasacnp->doyphasespin_2 doyphasespin_3 doyphasespin_3 proc~spincasacnp->doyphasespin_3 doyphasespin_4 doyphasespin_4 proc~spincasacnp->doyphasespin_4 dprecip_spin dprecip_spin proc~spincasacnp->dprecip_spin drhum_spin drhum_spin proc~spincasacnp->drhum_spin dslr_spin dslr_spin proc~spincasacnp->dslr_spin dtemp_max_spin dtemp_max_spin proc~spincasacnp->dtemp_max_spin du10_max_spin du10_max_spin proc~spincasacnp->du10_max_spin ffdi_spin ffdi_spin proc~spincasacnp->ffdi_spin fraccalloc fraccalloc proc~spincasacnp->fraccalloc frecspin frecspin proc~spincasacnp->frecspin isoratio isoratio proc~spincasacnp->isoratio kbdi_spin kbdi_spin proc~spincasacnp->kbdi_spin last_precip_spin last_precip_spin proc~spincasacnp->last_precip_spin moistspin_1 moistspin_1 proc~spincasacnp->moistspin_1 moistspin_2 moistspin_2 proc~spincasacnp->moistspin_2 moistspin_3 moistspin_3 proc~spincasacnp->moistspin_3 moistspin_4 moistspin_4 proc~spincasacnp->moistspin_4 moistspin_5 moistspin_5 proc~spincasacnp->moistspin_5 moistspin_6 moistspin_6 proc~spincasacnp->moistspin_6 mtempspin mtempspin proc~spincasacnp->mtempspin phasespin phasespin proc~spincasacnp->phasespin proc~analyticpool casa_cable::analyticpool proc~spincasacnp->proc~analyticpool proc~biogeochem casa_inout::biogeochem proc~spincasacnp->proc~biogeochem proc~casa_fluxout casa_inout::casa_fluxout proc~spincasacnp->proc~casa_fluxout proc~popdriver casa_cable::POPdriver proc~spincasacnp->proc~popdriver proc~read_casa_dump casa_cable::read_casa_dump proc~spincasacnp->proc~read_casa_dump proc~write_casa_output_nc casa_inout::write_casa_output_nc proc~spincasacnp->proc~write_casa_output_nc rationcsoilnew rationcsoilnew proc~spincasacnp->rationcsoilnew tairkspin tairkspin proc~spincasacnp->tairkspin tsoilspin_1 tsoilspin_1 proc~spincasacnp->tsoilspin_1 tsoilspin_2 tsoilspin_2 proc~spincasacnp->tsoilspin_2 tsoilspin_3 tsoilspin_3 proc~spincasacnp->tsoilspin_3 tsoilspin_4 tsoilspin_4 proc~spincasacnp->tsoilspin_4 tsoilspin_5 tsoilspin_5 proc~spincasacnp->tsoilspin_5 tsoilspin_6 tsoilspin_6 proc~spincasacnp->tsoilspin_6 write_blaze_output_nc write_blaze_output_nc proc~spincasacnp->write_blaze_output_nc clay clay proc~analyticpool->clay clitter clitter proc~analyticpool->clitter csoil csoil proc~analyticpool->csoil fracligninplant fracligninplant proc~analyticpool->fracligninplant fromltos fromltos proc~analyticpool->fromltos fromstos fromstos proc~analyticpool->fromstos isorder isorder proc~analyticpool->isorder iveg iveg proc~analyticpool->iveg iveg2 iveg2 proc~analyticpool->iveg2 klitter klitter proc~analyticpool->klitter kmlabp kmlabp proc~analyticpool->kmlabp ksoil ksoil proc~analyticpool->ksoil litterrate litterrate proc~analyticpool->litterrate nlitter nlitter proc~analyticpool->nlitter nsoil nsoil proc~analyticpool->nsoil psoillab psoillab proc~analyticpool->psoillab psorbmax psorbmax proc~analyticpool->psorbmax rationclitter rationclitter proc~analyticpool->rationclitter rationcsoil rationcsoil proc~analyticpool->rationcsoil rationpsoil rationpsoil proc~analyticpool->rationpsoil ratiopclitter ratiopclitter proc~analyticpool->ratiopclitter ratiopcsoil ratiopcsoil proc~analyticpool->ratiopcsoil silt silt proc~analyticpool->silt soilrate soilrate proc~analyticpool->soilrate cplant_turnover cplant_turnover proc~biogeochem->cplant_turnover iwood iwood proc~biogeochem->iwood proc~biogeochem->klitter klitter_fire klitter_fire proc~biogeochem->klitter_fire kplant kplant proc~biogeochem->kplant kplant_fire kplant_fire proc~biogeochem->kplant_fire pop_grid pop_grid proc~biogeochem->pop_grid proc~avgsoil casa_cnp_module::avgsoil proc~biogeochem->proc~avgsoil proc~casa_allocation casa_cnp_module::casa_allocation proc~biogeochem->proc~casa_allocation proc~casa_cnpbal casa_cnp_module::casa_cnpbal proc~biogeochem->proc~casa_cnpbal proc~casa_cnpcycle casa_cnp_module::casa_cnpcycle proc~biogeochem->proc~casa_cnpcycle proc~casa_cnpflux casa_inout::casa_cnpflux proc~biogeochem->proc~casa_cnpflux proc~casa_coeffplant casa_cnp_module::casa_coeffplant proc~biogeochem->proc~casa_coeffplant proc~casa_coeffsoil casa_cnp_module::casa_coeffsoil proc~biogeochem->proc~casa_coeffsoil proc~casa_delplant casa_cnp_module::casa_delplant proc~biogeochem->proc~casa_delplant proc~casa_delsoil casa_cnp_module::casa_delsoil proc~biogeochem->proc~casa_delsoil proc~casa_ndummy casa_cnp_module::casa_ndummy proc~biogeochem->proc~casa_ndummy proc~casa_nuptake casa_cnp_module::casa_nuptake proc~biogeochem->proc~casa_nuptake proc~casa_pdummy casa_cnp_module::casa_pdummy proc~biogeochem->proc~casa_pdummy proc~casa_puptake casa_cnp_module::casa_puptake proc~biogeochem->proc~casa_puptake proc~casa_rplant casa_cnp_module::casa_rplant proc~biogeochem->proc~casa_rplant proc~casa_xkn casa_cnp_module::casa_xkN proc~biogeochem->proc~casa_xkn proc~casa_xnp casa_cnp_module::casa_xnp proc~biogeochem->proc~casa_xnp proc~casa_xrateplant casa_cnp_module::casa_xrateplant proc~biogeochem->proc~casa_xrateplant proc~casa_xratesoil casa_cnp_module::casa_xratesoil proc~biogeochem->proc~casa_xratesoil proc~phenology casa_cnp_module::phenology proc~biogeochem->proc~phenology areacell areacell proc~casa_fluxout->areacell fcgppyear fcgppyear proc~casa_fluxout->fcgppyear fcneeyear fcneeyear proc~casa_fluxout->fcneeyear fcnppyear fcnppyear proc~casa_fluxout->fcnppyear fcrgrowyear fcrgrowyear proc~casa_fluxout->fcrgrowyear fcrmleafyear fcrmleafyear proc~casa_fluxout->fcrmleafyear fcrmrootyear fcrmrootyear proc~casa_fluxout->fcrmrootyear fcrmwoodyear fcrmwoodyear proc~casa_fluxout->fcrmwoodyear fcrsyear fcrsyear proc~casa_fluxout->fcrsyear fndepyear fndepyear proc~casa_fluxout->fndepyear fnfixyear fnfixyear proc~casa_fluxout->fnfixyear fnleachyear fnleachyear proc~casa_fluxout->fnleachyear fnlossyear fnlossyear proc~casa_fluxout->fnlossyear fnsnetyear fnsnetyear proc~casa_fluxout->fnsnetyear fnupyear fnupyear proc~casa_fluxout->fnupyear fpdustyear fpdustyear proc~casa_fluxout->fpdustyear fpleachyear fpleachyear proc~casa_fluxout->fpleachyear fplossyear fplossyear proc~casa_fluxout->fplossyear fpsnetyear fpsnetyear proc~casa_fluxout->fpsnetyear fpupyear fpupyear proc~casa_fluxout->fpupyear fpweayear fpweayear proc~casa_fluxout->fpweayear isoilm isoilm proc~casa_fluxout->isoilm proc~casa_fluxout->isorder proc~casa_fluxout->iveg lat lat proc~casa_fluxout->lat lon lon proc~casa_fluxout->lon disturbance_intensity disturbance_intensity proc~popdriver->disturbance_intensity disturbance_interval disturbance_interval proc~popdriver->disturbance_interval proc~popstep POPModule::POPStep proc~popdriver->proc~popstep get_var_nc get_var_nc proc~read_casa_dump->get_var_nc nf90_close nf90_close proc~read_casa_dump->nf90_close nf90_open nf90_open proc~read_casa_dump->nf90_open stderr_nc stderr_nc proc~read_casa_dump->stderr_nc handle_err handle_err proc~write_casa_output_nc->handle_err proc~write_casa_output_nc->nf90_close nf90_create nf90_create proc~write_casa_output_nc->nf90_create nf90_def_dim nf90_def_dim proc~write_casa_output_nc->nf90_def_dim nf90_def_var nf90_def_var proc~write_casa_output_nc->nf90_def_var nf90_enddef nf90_enddef proc~write_casa_output_nc->nf90_enddef nf90_put_att nf90_put_att proc~write_casa_output_nc->nf90_put_att nf90_put_var nf90_put_var proc~write_casa_output_nc->nf90_put_var patch patch proc~write_casa_output_nc->patch btran btran proc~avgsoil->btran moist moist proc~avgsoil->moist moistavg moistavg proc~avgsoil->moistavg tsoilavg tsoilavg proc~avgsoil->tsoilavg proc~casa_allocation->cplant proc~casa_allocation->fraccalloc proc~casa_allocation->iveg proc~casa_allocation->btran crmplant crmplant proc~casa_allocation->crmplant fracnpptop fracnpptop proc~casa_allocation->fracnpptop glai glai proc~casa_allocation->glai glaimax glaimax proc~casa_allocation->glaimax glaimin glaimin proc~casa_allocation->glaimin kplant_tot kplant_tot proc~casa_allocation->kplant_tot la_to_sa la_to_sa proc~casa_allocation->la_to_sa proc~casa_allocation->moistavg proc~casa_wolf casa_cnp_module::casa_wolf proc~casa_allocation->proc~casa_wolf sfc sfc proc~casa_allocation->sfc sla sla proc~casa_allocation->sla swilt swilt proc~casa_allocation->swilt proc~casa_allocation->tsoilavg proc~casa_cnpbal->cplant proc~casa_cnpbal->klitter proc~casa_cnpbal->klitter_fire proc~casa_cnpbal->kplant proc~casa_cnpbal->kplant_fire proc~casa_cnpbal->psoillab clabile clabile proc~casa_cnpbal->clabile clabilelast clabilelast proc~casa_cnpbal->clabilelast clitterlast clitterlast proc~casa_cnpbal->clitterlast cnpp cnpp proc~casa_cnpbal->cnpp cplantlast cplantlast proc~casa_cnpbal->cplantlast crsoil crsoil proc~casa_cnpbal->crsoil fharvest fharvest proc~casa_cnpbal->fharvest fluxctoco2_plant_fire fluxctoco2_plant_fire proc~casa_cnpbal->fluxctoco2_plant_fire fluxctolitter fluxctolitter proc~casa_cnpbal->fluxctolitter fluxfromptoco2 fluxfromptoco2 proc~casa_cnpbal->fluxfromptoco2 fromptol_fire fromptol_fire proc~casa_cnpbal->fromptol_fire klitter_tot klitter_tot proc~casa_cnpbal->klitter_tot proc~casa_cnpbal->kplant_tot nmindep nmindep proc~casa_cnpbal->nmindep nminfix nminfix proc~casa_cnpbal->nminfix nminleach nminleach proc~casa_cnpbal->nminleach nminloss nminloss proc~casa_cnpbal->nminloss nminuptake nminuptake proc~casa_cnpbal->nminuptake nsoilmin nsoilmin proc~casa_cnpbal->nsoilmin nsoilminlast nsoilminlast proc~casa_cnpbal->nsoilminlast nupland nupland proc~casa_cnpbal->nupland pdep pdep proc~casa_cnpbal->pdep plabuptake plabuptake proc~casa_cnpbal->plabuptake pleach pleach proc~casa_cnpbal->pleach ploss ploss proc~casa_cnpbal->ploss psoillablast psoillablast proc~casa_cnpbal->psoillablast psoilocc psoilocc proc~casa_cnpbal->psoilocc psoilocclast psoilocclast proc~casa_cnpbal->psoilocclast psoilsorb psoilsorb proc~casa_cnpbal->psoilsorb psoilsorblast psoilsorblast proc~casa_cnpbal->psoilsorblast pupland pupland proc~casa_cnpbal->pupland pwea pwea proc~casa_cnpbal->pwea proc~casa_cnpcycle->cplant proc~casa_cnpcycle->clitter proc~casa_cnpcycle->csoil proc~casa_cnpcycle->iveg proc~casa_cnpcycle->iveg2 proc~casa_cnpcycle->kmlabp proc~casa_cnpcycle->lat proc~casa_cnpcycle->lon proc~casa_cnpcycle->nlitter proc~casa_cnpcycle->nsoil proc~casa_cnpcycle->psoillab proc~casa_cnpcycle->psorbmax proc~casa_cnpcycle->clabile dclabiledt dclabiledt proc~casa_cnpcycle->dclabiledt dclitterdt dclitterdt proc~casa_cnpcycle->dclitterdt dcplantdt dcplantdt proc~casa_cnpcycle->dcplantdt dcsoildt dcsoildt proc~casa_cnpcycle->dcsoildt dnlitterdt dnlitterdt proc~casa_cnpcycle->dnlitterdt dnplantdt dnplantdt proc~casa_cnpcycle->dnplantdt dnsoildt dnsoildt proc~casa_cnpcycle->dnsoildt dnsoilmindt dnsoilmindt proc~casa_cnpcycle->dnsoilmindt dplitterdt dplitterdt proc~casa_cnpcycle->dplitterdt dpplantdt dpplantdt proc~casa_cnpcycle->dpplantdt dpsoildt dpsoildt proc~casa_cnpcycle->dpsoildt dpsoillabdt dpsoillabdt proc~casa_cnpcycle->dpsoillabdt dpsoiloccdt dpsoiloccdt proc~casa_cnpcycle->dpsoiloccdt proc~casa_cnpcycle->glai proc~casa_cnpcycle->glaimax proc~casa_cnpcycle->glaimin nplant nplant proc~casa_cnpcycle->nplant proc~casa_cnpcycle->nsoilmin plitter plitter proc~casa_cnpcycle->plitter pplant pplant proc~casa_cnpcycle->pplant proc~casa_poolzero casa_cnp_module::casa_poolzero proc~casa_cnpcycle->proc~casa_poolzero psoil psoil proc~casa_cnpcycle->psoil proc~casa_cnpcycle->psoilocc rationcplantmax rationcplantmax proc~casa_cnpcycle->rationcplantmax proc~casa_cnpcycle->sla proc~casa_cnpflux->fcrmleafyear proc~casa_cnpflux->fcrmrootyear proc~casa_cnpflux->fcrmwoodyear proc~casa_cnpflux->crmplant proc~casa_coeffplant->cplant proc~casa_coeffplant->fracligninplant proc~casa_coeffplant->iveg proc~casa_coeffplant->kplant proc~casa_coeffplant->kplant_fire fromptol fromptol proc~casa_coeffplant->fromptol ftransnptol ftransnptol proc~casa_coeffplant->ftransnptol proc~casa_coeffplant->glai proc~casa_coeffplant->glaimin proc~casa_coeffplant->nplant plantrate plantrate proc~casa_coeffplant->plantrate proc~casa_coeffsoil->clay proc~casa_coeffsoil->fracligninplant proc~casa_coeffsoil->fromltos proc~casa_coeffsoil->fromstos proc~casa_coeffsoil->isorder proc~casa_coeffsoil->iveg proc~casa_coeffsoil->iveg2 proc~casa_coeffsoil->klitter proc~casa_coeffsoil->klitter_fire proc~casa_coeffsoil->ksoil proc~casa_coeffsoil->litterrate proc~casa_coeffsoil->silt proc~casa_coeffsoil->soilrate fromltoco2 fromltoco2 proc~casa_coeffsoil->fromltoco2 fromstoco2 fromstoco2 proc~casa_coeffsoil->fromstoco2 xkplab xkplab proc~casa_coeffsoil->xkplab xkpocc xkpocc proc~casa_coeffsoil->xkpocc xkpsorb xkpsorb proc~casa_coeffsoil->xkpsorb proc~casa_delplant->cplant proc~casa_delplant->fraccalloc proc~casa_delplant->iveg proc~casa_delplant->iveg2 proc~casa_delplant->kplant proc~casa_delplant->kplant_fire cgpp cgpp proc~casa_delplant->cgpp charvest charvest proc~casa_delplant->charvest clabloss clabloss proc~casa_delplant->clabloss proc~casa_delplant->cnpp crgplant crgplant proc~casa_delplant->crgplant proc~casa_delplant->crmplant proc~casa_delplant->dcplantdt proc~casa_delplant->dnplantdt proc~casa_delplant->dpplantdt proc~casa_delplant->fharvest proc~casa_delplant->fluxctoco2_plant_fire proc~casa_delplant->fluxctolitter proc~casa_delplant->fluxfromptoco2 fluxfromptoharvest fluxfromptoharvest proc~casa_delplant->fluxfromptoharvest fluxntolitter fluxntolitter proc~casa_delplant->fluxntolitter fluxptolitter fluxptolitter proc~casa_delplant->fluxptolitter fracclabile fracclabile proc~casa_delplant->fracclabile fracnalloc fracnalloc proc~casa_delplant->fracnalloc fracpalloc fracpalloc proc~casa_delplant->fracpalloc proc~casa_delplant->fromptol proc~casa_delplant->fromptol_fire proc~casa_delplant->ftransnptol ftranspptol ftranspptol proc~casa_delplant->ftranspptol proc~casa_delplant->kplant_tot lnonwood lnonwood proc~casa_delplant->lnonwood nharvest nharvest proc~casa_delplant->nharvest proc~casa_delplant->nminuptake proc~casa_delplant->nplant pharvest pharvest proc~casa_delplant->pharvest proc~casa_delplant->plabuptake proc~casa_delplant->pplant proc~casa_delsoil->rationcsoilnew proc~casa_delsoil->clitter proc~casa_delsoil->csoil proc~casa_delsoil->fromltos proc~casa_delsoil->fromstos proc~casa_delsoil->iveg proc~casa_delsoil->iveg2 proc~casa_delsoil->klitter proc~casa_delsoil->klitter_fire proc~casa_delsoil->kmlabp proc~casa_delsoil->ksoil proc~casa_delsoil->nlitter proc~casa_delsoil->nsoil proc~casa_delsoil->psoillab proc~casa_delsoil->psorbmax proc~casa_delsoil->rationpsoil proc~casa_delsoil->cnpp costnpup costnpup proc~casa_delsoil->costnpup proc~casa_delsoil->crsoil proc~casa_delsoil->dpsoillabdt fluxctoco2 fluxctoco2 proc~casa_delsoil->fluxctoco2 fluxctoco2_litter_fire fluxctoco2_litter_fire proc~casa_delsoil->fluxctoco2_litter_fire proc~casa_delsoil->fluxctolitter fluxctosoil fluxctosoil proc~casa_delsoil->fluxctosoil fluxfromltoco2 fluxfromltoco2 proc~casa_delsoil->fluxfromltoco2 fluxfromltos fluxfromltos proc~casa_delsoil->fluxfromltos fluxfromstoco2 fluxfromstoco2 proc~casa_delsoil->fluxfromstoco2 fluxfromstos fluxfromstos proc~casa_delsoil->fluxfromstos proc~casa_delsoil->fluxntolitter fluxntosoil fluxntosoil proc~casa_delsoil->fluxntosoil proc~casa_delsoil->fluxptolitter fluxptosoil fluxptosoil proc~casa_delsoil->fluxptosoil fnminleach fnminleach proc~casa_delsoil->fnminleach fnminloss fnminloss proc~casa_delsoil->fnminloss fpleach fpleach proc~casa_delsoil->fpleach proc~casa_delsoil->fromltoco2 proc~casa_delsoil->fromstoco2 proc~casa_delsoil->klitter_tot kpocc kpocc proc~casa_delsoil->kpocc kpsorb kpsorb proc~casa_delsoil->kpsorb nlittermin nlittermin proc~casa_delsoil->nlittermin proc~casa_delsoil->nmindep proc~casa_delsoil->nminfix proc~casa_delsoil->nminleach proc~casa_delsoil->nminloss nsimm nsimm proc~casa_delsoil->nsimm nsmin nsmin proc~casa_delsoil->nsmin nsnet nsnet proc~casa_delsoil->nsnet proc~casa_delsoil->nsoilmin proc~casa_delsoil->nupland proc~casa_delsoil->pdep proc~casa_delsoil->pleach proc~casa_delsoil->plitter plittermin plittermin proc~casa_delsoil->plittermin prodptase prodptase proc~casa_delsoil->prodptase psimm psimm proc~casa_delsoil->psimm psmin psmin proc~casa_delsoil->psmin psnet psnet proc~casa_delsoil->psnet proc~casa_delsoil->psoil proc~casa_delsoil->psoilocc proc~casa_delsoil->psoilsorb proc~casa_delsoil->pupland proc~casa_delsoil->pwea proc~casa_delsoil->tsoilavg proc~casa_ndummy->cplant rationcplant rationcplant proc~casa_ndummy->rationcplant proc~casa_nuptake->iveg proc~casa_nuptake->iveg2 kminn kminn proc~casa_nuptake->kminn proc~casa_nuptake->nminuptake proc~casa_nuptake->nsoilmin proc~casa_nrequire casa_cnp_module::casa_Nrequire proc~casa_nuptake->proc~casa_nrequire proc~casa_pdummy->nplant rationpplant rationpplant proc~casa_pdummy->rationpplant proc~casa_puptake->iveg proc~casa_puptake->psoillab kuplabp kuplabp proc~casa_puptake->kuplabp proc~casa_puptake->plabuptake proc~casa_prequire casa_cnp_module::casa_Prequire proc~casa_puptake->proc~casa_prequire proc~casa_rplant->cplant proc~casa_rplant->iveg proc~casa_rplant->cgpp proc~casa_rplant->clabile proc~casa_rplant->crgplant proc~casa_rplant->crmplant frac_sapwood frac_sapwood proc~casa_rplant->frac_sapwood frec frec proc~casa_rplant->frec kclabrate kclabrate proc~casa_rplant->kclabrate proc~casa_rplant->nplant proc~vcmax_np casa_cnp_module::vcmax_np proc~casa_rplant->proc~vcmax_np qtemp_max_last_year qtemp_max_last_year proc~casa_rplant->qtemp_max_last_year proc~casa_rplant->rationcplantmax ratiopcplantmax ratiopcplantmax proc~casa_rplant->ratiopcplantmax rmplant rmplant proc~casa_rplant->rmplant proc~casa_rplant->sla tairk tairk proc~casa_rplant->tairk proc~casa_rplant->tsoilavg vcmax vcmax proc~casa_rplant->vcmax vcmax_scalar vcmax_scalar proc~casa_rplant->vcmax_scalar proc~casa_xkn->rationcsoilnew proc~casa_xkn->clitter proc~casa_xkn->csoil proc~casa_xkn->fromltos proc~casa_xkn->fromstos proc~casa_xkn->iveg proc~casa_xkn->iveg2 proc~casa_xkn->klitter proc~casa_xkn->ksoil proc~casa_xkn->nlitter proc~casa_xkn->nsoil maxcwd maxcwd proc~casa_xkn->maxcwd maxfinelitter maxfinelitter proc~casa_xkn->maxfinelitter proc~casa_xkn->nsoilmin rationcsoilmax rationcsoilmax proc~casa_xkn->rationcsoilmax rationcsoilmin rationcsoilmin proc~casa_xkn->rationcsoilmin proc~casa_xnp->cplant proc~casa_xnp->iveg proc~casa_xnp->iveg2 proc~casa_xnp->psoillab proc~casa_xnp->cgpp proc~casa_xnp->cnpp proc~casa_xnp->fharvest proc~casa_xnp->fracclabile proc~casa_xnp->nplant proc~casa_xnp->nsoilmin proc~casa_xnp->pplant proc~casa_xnp->proc~casa_nrequire proc~casa_xnp->proc~casa_prequire xnpmax xnpmax proc~casa_xnp->xnpmax proc~casa_xrateplant->iveg proc~casa_xrateplant->iveg2 proc~casa_xrateplant->btran ge ge proc~casa_xrateplant->ge le le proc~casa_xrateplant->le proc~casa_xrateplant->lnonwood phase phase proc~casa_xrateplant->phase proc~casa_xrateplant->tairk tkshed tkshed proc~casa_xrateplant->tkshed xkleafcoldexp xkleafcoldexp proc~casa_xrateplant->xkleafcoldexp xkleafcoldmax xkleafcoldmax proc~casa_xrateplant->xkleafcoldmax xkleafdryexp xkleafdryexp proc~casa_xrateplant->xkleafdryexp xkleafdrymax xkleafdrymax proc~casa_xrateplant->xkleafdrymax proc~casa_xratesoil->iveg proc~casa_xratesoil->iveg2 damm_alpha damm_alpha proc~casa_xratesoil->damm_alpha damm_ea damm_ea proc~casa_xratesoil->damm_ea damm_enzpool damm_enzpool proc~casa_xratesoil->damm_enzpool damm_kmcp damm_kmcp proc~casa_xratesoil->damm_kmcp damm_kmo2 damm_kmo2 proc~casa_xratesoil->damm_kmo2 proc~casa_xratesoil->moistavg q10soil q10soil proc~casa_xratesoil->q10soil ssat ssat proc~casa_xratesoil->ssat proc~casa_xratesoil->tsoilavg xkoptlitter xkoptlitter proc~casa_xratesoil->xkoptlitter xkoptsoil xkoptsoil proc~casa_xratesoil->xkoptsoil doyphase doyphase proc~phenology->doyphase proc~phenology->phase proc~popstep->pop_grid proc~getdiagnostics POPModule::GetDiagnostics proc~popstep->proc~getdiagnostics proc~getpatchfrequencies POPModule::GetPatchFrequencies proc~popstep->proc~getpatchfrequencies proc~getuniqueagefrequencies POPModule::GetUniqueAgeFrequencies proc~popstep->proc~getuniqueagefrequencies proc~patch_disturb POPModule::Patch_disturb proc~popstep->proc~patch_disturb proc~patch_partial_disturb POPModule::Patch_partial_disturb proc~popstep->proc~patch_partial_disturb proc~patch_partial_disturb2 POPModule::Patch_partial_disturb2 proc~popstep->proc~patch_partial_disturb2 proc~patchannualdynamics POPModule::PatchAnnualDynamics proc~popstep->proc~patchannualdynamics proc~casa_nrequire->cplant proc~casa_nrequire->fraccalloc proc~casa_nrequire->iveg proc~casa_nrequire->iveg2 proc~casa_nrequire->kplant proc~casa_nrequire->ftransnptol proc~casa_nrequire->nplant proc~casa_nrequire->nsoilmin proc~casa_nrequire->rationcplantmax rationcplantmin rationcplantmin proc~casa_nrequire->rationcplantmin proc~casa_poolzero->cplant proc~casa_poolzero->clitter proc~casa_poolzero->csoil proc~casa_poolzero->nlitter proc~casa_poolzero->nsoil proc~casa_poolzero->nplant proc~casa_prequire->cplant proc~casa_prequire->fraccalloc proc~casa_prequire->iveg proc~casa_prequire->iveg2 proc~casa_prequire->kplant proc~casa_prequire->ftranspptol proc~casa_prequire->nplant proc~casa_prequire->pplant rationpplantmax rationpplantmax proc~casa_prequire->rationpplantmax rationpplantmin rationpplantmin proc~casa_prequire->rationpplantmin proc~casa_wolf->cplant proc~casa_wolf->iveg proc~casa_wolf->iveg2 proc~casa_wolf->cnpp proc~casa_wolf->fracnpptop proc~getdiagnostics->pop_grid proc~get_allometry POPModule::GET_ALLOMETRY proc~getdiagnostics->proc~get_allometry proc~interpolate_biomass_1d POPModule::INTERPOLATE_BIOMASS_1D proc~getdiagnostics->proc~interpolate_biomass_1d proc~interpolate_biomass_2d POPModule::INTERPOLATE_BIOMASS_2D proc~getdiagnostics->proc~interpolate_biomass_2d proc~smooth_flux POPModule::SMOOTH_FLUX proc~getdiagnostics->proc~smooth_flux proc~getpatchfrequencies->pop_grid proc~getuniqueagefrequencies->pop_grid proc~cumexponential POPModule::CumExponential proc~getuniqueagefrequencies->proc~cumexponential proc~realexponential POPModule::REALExponential proc~getuniqueagefrequencies->proc~realexponential proc~patch_disturb->pop_grid proc~layer_recruitment_single_patch POPModule::layer_recruitment_single_patch proc~patch_disturb->proc~layer_recruitment_single_patch proc~patch_partial_disturb->pop_grid proc~patch_partial_disturb2->pop_grid proc~patchannualdynamics->pop_grid proc~patchannualdynamics->proc~get_allometry proc~layer_recruitment POPModule::layer_recruitment proc~patchannualdynamics->proc~layer_recruitment proc~allometry POPModule::Allometry proc~get_allometry->proc~allometry proc~getheight POPModule::GetHeight proc~get_allometry->proc~getheight proc~williams_allometry POPModule::Williams_Allometry proc~get_allometry->proc~williams_allometry proc~interpolate_biomass_1d->pop_grid proc~interpolate_biomass_1d->proc~realexponential proc~interpolate_biomass_2d->pop_grid proc~interpolate_biomass_2d->proc~realexponential eq eq proc~interpolate_biomass_2d->eq proc~area_triangle POPModule::Area_Triangle proc~interpolate_biomass_2d->proc~area_triangle proc~layer_recruitment->pop_grid proc~layer_recruitment->proc~get_allometry proc~layer_recruitment_single_patch->pop_grid proc~layer_recruitment_single_patch->proc~get_allometry proc~smooth_flux->pop_grid proc~regress POPModule::REGRESS proc~smooth_flux->proc~regress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/spincasacnp.html"},{"title":"alloc_casabiome – POP","text":"private  subroutine alloc_casabiome(casabiome) Uses casadimension cable_def_types_mod proc~~alloc_casabiome~~UsesGraph proc~alloc_casabiome casavariable::alloc_casabiome cable_def_types_mod cable_def_types_mod proc~alloc_casabiome->cable_def_types_mod module~casadimension casadimension proc~alloc_casabiome->module~casadimension module~casadimension->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. vh_js !! Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(inout) :: casabiome Calls proc~~alloc_casabiome~~CallsGraph proc~alloc_casabiome casavariable::alloc_casabiome costnpup costnpup proc~alloc_casabiome->costnpup damm_alpha damm_alpha proc~alloc_casabiome->damm_alpha damm_ea damm_ea proc~alloc_casabiome->damm_ea damm_enzpool damm_enzpool proc~alloc_casabiome->damm_enzpool damm_kmcp damm_kmcp proc~alloc_casabiome->damm_kmcp damm_kmo2 damm_kmo2 proc~alloc_casabiome->damm_kmo2 disturbance_interval disturbance_interval proc~alloc_casabiome->disturbance_interval fraclabile fraclabile proc~alloc_casabiome->fraclabile fraclignin fraclignin proc~alloc_casabiome->fraclignin fracligninplant fracligninplant proc~alloc_casabiome->fracligninplant fracnpptop fracnpptop proc~alloc_casabiome->fracnpptop ftransnptol ftransnptol proc~alloc_casabiome->ftransnptol ftranspptol ftranspptol proc~alloc_casabiome->ftranspptol glaimax glaimax proc~alloc_casabiome->glaimax glaimin glaimin proc~alloc_casabiome->glaimin ivt2 ivt2 proc~alloc_casabiome->ivt2 kclabrate kclabrate proc~alloc_casabiome->kclabrate kminn kminn proc~alloc_casabiome->kminn kroot kroot proc~alloc_casabiome->kroot krootlen krootlen proc~alloc_casabiome->krootlen kuplabp kuplabp proc~alloc_casabiome->kuplabp kuptake kuptake proc~alloc_casabiome->kuptake la_to_sa la_to_sa proc~alloc_casabiome->la_to_sa litterrate litterrate proc~alloc_casabiome->litterrate maxcwd maxcwd proc~alloc_casabiome->maxcwd maxfinelitter maxfinelitter proc~alloc_casabiome->maxfinelitter nintercept nintercept proc~alloc_casabiome->nintercept nslope nslope proc~alloc_casabiome->nslope plantrate plantrate proc~alloc_casabiome->plantrate prodptase prodptase proc~alloc_casabiome->prodptase q10soil q10soil proc~alloc_casabiome->q10soil ratiofrootleaf ratiofrootleaf proc~alloc_casabiome->ratiofrootleaf rationcplantmax rationcplantmax proc~alloc_casabiome->rationcplantmax rationcplantmin rationcplantmin proc~alloc_casabiome->rationcplantmin rationpplantmax rationpplantmax proc~alloc_casabiome->rationpplantmax rationpplantmin rationpplantmin proc~alloc_casabiome->rationpplantmin ratiopcplantmax ratiopcplantmax proc~alloc_casabiome->ratiopcplantmax ratiopcplantmin ratiopcplantmin proc~alloc_casabiome->ratiopcplantmin rmplant rmplant proc~alloc_casabiome->rmplant rootdepth rootdepth proc~alloc_casabiome->rootdepth sla sla proc~alloc_casabiome->sla soilrate soilrate proc~alloc_casabiome->soilrate vcmax_scalar vcmax_scalar proc~alloc_casabiome->vcmax_scalar xkleafcoldexp xkleafcoldexp proc~alloc_casabiome->xkleafcoldexp xkleafcoldmax xkleafcoldmax proc~alloc_casabiome->xkleafcoldmax xkleafdryexp xkleafdryexp proc~alloc_casabiome->xkleafdryexp xkleafdrymax xkleafdrymax proc~alloc_casabiome->xkleafdrymax xkoptlitter xkoptlitter proc~alloc_casabiome->xkoptlitter xkoptsoil xkoptsoil proc~alloc_casabiome->xkoptsoil xkplab xkplab proc~alloc_casabiome->xkplab xkpocc xkpocc proc~alloc_casabiome->xkpocc xkpsorb xkpsorb proc~alloc_casabiome->xkpsorb xnpmax xnpmax proc~alloc_casabiome->xnpmax Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~alloc_casabiome~~CalledByGraph proc~alloc_casabiome casavariable::alloc_casabiome interface~alloc_casa_var casavariable::alloc_casa_var interface~alloc_casa_var->proc~alloc_casabiome Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/alloc_casabiome.html"},{"title":"alloc_casapool – POP","text":"private  subroutine alloc_casapool(casapool, arraysize) Uses casadimension proc~~alloc_casapool~~UsesGraph proc~alloc_casapool casavariable::alloc_casapool module~casadimension casadimension proc~alloc_casapool->module~casadimension cable_def_types_mod cable_def_types_mod module~casadimension->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: casapool integer, intent(in) :: arraysize Calls proc~~alloc_casapool~~CallsGraph proc~alloc_casapool casavariable::alloc_casapool clabile clabile proc~alloc_casapool->clabile clitter clitter proc~alloc_casapool->clitter cplant cplant proc~alloc_casapool->cplant csoil csoil proc~alloc_casapool->csoil ctot ctot proc~alloc_casapool->ctot ctot_0 ctot_0 proc~alloc_casapool->ctot_0 dclabiledt dclabiledt proc~alloc_casapool->dclabiledt dclitterdt dclitterdt proc~alloc_casapool->dclitterdt dcplantdt dcplantdt proc~alloc_casapool->dcplantdt dcsoildt dcsoildt proc~alloc_casapool->dcsoildt dnlitterdt dnlitterdt proc~alloc_casapool->dnlitterdt dnplantdt dnplantdt proc~alloc_casapool->dnplantdt dnsoildt dnsoildt proc~alloc_casapool->dnsoildt dnsoilmindt dnsoilmindt proc~alloc_casapool->dnsoilmindt dplitterdt dplitterdt proc~alloc_casapool->dplitterdt dpplantdt dpplantdt proc~alloc_casapool->dpplantdt dpsoildt dpsoildt proc~alloc_casapool->dpsoildt dpsoillabdt dpsoillabdt proc~alloc_casapool->dpsoillabdt dpsoiloccdt dpsoiloccdt proc~alloc_casapool->dpsoiloccdt dpsoilsorbdt dpsoilsorbdt proc~alloc_casapool->dpsoilsorbdt nlitter nlitter proc~alloc_casapool->nlitter nplant nplant proc~alloc_casapool->nplant nsoil nsoil proc~alloc_casapool->nsoil nsoilmin nsoilmin proc~alloc_casapool->nsoilmin plitter plitter proc~alloc_casapool->plitter pplant pplant proc~alloc_casapool->pplant psoil psoil proc~alloc_casapool->psoil psoillab psoillab proc~alloc_casapool->psoillab psoilocc psoilocc proc~alloc_casapool->psoilocc psoilsorb psoilsorb proc~alloc_casapool->psoilsorb rationclitter rationclitter proc~alloc_casapool->rationclitter rationcplant rationcplant proc~alloc_casapool->rationcplant rationcsoil rationcsoil proc~alloc_casapool->rationcsoil rationcsoilmax rationcsoilmax proc~alloc_casapool->rationcsoilmax rationcsoilmin rationcsoilmin proc~alloc_casapool->rationcsoilmin rationcsoilnew rationcsoilnew proc~alloc_casapool->rationcsoilnew rationplitter rationplitter proc~alloc_casapool->rationplitter rationpplant rationpplant proc~alloc_casapool->rationpplant rationpsoil rationpsoil proc~alloc_casapool->rationpsoil ratiopclitter ratiopclitter proc~alloc_casapool->ratiopclitter ratiopcplant ratiopcplant proc~alloc_casapool->ratiopcplant ratiopcsoil ratiopcsoil proc~alloc_casapool->ratiopcsoil Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~alloc_casapool~~CalledByGraph proc~alloc_casapool casavariable::alloc_casapool interface~alloc_casa_var casavariable::alloc_casa_var interface~alloc_casa_var->proc~alloc_casapool proc~alloc_sum_casa casavariable::alloc_sum_casa proc~alloc_sum_casa->proc~alloc_casapool Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/alloc_casapool.html"},{"title":"alloc_casaflux – POP","text":"private  subroutine alloc_casaflux(casaflux, arraysize) Uses casadimension proc~~alloc_casaflux~~UsesGraph proc~alloc_casaflux casavariable::alloc_casaflux module~casadimension casadimension proc~alloc_casaflux->module~casadimension cable_def_types_mod cable_def_types_mod module~casadimension->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(inout) :: casaflux integer, intent(in) :: arraysize Calls proc~~alloc_casaflux~~CallsGraph proc~alloc_casaflux casavariable::alloc_casaflux cgpp cgpp proc~alloc_casaflux->cgpp charvest charvest proc~alloc_casaflux->charvest clabloss clabloss proc~alloc_casaflux->clabloss cnep cnep proc~alloc_casaflux->cnep cnpp cnpp proc~alloc_casaflux->cnpp cplant_turnover cplant_turnover proc~alloc_casaflux->cplant_turnover cplant_turnover_crowding cplant_turnover_crowding proc~alloc_casaflux->cplant_turnover_crowding cplant_turnover_disturbance cplant_turnover_disturbance proc~alloc_casaflux->cplant_turnover_disturbance cplant_turnover_resource_limitation cplant_turnover_resource_limitation proc~alloc_casaflux->cplant_turnover_resource_limitation crgplant crgplant proc~alloc_casaflux->crgplant crmplant crmplant proc~alloc_casaflux->crmplant crp crp proc~alloc_casaflux->crp crsoil crsoil proc~alloc_casaflux->crsoil ctransferluc ctransferluc proc~alloc_casaflux->ctransferluc fcrop fcrop proc~alloc_casaflux->fcrop fharvest fharvest proc~alloc_casaflux->fharvest fluxctoclear fluxctoclear proc~alloc_casaflux->fluxctoclear fluxctoco2 fluxctoco2 proc~alloc_casaflux->fluxctoco2 fluxctoco2_litter_fire fluxctoco2_litter_fire proc~alloc_casaflux->fluxctoco2_litter_fire fluxctoco2_plant_fire fluxctoco2_plant_fire proc~alloc_casaflux->fluxctoco2_plant_fire fluxctohwp fluxctohwp proc~alloc_casaflux->fluxctohwp fluxctolitter fluxctolitter proc~alloc_casaflux->fluxctolitter fluxctosoil fluxctosoil proc~alloc_casaflux->fluxctosoil fluxfromltoco2 fluxfromltoco2 proc~alloc_casaflux->fluxfromltoco2 fluxfromltoco2_fire fluxfromltoco2_fire proc~alloc_casaflux->fluxfromltoco2_fire fluxfromltos fluxfromltos proc~alloc_casaflux->fluxfromltos fluxfromptoco2 fluxfromptoco2 proc~alloc_casaflux->fluxfromptoco2 fluxfromptoco2_fire fluxfromptoco2_fire proc~alloc_casaflux->fluxfromptoco2_fire fluxfromptoharvest fluxfromptoharvest proc~alloc_casaflux->fluxfromptoharvest fluxfromptol fluxfromptol proc~alloc_casaflux->fluxfromptol fluxfromstoco2 fluxfromstoco2 proc~alloc_casaflux->fluxfromstoco2 fluxfromstos fluxfromstos proc~alloc_casaflux->fluxfromstos fluxntoatm_fire fluxntoatm_fire proc~alloc_casaflux->fluxntoatm_fire fluxntoclear fluxntoclear proc~alloc_casaflux->fluxntoclear fluxntohwp fluxntohwp proc~alloc_casaflux->fluxntohwp fluxntolitter fluxntolitter proc~alloc_casaflux->fluxntolitter fluxntosoil fluxntosoil proc~alloc_casaflux->fluxntosoil fluxptoclear fluxptoclear proc~alloc_casaflux->fluxptoclear fluxptohwp fluxptohwp proc~alloc_casaflux->fluxptohwp fluxptolitter fluxptolitter proc~alloc_casaflux->fluxptolitter fluxptosoil fluxptosoil proc~alloc_casaflux->fluxptosoil fnminleach fnminleach proc~alloc_casaflux->fnminleach fnminloss fnminloss proc~alloc_casaflux->fnminloss fpleach fpleach proc~alloc_casaflux->fpleach frac_sapwood frac_sapwood proc~alloc_casaflux->frac_sapwood fraccalloc fraccalloc proc~alloc_casaflux->fraccalloc fracclabile fracclabile proc~alloc_casaflux->fracclabile fracnalloc fracnalloc proc~alloc_casaflux->fracnalloc fracpalloc fracpalloc proc~alloc_casaflux->fracpalloc fromltoco2 fromltoco2 proc~alloc_casaflux->fromltoco2 fromltos fromltos proc~alloc_casaflux->fromltos fromptol fromptol proc~alloc_casaflux->fromptol fromptol_fire fromptol_fire proc~alloc_casaflux->fromptol_fire fromstoco2 fromstoco2 proc~alloc_casaflux->fromstoco2 fromstos fromstos proc~alloc_casaflux->fromstos klitter klitter proc~alloc_casaflux->klitter klitter_fire klitter_fire proc~alloc_casaflux->klitter_fire klitter_tot klitter_tot proc~alloc_casaflux->klitter_tot kmlabp kmlabp proc~alloc_casaflux->kmlabp kplab kplab proc~alloc_casaflux->kplab kplant kplant proc~alloc_casaflux->kplant kplant_fire kplant_fire proc~alloc_casaflux->kplant_fire kplant_tot kplant_tot proc~alloc_casaflux->kplant_tot kpocc kpocc proc~alloc_casaflux->kpocc kpsorb kpsorb proc~alloc_casaflux->kpsorb ksoil ksoil proc~alloc_casaflux->ksoil nharvest nharvest proc~alloc_casaflux->nharvest nlittermin nlittermin proc~alloc_casaflux->nlittermin nmindep nmindep proc~alloc_casaflux->nmindep nminfix nminfix proc~alloc_casaflux->nminfix nminleach nminleach proc~alloc_casaflux->nminleach nminloss nminloss proc~alloc_casaflux->nminloss nminuptake nminuptake proc~alloc_casaflux->nminuptake nsimm nsimm proc~alloc_casaflux->nsimm nsmin nsmin proc~alloc_casaflux->nsmin nsnet nsnet proc~alloc_casaflux->nsnet nupland nupland proc~alloc_casaflux->nupland pdep pdep proc~alloc_casaflux->pdep pharvest pharvest proc~alloc_casaflux->pharvest plabuptake plabuptake proc~alloc_casaflux->plabuptake pleach pleach proc~alloc_casaflux->pleach plittermin plittermin proc~alloc_casaflux->plittermin ploss ploss proc~alloc_casaflux->ploss psimm psimm proc~alloc_casaflux->psimm psmin psmin proc~alloc_casaflux->psmin psnet psnet proc~alloc_casaflux->psnet psorbmax psorbmax proc~alloc_casaflux->psorbmax pupland pupland proc~alloc_casaflux->pupland pwea pwea proc~alloc_casaflux->pwea sapwood_area sapwood_area proc~alloc_casaflux->sapwood_area stemnpp stemnpp proc~alloc_casaflux->stemnpp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~alloc_casaflux~~CalledByGraph proc~alloc_casaflux casavariable::alloc_casaflux interface~alloc_casa_var casavariable::alloc_casa_var interface~alloc_casa_var->proc~alloc_casaflux proc~alloc_sum_casa casavariable::alloc_sum_casa proc~alloc_sum_casa->proc~alloc_casaflux Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/alloc_casaflux.html"},{"title":"alloc_casamet – POP","text":"private  subroutine alloc_casamet(casamet, arraysize) Uses casadimension cable_def_types_mod proc~~alloc_casamet~~UsesGraph proc~alloc_casamet casavariable::alloc_casamet cable_def_types_mod cable_def_types_mod proc~alloc_casamet->cable_def_types_mod module~casadimension casadimension proc~alloc_casamet->module~casadimension module~casadimension->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( casa_met ), intent(inout) :: casamet integer, intent(in) :: arraysize Calls proc~~alloc_casamet~~CallsGraph proc~alloc_casamet casavariable::alloc_casamet aprecip_av20_spin aprecip_av20_spin proc~alloc_casamet->aprecip_av20_spin areacell areacell proc~alloc_casamet->areacell btran btran proc~alloc_casamet->btran can12spin can12spin proc~alloc_casamet->can12spin can13spin can13spin proc~alloc_casamet->can13spin cgppspin cgppspin proc~alloc_casamet->cgppspin crmplantspin_1 crmplantspin_1 proc~alloc_casamet->crmplantspin_1 crmplantspin_2 crmplantspin_2 proc~alloc_casamet->crmplantspin_2 crmplantspin_3 crmplantspin_3 proc~alloc_casamet->crmplantspin_3 d_macarthur_spin d_macarthur_spin proc~alloc_casamet->d_macarthur_spin dprecip_spin dprecip_spin proc~alloc_casamet->dprecip_spin drhum_spin drhum_spin proc~alloc_casamet->drhum_spin dslr_spin dslr_spin proc~alloc_casamet->dslr_spin dtemp_max_spin dtemp_max_spin proc~alloc_casamet->dtemp_max_spin dtemp_min_spin dtemp_min_spin proc~alloc_casamet->dtemp_min_spin du10_max_spin du10_max_spin proc~alloc_casamet->du10_max_spin ffdi_spin ffdi_spin proc~alloc_casamet->ffdi_spin frecspin frecspin proc~alloc_casamet->frecspin glai glai proc~alloc_casamet->glai ijgcm ijgcm proc~alloc_casamet->ijgcm isorder isorder proc~alloc_casamet->isorder iveg2 iveg2 proc~alloc_casamet->iveg2 kbdi_spin kbdi_spin proc~alloc_casamet->kbdi_spin last_precip_spin last_precip_spin proc~alloc_casamet->last_precip_spin lat lat proc~alloc_casamet->lat lnonwood lnonwood proc~alloc_casamet->lnonwood lon lon proc~alloc_casamet->lon moist moist proc~alloc_casamet->moist moistavg moistavg proc~alloc_casamet->moistavg moistspin_1 moistspin_1 proc~alloc_casamet->moistspin_1 moistspin_2 moistspin_2 proc~alloc_casamet->moistspin_2 moistspin_3 moistspin_3 proc~alloc_casamet->moistspin_3 moistspin_4 moistspin_4 proc~alloc_casamet->moistspin_4 moistspin_5 moistspin_5 proc~alloc_casamet->moistspin_5 moistspin_6 moistspin_6 proc~alloc_casamet->moistspin_6 mtempspin mtempspin proc~alloc_casamet->mtempspin precip precip proc~alloc_casamet->precip tairk tairk proc~alloc_casamet->tairk tairkspin tairkspin proc~alloc_casamet->tairkspin tsoil tsoil proc~alloc_casamet->tsoil tsoilavg tsoilavg proc~alloc_casamet->tsoilavg tsoilspin_1 tsoilspin_1 proc~alloc_casamet->tsoilspin_1 tsoilspin_2 tsoilspin_2 proc~alloc_casamet->tsoilspin_2 tsoilspin_3 tsoilspin_3 proc~alloc_casamet->tsoilspin_3 tsoilspin_4 tsoilspin_4 proc~alloc_casamet->tsoilspin_4 tsoilspin_5 tsoilspin_5 proc~alloc_casamet->tsoilspin_5 tsoilspin_6 tsoilspin_6 proc~alloc_casamet->tsoilspin_6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~alloc_casamet~~CalledByGraph proc~alloc_casamet casavariable::alloc_casamet interface~alloc_casa_var casavariable::alloc_casa_var interface~alloc_casa_var->proc~alloc_casamet Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/alloc_casamet.html"},{"title":"alloc_casabal – POP","text":"private  subroutine alloc_casabal(casabal, arraysize) Uses casadimension proc~~alloc_casabal~~UsesGraph proc~alloc_casabal casavariable::alloc_casabal module~casadimension casadimension proc~alloc_casabal->module~casadimension cable_def_types_mod cable_def_types_mod module~casadimension->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( casa_balance ), intent(inout) :: casabal integer, intent(in) :: arraysize Calls proc~~alloc_casabal~~CallsGraph proc~alloc_casabal casavariable::alloc_casabal cbalance cbalance proc~alloc_casabal->cbalance clabilelast clabilelast proc~alloc_casabal->clabilelast cleafmean cleafmean proc~alloc_casabal->cleafmean clitterlast clitterlast proc~alloc_casabal->clitterlast cplantlast cplantlast proc~alloc_casabal->cplantlast crootmean crootmean proc~alloc_casabal->crootmean csoillast csoillast proc~alloc_casabal->csoillast dcdtyear dcdtyear proc~alloc_casabal->dcdtyear fcgppyear fcgppyear proc~alloc_casabal->fcgppyear fcneeyear fcneeyear proc~alloc_casabal->fcneeyear fcnppyear fcnppyear proc~alloc_casabal->fcnppyear fcrgrowyear fcrgrowyear proc~alloc_casabal->fcrgrowyear fcrmleafyear fcrmleafyear proc~alloc_casabal->fcrmleafyear fcrmrootyear fcrmrootyear proc~alloc_casabal->fcrmrootyear fcrmwoodyear fcrmwoodyear proc~alloc_casabal->fcrmwoodyear fcrpyear fcrpyear proc~alloc_casabal->fcrpyear fcrsyear fcrsyear proc~alloc_casabal->fcrsyear fndepyear fndepyear proc~alloc_casabal->fndepyear fnfixyear fnfixyear proc~alloc_casabal->fnfixyear fnleachyear fnleachyear proc~alloc_casabal->fnleachyear fnlossyear fnlossyear proc~alloc_casabal->fnlossyear fnsnetyear fnsnetyear proc~alloc_casabal->fnsnetyear fnupyear fnupyear proc~alloc_casabal->fnupyear fpdustyear fpdustyear proc~alloc_casabal->fpdustyear fpleachyear fpleachyear proc~alloc_casabal->fpleachyear fplossyear fplossyear proc~alloc_casabal->fplossyear fpsnetyear fpsnetyear proc~alloc_casabal->fpsnetyear fpupyear fpupyear proc~alloc_casabal->fpupyear fpweayear fpweayear proc~alloc_casabal->fpweayear glaimon glaimon proc~alloc_casabal->glaimon glaimonx glaimonx proc~alloc_casabal->glaimonx laimax laimax proc~alloc_casabal->laimax nbalance nbalance proc~alloc_casabal->nbalance nlitterlast nlitterlast proc~alloc_casabal->nlitterlast nplantlast nplantlast proc~alloc_casabal->nplantlast nsoillast nsoillast proc~alloc_casabal->nsoillast nsoilminlast nsoilminlast proc~alloc_casabal->nsoilminlast pbalance pbalance proc~alloc_casabal->pbalance plitterlast plitterlast proc~alloc_casabal->plitterlast pplantlast pplantlast proc~alloc_casabal->pplantlast psoillablast psoillablast proc~alloc_casabal->psoillablast psoillast psoillast proc~alloc_casabal->psoillast psoilocclast psoilocclast proc~alloc_casabal->psoilocclast psoilsorblast psoilsorblast proc~alloc_casabal->psoilsorblast sumcbal sumcbal proc~alloc_casabal->sumcbal sumnbal sumnbal proc~alloc_casabal->sumnbal sumpbal sumpbal proc~alloc_casabal->sumpbal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~alloc_casabal~~CalledByGraph proc~alloc_casabal casavariable::alloc_casabal interface~alloc_casa_var casavariable::alloc_casa_var interface~alloc_casa_var->proc~alloc_casabal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/alloc_casabal.html"},{"title":"alloc_sum_casa – POP","text":"public  subroutine alloc_sum_casa(sum_casapool, sum_casaflux, arraysize) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: sum_casapool type( casa_flux ), intent(inout) :: sum_casaflux integer, intent(in) :: arraysize Calls proc~~alloc_sum_casa~~CallsGraph proc~alloc_sum_casa casavariable::alloc_sum_casa proc~alloc_casaflux casavariable::alloc_casaflux proc~alloc_sum_casa->proc~alloc_casaflux proc~alloc_casapool casavariable::alloc_casapool proc~alloc_sum_casa->proc~alloc_casapool cgpp cgpp proc~alloc_casaflux->cgpp charvest charvest proc~alloc_casaflux->charvest clabloss clabloss proc~alloc_casaflux->clabloss cnep cnep proc~alloc_casaflux->cnep cnpp cnpp proc~alloc_casaflux->cnpp cplant_turnover cplant_turnover proc~alloc_casaflux->cplant_turnover cplant_turnover_crowding cplant_turnover_crowding proc~alloc_casaflux->cplant_turnover_crowding cplant_turnover_disturbance cplant_turnover_disturbance proc~alloc_casaflux->cplant_turnover_disturbance cplant_turnover_resource_limitation cplant_turnover_resource_limitation proc~alloc_casaflux->cplant_turnover_resource_limitation crgplant crgplant proc~alloc_casaflux->crgplant crmplant crmplant proc~alloc_casaflux->crmplant crp crp proc~alloc_casaflux->crp crsoil crsoil proc~alloc_casaflux->crsoil ctransferluc ctransferluc proc~alloc_casaflux->ctransferluc fcrop fcrop proc~alloc_casaflux->fcrop fharvest fharvest proc~alloc_casaflux->fharvest fluxctoclear fluxctoclear proc~alloc_casaflux->fluxctoclear fluxctoco2 fluxctoco2 proc~alloc_casaflux->fluxctoco2 fluxctoco2_litter_fire fluxctoco2_litter_fire proc~alloc_casaflux->fluxctoco2_litter_fire fluxctoco2_plant_fire fluxctoco2_plant_fire proc~alloc_casaflux->fluxctoco2_plant_fire fluxctohwp fluxctohwp proc~alloc_casaflux->fluxctohwp fluxctolitter fluxctolitter proc~alloc_casaflux->fluxctolitter fluxctosoil fluxctosoil proc~alloc_casaflux->fluxctosoil fluxfromltoco2 fluxfromltoco2 proc~alloc_casaflux->fluxfromltoco2 fluxfromltoco2_fire fluxfromltoco2_fire proc~alloc_casaflux->fluxfromltoco2_fire fluxfromltos fluxfromltos proc~alloc_casaflux->fluxfromltos fluxfromptoco2 fluxfromptoco2 proc~alloc_casaflux->fluxfromptoco2 fluxfromptoco2_fire fluxfromptoco2_fire proc~alloc_casaflux->fluxfromptoco2_fire fluxfromptoharvest fluxfromptoharvest proc~alloc_casaflux->fluxfromptoharvest fluxfromptol fluxfromptol proc~alloc_casaflux->fluxfromptol fluxfromstoco2 fluxfromstoco2 proc~alloc_casaflux->fluxfromstoco2 fluxfromstos fluxfromstos proc~alloc_casaflux->fluxfromstos fluxntoatm_fire fluxntoatm_fire proc~alloc_casaflux->fluxntoatm_fire fluxntoclear fluxntoclear proc~alloc_casaflux->fluxntoclear fluxntohwp fluxntohwp proc~alloc_casaflux->fluxntohwp fluxntolitter fluxntolitter proc~alloc_casaflux->fluxntolitter fluxntosoil fluxntosoil proc~alloc_casaflux->fluxntosoil fluxptoclear fluxptoclear proc~alloc_casaflux->fluxptoclear fluxptohwp fluxptohwp proc~alloc_casaflux->fluxptohwp fluxptolitter fluxptolitter proc~alloc_casaflux->fluxptolitter fluxptosoil fluxptosoil proc~alloc_casaflux->fluxptosoil fnminleach fnminleach proc~alloc_casaflux->fnminleach fnminloss fnminloss proc~alloc_casaflux->fnminloss fpleach fpleach proc~alloc_casaflux->fpleach frac_sapwood frac_sapwood proc~alloc_casaflux->frac_sapwood fraccalloc fraccalloc proc~alloc_casaflux->fraccalloc fracclabile fracclabile proc~alloc_casaflux->fracclabile fracnalloc fracnalloc proc~alloc_casaflux->fracnalloc fracpalloc fracpalloc proc~alloc_casaflux->fracpalloc fromltoco2 fromltoco2 proc~alloc_casaflux->fromltoco2 fromltos fromltos proc~alloc_casaflux->fromltos fromptol fromptol proc~alloc_casaflux->fromptol fromptol_fire fromptol_fire proc~alloc_casaflux->fromptol_fire fromstoco2 fromstoco2 proc~alloc_casaflux->fromstoco2 fromstos fromstos proc~alloc_casaflux->fromstos klitter klitter proc~alloc_casaflux->klitter klitter_fire klitter_fire proc~alloc_casaflux->klitter_fire klitter_tot klitter_tot proc~alloc_casaflux->klitter_tot kmlabp kmlabp proc~alloc_casaflux->kmlabp kplab kplab proc~alloc_casaflux->kplab kplant kplant proc~alloc_casaflux->kplant kplant_fire kplant_fire proc~alloc_casaflux->kplant_fire kplant_tot kplant_tot proc~alloc_casaflux->kplant_tot kpocc kpocc proc~alloc_casaflux->kpocc kpsorb kpsorb proc~alloc_casaflux->kpsorb ksoil ksoil proc~alloc_casaflux->ksoil nharvest nharvest proc~alloc_casaflux->nharvest nlittermin nlittermin proc~alloc_casaflux->nlittermin nmindep nmindep proc~alloc_casaflux->nmindep nminfix nminfix proc~alloc_casaflux->nminfix nminleach nminleach proc~alloc_casaflux->nminleach nminloss nminloss proc~alloc_casaflux->nminloss nminuptake nminuptake proc~alloc_casaflux->nminuptake nsimm nsimm proc~alloc_casaflux->nsimm nsmin nsmin proc~alloc_casaflux->nsmin nsnet nsnet proc~alloc_casaflux->nsnet nupland nupland proc~alloc_casaflux->nupland pdep pdep proc~alloc_casaflux->pdep pharvest pharvest proc~alloc_casaflux->pharvest plabuptake plabuptake proc~alloc_casaflux->plabuptake pleach pleach proc~alloc_casaflux->pleach plittermin plittermin proc~alloc_casaflux->plittermin ploss ploss proc~alloc_casaflux->ploss psimm psimm proc~alloc_casaflux->psimm psmin psmin proc~alloc_casaflux->psmin psnet psnet proc~alloc_casaflux->psnet psorbmax psorbmax proc~alloc_casaflux->psorbmax pupland pupland proc~alloc_casaflux->pupland pwea pwea proc~alloc_casaflux->pwea sapwood_area sapwood_area proc~alloc_casaflux->sapwood_area stemnpp stemnpp proc~alloc_casaflux->stemnpp clabile clabile proc~alloc_casapool->clabile clitter clitter proc~alloc_casapool->clitter cplant cplant proc~alloc_casapool->cplant csoil csoil proc~alloc_casapool->csoil ctot ctot proc~alloc_casapool->ctot ctot_0 ctot_0 proc~alloc_casapool->ctot_0 dclabiledt dclabiledt proc~alloc_casapool->dclabiledt dclitterdt dclitterdt proc~alloc_casapool->dclitterdt dcplantdt dcplantdt proc~alloc_casapool->dcplantdt dcsoildt dcsoildt proc~alloc_casapool->dcsoildt dnlitterdt dnlitterdt proc~alloc_casapool->dnlitterdt dnplantdt dnplantdt proc~alloc_casapool->dnplantdt dnsoildt dnsoildt proc~alloc_casapool->dnsoildt dnsoilmindt dnsoilmindt proc~alloc_casapool->dnsoilmindt dplitterdt dplitterdt proc~alloc_casapool->dplitterdt dpplantdt dpplantdt proc~alloc_casapool->dpplantdt dpsoildt dpsoildt proc~alloc_casapool->dpsoildt dpsoillabdt dpsoillabdt proc~alloc_casapool->dpsoillabdt dpsoiloccdt dpsoiloccdt proc~alloc_casapool->dpsoiloccdt dpsoilsorbdt dpsoilsorbdt proc~alloc_casapool->dpsoilsorbdt nlitter nlitter proc~alloc_casapool->nlitter nplant nplant proc~alloc_casapool->nplant nsoil nsoil proc~alloc_casapool->nsoil nsoilmin nsoilmin proc~alloc_casapool->nsoilmin plitter plitter proc~alloc_casapool->plitter pplant pplant proc~alloc_casapool->pplant psoil psoil proc~alloc_casapool->psoil psoillab psoillab proc~alloc_casapool->psoillab psoilocc psoilocc proc~alloc_casapool->psoilocc psoilsorb psoilsorb proc~alloc_casapool->psoilsorb rationclitter rationclitter proc~alloc_casapool->rationclitter rationcplant rationcplant proc~alloc_casapool->rationcplant rationcsoil rationcsoil proc~alloc_casapool->rationcsoil rationcsoilmax rationcsoilmax proc~alloc_casapool->rationcsoilmax rationcsoilmin rationcsoilmin proc~alloc_casapool->rationcsoilmin rationcsoilnew rationcsoilnew proc~alloc_casapool->rationcsoilnew rationplitter rationplitter proc~alloc_casapool->rationplitter rationpplant rationpplant proc~alloc_casapool->rationpplant rationpsoil rationpsoil proc~alloc_casapool->rationpsoil ratiopclitter ratiopclitter proc~alloc_casapool->ratiopclitter ratiopcplant ratiopcplant proc~alloc_casapool->ratiopcplant ratiopcsoil ratiopcsoil proc~alloc_casapool->ratiopcsoil Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/alloc_sum_casa.html"},{"title":"zero_casabiome – POP","text":"private  subroutine zero_casabiome(casabiome) Uses cable_def_types_mod proc~~zero_casabiome~~UsesGraph proc~zero_casabiome casavariable::zero_casabiome cable_def_types_mod cable_def_types_mod proc~zero_casabiome->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(inout) :: casabiome Called by proc~~zero_casabiome~~CalledByGraph proc~zero_casabiome casavariable::zero_casabiome interface~zero_casa_var casavariable::zero_casa_var interface~zero_casa_var->proc~zero_casabiome Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/zero_casabiome.html"},{"title":"zero_casapool – POP","text":"private  subroutine zero_casapool(casapool) Uses cable_def_types_mod proc~~zero_casapool~~UsesGraph proc~zero_casapool casavariable::zero_casapool cable_def_types_mod cable_def_types_mod proc~zero_casapool->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: casapool Called by proc~~zero_casapool~~CalledByGraph proc~zero_casapool casavariable::zero_casapool interface~zero_casa_var casavariable::zero_casa_var interface~zero_casa_var->proc~zero_casapool proc~zero_sum_casa casavariable::zero_sum_casa proc~zero_sum_casa->proc~zero_casapool proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~zero_sum_casa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/zero_casapool.html"},{"title":"zero_casaflux – POP","text":"private  subroutine zero_casaflux(casaflux) Uses cable_def_types_mod proc~~zero_casaflux~~UsesGraph proc~zero_casaflux casavariable::zero_casaflux cable_def_types_mod cable_def_types_mod proc~zero_casaflux->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(inout) :: casaflux Called by proc~~zero_casaflux~~CalledByGraph proc~zero_casaflux casavariable::zero_casaflux interface~zero_casa_var casavariable::zero_casa_var interface~zero_casa_var->proc~zero_casaflux proc~zero_sum_casa casavariable::zero_sum_casa proc~zero_sum_casa->proc~zero_casaflux proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~zero_sum_casa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/zero_casaflux.html"},{"title":"zero_casamet – POP","text":"private  subroutine zero_casamet(casamet) Uses cable_def_types_mod proc~~zero_casamet~~UsesGraph proc~zero_casamet casavariable::zero_casamet cable_def_types_mod cable_def_types_mod proc~zero_casamet->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( casa_met ), intent(inout) :: casamet Called by proc~~zero_casamet~~CalledByGraph proc~zero_casamet casavariable::zero_casamet interface~zero_casa_var casavariable::zero_casa_var interface~zero_casa_var->proc~zero_casamet Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/zero_casamet.html"},{"title":"zero_casabal – POP","text":"private  subroutine zero_casabal(casabal) Uses cable_def_types_mod proc~~zero_casabal~~UsesGraph proc~zero_casabal casavariable::zero_casabal cable_def_types_mod cable_def_types_mod proc~zero_casabal->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( casa_balance ), intent(inout) :: casabal Called by proc~~zero_casabal~~CalledByGraph proc~zero_casabal casavariable::zero_casabal interface~zero_casa_var casavariable::zero_casa_var interface~zero_casa_var->proc~zero_casabal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/zero_casabal.html"},{"title":"print_casabiome – POP","text":"private  subroutine print_casabiome(casabiome) Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(in) :: casabiome Called by proc~~print_casabiome~~CalledByGraph proc~print_casabiome casavariable::print_casabiome interface~print_casa_var casavariable::print_casa_var interface~print_casa_var->proc~print_casabiome Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/print_casabiome.html"},{"title":"print_casapool – POP","text":"private  subroutine print_casapool(casapool) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(in) :: casapool Called by proc~~print_casapool~~CalledByGraph proc~print_casapool casavariable::print_casapool interface~print_casa_var casavariable::print_casa_var interface~print_casa_var->proc~print_casapool Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/print_casapool.html"},{"title":"print_casaflux – POP","text":"private  subroutine print_casaflux(casaflux) Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(in) :: casaflux Called by proc~~print_casaflux~~CalledByGraph proc~print_casaflux casavariable::print_casaflux interface~print_casa_var casavariable::print_casa_var interface~print_casa_var->proc~print_casaflux Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/print_casaflux.html"},{"title":"print_casamet – POP","text":"private  subroutine print_casamet(casamet) Arguments Type Intent Optional Attributes Name type( casa_met ), intent(in) :: casamet Called by proc~~print_casamet~~CalledByGraph proc~print_casamet casavariable::print_casamet interface~print_casa_var casavariable::print_casa_var interface~print_casa_var->proc~print_casamet Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/print_casamet.html"},{"title":"print_casabal – POP","text":"private  subroutine print_casabal(casabal) Arguments Type Intent Optional Attributes Name type( casa_balance ), intent(in) :: casabal Called by proc~~print_casabal~~CalledByGraph proc~print_casabal casavariable::print_casabal interface~print_casa_var casavariable::print_casa_var interface~print_casa_var->proc~print_casabal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/print_casabal.html"},{"title":"zero_sum_casa – POP","text":"public  subroutine zero_sum_casa(sum_casapool, sum_casaflux) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: sum_casapool type( casa_flux ), intent(inout) :: sum_casaflux Calls proc~~zero_sum_casa~~CallsGraph proc~zero_sum_casa casavariable::zero_sum_casa proc~zero_casaflux casavariable::zero_casaflux proc~zero_sum_casa->proc~zero_casaflux proc~zero_casapool casavariable::zero_casapool proc~zero_sum_casa->proc~zero_casapool Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~zero_sum_casa~~CalledByGraph proc~zero_sum_casa casavariable::zero_sum_casa proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~zero_sum_casa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/zero_sum_casa.html"},{"title":"update_sum_casa – POP","text":"public  subroutine update_sum_casa(sum_casapool, sum_casaflux, casapool, casaflux, sum_now, average_now, nsteps) Uses cable_def_types_mod proc~~update_sum_casa~~UsesGraph proc~update_sum_casa casavariable::update_sum_casa cable_def_types_mod cable_def_types_mod proc~update_sum_casa->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: sum_casapool type( casa_flux ), intent(inout) :: sum_casaflux type( casa_pool ), intent(in) :: casapool type( casa_flux ), intent(in) :: casaflux logical, intent(in) :: sum_now logical, intent(in) :: average_now integer, intent(in) :: nsteps Calls proc~~update_sum_casa~~CallsGraph proc~update_sum_casa casavariable::update_sum_casa fraccalloc fraccalloc proc~update_sum_casa->fraccalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~update_sum_casa~~CalledByGraph proc~update_sum_casa casavariable::update_sum_casa proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~update_sum_casa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/update_sum_casa.html"},{"title":"read_netcdf_casabiome – POP","text":"private  subroutine read_netcdf_casabiome(filename, casabiome) Uses cable_def_types_mod netcdf proc~~read_netcdf_casabiome~~UsesGraph proc~read_netcdf_casabiome casavariable::read_netcdf_casabiome cable_def_types_mod cable_def_types_mod proc~read_netcdf_casabiome->cable_def_types_mod netcdf netcdf proc~read_netcdf_casabiome->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_biome ), intent(inout) :: casabiome Calls proc~~read_netcdf_casabiome~~CallsGraph proc~read_netcdf_casabiome casavariable::read_netcdf_casabiome nc_err nc_err proc~read_netcdf_casabiome->nc_err nf90_close nf90_close proc~read_netcdf_casabiome->nf90_close nf90_get_var nf90_get_var proc~read_netcdf_casabiome->nf90_get_var nf90_inq_varid nf90_inq_varid proc~read_netcdf_casabiome->nf90_inq_varid nf90_open nf90_open proc~read_netcdf_casabiome->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_netcdf_casabiome~~CalledByGraph proc~read_netcdf_casabiome casavariable::read_netcdf_casabiome interface~read_netcdf_casa_var casavariable::read_netcdf_casa_var interface~read_netcdf_casa_var->proc~read_netcdf_casabiome proc~read_casa_restart_nc casa_inout::read_casa_restart_nc proc~read_casa_restart_nc->interface~read_netcdf_casa_var proc~casa_init casa_inout::casa_init proc~casa_init->proc~read_casa_restart_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/read_netcdf_casabiome.html"},{"title":"read_netcdf_casapool – POP","text":"private  subroutine read_netcdf_casapool(filename, casapool) Uses cable_def_types_mod netcdf proc~~read_netcdf_casapool~~UsesGraph proc~read_netcdf_casapool casavariable::read_netcdf_casapool cable_def_types_mod cable_def_types_mod proc~read_netcdf_casapool->cable_def_types_mod netcdf netcdf proc~read_netcdf_casapool->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_pool ), intent(inout) :: casapool Calls proc~~read_netcdf_casapool~~CallsGraph proc~read_netcdf_casapool casavariable::read_netcdf_casapool nc_err nc_err proc~read_netcdf_casapool->nc_err nf90_close nf90_close proc~read_netcdf_casapool->nf90_close nf90_get_var nf90_get_var proc~read_netcdf_casapool->nf90_get_var nf90_inq_varid nf90_inq_varid proc~read_netcdf_casapool->nf90_inq_varid nf90_open nf90_open proc~read_netcdf_casapool->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_netcdf_casapool~~CalledByGraph proc~read_netcdf_casapool casavariable::read_netcdf_casapool interface~read_netcdf_casa_var casavariable::read_netcdf_casa_var interface~read_netcdf_casa_var->proc~read_netcdf_casapool proc~read_casa_restart_nc casa_inout::read_casa_restart_nc proc~read_casa_restart_nc->interface~read_netcdf_casa_var proc~casa_init casa_inout::casa_init proc~casa_init->proc~read_casa_restart_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/read_netcdf_casapool.html"},{"title":"read_netcdf_casaflux – POP","text":"private  subroutine read_netcdf_casaflux(filename, casaflux) Uses cable_def_types_mod netcdf proc~~read_netcdf_casaflux~~UsesGraph proc~read_netcdf_casaflux casavariable::read_netcdf_casaflux cable_def_types_mod cable_def_types_mod proc~read_netcdf_casaflux->cable_def_types_mod netcdf netcdf proc~read_netcdf_casaflux->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_flux ), intent(inout) :: casaflux Calls proc~~read_netcdf_casaflux~~CallsGraph proc~read_netcdf_casaflux casavariable::read_netcdf_casaflux nc_err nc_err proc~read_netcdf_casaflux->nc_err nf90_close nf90_close proc~read_netcdf_casaflux->nf90_close nf90_get_var nf90_get_var proc~read_netcdf_casaflux->nf90_get_var nf90_inq_varid nf90_inq_varid proc~read_netcdf_casaflux->nf90_inq_varid nf90_open nf90_open proc~read_netcdf_casaflux->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_netcdf_casaflux~~CalledByGraph proc~read_netcdf_casaflux casavariable::read_netcdf_casaflux interface~read_netcdf_casa_var casavariable::read_netcdf_casa_var interface~read_netcdf_casa_var->proc~read_netcdf_casaflux proc~read_casa_restart_nc casa_inout::read_casa_restart_nc proc~read_casa_restart_nc->interface~read_netcdf_casa_var proc~casa_init casa_inout::casa_init proc~casa_init->proc~read_casa_restart_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/read_netcdf_casaflux.html"},{"title":"read_netcdf_casamet – POP","text":"private  subroutine read_netcdf_casamet(filename, casamet) Uses cable_def_types_mod netcdf proc~~read_netcdf_casamet~~UsesGraph proc~read_netcdf_casamet casavariable::read_netcdf_casamet cable_def_types_mod cable_def_types_mod proc~read_netcdf_casamet->cable_def_types_mod netcdf netcdf proc~read_netcdf_casamet->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_met ), intent(inout) :: casamet Calls proc~~read_netcdf_casamet~~CallsGraph proc~read_netcdf_casamet casavariable::read_netcdf_casamet nc_err nc_err proc~read_netcdf_casamet->nc_err nf90_close nf90_close proc~read_netcdf_casamet->nf90_close nf90_get_var nf90_get_var proc~read_netcdf_casamet->nf90_get_var nf90_inq_varid nf90_inq_varid proc~read_netcdf_casamet->nf90_inq_varid nf90_open nf90_open proc~read_netcdf_casamet->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_netcdf_casamet~~CalledByGraph proc~read_netcdf_casamet casavariable::read_netcdf_casamet interface~read_netcdf_casa_var casavariable::read_netcdf_casa_var interface~read_netcdf_casa_var->proc~read_netcdf_casamet proc~read_casa_restart_nc casa_inout::read_casa_restart_nc proc~read_casa_restart_nc->interface~read_netcdf_casa_var proc~casa_init casa_inout::casa_init proc~casa_init->proc~read_casa_restart_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/read_netcdf_casamet.html"},{"title":"read_netcdf_casabal – POP","text":"private  subroutine read_netcdf_casabal(filename, casabal) Uses cable_def_types_mod netcdf proc~~read_netcdf_casabal~~UsesGraph proc~read_netcdf_casabal casavariable::read_netcdf_casabal cable_def_types_mod cable_def_types_mod proc~read_netcdf_casabal->cable_def_types_mod netcdf netcdf proc~read_netcdf_casabal->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_balance ), intent(inout) :: casabal Calls proc~~read_netcdf_casabal~~CallsGraph proc~read_netcdf_casabal casavariable::read_netcdf_casabal nc_err nc_err proc~read_netcdf_casabal->nc_err nf90_close nf90_close proc~read_netcdf_casabal->nf90_close nf90_get_var nf90_get_var proc~read_netcdf_casabal->nf90_get_var nf90_inq_varid nf90_inq_varid proc~read_netcdf_casabal->nf90_inq_varid nf90_open nf90_open proc~read_netcdf_casabal->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_netcdf_casabal~~CalledByGraph proc~read_netcdf_casabal casavariable::read_netcdf_casabal interface~read_netcdf_casa_var casavariable::read_netcdf_casa_var interface~read_netcdf_casa_var->proc~read_netcdf_casabal proc~read_casa_restart_nc casa_inout::read_casa_restart_nc proc~read_casa_restart_nc->interface~read_netcdf_casa_var proc~casa_init casa_inout::casa_init proc~casa_init->proc~read_casa_restart_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/read_netcdf_casabal.html"},{"title":"write_netcdf_casabiome – POP","text":"private  subroutine write_netcdf_casabiome(filename, casabiome) Uses cable_def_types_mod netcdf proc~~write_netcdf_casabiome~~UsesGraph proc~write_netcdf_casabiome casavariable::write_netcdf_casabiome cable_def_types_mod cable_def_types_mod proc~write_netcdf_casabiome->cable_def_types_mod netcdf netcdf proc~write_netcdf_casabiome->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_biome ), intent(in) :: casabiome Calls proc~~write_netcdf_casabiome~~CallsGraph proc~write_netcdf_casabiome casavariable::write_netcdf_casabiome nc_err nc_err proc~write_netcdf_casabiome->nc_err nf90_close nf90_close proc~write_netcdf_casabiome->nf90_close nf90_create nf90_create proc~write_netcdf_casabiome->nf90_create nf90_def_dim nf90_def_dim proc~write_netcdf_casabiome->nf90_def_dim nf90_def_var nf90_def_var proc~write_netcdf_casabiome->nf90_def_var nf90_enddef nf90_enddef proc~write_netcdf_casabiome->nf90_enddef nf90_put_var nf90_put_var proc~write_netcdf_casabiome->nf90_put_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_netcdf_casabiome~~CalledByGraph proc~write_netcdf_casabiome casavariable::write_netcdf_casabiome interface~write_netcdf_casa_var casavariable::write_netcdf_casa_var interface~write_netcdf_casa_var->proc~write_netcdf_casabiome proc~write_casa_restart_nc casa_inout::write_casa_restart_nc proc~write_casa_restart_nc->interface~write_netcdf_casa_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/write_netcdf_casabiome.html"},{"title":"write_netcdf_casapool – POP","text":"private  subroutine write_netcdf_casapool(filename, casapool) Uses cable_def_types_mod netcdf proc~~write_netcdf_casapool~~UsesGraph proc~write_netcdf_casapool casavariable::write_netcdf_casapool cable_def_types_mod cable_def_types_mod proc~write_netcdf_casapool->cable_def_types_mod netcdf netcdf proc~write_netcdf_casapool->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_pool ), intent(in) :: casapool Calls proc~~write_netcdf_casapool~~CallsGraph proc~write_netcdf_casapool casavariable::write_netcdf_casapool nc_err nc_err proc~write_netcdf_casapool->nc_err nf90_close nf90_close proc~write_netcdf_casapool->nf90_close nf90_create nf90_create proc~write_netcdf_casapool->nf90_create nf90_def_dim nf90_def_dim proc~write_netcdf_casapool->nf90_def_dim nf90_def_var nf90_def_var proc~write_netcdf_casapool->nf90_def_var nf90_enddef nf90_enddef proc~write_netcdf_casapool->nf90_enddef nf90_put_var nf90_put_var proc~write_netcdf_casapool->nf90_put_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_netcdf_casapool~~CalledByGraph proc~write_netcdf_casapool casavariable::write_netcdf_casapool interface~write_netcdf_casa_var casavariable::write_netcdf_casa_var interface~write_netcdf_casa_var->proc~write_netcdf_casapool proc~write_casa_restart_nc casa_inout::write_casa_restart_nc proc~write_casa_restart_nc->interface~write_netcdf_casa_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/write_netcdf_casapool.html"},{"title":"write_netcdf_casaflux – POP","text":"private  subroutine write_netcdf_casaflux(filename, casaflux) Uses cable_def_types_mod netcdf proc~~write_netcdf_casaflux~~UsesGraph proc~write_netcdf_casaflux casavariable::write_netcdf_casaflux cable_def_types_mod cable_def_types_mod proc~write_netcdf_casaflux->cable_def_types_mod netcdf netcdf proc~write_netcdf_casaflux->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_flux ), intent(in) :: casaflux Calls proc~~write_netcdf_casaflux~~CallsGraph proc~write_netcdf_casaflux casavariable::write_netcdf_casaflux nc_err nc_err proc~write_netcdf_casaflux->nc_err nf90_close nf90_close proc~write_netcdf_casaflux->nf90_close nf90_create nf90_create proc~write_netcdf_casaflux->nf90_create nf90_def_dim nf90_def_dim proc~write_netcdf_casaflux->nf90_def_dim nf90_def_var nf90_def_var proc~write_netcdf_casaflux->nf90_def_var nf90_enddef nf90_enddef proc~write_netcdf_casaflux->nf90_enddef nf90_put_var nf90_put_var proc~write_netcdf_casaflux->nf90_put_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_netcdf_casaflux~~CalledByGraph proc~write_netcdf_casaflux casavariable::write_netcdf_casaflux interface~write_netcdf_casa_var casavariable::write_netcdf_casa_var interface~write_netcdf_casa_var->proc~write_netcdf_casaflux proc~write_casa_restart_nc casa_inout::write_casa_restart_nc proc~write_casa_restart_nc->interface~write_netcdf_casa_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/write_netcdf_casaflux.html"},{"title":"write_netcdf_casamet – POP","text":"private  subroutine write_netcdf_casamet(filename, casamet) Uses cable_def_types_mod netcdf proc~~write_netcdf_casamet~~UsesGraph proc~write_netcdf_casamet casavariable::write_netcdf_casamet cable_def_types_mod cable_def_types_mod proc~write_netcdf_casamet->cable_def_types_mod netcdf netcdf proc~write_netcdf_casamet->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_met ), intent(in) :: casamet Calls proc~~write_netcdf_casamet~~CallsGraph proc~write_netcdf_casamet casavariable::write_netcdf_casamet nc_err nc_err proc~write_netcdf_casamet->nc_err nf90_close nf90_close proc~write_netcdf_casamet->nf90_close nf90_create nf90_create proc~write_netcdf_casamet->nf90_create nf90_def_dim nf90_def_dim proc~write_netcdf_casamet->nf90_def_dim nf90_def_var nf90_def_var proc~write_netcdf_casamet->nf90_def_var nf90_enddef nf90_enddef proc~write_netcdf_casamet->nf90_enddef nf90_put_var nf90_put_var proc~write_netcdf_casamet->nf90_put_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_netcdf_casamet~~CalledByGraph proc~write_netcdf_casamet casavariable::write_netcdf_casamet interface~write_netcdf_casa_var casavariable::write_netcdf_casa_var interface~write_netcdf_casa_var->proc~write_netcdf_casamet proc~write_casa_restart_nc casa_inout::write_casa_restart_nc proc~write_casa_restart_nc->interface~write_netcdf_casa_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/write_netcdf_casamet.html"},{"title":"write_netcdf_casabal – POP","text":"private  subroutine write_netcdf_casabal(filename, casabal) Uses cable_def_types_mod netcdf proc~~write_netcdf_casabal~~UsesGraph proc~write_netcdf_casabal casavariable::write_netcdf_casabal cable_def_types_mod cable_def_types_mod proc~write_netcdf_casabal->cable_def_types_mod netcdf netcdf proc~write_netcdf_casabal->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_balance ), intent(in) :: casabal Calls proc~~write_netcdf_casabal~~CallsGraph proc~write_netcdf_casabal casavariable::write_netcdf_casabal nc_err nc_err proc~write_netcdf_casabal->nc_err nf90_close nf90_close proc~write_netcdf_casabal->nf90_close nf90_create nf90_create proc~write_netcdf_casabal->nf90_create nf90_def_dim nf90_def_dim proc~write_netcdf_casabal->nf90_def_dim nf90_def_var nf90_def_var proc~write_netcdf_casabal->nf90_def_var nf90_enddef nf90_enddef proc~write_netcdf_casabal->nf90_enddef nf90_put_var nf90_put_var proc~write_netcdf_casabal->nf90_put_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_netcdf_casabal~~CalledByGraph proc~write_netcdf_casabal casavariable::write_netcdf_casabal interface~write_netcdf_casa_var casavariable::write_netcdf_casa_var interface~write_netcdf_casa_var->proc~write_netcdf_casabal proc~write_casa_restart_nc casa_inout::write_casa_restart_nc proc~write_casa_restart_nc->interface~write_netcdf_casa_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/write_netcdf_casabal.html"},{"title":"alloc_casa_var – POP","text":"public interface alloc_casa_var Calls interface~~alloc_casa_var~~CallsGraph interface~alloc_casa_var casavariable::alloc_casa_var proc~alloc_casabal casavariable::alloc_casabal interface~alloc_casa_var->proc~alloc_casabal proc~alloc_casabiome casavariable::alloc_casabiome interface~alloc_casa_var->proc~alloc_casabiome proc~alloc_casaflux casavariable::alloc_casaflux interface~alloc_casa_var->proc~alloc_casaflux proc~alloc_casamet casavariable::alloc_casamet interface~alloc_casa_var->proc~alloc_casamet proc~alloc_casapool casavariable::alloc_casapool interface~alloc_casa_var->proc~alloc_casapool cbalance cbalance proc~alloc_casabal->cbalance clabilelast clabilelast proc~alloc_casabal->clabilelast cleafmean cleafmean proc~alloc_casabal->cleafmean clitterlast clitterlast proc~alloc_casabal->clitterlast cplantlast cplantlast proc~alloc_casabal->cplantlast crootmean crootmean proc~alloc_casabal->crootmean csoillast csoillast proc~alloc_casabal->csoillast dcdtyear dcdtyear proc~alloc_casabal->dcdtyear fcgppyear fcgppyear proc~alloc_casabal->fcgppyear fcneeyear fcneeyear proc~alloc_casabal->fcneeyear fcnppyear fcnppyear proc~alloc_casabal->fcnppyear fcrgrowyear fcrgrowyear proc~alloc_casabal->fcrgrowyear fcrmleafyear fcrmleafyear proc~alloc_casabal->fcrmleafyear fcrmrootyear fcrmrootyear proc~alloc_casabal->fcrmrootyear fcrmwoodyear fcrmwoodyear proc~alloc_casabal->fcrmwoodyear fcrpyear fcrpyear proc~alloc_casabal->fcrpyear fcrsyear fcrsyear proc~alloc_casabal->fcrsyear fndepyear fndepyear proc~alloc_casabal->fndepyear fnfixyear fnfixyear proc~alloc_casabal->fnfixyear fnleachyear fnleachyear proc~alloc_casabal->fnleachyear fnlossyear fnlossyear proc~alloc_casabal->fnlossyear fnsnetyear fnsnetyear proc~alloc_casabal->fnsnetyear fnupyear fnupyear proc~alloc_casabal->fnupyear fpdustyear fpdustyear proc~alloc_casabal->fpdustyear fpleachyear fpleachyear proc~alloc_casabal->fpleachyear fplossyear fplossyear proc~alloc_casabal->fplossyear fpsnetyear fpsnetyear proc~alloc_casabal->fpsnetyear fpupyear fpupyear proc~alloc_casabal->fpupyear fpweayear fpweayear proc~alloc_casabal->fpweayear glaimon glaimon proc~alloc_casabal->glaimon glaimonx glaimonx proc~alloc_casabal->glaimonx laimax laimax proc~alloc_casabal->laimax nbalance nbalance proc~alloc_casabal->nbalance nlitterlast nlitterlast proc~alloc_casabal->nlitterlast nplantlast nplantlast proc~alloc_casabal->nplantlast nsoillast nsoillast proc~alloc_casabal->nsoillast nsoilminlast nsoilminlast proc~alloc_casabal->nsoilminlast pbalance pbalance proc~alloc_casabal->pbalance plitterlast plitterlast proc~alloc_casabal->plitterlast pplantlast pplantlast proc~alloc_casabal->pplantlast psoillablast psoillablast proc~alloc_casabal->psoillablast psoillast psoillast proc~alloc_casabal->psoillast psoilocclast psoilocclast proc~alloc_casabal->psoilocclast psoilsorblast psoilsorblast proc~alloc_casabal->psoilsorblast sumcbal sumcbal proc~alloc_casabal->sumcbal sumnbal sumnbal proc~alloc_casabal->sumnbal sumpbal sumpbal proc~alloc_casabal->sumpbal costnpup costnpup proc~alloc_casabiome->costnpup damm_alpha damm_alpha proc~alloc_casabiome->damm_alpha damm_ea damm_ea proc~alloc_casabiome->damm_ea damm_enzpool damm_enzpool proc~alloc_casabiome->damm_enzpool damm_kmcp damm_kmcp proc~alloc_casabiome->damm_kmcp damm_kmo2 damm_kmo2 proc~alloc_casabiome->damm_kmo2 disturbance_interval disturbance_interval proc~alloc_casabiome->disturbance_interval fraclabile fraclabile proc~alloc_casabiome->fraclabile fraclignin fraclignin proc~alloc_casabiome->fraclignin fracligninplant fracligninplant proc~alloc_casabiome->fracligninplant fracnpptop fracnpptop proc~alloc_casabiome->fracnpptop ftransnptol ftransnptol proc~alloc_casabiome->ftransnptol ftranspptol ftranspptol proc~alloc_casabiome->ftranspptol glaimax glaimax proc~alloc_casabiome->glaimax glaimin glaimin proc~alloc_casabiome->glaimin ivt2 ivt2 proc~alloc_casabiome->ivt2 kclabrate kclabrate proc~alloc_casabiome->kclabrate kminn kminn proc~alloc_casabiome->kminn kroot kroot proc~alloc_casabiome->kroot krootlen krootlen proc~alloc_casabiome->krootlen kuplabp kuplabp proc~alloc_casabiome->kuplabp kuptake kuptake proc~alloc_casabiome->kuptake la_to_sa la_to_sa proc~alloc_casabiome->la_to_sa litterrate litterrate proc~alloc_casabiome->litterrate maxcwd maxcwd proc~alloc_casabiome->maxcwd maxfinelitter maxfinelitter proc~alloc_casabiome->maxfinelitter nintercept nintercept proc~alloc_casabiome->nintercept nslope nslope proc~alloc_casabiome->nslope plantrate plantrate proc~alloc_casabiome->plantrate prodptase prodptase proc~alloc_casabiome->prodptase q10soil q10soil proc~alloc_casabiome->q10soil ratiofrootleaf ratiofrootleaf proc~alloc_casabiome->ratiofrootleaf rationcplantmax rationcplantmax proc~alloc_casabiome->rationcplantmax rationcplantmin rationcplantmin proc~alloc_casabiome->rationcplantmin rationpplantmax rationpplantmax proc~alloc_casabiome->rationpplantmax rationpplantmin rationpplantmin proc~alloc_casabiome->rationpplantmin ratiopcplantmax ratiopcplantmax proc~alloc_casabiome->ratiopcplantmax ratiopcplantmin ratiopcplantmin proc~alloc_casabiome->ratiopcplantmin rmplant rmplant proc~alloc_casabiome->rmplant rootdepth rootdepth proc~alloc_casabiome->rootdepth sla sla proc~alloc_casabiome->sla soilrate soilrate proc~alloc_casabiome->soilrate vcmax_scalar vcmax_scalar proc~alloc_casabiome->vcmax_scalar xkleafcoldexp xkleafcoldexp proc~alloc_casabiome->xkleafcoldexp xkleafcoldmax xkleafcoldmax proc~alloc_casabiome->xkleafcoldmax xkleafdryexp xkleafdryexp proc~alloc_casabiome->xkleafdryexp xkleafdrymax xkleafdrymax proc~alloc_casabiome->xkleafdrymax xkoptlitter xkoptlitter proc~alloc_casabiome->xkoptlitter xkoptsoil xkoptsoil proc~alloc_casabiome->xkoptsoil xkplab xkplab proc~alloc_casabiome->xkplab xkpocc xkpocc proc~alloc_casabiome->xkpocc xkpsorb xkpsorb proc~alloc_casabiome->xkpsorb xnpmax xnpmax proc~alloc_casabiome->xnpmax cgpp cgpp proc~alloc_casaflux->cgpp charvest charvest proc~alloc_casaflux->charvest clabloss clabloss proc~alloc_casaflux->clabloss cnep cnep proc~alloc_casaflux->cnep cnpp cnpp proc~alloc_casaflux->cnpp cplant_turnover cplant_turnover proc~alloc_casaflux->cplant_turnover cplant_turnover_crowding cplant_turnover_crowding proc~alloc_casaflux->cplant_turnover_crowding cplant_turnover_disturbance cplant_turnover_disturbance proc~alloc_casaflux->cplant_turnover_disturbance cplant_turnover_resource_limitation cplant_turnover_resource_limitation proc~alloc_casaflux->cplant_turnover_resource_limitation crgplant crgplant proc~alloc_casaflux->crgplant crmplant crmplant proc~alloc_casaflux->crmplant crp crp proc~alloc_casaflux->crp crsoil crsoil proc~alloc_casaflux->crsoil ctransferluc ctransferluc proc~alloc_casaflux->ctransferluc fcrop fcrop proc~alloc_casaflux->fcrop fharvest fharvest proc~alloc_casaflux->fharvest fluxctoclear fluxctoclear proc~alloc_casaflux->fluxctoclear fluxctoco2 fluxctoco2 proc~alloc_casaflux->fluxctoco2 fluxctoco2_litter_fire fluxctoco2_litter_fire proc~alloc_casaflux->fluxctoco2_litter_fire fluxctoco2_plant_fire fluxctoco2_plant_fire proc~alloc_casaflux->fluxctoco2_plant_fire fluxctohwp fluxctohwp proc~alloc_casaflux->fluxctohwp fluxctolitter fluxctolitter proc~alloc_casaflux->fluxctolitter fluxctosoil fluxctosoil proc~alloc_casaflux->fluxctosoil fluxfromltoco2 fluxfromltoco2 proc~alloc_casaflux->fluxfromltoco2 fluxfromltoco2_fire fluxfromltoco2_fire proc~alloc_casaflux->fluxfromltoco2_fire fluxfromltos fluxfromltos proc~alloc_casaflux->fluxfromltos fluxfromptoco2 fluxfromptoco2 proc~alloc_casaflux->fluxfromptoco2 fluxfromptoco2_fire fluxfromptoco2_fire proc~alloc_casaflux->fluxfromptoco2_fire fluxfromptoharvest fluxfromptoharvest proc~alloc_casaflux->fluxfromptoharvest fluxfromptol fluxfromptol proc~alloc_casaflux->fluxfromptol fluxfromstoco2 fluxfromstoco2 proc~alloc_casaflux->fluxfromstoco2 fluxfromstos fluxfromstos proc~alloc_casaflux->fluxfromstos fluxntoatm_fire fluxntoatm_fire proc~alloc_casaflux->fluxntoatm_fire fluxntoclear fluxntoclear proc~alloc_casaflux->fluxntoclear fluxntohwp fluxntohwp proc~alloc_casaflux->fluxntohwp fluxntolitter fluxntolitter proc~alloc_casaflux->fluxntolitter fluxntosoil fluxntosoil proc~alloc_casaflux->fluxntosoil fluxptoclear fluxptoclear proc~alloc_casaflux->fluxptoclear fluxptohwp fluxptohwp proc~alloc_casaflux->fluxptohwp fluxptolitter fluxptolitter proc~alloc_casaflux->fluxptolitter fluxptosoil fluxptosoil proc~alloc_casaflux->fluxptosoil fnminleach fnminleach proc~alloc_casaflux->fnminleach fnminloss fnminloss proc~alloc_casaflux->fnminloss fpleach fpleach proc~alloc_casaflux->fpleach frac_sapwood frac_sapwood proc~alloc_casaflux->frac_sapwood fraccalloc fraccalloc proc~alloc_casaflux->fraccalloc fracclabile fracclabile proc~alloc_casaflux->fracclabile fracnalloc fracnalloc proc~alloc_casaflux->fracnalloc fracpalloc fracpalloc proc~alloc_casaflux->fracpalloc fromltoco2 fromltoco2 proc~alloc_casaflux->fromltoco2 fromltos fromltos proc~alloc_casaflux->fromltos fromptol fromptol proc~alloc_casaflux->fromptol fromptol_fire fromptol_fire proc~alloc_casaflux->fromptol_fire fromstoco2 fromstoco2 proc~alloc_casaflux->fromstoco2 fromstos fromstos proc~alloc_casaflux->fromstos klitter klitter proc~alloc_casaflux->klitter klitter_fire klitter_fire proc~alloc_casaflux->klitter_fire klitter_tot klitter_tot proc~alloc_casaflux->klitter_tot kmlabp kmlabp proc~alloc_casaflux->kmlabp kplab kplab proc~alloc_casaflux->kplab kplant kplant proc~alloc_casaflux->kplant kplant_fire kplant_fire proc~alloc_casaflux->kplant_fire kplant_tot kplant_tot proc~alloc_casaflux->kplant_tot kpocc kpocc proc~alloc_casaflux->kpocc kpsorb kpsorb proc~alloc_casaflux->kpsorb ksoil ksoil proc~alloc_casaflux->ksoil nharvest nharvest proc~alloc_casaflux->nharvest nlittermin nlittermin proc~alloc_casaflux->nlittermin nmindep nmindep proc~alloc_casaflux->nmindep nminfix nminfix proc~alloc_casaflux->nminfix nminleach nminleach proc~alloc_casaflux->nminleach nminloss nminloss proc~alloc_casaflux->nminloss nminuptake nminuptake proc~alloc_casaflux->nminuptake nsimm nsimm proc~alloc_casaflux->nsimm nsmin nsmin proc~alloc_casaflux->nsmin nsnet nsnet proc~alloc_casaflux->nsnet nupland nupland proc~alloc_casaflux->nupland pdep pdep proc~alloc_casaflux->pdep pharvest pharvest proc~alloc_casaflux->pharvest plabuptake plabuptake proc~alloc_casaflux->plabuptake pleach pleach proc~alloc_casaflux->pleach plittermin plittermin proc~alloc_casaflux->plittermin ploss ploss proc~alloc_casaflux->ploss psimm psimm proc~alloc_casaflux->psimm psmin psmin proc~alloc_casaflux->psmin psnet psnet proc~alloc_casaflux->psnet psorbmax psorbmax proc~alloc_casaflux->psorbmax pupland pupland proc~alloc_casaflux->pupland pwea pwea proc~alloc_casaflux->pwea sapwood_area sapwood_area proc~alloc_casaflux->sapwood_area stemnpp stemnpp proc~alloc_casaflux->stemnpp aprecip_av20_spin aprecip_av20_spin proc~alloc_casamet->aprecip_av20_spin areacell areacell proc~alloc_casamet->areacell btran btran proc~alloc_casamet->btran can12spin can12spin proc~alloc_casamet->can12spin can13spin can13spin proc~alloc_casamet->can13spin cgppspin cgppspin proc~alloc_casamet->cgppspin crmplantspin_1 crmplantspin_1 proc~alloc_casamet->crmplantspin_1 crmplantspin_2 crmplantspin_2 proc~alloc_casamet->crmplantspin_2 crmplantspin_3 crmplantspin_3 proc~alloc_casamet->crmplantspin_3 d_macarthur_spin d_macarthur_spin proc~alloc_casamet->d_macarthur_spin dprecip_spin dprecip_spin proc~alloc_casamet->dprecip_spin drhum_spin drhum_spin proc~alloc_casamet->drhum_spin dslr_spin dslr_spin proc~alloc_casamet->dslr_spin dtemp_max_spin dtemp_max_spin proc~alloc_casamet->dtemp_max_spin dtemp_min_spin dtemp_min_spin proc~alloc_casamet->dtemp_min_spin du10_max_spin du10_max_spin proc~alloc_casamet->du10_max_spin ffdi_spin ffdi_spin proc~alloc_casamet->ffdi_spin frecspin frecspin proc~alloc_casamet->frecspin glai glai proc~alloc_casamet->glai ijgcm ijgcm proc~alloc_casamet->ijgcm isorder isorder proc~alloc_casamet->isorder iveg2 iveg2 proc~alloc_casamet->iveg2 kbdi_spin kbdi_spin proc~alloc_casamet->kbdi_spin last_precip_spin last_precip_spin proc~alloc_casamet->last_precip_spin lat lat proc~alloc_casamet->lat lnonwood lnonwood proc~alloc_casamet->lnonwood lon lon proc~alloc_casamet->lon moist moist proc~alloc_casamet->moist moistavg moistavg proc~alloc_casamet->moistavg moistspin_1 moistspin_1 proc~alloc_casamet->moistspin_1 moistspin_2 moistspin_2 proc~alloc_casamet->moistspin_2 moistspin_3 moistspin_3 proc~alloc_casamet->moistspin_3 moistspin_4 moistspin_4 proc~alloc_casamet->moistspin_4 moistspin_5 moistspin_5 proc~alloc_casamet->moistspin_5 moistspin_6 moistspin_6 proc~alloc_casamet->moistspin_6 mtempspin mtempspin proc~alloc_casamet->mtempspin precip precip proc~alloc_casamet->precip tairk tairk proc~alloc_casamet->tairk tairkspin tairkspin proc~alloc_casamet->tairkspin tsoil tsoil proc~alloc_casamet->tsoil tsoilavg tsoilavg proc~alloc_casamet->tsoilavg tsoilspin_1 tsoilspin_1 proc~alloc_casamet->tsoilspin_1 tsoilspin_2 tsoilspin_2 proc~alloc_casamet->tsoilspin_2 tsoilspin_3 tsoilspin_3 proc~alloc_casamet->tsoilspin_3 tsoilspin_4 tsoilspin_4 proc~alloc_casamet->tsoilspin_4 tsoilspin_5 tsoilspin_5 proc~alloc_casamet->tsoilspin_5 tsoilspin_6 tsoilspin_6 proc~alloc_casamet->tsoilspin_6 clabile clabile proc~alloc_casapool->clabile clitter clitter proc~alloc_casapool->clitter cplant cplant proc~alloc_casapool->cplant csoil csoil proc~alloc_casapool->csoil ctot ctot proc~alloc_casapool->ctot ctot_0 ctot_0 proc~alloc_casapool->ctot_0 dclabiledt dclabiledt proc~alloc_casapool->dclabiledt dclitterdt dclitterdt proc~alloc_casapool->dclitterdt dcplantdt dcplantdt proc~alloc_casapool->dcplantdt dcsoildt dcsoildt proc~alloc_casapool->dcsoildt dnlitterdt dnlitterdt proc~alloc_casapool->dnlitterdt dnplantdt dnplantdt proc~alloc_casapool->dnplantdt dnsoildt dnsoildt proc~alloc_casapool->dnsoildt dnsoilmindt dnsoilmindt proc~alloc_casapool->dnsoilmindt dplitterdt dplitterdt proc~alloc_casapool->dplitterdt dpplantdt dpplantdt proc~alloc_casapool->dpplantdt dpsoildt dpsoildt proc~alloc_casapool->dpsoildt dpsoillabdt dpsoillabdt proc~alloc_casapool->dpsoillabdt dpsoiloccdt dpsoiloccdt proc~alloc_casapool->dpsoiloccdt dpsoilsorbdt dpsoilsorbdt proc~alloc_casapool->dpsoilsorbdt nlitter nlitter proc~alloc_casapool->nlitter nplant nplant proc~alloc_casapool->nplant nsoil nsoil proc~alloc_casapool->nsoil nsoilmin nsoilmin proc~alloc_casapool->nsoilmin plitter plitter proc~alloc_casapool->plitter pplant pplant proc~alloc_casapool->pplant psoil psoil proc~alloc_casapool->psoil psoillab psoillab proc~alloc_casapool->psoillab psoilocc psoilocc proc~alloc_casapool->psoilocc psoilsorb psoilsorb proc~alloc_casapool->psoilsorb rationclitter rationclitter proc~alloc_casapool->rationclitter rationcplant rationcplant proc~alloc_casapool->rationcplant rationcsoil rationcsoil proc~alloc_casapool->rationcsoil rationcsoilmax rationcsoilmax proc~alloc_casapool->rationcsoilmax rationcsoilmin rationcsoilmin proc~alloc_casapool->rationcsoilmin rationcsoilnew rationcsoilnew proc~alloc_casapool->rationcsoilnew rationplitter rationplitter proc~alloc_casapool->rationplitter rationpplant rationpplant proc~alloc_casapool->rationpplant rationpsoil rationpsoil proc~alloc_casapool->rationpsoil ratiopclitter ratiopclitter proc~alloc_casapool->ratiopclitter ratiopcplant ratiopcplant proc~alloc_casapool->ratiopcplant ratiopcsoil ratiopcsoil proc~alloc_casapool->ratiopcsoil Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures alloc_casabiome alloc_casapool alloc_casaflux alloc_casamet alloc_casabal Module Procedures private  subroutine alloc_casabiome (casabiome) vh_js !! Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(inout) :: casabiome private  subroutine alloc_casapool (casapool, arraysize) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: casapool integer, intent(in) :: arraysize private  subroutine alloc_casaflux (casaflux, arraysize) Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(inout) :: casaflux integer, intent(in) :: arraysize private  subroutine alloc_casamet (casamet, arraysize) Arguments Type Intent Optional Attributes Name type( casa_met ), intent(inout) :: casamet integer, intent(in) :: arraysize private  subroutine alloc_casabal (casabal, arraysize) Arguments Type Intent Optional Attributes Name type( casa_balance ), intent(inout) :: casabal integer, intent(in) :: arraysize","tags":"","loc":"interface/alloc_casa_var.html"},{"title":"zero_casa_var – POP","text":"public interface zero_casa_var Calls interface~~zero_casa_var~~CallsGraph interface~zero_casa_var casavariable::zero_casa_var proc~zero_casabal casavariable::zero_casabal interface~zero_casa_var->proc~zero_casabal proc~zero_casabiome casavariable::zero_casabiome interface~zero_casa_var->proc~zero_casabiome proc~zero_casaflux casavariable::zero_casaflux interface~zero_casa_var->proc~zero_casaflux proc~zero_casamet casavariable::zero_casamet interface~zero_casa_var->proc~zero_casamet proc~zero_casapool casavariable::zero_casapool interface~zero_casa_var->proc~zero_casapool Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures zero_casabiome zero_casapool zero_casaflux zero_casamet zero_casabal Module Procedures private  subroutine zero_casabiome (casabiome) Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(inout) :: casabiome private  subroutine zero_casapool (casapool) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: casapool private  subroutine zero_casaflux (casaflux) Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(inout) :: casaflux private  subroutine zero_casamet (casamet) Arguments Type Intent Optional Attributes Name type( casa_met ), intent(inout) :: casamet private  subroutine zero_casabal (casabal) Arguments Type Intent Optional Attributes Name type( casa_balance ), intent(inout) :: casabal","tags":"","loc":"interface/zero_casa_var.html"},{"title":"print_casa_var – POP","text":"public interface print_casa_var Calls interface~~print_casa_var~~CallsGraph interface~print_casa_var casavariable::print_casa_var proc~print_casabal casavariable::print_casabal interface~print_casa_var->proc~print_casabal proc~print_casabiome casavariable::print_casabiome interface~print_casa_var->proc~print_casabiome proc~print_casaflux casavariable::print_casaflux interface~print_casa_var->proc~print_casaflux proc~print_casamet casavariable::print_casamet interface~print_casa_var->proc~print_casamet proc~print_casapool casavariable::print_casapool interface~print_casa_var->proc~print_casapool Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures print_casabiome print_casapool print_casaflux print_casamet print_casabal Module Procedures private  subroutine print_casabiome (casabiome) Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(in) :: casabiome private  subroutine print_casapool (casapool) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(in) :: casapool private  subroutine print_casaflux (casaflux) Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(in) :: casaflux private  subroutine print_casamet (casamet) Arguments Type Intent Optional Attributes Name type( casa_met ), intent(in) :: casamet private  subroutine print_casabal (casabal) Arguments Type Intent Optional Attributes Name type( casa_balance ), intent(in) :: casabal","tags":"","loc":"interface/print_casa_var.html"},{"title":"read_netcdf_casa_var – POP","text":"public interface read_netcdf_casa_var Calls interface~~read_netcdf_casa_var~~CallsGraph interface~read_netcdf_casa_var casavariable::read_netcdf_casa_var proc~read_netcdf_casabal casavariable::read_netcdf_casabal interface~read_netcdf_casa_var->proc~read_netcdf_casabal proc~read_netcdf_casabiome casavariable::read_netcdf_casabiome interface~read_netcdf_casa_var->proc~read_netcdf_casabiome proc~read_netcdf_casaflux casavariable::read_netcdf_casaflux interface~read_netcdf_casa_var->proc~read_netcdf_casaflux proc~read_netcdf_casamet casavariable::read_netcdf_casamet interface~read_netcdf_casa_var->proc~read_netcdf_casamet proc~read_netcdf_casapool casavariable::read_netcdf_casapool interface~read_netcdf_casa_var->proc~read_netcdf_casapool nc_err nc_err proc~read_netcdf_casabal->nc_err nf90_close nf90_close proc~read_netcdf_casabal->nf90_close nf90_get_var nf90_get_var proc~read_netcdf_casabal->nf90_get_var nf90_inq_varid nf90_inq_varid proc~read_netcdf_casabal->nf90_inq_varid nf90_open nf90_open proc~read_netcdf_casabal->nf90_open proc~read_netcdf_casabiome->nc_err proc~read_netcdf_casabiome->nf90_close proc~read_netcdf_casabiome->nf90_get_var proc~read_netcdf_casabiome->nf90_inq_varid proc~read_netcdf_casabiome->nf90_open proc~read_netcdf_casaflux->nc_err proc~read_netcdf_casaflux->nf90_close proc~read_netcdf_casaflux->nf90_get_var proc~read_netcdf_casaflux->nf90_inq_varid proc~read_netcdf_casaflux->nf90_open proc~read_netcdf_casamet->nc_err proc~read_netcdf_casamet->nf90_close proc~read_netcdf_casamet->nf90_get_var proc~read_netcdf_casamet->nf90_inq_varid proc~read_netcdf_casamet->nf90_open proc~read_netcdf_casapool->nc_err proc~read_netcdf_casapool->nf90_close proc~read_netcdf_casapool->nf90_get_var proc~read_netcdf_casapool->nf90_inq_varid proc~read_netcdf_casapool->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~read_netcdf_casa_var~~CalledByGraph interface~read_netcdf_casa_var casavariable::read_netcdf_casa_var proc~read_casa_restart_nc casa_inout::read_casa_restart_nc proc~read_casa_restart_nc->interface~read_netcdf_casa_var proc~casa_init casa_inout::casa_init proc~casa_init->proc~read_casa_restart_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures read_netcdf_casabiome read_netcdf_casapool read_netcdf_casaflux read_netcdf_casamet read_netcdf_casabal Module Procedures private  subroutine read_netcdf_casabiome (filename, casabiome) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_biome ), intent(inout) :: casabiome private  subroutine read_netcdf_casapool (filename, casapool) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_pool ), intent(inout) :: casapool private  subroutine read_netcdf_casaflux (filename, casaflux) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_flux ), intent(inout) :: casaflux private  subroutine read_netcdf_casamet (filename, casamet) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_met ), intent(inout) :: casamet private  subroutine read_netcdf_casabal (filename, casabal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_balance ), intent(inout) :: casabal","tags":"","loc":"interface/read_netcdf_casa_var.html"},{"title":"write_netcdf_casa_var – POP","text":"public interface write_netcdf_casa_var Calls interface~~write_netcdf_casa_var~~CallsGraph interface~write_netcdf_casa_var casavariable::write_netcdf_casa_var proc~write_netcdf_casabal casavariable::write_netcdf_casabal interface~write_netcdf_casa_var->proc~write_netcdf_casabal proc~write_netcdf_casabiome casavariable::write_netcdf_casabiome interface~write_netcdf_casa_var->proc~write_netcdf_casabiome proc~write_netcdf_casaflux casavariable::write_netcdf_casaflux interface~write_netcdf_casa_var->proc~write_netcdf_casaflux proc~write_netcdf_casamet casavariable::write_netcdf_casamet interface~write_netcdf_casa_var->proc~write_netcdf_casamet proc~write_netcdf_casapool casavariable::write_netcdf_casapool interface~write_netcdf_casa_var->proc~write_netcdf_casapool nc_err nc_err proc~write_netcdf_casabal->nc_err nf90_close nf90_close proc~write_netcdf_casabal->nf90_close nf90_create nf90_create proc~write_netcdf_casabal->nf90_create nf90_def_dim nf90_def_dim proc~write_netcdf_casabal->nf90_def_dim nf90_def_var nf90_def_var proc~write_netcdf_casabal->nf90_def_var nf90_enddef nf90_enddef proc~write_netcdf_casabal->nf90_enddef nf90_put_var nf90_put_var proc~write_netcdf_casabal->nf90_put_var proc~write_netcdf_casabiome->nc_err proc~write_netcdf_casabiome->nf90_close proc~write_netcdf_casabiome->nf90_create proc~write_netcdf_casabiome->nf90_def_dim proc~write_netcdf_casabiome->nf90_def_var proc~write_netcdf_casabiome->nf90_enddef proc~write_netcdf_casabiome->nf90_put_var proc~write_netcdf_casaflux->nc_err proc~write_netcdf_casaflux->nf90_close proc~write_netcdf_casaflux->nf90_create proc~write_netcdf_casaflux->nf90_def_dim proc~write_netcdf_casaflux->nf90_def_var proc~write_netcdf_casaflux->nf90_enddef proc~write_netcdf_casaflux->nf90_put_var proc~write_netcdf_casamet->nc_err proc~write_netcdf_casamet->nf90_close proc~write_netcdf_casamet->nf90_create proc~write_netcdf_casamet->nf90_def_dim proc~write_netcdf_casamet->nf90_def_var proc~write_netcdf_casamet->nf90_enddef proc~write_netcdf_casamet->nf90_put_var proc~write_netcdf_casapool->nc_err proc~write_netcdf_casapool->nf90_close proc~write_netcdf_casapool->nf90_create proc~write_netcdf_casapool->nf90_def_dim proc~write_netcdf_casapool->nf90_def_var proc~write_netcdf_casapool->nf90_enddef proc~write_netcdf_casapool->nf90_put_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~write_netcdf_casa_var~~CalledByGraph interface~write_netcdf_casa_var casavariable::write_netcdf_casa_var proc~write_casa_restart_nc casa_inout::write_casa_restart_nc proc~write_casa_restart_nc->interface~write_netcdf_casa_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures write_netcdf_casabiome write_netcdf_casapool write_netcdf_casaflux write_netcdf_casamet write_netcdf_casabal Module Procedures private  subroutine write_netcdf_casabiome (filename, casabiome) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_biome ), intent(in) :: casabiome private  subroutine write_netcdf_casapool (filename, casapool) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_pool ), intent(in) :: casapool private  subroutine write_netcdf_casaflux (filename, casaflux) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_flux ), intent(in) :: casaflux private  subroutine write_netcdf_casamet (filename, casamet) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_met ), intent(in) :: casamet private  subroutine write_netcdf_casabal (filename, casabal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_balance ), intent(in) :: casabal","tags":"","loc":"interface/write_netcdf_casa_var.html"},{"title":"alloc_phenvariable – POP","text":"public  subroutine alloc_phenvariable(phen, arraysize) Uses casadimension cable_def_types_mod proc~~alloc_phenvariable~~UsesGraph proc~alloc_phenvariable phenvariable::alloc_phenvariable cable_def_types_mod cable_def_types_mod proc~alloc_phenvariable->cable_def_types_mod module~casadimension casadimension proc~alloc_phenvariable->module~casadimension module~casadimension->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( phen_variable ), intent(inout) :: phen integer, intent(in) :: arraysize Calls proc~~alloc_phenvariable~~CallsGraph proc~alloc_phenvariable phenvariable::alloc_phenvariable aphen aphen proc~alloc_phenvariable->aphen doyphase doyphase proc~alloc_phenvariable->doyphase doyphasespin_1 doyphasespin_1 proc~alloc_phenvariable->doyphasespin_1 doyphasespin_2 doyphasespin_2 proc~alloc_phenvariable->doyphasespin_2 doyphasespin_3 doyphasespin_3 proc~alloc_phenvariable->doyphasespin_3 doyphasespin_4 doyphasespin_4 proc~alloc_phenvariable->doyphasespin_4 phase phase proc~alloc_phenvariable->phase phasespin phasespin proc~alloc_phenvariable->phasespin tkshed tkshed proc~alloc_phenvariable->tkshed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/alloc_phenvariable.html"},{"title":"dealloc_phenvariable – POP","text":"public  subroutine dealloc_phenvariable(phen) Arguments Type Intent Optional Attributes Name type( phen_variable ), intent(inout) :: phen Contents","tags":"","loc":"proc/dealloc_phenvariable.html"},{"title":"print_phenvariable – POP","text":"public  subroutine print_phenvariable(phen) Arguments Type Intent Optional Attributes Name type( phen_variable ), intent(in) :: phen Contents","tags":"","loc":"proc/print_phenvariable.html"},{"title":"zero_phenvariable – POP","text":"public  subroutine zero_phenvariable(phen) Uses cable_def_types_mod proc~~zero_phenvariable~~UsesGraph proc~zero_phenvariable phenvariable::zero_phenvariable cable_def_types_mod cable_def_types_mod proc~zero_phenvariable->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( phen_variable ), intent(inout) :: phen Contents","tags":"","loc":"proc/zero_phenvariable.html"},{"title":"read_netcdf_phen_var – POP","text":"public  subroutine read_netcdf_phen_var(filename, phen) Uses cable_def_types_mod netcdf proc~~read_netcdf_phen_var~~UsesGraph proc~read_netcdf_phen_var phenvariable::read_netcdf_phen_var cable_def_types_mod cable_def_types_mod proc~read_netcdf_phen_var->cable_def_types_mod netcdf netcdf proc~read_netcdf_phen_var->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( phen_variable ), intent(inout) :: phen Calls proc~~read_netcdf_phen_var~~CallsGraph proc~read_netcdf_phen_var phenvariable::read_netcdf_phen_var nc_err nc_err proc~read_netcdf_phen_var->nc_err nf90_close nf90_close proc~read_netcdf_phen_var->nf90_close nf90_get_var nf90_get_var proc~read_netcdf_phen_var->nf90_get_var nf90_inq_varid nf90_inq_varid proc~read_netcdf_phen_var->nf90_inq_varid nf90_open nf90_open proc~read_netcdf_phen_var->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_netcdf_phen_var~~CalledByGraph proc~read_netcdf_phen_var phenvariable::read_netcdf_phen_var proc~read_casa_restart_nc casa_inout::read_casa_restart_nc proc~read_casa_restart_nc->proc~read_netcdf_phen_var proc~casa_init casa_inout::casa_init proc~casa_init->proc~read_casa_restart_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/read_netcdf_phen_var.html"},{"title":"write_netcdf_phen_var – POP","text":"public  subroutine write_netcdf_phen_var(filename, phen) Uses cable_def_types_mod netcdf proc~~write_netcdf_phen_var~~UsesGraph proc~write_netcdf_phen_var phenvariable::write_netcdf_phen_var cable_def_types_mod cable_def_types_mod proc~write_netcdf_phen_var->cable_def_types_mod netcdf netcdf proc~write_netcdf_phen_var->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( phen_variable ), intent(in) :: phen Calls proc~~write_netcdf_phen_var~~CallsGraph proc~write_netcdf_phen_var phenvariable::write_netcdf_phen_var nc_err nc_err proc~write_netcdf_phen_var->nc_err nf90_close nf90_close proc~write_netcdf_phen_var->nf90_close nf90_create nf90_create proc~write_netcdf_phen_var->nf90_create nf90_def_dim nf90_def_dim proc~write_netcdf_phen_var->nf90_def_dim nf90_def_var nf90_def_var proc~write_netcdf_phen_var->nf90_def_var nf90_enddef nf90_enddef proc~write_netcdf_phen_var->nf90_enddef nf90_put_var nf90_put_var proc~write_netcdf_phen_var->nf90_put_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_netcdf_phen_var~~CalledByGraph proc~write_netcdf_phen_var phenvariable::write_netcdf_phen_var proc~write_casa_restart_nc casa_inout::write_casa_restart_nc proc~write_casa_restart_nc->proc~write_netcdf_phen_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/write_netcdf_phen_var.html"},{"title":"REALExponential – POP","text":"public  function REALExponential(lambda, x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda real(kind=dp), intent(in) :: x Return Value real(kind=dp) Called by proc~~realexponential~2~~CalledByGraph proc~realexponential~2 POPLUC_Module::REALExponential proc~calculate_weights POPLUC_Module::calculate_weights proc~calculate_weights->proc~realexponential~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/realexponential~2.html"},{"title":"zero_popluc – POP","text":"public  subroutine zero_popluc(popluc) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: popluc Called by proc~~zero_popluc~~CalledByGraph proc~zero_popluc POPLUC_Module::zero_popluc proc~popluc_init POPLUC_Module::POPLUC_Init proc~popluc_init->proc~zero_popluc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/zero_popluc.html"},{"title":"print_popluc – POP","text":"public  subroutine print_popluc(popluc) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(in) :: popluc Contents","tags":"","loc":"proc/print_popluc.html"},{"title":"execute_luc_event – POP","text":"public  subroutine execute_luc_event(from_state, to_state, frac_change_grid, g, POPLUC) Arguments Type Intent Optional Attributes Name character(len=5), intent(in) :: from_state character(len=5), intent(in) :: to_state real(kind=dp), intent(inout) :: frac_change_grid integer(kind=i4b), intent(in) :: g type( POPLUC_TYPE ), intent(inout) :: POPLUC Calls proc~~execute_luc_event~~CallsGraph proc~execute_luc_event POPLUC_Module::execute_luc_event biomass_age_secondary biomass_age_secondary proc~execute_luc_event->biomass_age_secondary crelclear crelclear proc~execute_luc_event->crelclear freq_age_secondary freq_age_secondary proc~execute_luc_event->freq_age_secondary grass grass proc~execute_luc_event->grass n_event n_event proc~execute_luc_event->n_event primf primf proc~execute_luc_event->primf ptog ptog proc~execute_luc_event->ptog ptos ptos proc~execute_luc_event->ptos stog stog proc~execute_luc_event->stog Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~execute_luc_event~~CalledByGraph proc~execute_luc_event POPLUC_Module::execute_luc_event proc~poplucstep POPLUC_Module::POPLUCStep proc~poplucstep->proc~execute_luc_event proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~poplucstep Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/execute_luc_event.html"},{"title":"calculate_weights – POP","text":"public  subroutine calculate_weights(POPLUC, g) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC integer(kind=i4b), intent(in) :: g Calls proc~~calculate_weights~~CallsGraph proc~calculate_weights POPLUC_Module::calculate_weights age_history_secdf age_history_secdf proc~calculate_weights->age_history_secdf area_history_secdf area_history_secdf proc~calculate_weights->area_history_secdf freq_age_primary freq_age_primary proc~calculate_weights->freq_age_primary n_event n_event proc~calculate_weights->n_event proc~realexponential~2 POPLUC_Module::REALExponential proc~calculate_weights->proc~realexponential~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/calculate_weights.html"},{"title":"INCREMENT_AGE – POP","text":"public  subroutine INCREMENT_AGE(POPLUC, g) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC integer(kind=i4b), intent(in) :: g Calls proc~~increment_age~~CallsGraph proc~increment_age POPLUC_Module::INCREMENT_AGE biomass_age_secondary biomass_age_secondary proc~increment_age->biomass_age_secondary freq_age_secondary freq_age_secondary proc~increment_age->freq_age_secondary smharv smharv proc~increment_age->smharv syharv syharv proc~increment_age->syharv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~increment_age~~CalledByGraph proc~increment_age POPLUC_Module::INCREMENT_AGE proc~poplucstep POPLUC_Module::POPLUCStep proc~poplucstep->proc~increment_age proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~poplucstep Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/increment_age.html"},{"title":"POPLUCStep – POP","text":"public  subroutine POPLUCStep(POPLUC, year) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC integer(kind=i4b), intent(in) :: year Calls proc~~poplucstep~~CallsGraph proc~poplucstep POPLUC_Module::POPLUCStep freq_age_secondary freq_age_secondary proc~poplucstep->freq_age_secondary gtop gtop proc~poplucstep->gtop gtos gtos proc~poplucstep->gtos primf primf proc~poplucstep->primf proc~execute_luc_event POPLUC_Module::execute_luc_event proc~poplucstep->proc~execute_luc_event proc~increment_age POPLUC_Module::INCREMENT_AGE proc~poplucstep->proc~increment_age ptog ptog proc~poplucstep->ptog ptos ptos proc~poplucstep->ptos stog stog proc~poplucstep->stog proc~execute_luc_event->freq_age_secondary proc~execute_luc_event->primf proc~execute_luc_event->ptog proc~execute_luc_event->ptos proc~execute_luc_event->stog biomass_age_secondary biomass_age_secondary proc~execute_luc_event->biomass_age_secondary crelclear crelclear proc~execute_luc_event->crelclear grass grass proc~execute_luc_event->grass n_event n_event proc~execute_luc_event->n_event proc~increment_age->freq_age_secondary proc~increment_age->biomass_age_secondary smharv smharv proc~increment_age->smharv syharv syharv proc~increment_age->syharv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~poplucstep~~CalledByGraph proc~poplucstep POPLUC_Module::POPLUCStep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~poplucstep Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/poplucstep.html"},{"title":"POPLUC_weights_transfer – POP","text":"public  subroutine POPLUC_weights_transfer(POPLUC, POP, LUC_EXPT) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(in) :: POPLUC type( POP_TYPE ), intent(inout) :: POP type(LUC_EXPT_TYPE), intent(in) :: LUC_EXPT Calls proc~~popluc_weights_transfer~~CallsGraph proc~popluc_weights_transfer POPLUC_Module::POPLUC_weights_transfer freq_age_secondary freq_age_secondary proc~popluc_weights_transfer->freq_age_secondary iwood iwood proc~popluc_weights_transfer->iwood landpt landpt proc~popluc_weights_transfer->landpt prim_only prim_only proc~popluc_weights_transfer->prim_only Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~popluc_weights_transfer~~CalledByGraph proc~popluc_weights_transfer POPLUC_Module::POPLUC_weights_transfer proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popluc_weights_transfer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/popluc_weights_transfer.html"},{"title":"POP_LUC_CASA_transfer – POP","text":"public  subroutine POP_LUC_CASA_transfer(POPLUC, POP, LUC_EXPT, casapool, casabal, casaflux, ktauday) Uses mo_utils proc~~pop_luc_casa_transfer~~UsesGraph proc~pop_luc_casa_transfer POPLUC_Module::POP_LUC_CASA_transfer mo_utils mo_utils proc~pop_luc_casa_transfer->mo_utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC type( POP_TYPE ), intent(inout) :: POP type(LUC_EXPT_TYPE), intent(in) :: LUC_EXPT type( casa_pool ), intent(inout) :: casapool type( casa_balance ), intent(inout) :: casabal type( casa_flux ), intent(inout) :: casaflux integer, intent(in) :: ktauday Calls proc~~pop_luc_casa_transfer~~CallsGraph proc~pop_luc_casa_transfer POPLUC_Module::POP_LUC_CASA_transfer agprod agprod proc~pop_luc_casa_transfer->agprod agprodloss agprodloss proc~pop_luc_casa_transfer->agprodloss charvest charvest proc~pop_luc_casa_transfer->charvest clabile clabile proc~pop_luc_casa_transfer->clabile clearprod clearprod proc~pop_luc_casa_transfer->clearprod clearprodloss clearprodloss proc~pop_luc_casa_transfer->clearprodloss clitter clitter proc~pop_luc_casa_transfer->clitter cplant cplant proc~pop_luc_casa_transfer->cplant crelclear crelclear proc~pop_luc_casa_transfer->crelclear crop crop proc~pop_luc_casa_transfer->crop csoil csoil proc~pop_luc_casa_transfer->csoil ctos ctos proc~pop_luc_casa_transfer->ctos ctransferluc ctransferluc proc~pop_luc_casa_transfer->ctransferluc eq eq proc~pop_luc_casa_transfer->eq fclearance fclearance proc~pop_luc_casa_transfer->fclearance fcneeyear fcneeyear proc~pop_luc_casa_transfer->fcneeyear fharvest fharvest proc~pop_luc_casa_transfer->fharvest fracclearprod fracclearprod proc~pop_luc_casa_transfer->fracclearprod fracclearresid fracclearresid proc~pop_luc_casa_transfer->fracclearresid fracharvprod fracharvprod proc~pop_luc_casa_transfer->fracharvprod fracharvresid fracharvresid proc~pop_luc_casa_transfer->fracharvresid fracharvsecresid fracharvsecresid proc~pop_luc_casa_transfer->fracharvsecresid grass grass proc~pop_luc_casa_transfer->grass gtos gtos proc~pop_luc_casa_transfer->gtos harvprod harvprod proc~pop_luc_casa_transfer->harvprod harvprodloss harvprodloss proc~pop_luc_casa_transfer->harvprodloss iwood iwood proc~pop_luc_casa_transfer->iwood kclear kclear proc~pop_luc_casa_transfer->kclear knatdist knatdist proc~pop_luc_casa_transfer->knatdist ksecharv ksecharv proc~pop_luc_casa_transfer->ksecharv landpt landpt proc~pop_luc_casa_transfer->landpt nlitter nlitter proc~pop_luc_casa_transfer->nlitter nplant nplant proc~pop_luc_casa_transfer->nplant nsoil nsoil proc~pop_luc_casa_transfer->nsoil nsoilmin nsoilmin proc~pop_luc_casa_transfer->nsoilmin past past proc~pop_luc_casa_transfer->past patch patch proc~pop_luc_casa_transfer->patch plitter plitter proc~pop_luc_casa_transfer->plitter pop_grid pop_grid proc~pop_luc_casa_transfer->pop_grid pplant pplant proc~pop_luc_casa_transfer->pplant prim_only prim_only proc~pop_luc_casa_transfer->prim_only psoil psoil proc~pop_luc_casa_transfer->psoil ptoc ptoc proc~pop_luc_casa_transfer->ptoc ptog ptog proc~pop_luc_casa_transfer->ptog ptoq ptoq proc~pop_luc_casa_transfer->ptoq ptos ptos proc~pop_luc_casa_transfer->ptos qtos qtos proc~pop_luc_casa_transfer->qtos secdf secdf proc~pop_luc_casa_transfer->secdf stoc stoc proc~pop_luc_casa_transfer->stoc stog stog proc~pop_luc_casa_transfer->stog stoq stoq proc~pop_luc_casa_transfer->stoq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pop_luc_casa_transfer~~CalledByGraph proc~pop_luc_casa_transfer POPLUC_Module::POP_LUC_CASA_transfer proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~pop_luc_casa_transfer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/pop_luc_casa_transfer.html"},{"title":"POPLUC_Init – POP","text":"public  subroutine POPLUC_Init(POPLUC, LUC_EXPT, casapool, casaflux, casabiome, veg, POP, np) Uses casaparm cable_def_types_mod proc~~popluc_init~~UsesGraph proc~popluc_init POPLUC_Module::POPLUC_Init cable_def_types_mod cable_def_types_mod proc~popluc_init->cable_def_types_mod module~casaparm casaparm proc~popluc_init->module~casaparm module~casaparm->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC type(LUC_EXPT_TYPE), intent(in) :: LUC_EXPT type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_biome ), intent(in) :: casabiome type(veg_parameter_type), intent(in) :: veg type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: np Calls proc~~popluc_init~~CallsGraph proc~popluc_init POPLUC_Module::POPLUC_Init cplant cplant proc~popluc_init->cplant iwood iwood proc~popluc_init->iwood landpt landpt proc~popluc_init->landpt patch patch proc~popluc_init->patch prim_only prim_only proc~popluc_init->prim_only proc~alloc_popluc POPLUC_Module::alloc_POPLUC proc~popluc_init->proc~alloc_popluc proc~pop_init_single POPModule::POP_init_single proc~popluc_init->proc~pop_init_single proc~popluc_set_params POPLUC_Module::POPLUC_set_params proc~popluc_init->proc~popluc_set_params proc~read_luc_restart_nc POPLUC_Module::READ_LUC_RESTART_NC proc~popluc_init->proc~read_luc_restart_nc proc~zero_popluc POPLUC_Module::zero_popluc proc~popluc_init->proc~zero_popluc rationcplantmin rationcplantmin proc~popluc_init->rationcplantmin ratiopcplantmin ratiopcplantmin proc~popluc_init->ratiopcplantmin age_history_secdf age_history_secdf proc~alloc_popluc->age_history_secdf agprod agprod proc~alloc_popluc->agprod agprodloss agprodloss proc~alloc_popluc->agprodloss area_history_secdf area_history_secdf proc~alloc_popluc->area_history_secdf biomass_age_primary biomass_age_primary proc~alloc_popluc->biomass_age_primary biomass_age_secondary biomass_age_secondary proc~alloc_popluc->biomass_age_secondary cbiomass cbiomass proc~alloc_popluc->cbiomass clearprod clearprod proc~alloc_popluc->clearprod clearprodloss clearprodloss proc~alloc_popluc->clearprodloss clitt clitt proc~alloc_popluc->clitt crelclear crelclear proc~alloc_popluc->crelclear crop crop proc~alloc_popluc->crop csoil csoil proc~alloc_popluc->csoil ctos ctos proc~alloc_popluc->ctos dcsharvclear dcsharvclear proc~alloc_popluc->dcsharvclear fag fag proc~alloc_popluc->fag fclearance fclearance proc~alloc_popluc->fclearance fharvest fharvest proc~alloc_popluc->fharvest fluxpclearresidtolitter fluxpclearresidtolitter proc~alloc_popluc->fluxpclearresidtolitter fluxpharvresidtolitter fluxpharvresidtolitter proc~alloc_popluc->fluxpharvresidtolitter fluxsclearresidtolitter fluxsclearresidtolitter proc~alloc_popluc->fluxsclearresidtolitter fluxsharvresidtolitter fluxsharvresidtolitter proc~alloc_popluc->fluxsharvresidtolitter fnep fnep proc~alloc_popluc->fnep frac_forest frac_forest proc~alloc_popluc->frac_forest frac_primf frac_primf proc~alloc_popluc->frac_primf fracclearprod fracclearprod proc~alloc_popluc->fracclearprod fracclearresid fracclearresid proc~alloc_popluc->fracclearresid fracharvprod fracharvprod proc~alloc_popluc->fracharvprod fracharvresid fracharvresid proc~alloc_popluc->fracharvresid fracharvsecresid fracharvsecresid proc~alloc_popluc->fracharvsecresid freq_age_primary freq_age_primary proc~alloc_popluc->freq_age_primary freq_age_secondary freq_age_secondary proc~alloc_popluc->freq_age_secondary ftransfergross ftransfergross proc~alloc_popluc->ftransfergross ftransfernet ftransfernet proc~alloc_popluc->ftransfernet grass grass proc~alloc_popluc->grass gtop gtop proc~alloc_popluc->gtop gtos gtos proc~alloc_popluc->gtos harvprod harvprod proc~alloc_popluc->harvprod harvprodloss harvprodloss proc~alloc_popluc->harvprodloss kclear kclear proc~alloc_popluc->kclear kexpand1 kexpand1 proc~alloc_popluc->kexpand1 kexpand2 kexpand2 proc~alloc_popluc->kexpand2 knatdist knatdist proc~alloc_popluc->knatdist ksecharv ksecharv proc~alloc_popluc->ksecharv latitude latitude proc~alloc_popluc->latitude longitude longitude proc~alloc_popluc->longitude past past proc~alloc_popluc->past pharv pharv proc~alloc_popluc->pharv primf primf proc~alloc_popluc->primf ptoc ptoc proc~alloc_popluc->ptoc ptog ptog proc~alloc_popluc->ptog ptoq ptoq proc~alloc_popluc->ptoq ptos ptos proc~alloc_popluc->ptos qtos qtos proc~alloc_popluc->qtos secdf secdf proc~alloc_popluc->secdf smharv smharv proc~alloc_popluc->smharv stoc stoc proc~alloc_popluc->stoc stog stog proc~alloc_popluc->stog stoq stoq proc~alloc_popluc->stoq syharv syharv proc~alloc_popluc->syharv proc~initpop2d_poisson POPModule::InitPOP2D_Poisson proc~pop_init_single->proc~initpop2d_poisson proc~layer_recruitment_single_patch POPModule::layer_recruitment_single_patch proc~pop_init_single->proc~layer_recruitment_single_patch proc~zeropop POPModule::ZeroPOP proc~pop_init_single->proc~zeropop biome biome proc~popluc_set_params->biome proc~popluc_set_params->fracharvresid proc~popluc_set_params->fracharvsecresid ivegp ivegp proc~popluc_set_params->ivegp handle_err handle_err proc~read_luc_restart_nc->handle_err nf90_close nf90_close proc~read_luc_restart_nc->nf90_close nf90_get_var nf90_get_var proc~read_luc_restart_nc->nf90_get_var nf90_inq_dimid nf90_inq_dimid proc~read_luc_restart_nc->nf90_inq_dimid nf90_inq_varid nf90_inq_varid proc~read_luc_restart_nc->nf90_inq_varid nf90_inquire_dimension nf90_inquire_dimension proc~read_luc_restart_nc->nf90_inquire_dimension nf90_open nf90_open proc~read_luc_restart_nc->nf90_open pop_grid pop_grid proc~initpop2d_poisson->pop_grid proc~cumexponential POPModule::CumExponential proc~initpop2d_poisson->proc~cumexponential proc~exponential POPModule::Exponential proc~initpop2d_poisson->proc~exponential proc~layer_recruitment_single_patch->pop_grid proc~get_allometry POPModule::GET_ALLOMETRY proc~layer_recruitment_single_patch->proc~get_allometry proc~allometry POPModule::Allometry proc~get_allometry->proc~allometry proc~getheight POPModule::GetHeight proc~get_allometry->proc~getheight proc~williams_allometry POPModule::Williams_Allometry proc~get_allometry->proc~williams_allometry Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/popluc_init.html"},{"title":"POPLUC_set_patchfrac – POP","text":"public  subroutine POPLUC_set_patchfrac(POPLUC, LUC_EXPT) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(in) :: POPLUC type(LUC_EXPT_TYPE), intent(in) :: LUC_EXPT Calls proc~~popluc_set_patchfrac~~CallsGraph proc~popluc_set_patchfrac POPLUC_Module::POPLUC_set_patchfrac grass grass proc~popluc_set_patchfrac->grass landpt landpt proc~popluc_set_patchfrac->landpt patch patch proc~popluc_set_patchfrac->patch prim_only prim_only proc~popluc_set_patchfrac->prim_only primf primf proc~popluc_set_patchfrac->primf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~popluc_set_patchfrac~~CalledByGraph proc~popluc_set_patchfrac POPLUC_Module::POPLUC_set_patchfrac proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popluc_set_patchfrac Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/popluc_set_patchfrac.html"},{"title":"POPLUC_set_params – POP","text":"public  subroutine POPLUC_set_params(POPLUC, LUC_EXPT) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC type(LUC_EXPT_TYPE), intent(in) :: LUC_EXPT Calls proc~~popluc_set_params~~CallsGraph proc~popluc_set_params POPLUC_Module::POPLUC_set_params biome biome proc~popluc_set_params->biome fracharvresid fracharvresid proc~popluc_set_params->fracharvresid fracharvsecresid fracharvsecresid proc~popluc_set_params->fracharvsecresid ivegp ivegp proc~popluc_set_params->ivegp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~popluc_set_params~~CalledByGraph proc~popluc_set_params POPLUC_Module::POPLUC_set_params proc~popluc_init POPLUC_Module::POPLUC_Init proc~popluc_init->proc~popluc_set_params Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/popluc_set_params.html"},{"title":"alloc_POPLUC – POP","text":"public  subroutine alloc_POPLUC(POPLUC, arraysize) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC integer, intent(in) :: arraysize Calls proc~~alloc_popluc~~CallsGraph proc~alloc_popluc POPLUC_Module::alloc_POPLUC age_history_secdf age_history_secdf proc~alloc_popluc->age_history_secdf agprod agprod proc~alloc_popluc->agprod agprodloss agprodloss proc~alloc_popluc->agprodloss area_history_secdf area_history_secdf proc~alloc_popluc->area_history_secdf biomass_age_primary biomass_age_primary proc~alloc_popluc->biomass_age_primary biomass_age_secondary biomass_age_secondary proc~alloc_popluc->biomass_age_secondary cbiomass cbiomass proc~alloc_popluc->cbiomass clearprod clearprod proc~alloc_popluc->clearprod clearprodloss clearprodloss proc~alloc_popluc->clearprodloss clitt clitt proc~alloc_popluc->clitt crelclear crelclear proc~alloc_popluc->crelclear crop crop proc~alloc_popluc->crop csoil csoil proc~alloc_popluc->csoil ctos ctos proc~alloc_popluc->ctos dcsharvclear dcsharvclear proc~alloc_popluc->dcsharvclear fag fag proc~alloc_popluc->fag fclearance fclearance proc~alloc_popluc->fclearance fharvest fharvest proc~alloc_popluc->fharvest fluxpclearresidtolitter fluxpclearresidtolitter proc~alloc_popluc->fluxpclearresidtolitter fluxpharvresidtolitter fluxpharvresidtolitter proc~alloc_popluc->fluxpharvresidtolitter fluxsclearresidtolitter fluxsclearresidtolitter proc~alloc_popluc->fluxsclearresidtolitter fluxsharvresidtolitter fluxsharvresidtolitter proc~alloc_popluc->fluxsharvresidtolitter fnep fnep proc~alloc_popluc->fnep frac_forest frac_forest proc~alloc_popluc->frac_forest frac_primf frac_primf proc~alloc_popluc->frac_primf fracclearprod fracclearprod proc~alloc_popluc->fracclearprod fracclearresid fracclearresid proc~alloc_popluc->fracclearresid fracharvprod fracharvprod proc~alloc_popluc->fracharvprod fracharvresid fracharvresid proc~alloc_popluc->fracharvresid fracharvsecresid fracharvsecresid proc~alloc_popluc->fracharvsecresid freq_age_primary freq_age_primary proc~alloc_popluc->freq_age_primary freq_age_secondary freq_age_secondary proc~alloc_popluc->freq_age_secondary ftransfergross ftransfergross proc~alloc_popluc->ftransfergross ftransfernet ftransfernet proc~alloc_popluc->ftransfernet grass grass proc~alloc_popluc->grass gtop gtop proc~alloc_popluc->gtop gtos gtos proc~alloc_popluc->gtos harvprod harvprod proc~alloc_popluc->harvprod harvprodloss harvprodloss proc~alloc_popluc->harvprodloss kclear kclear proc~alloc_popluc->kclear kexpand1 kexpand1 proc~alloc_popluc->kexpand1 kexpand2 kexpand2 proc~alloc_popluc->kexpand2 knatdist knatdist proc~alloc_popluc->knatdist ksecharv ksecharv proc~alloc_popluc->ksecharv latitude latitude proc~alloc_popluc->latitude longitude longitude proc~alloc_popluc->longitude past past proc~alloc_popluc->past pharv pharv proc~alloc_popluc->pharv primf primf proc~alloc_popluc->primf ptoc ptoc proc~alloc_popluc->ptoc ptog ptog proc~alloc_popluc->ptog ptoq ptoq proc~alloc_popluc->ptoq ptos ptos proc~alloc_popluc->ptos qtos qtos proc~alloc_popluc->qtos secdf secdf proc~alloc_popluc->secdf smharv smharv proc~alloc_popluc->smharv stoc stoc proc~alloc_popluc->stoc stog stog proc~alloc_popluc->stog stoq stoq proc~alloc_popluc->stoq syharv syharv proc~alloc_popluc->syharv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~alloc_popluc~~CalledByGraph proc~alloc_popluc POPLUC_Module::alloc_POPLUC proc~popluc_init POPLUC_Module::POPLUC_Init proc~popluc_init->proc~alloc_popluc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/alloc_popluc.html"},{"title":"WRITE_LUC_OUTPUT_NC – POP","text":"public  subroutine WRITE_LUC_OUTPUT_NC(POPLUC, ctime, FINAL) Uses netcdf CABLE_COMMON_MODULE proc~~write_luc_output_nc~~UsesGraph proc~write_luc_output_nc POPLUC_Module::WRITE_LUC_OUTPUT_NC CABLE_COMMON_MODULE CABLE_COMMON_MODULE proc~write_luc_output_nc->CABLE_COMMON_MODULE netcdf netcdf proc~write_luc_output_nc->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(in) :: POPLUC integer, intent(in) :: ctime logical, intent(in) :: FINAL Calls proc~~write_luc_output_nc~~CallsGraph proc~write_luc_output_nc POPLUC_Module::WRITE_LUC_OUTPUT_NC handle_err handle_err proc~write_luc_output_nc->handle_err nf90_close nf90_close proc~write_luc_output_nc->nf90_close nf90_create nf90_create proc~write_luc_output_nc->nf90_create nf90_def_dim nf90_def_dim proc~write_luc_output_nc->nf90_def_dim nf90_def_var nf90_def_var proc~write_luc_output_nc->nf90_def_var nf90_enddef nf90_enddef proc~write_luc_output_nc->nf90_enddef nf90_put_att nf90_put_att proc~write_luc_output_nc->nf90_put_att nf90_put_var nf90_put_var proc~write_luc_output_nc->nf90_put_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/write_luc_output_nc.html"},{"title":"WRITE_LUC_RESTART_NC – POP","text":"public  subroutine WRITE_LUC_RESTART_NC(POPLUC) Uses cable_common_module netcdf proc~~write_luc_restart_nc~~UsesGraph proc~write_luc_restart_nc POPLUC_Module::WRITE_LUC_RESTART_NC cable_common_module cable_common_module proc~write_luc_restart_nc->cable_common_module netcdf netcdf proc~write_luc_restart_nc->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(in) :: POPLUC Calls proc~~write_luc_restart_nc~~CallsGraph proc~write_luc_restart_nc POPLUC_Module::WRITE_LUC_RESTART_NC handle_err handle_err proc~write_luc_restart_nc->handle_err nf90_close nf90_close proc~write_luc_restart_nc->nf90_close nf90_create nf90_create proc~write_luc_restart_nc->nf90_create nf90_def_dim nf90_def_dim proc~write_luc_restart_nc->nf90_def_dim nf90_def_var nf90_def_var proc~write_luc_restart_nc->nf90_def_var nf90_enddef nf90_enddef proc~write_luc_restart_nc->nf90_enddef nf90_put_att nf90_put_att proc~write_luc_restart_nc->nf90_put_att nf90_put_var nf90_put_var proc~write_luc_restart_nc->nf90_put_var nf90_redef nf90_redef proc~write_luc_restart_nc->nf90_redef Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_luc_restart_nc~~CalledByGraph proc~write_luc_restart_nc POPLUC_Module::WRITE_LUC_RESTART_NC proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~write_luc_restart_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/write_luc_restart_nc.html"},{"title":"READ_LUC_RESTART_NC – POP","text":"public  subroutine READ_LUC_RESTART_NC(POPLUC) Uses netcdf CABLE_COMMON_MODULE proc~~read_luc_restart_nc~~UsesGraph proc~read_luc_restart_nc POPLUC_Module::READ_LUC_RESTART_NC CABLE_COMMON_MODULE CABLE_COMMON_MODULE proc~read_luc_restart_nc->CABLE_COMMON_MODULE netcdf netcdf proc~read_luc_restart_nc->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC Calls proc~~read_luc_restart_nc~~CallsGraph proc~read_luc_restart_nc POPLUC_Module::READ_LUC_RESTART_NC handle_err handle_err proc~read_luc_restart_nc->handle_err nf90_close nf90_close proc~read_luc_restart_nc->nf90_close nf90_get_var nf90_get_var proc~read_luc_restart_nc->nf90_get_var nf90_inq_dimid nf90_inq_dimid proc~read_luc_restart_nc->nf90_inq_dimid nf90_inq_varid nf90_inq_varid proc~read_luc_restart_nc->nf90_inq_varid nf90_inquire_dimension nf90_inquire_dimension proc~read_luc_restart_nc->nf90_inquire_dimension nf90_open nf90_open proc~read_luc_restart_nc->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_luc_restart_nc~~CalledByGraph proc~read_luc_restart_nc POPLUC_Module::READ_LUC_RESTART_NC proc~popluc_init POPLUC_Module::POPLUC_Init proc~popluc_init->proc~read_luc_restart_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/read_luc_restart_nc.html"},{"title":"WRITE_LUC_OUTPUT_GRID_NC – POP","text":"public  subroutine WRITE_LUC_OUTPUT_GRID_NC(POPLUC, ctime, FINAL) Uses netcdf CABLE_COMMON_MODULE cable_IO_vars_module proc~~write_luc_output_grid_nc~~UsesGraph proc~write_luc_output_grid_nc POPLUC_Module::WRITE_LUC_OUTPUT_GRID_NC CABLE_COMMON_MODULE CABLE_COMMON_MODULE proc~write_luc_output_grid_nc->CABLE_COMMON_MODULE cable_IO_vars_module cable_IO_vars_module proc~write_luc_output_grid_nc->cable_IO_vars_module netcdf netcdf proc~write_luc_output_grid_nc->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(in) :: POPLUC integer, intent(in) :: ctime logical, intent(in) :: FINAL Calls proc~~write_luc_output_grid_nc~~CallsGraph proc~write_luc_output_grid_nc POPLUC_Module::WRITE_LUC_OUTPUT_GRID_NC cbiomass cbiomass proc~write_luc_output_grid_nc->cbiomass clearprod clearprod proc~write_luc_output_grid_nc->clearprod clearprodloss clearprodloss proc~write_luc_output_grid_nc->clearprodloss clitt clitt proc~write_luc_output_grid_nc->clitt csoil csoil proc~write_luc_output_grid_nc->csoil fclearance fclearance proc~write_luc_output_grid_nc->fclearance fharvest fharvest proc~write_luc_output_grid_nc->fharvest fnep fnep proc~write_luc_output_grid_nc->fnep ftransfergross ftransfergross proc~write_luc_output_grid_nc->ftransfergross ftransfernet ftransfernet proc~write_luc_output_grid_nc->ftransfernet handle_err handle_err proc~write_luc_output_grid_nc->handle_err harvprod harvprod proc~write_luc_output_grid_nc->harvprod harvprodloss harvprodloss proc~write_luc_output_grid_nc->harvprodloss lat_all lat_all proc~write_luc_output_grid_nc->lat_all lon_all lon_all proc~write_luc_output_grid_nc->lon_all nf90_close nf90_close proc~write_luc_output_grid_nc->nf90_close nf90_create nf90_create proc~write_luc_output_grid_nc->nf90_create nf90_def_dim nf90_def_dim proc~write_luc_output_grid_nc->nf90_def_dim nf90_def_var nf90_def_var proc~write_luc_output_grid_nc->nf90_def_var nf90_enddef nf90_enddef proc~write_luc_output_grid_nc->nf90_enddef nf90_put_att nf90_put_att proc~write_luc_output_grid_nc->nf90_put_att nf90_put_var nf90_put_var proc~write_luc_output_grid_nc->nf90_put_var nf90_redef nf90_redef proc~write_luc_output_grid_nc->nf90_redef Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/write_luc_output_grid_nc.html"},{"title":"POP_IO – POP","text":"public  subroutine POP_IO(POP, casamet, YEAR, ACTION, CF) Uses casavariable TypeDef POP_Constants POP_Types mo_utils CABLE_COMMON_MODULE casadimension netcdf proc~~pop_io~~UsesGraph proc~pop_io cable_pop_io::POP_IO CABLE_COMMON_MODULE CABLE_COMMON_MODULE proc~pop_io->CABLE_COMMON_MODULE mo_utils mo_utils proc~pop_io->mo_utils module~casadimension casadimension proc~pop_io->module~casadimension module~casavariable casavariable proc~pop_io->module~casavariable module~pop_constants POP_Constants proc~pop_io->module~pop_constants module~pop_types POP_Types proc~pop_io->module~pop_types module~typedef TypeDef proc~pop_io->module~typedef netcdf netcdf proc~pop_io->netcdf cable_def_types_mod cable_def_types_mod module~casadimension->cable_def_types_mod module~casavariable->cable_def_types_mod module~pop_constants->module~typedef module~pop_types->module~pop_constants module~pop_types->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP type( casa_met ), intent(in) :: casamet integer, intent(in) :: YEAR character(len=*), intent(in) :: ACTION logical, intent(in) :: CF Calls proc~~pop_io~~CallsGraph proc~pop_io cable_pop_io::POP_IO handle_err handle_err proc~pop_io->handle_err lat lat proc~pop_io->lat lon lon proc~pop_io->lon ne ne proc~pop_io->ne nf90_close nf90_close proc~pop_io->nf90_close nf90_create nf90_create proc~pop_io->nf90_create nf90_def_dim nf90_def_dim proc~pop_io->nf90_def_dim nf90_def_var nf90_def_var proc~pop_io->nf90_def_var nf90_enddef nf90_enddef proc~pop_io->nf90_enddef nf90_get_var nf90_get_var proc~pop_io->nf90_get_var nf90_inq_dimid nf90_inq_dimid proc~pop_io->nf90_inq_dimid nf90_inq_varid nf90_inq_varid proc~pop_io->nf90_inq_varid nf90_inquire_dimension nf90_inquire_dimension proc~pop_io->nf90_inquire_dimension nf90_open nf90_open proc~pop_io->nf90_open nf90_put_att nf90_put_att proc~pop_io->nf90_put_att nf90_put_var nf90_put_var proc~pop_io->nf90_put_var pop_grid pop_grid proc~pop_io->pop_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/pop_io.html"},{"title":"light_inhibition – POP","text":"public  function light_inhibition(APAR) result(xrd) Arguments Type Intent Optional Attributes Name real, intent(in) :: APAR Return Value real Called by proc~~light_inhibition~~CalledByGraph proc~light_inhibition cable_optimise_JV_module::light_inhibition proc~diff_ac_aj cable_optimise_JV_module::diff_Ac_Aj proc~diff_ac_aj->proc~light_inhibition proc~total_an_ac_aj cable_optimise_JV_module::total_An_Ac_Aj proc~total_an_ac_aj->proc~light_inhibition proc~total_photosynthesis cable_optimise_JV_module::total_photosynthesis proc~total_photosynthesis->proc~light_inhibition proc~total_photosynthesis_cost cable_optimise_JV_module::total_photosynthesis_cost proc~total_photosynthesis_cost->proc~light_inhibition proc~optimise_jv cable_optimise_JV_module::optimise_JV proc~optimise_jv->proc~diff_ac_aj proc~optimise_jv->proc~total_photosynthesis_cost proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~optimise_jv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/light_inhibition.html"},{"title":"total_photosynthesis_cost – POP","text":"public  function total_photosynthesis_cost(bjv) Uses cable_def_types_mod cable_canopy_module proc~~total_photosynthesis_cost~~UsesGraph proc~total_photosynthesis_cost cable_optimise_JV_module::total_photosynthesis_cost cable_canopy_module cable_canopy_module proc~total_photosynthesis_cost->cable_canopy_module cable_def_types_mod cable_def_types_mod proc~total_photosynthesis_cost->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: bjv Return Value real Calls proc~~total_photosynthesis_cost~~CallsGraph proc~total_photosynthesis_cost cable_optimise_JV_module::total_photosynthesis_cost ej3x ej3x proc~total_photosynthesis_cost->ej3x point2constants point2constants proc~total_photosynthesis_cost->point2constants proc~fabc cable_optimise_JV_module::fabc proc~total_photosynthesis_cost->proc~fabc proc~fabcd cable_optimise_JV_module::fabcd proc~total_photosynthesis_cost->proc~fabcd proc~fam_c3 cable_optimise_JV_module::fAm_c3 proc~total_photosynthesis_cost->proc~fam_c3 proc~fan_c3 cable_optimise_JV_module::fAn_c3 proc~total_photosynthesis_cost->proc~fan_c3 proc~fpq cable_optimise_JV_module::fpq proc~total_photosynthesis_cost->proc~fpq proc~light_inhibition cable_optimise_JV_module::light_inhibition proc~total_photosynthesis_cost->proc~light_inhibition xejmxt3 xejmxt3 proc~total_photosynthesis_cost->xejmxt3 xejmxt3_acclim xejmxt3_acclim proc~total_photosynthesis_cost->xejmxt3_acclim xgmest xgmest proc~total_photosynthesis_cost->xgmest xrdt xrdt proc~total_photosynthesis_cost->xrdt xvcmxt3 xvcmxt3 proc~total_photosynthesis_cost->xvcmxt3 xvcmxt3_acclim xvcmxt3_acclim proc~total_photosynthesis_cost->xvcmxt3_acclim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~total_photosynthesis_cost~~CalledByGraph proc~total_photosynthesis_cost cable_optimise_JV_module::total_photosynthesis_cost proc~optimise_jv cable_optimise_JV_module::optimise_JV proc~optimise_jv->proc~total_photosynthesis_cost proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~optimise_jv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/total_photosynthesis_cost.html"},{"title":"total_photosynthesis – POP","text":"public  function total_photosynthesis(bjv) Uses cable_def_types_mod cable_canopy_module proc~~total_photosynthesis~~UsesGraph proc~total_photosynthesis cable_optimise_JV_module::total_photosynthesis cable_canopy_module cable_canopy_module proc~total_photosynthesis->cable_canopy_module cable_def_types_mod cable_def_types_mod proc~total_photosynthesis->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: bjv Return Value real Calls proc~~total_photosynthesis~~CallsGraph proc~total_photosynthesis cable_optimise_JV_module::total_photosynthesis ej3x ej3x proc~total_photosynthesis->ej3x point2constants point2constants proc~total_photosynthesis->point2constants proc~fabc cable_optimise_JV_module::fabc proc~total_photosynthesis->proc~fabc proc~fabcd cable_optimise_JV_module::fabcd proc~total_photosynthesis->proc~fabcd proc~fam_c3 cable_optimise_JV_module::fAm_c3 proc~total_photosynthesis->proc~fam_c3 proc~fan_c3 cable_optimise_JV_module::fAn_c3 proc~total_photosynthesis->proc~fan_c3 proc~fpq cable_optimise_JV_module::fpq proc~total_photosynthesis->proc~fpq proc~light_inhibition cable_optimise_JV_module::light_inhibition proc~total_photosynthesis->proc~light_inhibition xejmxt3 xejmxt3 proc~total_photosynthesis->xejmxt3 xejmxt3_acclim xejmxt3_acclim proc~total_photosynthesis->xejmxt3_acclim xgmest xgmest proc~total_photosynthesis->xgmest xrdt xrdt proc~total_photosynthesis->xrdt xvcmxt3 xvcmxt3 proc~total_photosynthesis->xvcmxt3 xvcmxt3_acclim xvcmxt3_acclim proc~total_photosynthesis->xvcmxt3_acclim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/total_photosynthesis.html"},{"title":"diff_Ac_Aj – POP","text":"public  function diff_Ac_Aj(bjv) Uses cable_def_types_mod cable_canopy_module proc~~diff_ac_aj~~UsesGraph proc~diff_ac_aj cable_optimise_JV_module::diff_Ac_Aj cable_canopy_module cable_canopy_module proc~diff_ac_aj->cable_canopy_module cable_def_types_mod cable_def_types_mod proc~diff_ac_aj->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: bjv Return Value real Calls proc~~diff_ac_aj~~CallsGraph proc~diff_ac_aj cable_optimise_JV_module::diff_Ac_Aj ej3x ej3x proc~diff_ac_aj->ej3x point2constants point2constants proc~diff_ac_aj->point2constants proc~fabc cable_optimise_JV_module::fabc proc~diff_ac_aj->proc~fabc proc~fabcd cable_optimise_JV_module::fabcd proc~diff_ac_aj->proc~fabcd proc~fam_c3 cable_optimise_JV_module::fAm_c3 proc~diff_ac_aj->proc~fam_c3 proc~fan_c3 cable_optimise_JV_module::fAn_c3 proc~diff_ac_aj->proc~fan_c3 proc~fpq cable_optimise_JV_module::fpq proc~diff_ac_aj->proc~fpq proc~light_inhibition cable_optimise_JV_module::light_inhibition proc~diff_ac_aj->proc~light_inhibition xejmxt3 xejmxt3 proc~diff_ac_aj->xejmxt3 xejmxt3_acclim xejmxt3_acclim proc~diff_ac_aj->xejmxt3_acclim xgmest xgmest proc~diff_ac_aj->xgmest xrdt xrdt proc~diff_ac_aj->xrdt xvcmxt3 xvcmxt3 proc~diff_ac_aj->xvcmxt3 xvcmxt3_acclim xvcmxt3_acclim proc~diff_ac_aj->xvcmxt3_acclim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~diff_ac_aj~~CalledByGraph proc~diff_ac_aj cable_optimise_JV_module::diff_Ac_Aj proc~optimise_jv cable_optimise_JV_module::optimise_JV proc~optimise_jv->proc~diff_ac_aj proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~optimise_jv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/diff_ac_aj.html"},{"title":"golden – POP","text":"public  function golden(ax, bx, cx, func, tol, xmin) Arguments Type Intent Optional Attributes Name real, intent(in) :: ax real, intent(in) :: bx real, intent(in) :: cx public  function func(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real real, intent(in) :: tol real, intent(out) :: xmin Return Value real Called by proc~~golden~~CalledByGraph proc~golden cable_optimise_JV_module::golden proc~optimise_jv cable_optimise_JV_module::optimise_JV proc~optimise_jv->proc~golden proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~optimise_jv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/golden.html"},{"title":"rtbis – POP","text":"public  function rtbis(func, x1, x2, xacc) Uses mo_utils proc~~rtbis~~UsesGraph proc~rtbis cable_optimise_JV_module::rtbis mo_utils mo_utils proc~rtbis->mo_utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name public  function func(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real real, intent(in) :: x1 real, intent(in) :: x2 real, intent(in) :: xacc Return Value real Calls proc~~rtbis~~CallsGraph proc~rtbis cable_optimise_JV_module::rtbis eq eq proc~rtbis->eq ge ge proc~rtbis->ge le le proc~rtbis->le Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rtbis~~CalledByGraph proc~rtbis cable_optimise_JV_module::rtbis proc~optimise_jv cable_optimise_JV_module::optimise_JV proc~optimise_jv->proc~rtbis proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~optimise_jv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/rtbis.html"},{"title":"optimise_JV – POP","text":"public  subroutine optimise_JV(veg, climate, ktauday, bjv, relcostJ) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type(climate_type), intent(in) :: climate integer, intent(in) :: ktauday real, intent(in), DIMENSION(mp) :: bjv real, intent(in), DIMENSION(mp) :: relcostJ Calls proc~~optimise_jv~~CallsGraph proc~optimise_jv cable_optimise_JV_module::optimise_JV a1gs a1gs proc~optimise_jv->a1gs apar_leaf_shade apar_leaf_shade proc~optimise_jv->apar_leaf_shade apar_leaf_sun apar_leaf_sun proc~optimise_jv->apar_leaf_sun cfrd cfrd proc~optimise_jv->cfrd cs_shade cs_shade proc~optimise_jv->cs_shade cs_sun cs_sun proc~optimise_jv->cs_sun d0gs d0gs proc~optimise_jv->d0gs dleaf_shade dleaf_shade proc~optimise_jv->dleaf_shade dleaf_sun dleaf_sun proc~optimise_jv->dleaf_sun ejmax ejmax proc~optimise_jv->ejmax frac4 frac4 proc~optimise_jv->frac4 mtemp mtemp proc~optimise_jv->mtemp mtemp_max20 mtemp_max20 proc~optimise_jv->mtemp_max20 point2constants point2constants proc~optimise_jv->point2constants proc~diff_ac_aj cable_optimise_JV_module::diff_Ac_Aj proc~optimise_jv->proc~diff_ac_aj proc~golden cable_optimise_JV_module::golden proc~optimise_jv->proc~golden proc~rtbis cable_optimise_JV_module::rtbis proc~optimise_jv->proc~rtbis proc~total_photosynthesis_cost cable_optimise_JV_module::total_photosynthesis_cost proc~optimise_jv->proc~total_photosynthesis_cost scalex_shade scalex_shade proc~optimise_jv->scalex_shade scalex_sun scalex_sun proc~optimise_jv->scalex_sun tleaf_shade tleaf_shade proc~optimise_jv->tleaf_shade tleaf_sun tleaf_sun proc~optimise_jv->tleaf_sun vcmax vcmax proc~optimise_jv->vcmax vcmax_shade vcmax_shade proc~optimise_jv->vcmax_shade vcmax_sun vcmax_sun proc~optimise_jv->vcmax_sun vcmaxcc vcmaxcc proc~optimise_jv->vcmaxcc proc~diff_ac_aj->point2constants ej3x ej3x proc~diff_ac_aj->ej3x proc~fabc cable_optimise_JV_module::fabc proc~diff_ac_aj->proc~fabc proc~fabcd cable_optimise_JV_module::fabcd proc~diff_ac_aj->proc~fabcd proc~fam_c3 cable_optimise_JV_module::fAm_c3 proc~diff_ac_aj->proc~fam_c3 proc~fan_c3 cable_optimise_JV_module::fAn_c3 proc~diff_ac_aj->proc~fan_c3 proc~fpq cable_optimise_JV_module::fpq proc~diff_ac_aj->proc~fpq proc~light_inhibition cable_optimise_JV_module::light_inhibition proc~diff_ac_aj->proc~light_inhibition xejmxt3 xejmxt3 proc~diff_ac_aj->xejmxt3 xejmxt3_acclim xejmxt3_acclim proc~diff_ac_aj->xejmxt3_acclim xgmest xgmest proc~diff_ac_aj->xgmest xrdt xrdt proc~diff_ac_aj->xrdt xvcmxt3 xvcmxt3 proc~diff_ac_aj->xvcmxt3 xvcmxt3_acclim xvcmxt3_acclim proc~diff_ac_aj->xvcmxt3_acclim eq eq proc~rtbis->eq ge ge proc~rtbis->ge le le proc~rtbis->le proc~total_photosynthesis_cost->point2constants proc~total_photosynthesis_cost->ej3x proc~total_photosynthesis_cost->proc~fabc proc~total_photosynthesis_cost->proc~fabcd proc~total_photosynthesis_cost->proc~fam_c3 proc~total_photosynthesis_cost->proc~fan_c3 proc~total_photosynthesis_cost->proc~fpq proc~total_photosynthesis_cost->proc~light_inhibition proc~total_photosynthesis_cost->xejmxt3 proc~total_photosynthesis_cost->xejmxt3_acclim proc~total_photosynthesis_cost->xgmest proc~total_photosynthesis_cost->xrdt proc~total_photosynthesis_cost->xvcmxt3 proc~total_photosynthesis_cost->xvcmxt3_acclim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~optimise_jv~~CalledByGraph proc~optimise_jv cable_optimise_JV_module::optimise_JV proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~optimise_jv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/optimise_jv.html"},{"title":"fAn_c3 – POP","text":"public  subroutine fAn_c3(a, b, c, A2) Uses cable_def_types_mod proc~~fan_c3~~UsesGraph proc~fan_c3 cable_optimise_JV_module::fAn_c3 cable_def_types_mod cable_def_types_mod proc~fan_c3->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in) :: a real(kind=r_2), intent(in) :: b real(kind=r_2), intent(in) :: c real(kind=r_2), intent(out) :: A2 Called by proc~~fan_c3~~CalledByGraph proc~fan_c3 cable_optimise_JV_module::fAn_c3 proc~diff_ac_aj cable_optimise_JV_module::diff_Ac_Aj proc~diff_ac_aj->proc~fan_c3 proc~total_an_ac_aj cable_optimise_JV_module::total_An_Ac_Aj proc~total_an_ac_aj->proc~fan_c3 proc~total_photosynthesis cable_optimise_JV_module::total_photosynthesis proc~total_photosynthesis->proc~fan_c3 proc~total_photosynthesis_cost cable_optimise_JV_module::total_photosynthesis_cost proc~total_photosynthesis_cost->proc~fan_c3 proc~optimise_jv cable_optimise_JV_module::optimise_JV proc~optimise_jv->proc~diff_ac_aj proc~optimise_jv->proc~total_photosynthesis_cost proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~optimise_jv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/fan_c3.html"},{"title":"fabc – POP","text":"public  subroutine fabc(Cs, g0, x, gamm, beta, Gammastar, Rd, a, b, c) Uses cable_def_types_mod proc~~fabc~~UsesGraph proc~fabc cable_optimise_JV_module::fabc cable_def_types_mod cable_def_types_mod proc~fabc->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: Cs real, intent(in) :: g0 real, intent(in) :: x real, intent(in) :: gamm real, intent(in) :: beta real, intent(in) :: Gammastar real, intent(in) :: Rd real(kind=r_2), intent(out) :: a real(kind=r_2), intent(out) :: b real(kind=r_2), intent(out) :: c Called by proc~~fabc~~CalledByGraph proc~fabc cable_optimise_JV_module::fabc proc~diff_ac_aj cable_optimise_JV_module::diff_Ac_Aj proc~diff_ac_aj->proc~fabc proc~total_an_ac_aj cable_optimise_JV_module::total_An_Ac_Aj proc~total_an_ac_aj->proc~fabc proc~total_photosynthesis cable_optimise_JV_module::total_photosynthesis proc~total_photosynthesis->proc~fabc proc~total_photosynthesis_cost cable_optimise_JV_module::total_photosynthesis_cost proc~total_photosynthesis_cost->proc~fabc proc~optimise_jv cable_optimise_JV_module::optimise_JV proc~optimise_jv->proc~diff_ac_aj proc~optimise_jv->proc~total_photosynthesis_cost proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~optimise_jv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/fabc.html"},{"title":"fabcd – POP","text":"public  subroutine fabcd(Cs, g0, x, gamm, beta, Gammastar, Rd, gm, a, b, c1, d) Uses cable_def_types_mod proc~~fabcd~~UsesGraph proc~fabcd cable_optimise_JV_module::fabcd cable_def_types_mod cable_def_types_mod proc~fabcd->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: Cs real, intent(in) :: g0 real, intent(in) :: x real, intent(in) :: gamm real, intent(in) :: beta real, intent(in) :: Gammastar real, intent(in) :: Rd real, intent(in) :: gm real(kind=r_2), intent(out) :: a real(kind=r_2), intent(out) :: b real(kind=r_2), intent(out) :: c1 real(kind=r_2), intent(out) :: d Called by proc~~fabcd~~CalledByGraph proc~fabcd cable_optimise_JV_module::fabcd proc~diff_ac_aj cable_optimise_JV_module::diff_Ac_Aj proc~diff_ac_aj->proc~fabcd proc~total_an_ac_aj cable_optimise_JV_module::total_An_Ac_Aj proc~total_an_ac_aj->proc~fabcd proc~total_photosynthesis cable_optimise_JV_module::total_photosynthesis proc~total_photosynthesis->proc~fabcd proc~total_photosynthesis_cost cable_optimise_JV_module::total_photosynthesis_cost proc~total_photosynthesis_cost->proc~fabcd proc~optimise_jv cable_optimise_JV_module::optimise_JV proc~optimise_jv->proc~diff_ac_aj proc~optimise_jv->proc~total_photosynthesis_cost proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~optimise_jv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/fabcd.html"},{"title":"fpq – POP","text":"public  subroutine fpq(a, b, c, d, p, q) Uses cable_def_types_mod proc~~fpq~~UsesGraph proc~fpq cable_optimise_JV_module::fpq cable_def_types_mod cable_def_types_mod proc~fpq->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in) :: a real(kind=r_2), intent(in) :: b real(kind=r_2), intent(in) :: c real(kind=r_2), intent(in) :: d real(kind=r_2), intent(out) :: p real(kind=r_2), intent(out) :: q Called by proc~~fpq~~CalledByGraph proc~fpq cable_optimise_JV_module::fpq proc~diff_ac_aj cable_optimise_JV_module::diff_Ac_Aj proc~diff_ac_aj->proc~fpq proc~total_an_ac_aj cable_optimise_JV_module::total_An_Ac_Aj proc~total_an_ac_aj->proc~fpq proc~total_photosynthesis cable_optimise_JV_module::total_photosynthesis proc~total_photosynthesis->proc~fpq proc~total_photosynthesis_cost cable_optimise_JV_module::total_photosynthesis_cost proc~total_photosynthesis_cost->proc~fpq proc~optimise_jv cable_optimise_JV_module::optimise_JV proc~optimise_jv->proc~diff_ac_aj proc~optimise_jv->proc~total_photosynthesis_cost proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~optimise_jv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/fpq.html"},{"title":"fAm_c3 – POP","text":"public  subroutine fAm_c3(a, b, c1, d, p, q, Am) Uses cable_def_types_mod mo_constants proc~~fam_c3~~UsesGraph proc~fam_c3 cable_optimise_JV_module::fAm_c3 cable_def_types_mod cable_def_types_mod proc~fam_c3->cable_def_types_mod mo_constants mo_constants proc~fam_c3->mo_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in) :: a real(kind=r_2), intent(in) :: b real(kind=r_2), intent(in) :: c1 real(kind=r_2), intent(in) :: d real(kind=r_2), intent(in) :: p real(kind=r_2), intent(in) :: q real(kind=r_2), intent(out) :: Am Called by proc~~fam_c3~~CalledByGraph proc~fam_c3 cable_optimise_JV_module::fAm_c3 proc~diff_ac_aj cable_optimise_JV_module::diff_Ac_Aj proc~diff_ac_aj->proc~fam_c3 proc~total_an_ac_aj cable_optimise_JV_module::total_An_Ac_Aj proc~total_an_ac_aj->proc~fam_c3 proc~total_photosynthesis cable_optimise_JV_module::total_photosynthesis proc~total_photosynthesis->proc~fam_c3 proc~total_photosynthesis_cost cable_optimise_JV_module::total_photosynthesis_cost proc~total_photosynthesis_cost->proc~fam_c3 proc~optimise_jv cable_optimise_JV_module::optimise_JV proc~optimise_jv->proc~diff_ac_aj proc~optimise_jv->proc~total_photosynthesis_cost proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~optimise_jv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/fam_c3.html"},{"title":"total_An_Ac_Aj – POP","text":"public  subroutine total_An_Ac_Aj(bjv, total_An, total_Ac, total_Aj) Uses cable_def_types_mod cable_canopy_module proc~~total_an_ac_aj~~UsesGraph proc~total_an_ac_aj cable_optimise_JV_module::total_An_Ac_Aj cable_canopy_module cable_canopy_module proc~total_an_ac_aj->cable_canopy_module cable_def_types_mod cable_def_types_mod proc~total_an_ac_aj->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: bjv real, intent(out) :: total_An real, intent(out) :: total_Ac real, intent(out) :: total_Aj Calls proc~~total_an_ac_aj~~CallsGraph proc~total_an_ac_aj cable_optimise_JV_module::total_An_Ac_Aj ej3x ej3x proc~total_an_ac_aj->ej3x point2constants point2constants proc~total_an_ac_aj->point2constants proc~fabc cable_optimise_JV_module::fabc proc~total_an_ac_aj->proc~fabc proc~fabcd cable_optimise_JV_module::fabcd proc~total_an_ac_aj->proc~fabcd proc~fam_c3 cable_optimise_JV_module::fAm_c3 proc~total_an_ac_aj->proc~fam_c3 proc~fan_c3 cable_optimise_JV_module::fAn_c3 proc~total_an_ac_aj->proc~fan_c3 proc~fpq cable_optimise_JV_module::fpq proc~total_an_ac_aj->proc~fpq proc~light_inhibition cable_optimise_JV_module::light_inhibition proc~total_an_ac_aj->proc~light_inhibition xejmxt3 xejmxt3 proc~total_an_ac_aj->xejmxt3 xejmxt3_acclim xejmxt3_acclim proc~total_an_ac_aj->xejmxt3_acclim xgmest xgmest proc~total_an_ac_aj->xgmest xrdt xrdt proc~total_an_ac_aj->xrdt xvcmxt3 xvcmxt3 proc~total_an_ac_aj->xvcmxt3 xvcmxt3_acclim xvcmxt3_acclim proc~total_an_ac_aj->xvcmxt3_acclim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/total_an_ac_aj.html"},{"title":"cable_phenology_clim – POP","text":"public  subroutine cable_phenology_clim(veg, climate, phen) Uses casavariable casaparm phenvariable mo_utils casadimension proc~~cable_phenology_clim~~UsesGraph proc~cable_phenology_clim cable_phenology_module::cable_phenology_clim mo_utils mo_utils proc~cable_phenology_clim->mo_utils module~casadimension casadimension proc~cable_phenology_clim->module~casadimension module~casaparm casaparm proc~cable_phenology_clim->module~casaparm module~casavariable casavariable proc~cable_phenology_clim->module~casavariable module~phenvariable phenvariable proc~cable_phenology_clim->module~phenvariable cable_def_types_mod cable_def_types_mod module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->module~casadimension module~phenvariable->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(in) :: veg type(climate_type), intent(in) :: climate type( phen_variable ), intent(inout) :: phen Calls proc~~cable_phenology_clim~~CallsGraph proc~cable_phenology_clim cable_phenology_module::cable_phenology_clim aphen aphen proc~cable_phenology_clim->aphen chilldays chilldays proc~cable_phenology_clim->chilldays doyphase doyphase proc~cable_phenology_clim->doyphase eq eq proc~cable_phenology_clim->eq gdd5 gdd5 proc~cable_phenology_clim->gdd5 ge ge proc~cable_phenology_clim->ge gmd gmd proc~cable_phenology_clim->gmd iveg iveg proc~cable_phenology_clim->iveg patch patch proc~cable_phenology_clim->patch phase phase proc~cable_phenology_clim->phase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cable_phenology_clim~~CalledByGraph proc~cable_phenology_clim cable_phenology_module::cable_phenology_clim proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~cable_phenology_clim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/cable_phenology_clim.html"},{"title":"zero_casa_dump – POP","text":"public  subroutine zero_casa_dump(casamet, phen) Uses cable_common_module casavariable cable_def_types_mod phenvariable proc~~zero_casa_dump~~UsesGraph proc~zero_casa_dump casa_inout::zero_casa_dump cable_common_module cable_common_module proc~zero_casa_dump->cable_common_module cable_def_types_mod cable_def_types_mod proc~zero_casa_dump->cable_def_types_mod module~casavariable casavariable proc~zero_casa_dump->module~casavariable module~phenvariable phenvariable proc~zero_casa_dump->module~phenvariable module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~casadimension casadimension module~phenvariable->module~casadimension module~casadimension->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( casa_met ), intent(inout) :: casamet type( phen_variable ), intent(inout) :: phen Called by proc~~zero_casa_dump~~CalledByGraph proc~zero_casa_dump casa_inout::zero_casa_dump proc~casa_init casa_inout::casa_init proc~casa_init->proc~zero_casa_dump Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/zero_casa_dump.html"},{"title":"casa_readbiome – POP","text":"public  subroutine casa_readbiome(veg, soil, casabiome, casapool, casaflux, casamet, phen) Uses casavariable casaparm phenvariable cable_def_types_mod cable_common_module casadimension proc~~casa_readbiome~~UsesGraph proc~casa_readbiome casa_inout::casa_readbiome cable_common_module cable_common_module proc~casa_readbiome->cable_common_module cable_def_types_mod cable_def_types_mod proc~casa_readbiome->cable_def_types_mod module~casadimension casadimension proc~casa_readbiome->module~casadimension module~casaparm casaparm proc~casa_readbiome->module~casaparm module~casavariable casavariable proc~casa_readbiome->module~casavariable module~phenvariable phenvariable proc~casa_readbiome->module~phenvariable module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~phenvariable->module~casadimension Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. vh_js !!\nvh_js !!\nvh_js Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( phen_variable ), intent(inout) :: phen Calls proc~~casa_readbiome~~CallsGraph proc~casa_readbiome casa_inout::casa_readbiome clitter clitter proc~casa_readbiome->clitter cplant cplant proc~casa_readbiome->cplant csoil csoil proc~casa_readbiome->csoil fracligninplant fracligninplant proc~casa_readbiome->fracligninplant fracnpptop fracnpptop proc~casa_readbiome->fracnpptop ftransnptol ftransnptol proc~casa_readbiome->ftransnptol ftranspptol ftranspptol proc~casa_readbiome->ftranspptol glaimax glaimax proc~casa_readbiome->glaimax glaimin glaimin proc~casa_readbiome->glaimin isorder isorder proc~casa_readbiome->isorder iveg iveg proc~casa_readbiome->iveg iveg2 iveg2 proc~casa_readbiome->iveg2 ivt2 ivt2 proc~casa_readbiome->ivt2 kminn kminn proc~casa_readbiome->kminn kmlabp kmlabp proc~casa_readbiome->kmlabp kroot kroot proc~casa_readbiome->kroot krootlen krootlen proc~casa_readbiome->krootlen kuplabp kuplabp proc~casa_readbiome->kuplabp kuptake kuptake proc~casa_readbiome->kuptake nlitter nlitter proc~casa_readbiome->nlitter nsoil nsoil proc~casa_readbiome->nsoil plitter plitter proc~casa_readbiome->plitter psoillab psoillab proc~casa_readbiome->psoillab psorbmax psorbmax proc~casa_readbiome->psorbmax rationcplant rationcplant proc~casa_readbiome->rationcplant rationcplantmax rationcplantmax proc~casa_readbiome->rationcplantmax rationcplantmin rationcplantmin proc~casa_readbiome->rationcplantmin rationcsoil rationcsoil proc~casa_readbiome->rationcsoil rationcsoilmax rationcsoilmax proc~casa_readbiome->rationcsoilmax rationpplantmin rationpplantmin proc~casa_readbiome->rationpplantmin ratiopcplantmin ratiopcplantmin proc~casa_readbiome->ratiopcplantmin rmplant rmplant proc~casa_readbiome->rmplant rootdepth rootdepth proc~casa_readbiome->rootdepth sla sla proc~casa_readbiome->sla tkshed tkshed proc~casa_readbiome->tkshed xkleafcoldexp xkleafcoldexp proc~casa_readbiome->xkleafcoldexp xkleafdryexp xkleafdryexp proc~casa_readbiome->xkleafdryexp zse zse proc~casa_readbiome->zse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_readbiome.html"},{"title":"casa_readphen – POP","text":"public  subroutine casa_readphen(veg, casamet, phen) Uses casavariable casaparm phenvariable cable_def_types_mod casadimension proc~~casa_readphen~~UsesGraph proc~casa_readphen casa_inout::casa_readphen cable_def_types_mod cable_def_types_mod proc~casa_readphen->cable_def_types_mod module~casadimension casadimension proc~casa_readphen->module~casadimension module~casaparm casaparm proc~casa_readphen->module~casaparm module~casavariable casavariable proc~casa_readphen->module~casavariable module~phenvariable phenvariable proc~casa_readphen->module~phenvariable module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~phenvariable->module~casadimension Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(in) :: veg type( casa_met ), intent(in) :: casamet type( phen_variable ), intent(inout) :: phen Calls proc~~casa_readphen~~CallsGraph proc~casa_readphen casa_inout::casa_readphen doyphase doyphase proc~casa_readphen->doyphase iveg iveg proc~casa_readphen->iveg lat lat proc~casa_readphen->lat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_readphen.html"},{"title":"casa_init – POP","text":"public  subroutine casa_init(casabiome, casamet, casaflux, casapool, casabal, phen) Uses casavariable casaparm phenvariable cable_io_vars_module cable_def_types_mod cable_common_module casadimension proc~~casa_init~~UsesGraph proc~casa_init casa_inout::casa_init cable_common_module cable_common_module proc~casa_init->cable_common_module cable_def_types_mod cable_def_types_mod proc~casa_init->cable_def_types_mod cable_io_vars_module cable_io_vars_module proc~casa_init->cable_io_vars_module module~casadimension casadimension proc~casa_init->module~casadimension module~casaparm casaparm proc~casa_init->module~casaparm module~casavariable casavariable proc~casa_init->module~casavariable module~phenvariable phenvariable proc~casa_init->module~phenvariable module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~phenvariable->module~casadimension Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. for first time reading file *_1220.csv  (BP may2010) SUBROUTINE casa_init(mst,casapool,casabal)\n end addition (BP may2010) Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(inout) :: casabiome type( casa_met ), intent(inout) :: casamet type( casa_flux ), intent(inout) :: casaflux type( casa_pool ), intent(inout) :: casapool type( casa_balance ), intent(inout) :: casabal type( phen_variable ), intent(inout) :: phen Calls proc~~casa_init~~CallsGraph proc~casa_init casa_inout::casa_init doyphase doyphase proc~casa_init->doyphase patch patch proc~casa_init->patch proc~read_casa_restart_nc casa_inout::read_casa_restart_nc proc~casa_init->proc~read_casa_restart_nc proc~zero_casa_dump casa_inout::zero_casa_dump proc~casa_init->proc~zero_casa_dump interface~read_netcdf_casa_var casavariable::read_netcdf_casa_var proc~read_casa_restart_nc->interface~read_netcdf_casa_var proc~read_netcdf_phen_var phenvariable::read_netcdf_phen_var proc~read_casa_restart_nc->proc~read_netcdf_phen_var proc~read_netcdf_casabal casavariable::read_netcdf_casabal interface~read_netcdf_casa_var->proc~read_netcdf_casabal proc~read_netcdf_casabiome casavariable::read_netcdf_casabiome interface~read_netcdf_casa_var->proc~read_netcdf_casabiome proc~read_netcdf_casaflux casavariable::read_netcdf_casaflux interface~read_netcdf_casa_var->proc~read_netcdf_casaflux proc~read_netcdf_casamet casavariable::read_netcdf_casamet interface~read_netcdf_casa_var->proc~read_netcdf_casamet proc~read_netcdf_casapool casavariable::read_netcdf_casapool interface~read_netcdf_casa_var->proc~read_netcdf_casapool nc_err nc_err proc~read_netcdf_phen_var->nc_err nf90_close nf90_close proc~read_netcdf_phen_var->nf90_close nf90_get_var nf90_get_var proc~read_netcdf_phen_var->nf90_get_var nf90_inq_varid nf90_inq_varid proc~read_netcdf_phen_var->nf90_inq_varid nf90_open nf90_open proc~read_netcdf_phen_var->nf90_open proc~read_netcdf_casabal->nc_err proc~read_netcdf_casabal->nf90_close proc~read_netcdf_casabal->nf90_get_var proc~read_netcdf_casabal->nf90_inq_varid proc~read_netcdf_casabal->nf90_open proc~read_netcdf_casabiome->nc_err proc~read_netcdf_casabiome->nf90_close proc~read_netcdf_casabiome->nf90_get_var proc~read_netcdf_casabiome->nf90_inq_varid proc~read_netcdf_casabiome->nf90_open proc~read_netcdf_casaflux->nc_err proc~read_netcdf_casaflux->nf90_close proc~read_netcdf_casaflux->nf90_get_var proc~read_netcdf_casaflux->nf90_inq_varid proc~read_netcdf_casaflux->nf90_open proc~read_netcdf_casamet->nc_err proc~read_netcdf_casamet->nf90_close proc~read_netcdf_casamet->nf90_get_var proc~read_netcdf_casamet->nf90_inq_varid proc~read_netcdf_casamet->nf90_open proc~read_netcdf_casapool->nc_err proc~read_netcdf_casapool->nf90_close proc~read_netcdf_casapool->nf90_get_var proc~read_netcdf_casapool->nf90_inq_varid proc~read_netcdf_casapool->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_init.html"},{"title":"casa_poolout – POP","text":"public  subroutine casa_poolout(ktau, veg, soil, casabiome, casapool, casaflux, casamet, casabal, phen) Uses casavariable casaparm phenvariable cable_def_types_mod cable_common_module casadimension proc~~casa_poolout~~UsesGraph proc~casa_poolout casa_inout::casa_poolout cable_common_module cable_common_module proc~casa_poolout->cable_common_module cable_def_types_mod cable_def_types_mod proc~casa_poolout->cable_def_types_mod module~casadimension casadimension proc~casa_poolout->module~casadimension module~casaparm casaparm proc~casa_poolout->module~casaparm module~casavariable casavariable proc~casa_poolout->module~casavariable module~phenvariable phenvariable proc~casa_poolout->module~phenvariable module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~phenvariable->module~casadimension Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. vh_js  !! Arguments Type Intent Optional Attributes Name integer, intent(in) :: ktau type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( casa_balance ), intent(inout) :: casabal type( phen_variable ), intent(inout) :: phen Calls proc~~casa_poolout~~CallsGraph proc~casa_poolout casa_inout::casa_poolout 100 100 proc~casa_poolout->100 2 2 proc~casa_poolout->2 5 5 proc~casa_poolout->5 aphen aphen proc~casa_poolout->aphen areacell areacell proc~casa_poolout->areacell clabile clabile proc~casa_poolout->clabile clitter clitter proc~casa_poolout->clitter cplant cplant proc~casa_poolout->cplant csoil csoil proc~casa_poolout->csoil doyphase doyphase proc~casa_poolout->doyphase frac_sapwood frac_sapwood proc~casa_poolout->frac_sapwood glai glai proc~casa_poolout->glai isoilm isoilm proc~casa_poolout->isoilm isorder isorder proc~casa_poolout->isorder iveg iveg proc~casa_poolout->iveg iveg2 iveg2 proc~casa_poolout->iveg2 kmlabp kmlabp proc~casa_poolout->kmlabp lat lat proc~casa_poolout->lat lon lon proc~casa_poolout->lon nlitter nlitter proc~casa_poolout->nlitter nplant nplant proc~casa_poolout->nplant nsoil nsoil proc~casa_poolout->nsoil nsoilmin nsoilmin proc~casa_poolout->nsoilmin phase phase proc~casa_poolout->phase plitter plitter proc~casa_poolout->plitter pplant pplant proc~casa_poolout->pplant psoil psoil proc~casa_poolout->psoil psoillab psoillab proc~casa_poolout->psoillab psoilocc psoilocc proc~casa_poolout->psoilocc psoilsorb psoilsorb proc~casa_poolout->psoilsorb psorbmax psorbmax proc~casa_poolout->psorbmax rationclitter rationclitter proc~casa_poolout->rationclitter rationcplant rationcplant proc~casa_poolout->rationcplant rationcsoil rationcsoil proc~casa_poolout->rationcsoil rationplitter rationplitter proc~casa_poolout->rationplitter rationpplant rationpplant proc~casa_poolout->rationpplant sapwood_area sapwood_area proc~casa_poolout->sapwood_area sla sla proc~casa_poolout->sla sumcbal sumcbal proc~casa_poolout->sumcbal sumnbal sumnbal proc~casa_poolout->sumnbal sumpbal sumpbal proc~casa_poolout->sumpbal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_poolout.html"},{"title":"casa_fluxout – POP","text":"public  subroutine casa_fluxout(myear, veg, soil, casabal, casamet) Uses casavariable casaparm phenvariable cable_def_types_mod casadimension proc~~casa_fluxout~~UsesGraph proc~casa_fluxout casa_inout::casa_fluxout cable_def_types_mod cable_def_types_mod proc~casa_fluxout->cable_def_types_mod module~casadimension casadimension proc~casa_fluxout->module~casadimension module~casaparm casaparm proc~casa_fluxout->module~casaparm module~casavariable casavariable proc~casa_fluxout->module~casavariable module~phenvariable phenvariable proc~casa_fluxout->module~phenvariable module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~phenvariable->module~casadimension Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: myear type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_balance ), intent(inout) :: casabal type( casa_met ), intent(inout) :: casamet Calls proc~~casa_fluxout~~CallsGraph proc~casa_fluxout casa_inout::casa_fluxout areacell areacell proc~casa_fluxout->areacell fcgppyear fcgppyear proc~casa_fluxout->fcgppyear fcneeyear fcneeyear proc~casa_fluxout->fcneeyear fcnppyear fcnppyear proc~casa_fluxout->fcnppyear fcrgrowyear fcrgrowyear proc~casa_fluxout->fcrgrowyear fcrmleafyear fcrmleafyear proc~casa_fluxout->fcrmleafyear fcrmrootyear fcrmrootyear proc~casa_fluxout->fcrmrootyear fcrmwoodyear fcrmwoodyear proc~casa_fluxout->fcrmwoodyear fcrsyear fcrsyear proc~casa_fluxout->fcrsyear fndepyear fndepyear proc~casa_fluxout->fndepyear fnfixyear fnfixyear proc~casa_fluxout->fnfixyear fnleachyear fnleachyear proc~casa_fluxout->fnleachyear fnlossyear fnlossyear proc~casa_fluxout->fnlossyear fnsnetyear fnsnetyear proc~casa_fluxout->fnsnetyear fnupyear fnupyear proc~casa_fluxout->fnupyear fpdustyear fpdustyear proc~casa_fluxout->fpdustyear fpleachyear fpleachyear proc~casa_fluxout->fpleachyear fplossyear fplossyear proc~casa_fluxout->fplossyear fpsnetyear fpsnetyear proc~casa_fluxout->fpsnetyear fpupyear fpupyear proc~casa_fluxout->fpupyear fpweayear fpweayear proc~casa_fluxout->fpweayear isoilm isoilm proc~casa_fluxout->isoilm isorder isorder proc~casa_fluxout->isorder iveg iveg proc~casa_fluxout->iveg lat lat proc~casa_fluxout->lat lon lon proc~casa_fluxout->lon Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_fluxout~~CalledByGraph proc~casa_fluxout casa_inout::casa_fluxout proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~casa_fluxout Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_fluxout.html"},{"title":"casa_cnpflux – POP","text":"public  subroutine casa_cnpflux(casaflux, casapool, casabal, zeroflux) Uses casadimension cable_def_types_mod casavariable casaparm proc~~casa_cnpflux~~UsesGraph proc~casa_cnpflux casa_inout::casa_cnpflux cable_def_types_mod cable_def_types_mod proc~casa_cnpflux->cable_def_types_mod module~casadimension casadimension proc~casa_cnpflux->module~casadimension module~casaparm casaparm proc~casa_cnpflux->module~casaparm module~casavariable casavariable proc~casa_cnpflux->module~casavariable module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(inout) :: casaflux type( casa_pool ), intent(in) :: casapool type( casa_balance ), intent(inout) :: casabal logical, intent(in) :: zeroflux Calls proc~~casa_cnpflux~~CallsGraph proc~casa_cnpflux casa_inout::casa_cnpflux crmplant crmplant proc~casa_cnpflux->crmplant fcrmleafyear fcrmleafyear proc~casa_cnpflux->fcrmleafyear fcrmrootyear fcrmrootyear proc~casa_cnpflux->fcrmrootyear fcrmwoodyear fcrmwoodyear proc~casa_cnpflux->fcrmwoodyear Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_cnpflux~~CalledByGraph proc~casa_cnpflux casa_inout::casa_cnpflux proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_cnpflux proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_cnpflux.html"},{"title":"biogeochem – POP","text":"public  subroutine biogeochem(idoy, LALLOC, veg, soil, casabiome, casapool, casaflux, casamet, casabal, phen, POP, climate, xnplimit, xkNlimiting, xklitter, xksoil, xkleaf, xkleafcold, xkleafdry, cleaf2met, cleaf2str, croot2met, croot2str, cwood2cwd, nleaf2met, nleaf2str, nroot2met, nroot2str, nwood2cwd, pleaf2met, pleaf2str, proot2met, proot2str, pwood2cwd) Uses casadimension POP_Types cable_def_types_mod casa_cnp_module proc~~biogeochem~~UsesGraph proc~biogeochem casa_inout::biogeochem cable_def_types_mod cable_def_types_mod proc~biogeochem->cable_def_types_mod module~casa_cnp_module casa_cnp_module proc~biogeochem->module~casa_cnp_module module~casadimension casadimension proc~biogeochem->module~casadimension module~pop_types POP_Types proc~biogeochem->module~pop_types module~casa_cnp_module->cable_def_types_mod module~casa_cnp_module->module~casadimension cable_IO_vars_module cable_IO_vars_module module~casa_cnp_module->cable_IO_vars_module cable_common_module cable_common_module module~casa_cnp_module->cable_common_module module~casaparm casaparm module~casa_cnp_module->module~casaparm module~casavariable casavariable module~casa_cnp_module->module~casavariable module~phenvariable phenvariable module~casa_cnp_module->module~phenvariable module~casadimension->cable_def_types_mod module~pop_constants POP_Constants module~pop_types->module~pop_constants module~typedef TypeDef module~pop_types->module~typedef module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~phenvariable->module~casadimension module~pop_constants->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. vh_js !! Arguments Type Intent Optional Attributes Name integer, intent(in) :: idoy integer, intent(in) :: LALLOC type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( casa_balance ), intent(inout) :: casabal type( phen_variable ), intent(inout) :: phen type( POP_TYPE ), intent(in) :: POP type(climate_TYPE), intent(in) :: climate real(kind=r_2), intent(out), dimension(mp) :: xnplimit real(kind=r_2), intent(out), dimension(mp) :: xkNlimiting real(kind=r_2), intent(out), dimension(mp) :: xklitter real(kind=r_2), intent(out), dimension(mp) :: xksoil real(kind=r_2), intent(out), dimension(mp) :: xkleaf real(kind=r_2), intent(out), dimension(mp) :: xkleafcold real(kind=r_2), intent(out), dimension(mp) :: xkleafdry real(kind=r_2), intent(out), dimension(mp) :: cleaf2met real(kind=r_2), intent(out), dimension(mp) :: cleaf2str real(kind=r_2), intent(out), dimension(mp) :: croot2met real(kind=r_2), intent(out), dimension(mp) :: croot2str real(kind=r_2), intent(out), dimension(mp) :: cwood2cwd real(kind=r_2), intent(out), dimension(mp) :: nleaf2met real(kind=r_2), intent(out), dimension(mp) :: nleaf2str real(kind=r_2), intent(out), dimension(mp) :: nroot2met real(kind=r_2), intent(out), dimension(mp) :: nroot2str real(kind=r_2), intent(out), dimension(mp) :: nwood2cwd real(kind=r_2), intent(out), dimension(mp) :: pleaf2met real(kind=r_2), intent(out), dimension(mp) :: pleaf2str real(kind=r_2), intent(out), dimension(mp) :: proot2met real(kind=r_2), intent(out), dimension(mp) :: proot2str real(kind=r_2), intent(out), dimension(mp) :: pwood2cwd Calls proc~~biogeochem~~CallsGraph proc~biogeochem casa_inout::biogeochem cplant_turnover cplant_turnover proc~biogeochem->cplant_turnover iwood iwood proc~biogeochem->iwood klitter klitter proc~biogeochem->klitter klitter_fire klitter_fire proc~biogeochem->klitter_fire kplant kplant proc~biogeochem->kplant kplant_fire kplant_fire proc~biogeochem->kplant_fire pop_grid pop_grid proc~biogeochem->pop_grid proc~avgsoil casa_cnp_module::avgsoil proc~biogeochem->proc~avgsoil proc~casa_allocation casa_cnp_module::casa_allocation proc~biogeochem->proc~casa_allocation proc~casa_cnpbal casa_cnp_module::casa_cnpbal proc~biogeochem->proc~casa_cnpbal proc~casa_cnpcycle casa_cnp_module::casa_cnpcycle proc~biogeochem->proc~casa_cnpcycle proc~casa_cnpflux casa_inout::casa_cnpflux proc~biogeochem->proc~casa_cnpflux proc~casa_coeffplant casa_cnp_module::casa_coeffplant proc~biogeochem->proc~casa_coeffplant proc~casa_coeffsoil casa_cnp_module::casa_coeffsoil proc~biogeochem->proc~casa_coeffsoil proc~casa_delplant casa_cnp_module::casa_delplant proc~biogeochem->proc~casa_delplant proc~casa_delsoil casa_cnp_module::casa_delsoil proc~biogeochem->proc~casa_delsoil proc~casa_ndummy casa_cnp_module::casa_ndummy proc~biogeochem->proc~casa_ndummy proc~casa_nuptake casa_cnp_module::casa_nuptake proc~biogeochem->proc~casa_nuptake proc~casa_pdummy casa_cnp_module::casa_pdummy proc~biogeochem->proc~casa_pdummy proc~casa_puptake casa_cnp_module::casa_puptake proc~biogeochem->proc~casa_puptake proc~casa_rplant casa_cnp_module::casa_rplant proc~biogeochem->proc~casa_rplant proc~casa_xkn casa_cnp_module::casa_xkN proc~biogeochem->proc~casa_xkn proc~casa_xnp casa_cnp_module::casa_xnp proc~biogeochem->proc~casa_xnp proc~casa_xrateplant casa_cnp_module::casa_xrateplant proc~biogeochem->proc~casa_xrateplant proc~casa_xratesoil casa_cnp_module::casa_xratesoil proc~biogeochem->proc~casa_xratesoil proc~phenology casa_cnp_module::phenology proc~biogeochem->proc~phenology btran btran proc~avgsoil->btran moist moist proc~avgsoil->moist moistavg moistavg proc~avgsoil->moistavg tsoilavg tsoilavg proc~avgsoil->tsoilavg proc~casa_allocation->btran cplant cplant proc~casa_allocation->cplant crmplant crmplant proc~casa_allocation->crmplant fraccalloc fraccalloc proc~casa_allocation->fraccalloc fracnpptop fracnpptop proc~casa_allocation->fracnpptop glai glai proc~casa_allocation->glai glaimax glaimax proc~casa_allocation->glaimax glaimin glaimin proc~casa_allocation->glaimin iveg iveg proc~casa_allocation->iveg kplant_tot kplant_tot proc~casa_allocation->kplant_tot la_to_sa la_to_sa proc~casa_allocation->la_to_sa proc~casa_allocation->moistavg proc~casa_wolf casa_cnp_module::casa_wolf proc~casa_allocation->proc~casa_wolf sfc sfc proc~casa_allocation->sfc sla sla proc~casa_allocation->sla swilt swilt proc~casa_allocation->swilt proc~casa_allocation->tsoilavg proc~casa_cnpbal->klitter proc~casa_cnpbal->klitter_fire proc~casa_cnpbal->kplant proc~casa_cnpbal->kplant_fire clabile clabile proc~casa_cnpbal->clabile clabilelast clabilelast proc~casa_cnpbal->clabilelast clitterlast clitterlast proc~casa_cnpbal->clitterlast cnpp cnpp proc~casa_cnpbal->cnpp proc~casa_cnpbal->cplant cplantlast cplantlast proc~casa_cnpbal->cplantlast crsoil crsoil proc~casa_cnpbal->crsoil fharvest fharvest proc~casa_cnpbal->fharvest fluxctoco2_plant_fire fluxctoco2_plant_fire proc~casa_cnpbal->fluxctoco2_plant_fire fluxctolitter fluxctolitter proc~casa_cnpbal->fluxctolitter fluxfromptoco2 fluxfromptoco2 proc~casa_cnpbal->fluxfromptoco2 fromptol_fire fromptol_fire proc~casa_cnpbal->fromptol_fire klitter_tot klitter_tot proc~casa_cnpbal->klitter_tot proc~casa_cnpbal->kplant_tot nmindep nmindep proc~casa_cnpbal->nmindep nminfix nminfix proc~casa_cnpbal->nminfix nminleach nminleach proc~casa_cnpbal->nminleach nminloss nminloss proc~casa_cnpbal->nminloss nminuptake nminuptake proc~casa_cnpbal->nminuptake nsoilmin nsoilmin proc~casa_cnpbal->nsoilmin nsoilminlast nsoilminlast proc~casa_cnpbal->nsoilminlast nupland nupland proc~casa_cnpbal->nupland pdep pdep proc~casa_cnpbal->pdep plabuptake plabuptake proc~casa_cnpbal->plabuptake pleach pleach proc~casa_cnpbal->pleach ploss ploss proc~casa_cnpbal->ploss psoillab psoillab proc~casa_cnpbal->psoillab psoillablast psoillablast proc~casa_cnpbal->psoillablast psoilocc psoilocc proc~casa_cnpbal->psoilocc psoilocclast psoilocclast proc~casa_cnpbal->psoilocclast psoilsorb psoilsorb proc~casa_cnpbal->psoilsorb psoilsorblast psoilsorblast proc~casa_cnpbal->psoilsorblast pupland pupland proc~casa_cnpbal->pupland pwea pwea proc~casa_cnpbal->pwea proc~casa_cnpcycle->clabile clitter clitter proc~casa_cnpcycle->clitter proc~casa_cnpcycle->cplant csoil csoil proc~casa_cnpcycle->csoil dclabiledt dclabiledt proc~casa_cnpcycle->dclabiledt dclitterdt dclitterdt proc~casa_cnpcycle->dclitterdt dcplantdt dcplantdt proc~casa_cnpcycle->dcplantdt dcsoildt dcsoildt proc~casa_cnpcycle->dcsoildt dnlitterdt dnlitterdt proc~casa_cnpcycle->dnlitterdt dnplantdt dnplantdt proc~casa_cnpcycle->dnplantdt dnsoildt dnsoildt proc~casa_cnpcycle->dnsoildt dnsoilmindt dnsoilmindt proc~casa_cnpcycle->dnsoilmindt dplitterdt dplitterdt proc~casa_cnpcycle->dplitterdt dpplantdt dpplantdt proc~casa_cnpcycle->dpplantdt dpsoildt dpsoildt proc~casa_cnpcycle->dpsoildt dpsoillabdt dpsoillabdt proc~casa_cnpcycle->dpsoillabdt dpsoiloccdt dpsoiloccdt proc~casa_cnpcycle->dpsoiloccdt proc~casa_cnpcycle->glai proc~casa_cnpcycle->glaimax proc~casa_cnpcycle->glaimin proc~casa_cnpcycle->iveg iveg2 iveg2 proc~casa_cnpcycle->iveg2 kmlabp kmlabp proc~casa_cnpcycle->kmlabp lat lat proc~casa_cnpcycle->lat lon lon proc~casa_cnpcycle->lon nlitter nlitter proc~casa_cnpcycle->nlitter nplant nplant proc~casa_cnpcycle->nplant nsoil nsoil proc~casa_cnpcycle->nsoil proc~casa_cnpcycle->nsoilmin plitter plitter proc~casa_cnpcycle->plitter pplant pplant proc~casa_cnpcycle->pplant proc~casa_poolzero casa_cnp_module::casa_poolzero proc~casa_cnpcycle->proc~casa_poolzero psoil psoil proc~casa_cnpcycle->psoil proc~casa_cnpcycle->psoillab proc~casa_cnpcycle->psoilocc psorbmax psorbmax proc~casa_cnpcycle->psorbmax rationcplantmax rationcplantmax proc~casa_cnpcycle->rationcplantmax proc~casa_cnpcycle->sla proc~casa_cnpflux->crmplant fcrmleafyear fcrmleafyear proc~casa_cnpflux->fcrmleafyear fcrmrootyear fcrmrootyear proc~casa_cnpflux->fcrmrootyear fcrmwoodyear fcrmwoodyear proc~casa_cnpflux->fcrmwoodyear proc~casa_coeffplant->kplant proc~casa_coeffplant->kplant_fire proc~casa_coeffplant->cplant fracligninplant fracligninplant proc~casa_coeffplant->fracligninplant fromptol fromptol proc~casa_coeffplant->fromptol ftransnptol ftransnptol proc~casa_coeffplant->ftransnptol proc~casa_coeffplant->glai proc~casa_coeffplant->glaimin proc~casa_coeffplant->iveg proc~casa_coeffplant->nplant plantrate plantrate proc~casa_coeffplant->plantrate proc~casa_coeffsoil->klitter proc~casa_coeffsoil->klitter_fire clay clay proc~casa_coeffsoil->clay proc~casa_coeffsoil->fracligninplant fromltoco2 fromltoco2 proc~casa_coeffsoil->fromltoco2 fromltos fromltos proc~casa_coeffsoil->fromltos fromstoco2 fromstoco2 proc~casa_coeffsoil->fromstoco2 fromstos fromstos proc~casa_coeffsoil->fromstos isorder isorder proc~casa_coeffsoil->isorder proc~casa_coeffsoil->iveg proc~casa_coeffsoil->iveg2 ksoil ksoil proc~casa_coeffsoil->ksoil litterrate litterrate proc~casa_coeffsoil->litterrate silt silt proc~casa_coeffsoil->silt soilrate soilrate proc~casa_coeffsoil->soilrate xkplab xkplab proc~casa_coeffsoil->xkplab xkpocc xkpocc proc~casa_coeffsoil->xkpocc xkpsorb xkpsorb proc~casa_coeffsoil->xkpsorb proc~casa_delplant->kplant proc~casa_delplant->kplant_fire cgpp cgpp proc~casa_delplant->cgpp charvest charvest proc~casa_delplant->charvest clabloss clabloss proc~casa_delplant->clabloss proc~casa_delplant->cnpp proc~casa_delplant->cplant crgplant crgplant proc~casa_delplant->crgplant proc~casa_delplant->crmplant proc~casa_delplant->dcplantdt proc~casa_delplant->dnplantdt proc~casa_delplant->dpplantdt proc~casa_delplant->fharvest proc~casa_delplant->fluxctoco2_plant_fire proc~casa_delplant->fluxctolitter proc~casa_delplant->fluxfromptoco2 fluxfromptoharvest fluxfromptoharvest proc~casa_delplant->fluxfromptoharvest fluxntolitter fluxntolitter proc~casa_delplant->fluxntolitter fluxptolitter fluxptolitter proc~casa_delplant->fluxptolitter proc~casa_delplant->fraccalloc fracclabile fracclabile proc~casa_delplant->fracclabile fracnalloc fracnalloc proc~casa_delplant->fracnalloc fracpalloc fracpalloc proc~casa_delplant->fracpalloc proc~casa_delplant->fromptol proc~casa_delplant->fromptol_fire proc~casa_delplant->ftransnptol ftranspptol ftranspptol proc~casa_delplant->ftranspptol proc~casa_delplant->iveg proc~casa_delplant->iveg2 proc~casa_delplant->kplant_tot lnonwood lnonwood proc~casa_delplant->lnonwood nharvest nharvest proc~casa_delplant->nharvest proc~casa_delplant->nminuptake proc~casa_delplant->nplant pharvest pharvest proc~casa_delplant->pharvest proc~casa_delplant->plabuptake proc~casa_delplant->pplant proc~casa_delsoil->klitter proc~casa_delsoil->klitter_fire proc~casa_delsoil->clitter proc~casa_delsoil->cnpp costnpup costnpup proc~casa_delsoil->costnpup proc~casa_delsoil->crsoil proc~casa_delsoil->csoil proc~casa_delsoil->dpsoillabdt fluxctoco2 fluxctoco2 proc~casa_delsoil->fluxctoco2 fluxctoco2_litter_fire fluxctoco2_litter_fire proc~casa_delsoil->fluxctoco2_litter_fire proc~casa_delsoil->fluxctolitter fluxctosoil fluxctosoil proc~casa_delsoil->fluxctosoil fluxfromltoco2 fluxfromltoco2 proc~casa_delsoil->fluxfromltoco2 fluxfromltos fluxfromltos proc~casa_delsoil->fluxfromltos fluxfromstoco2 fluxfromstoco2 proc~casa_delsoil->fluxfromstoco2 fluxfromstos fluxfromstos proc~casa_delsoil->fluxfromstos proc~casa_delsoil->fluxntolitter fluxntosoil fluxntosoil proc~casa_delsoil->fluxntosoil proc~casa_delsoil->fluxptolitter fluxptosoil fluxptosoil proc~casa_delsoil->fluxptosoil fnminleach fnminleach proc~casa_delsoil->fnminleach fnminloss fnminloss proc~casa_delsoil->fnminloss fpleach fpleach proc~casa_delsoil->fpleach proc~casa_delsoil->fromltoco2 proc~casa_delsoil->fromltos proc~casa_delsoil->fromstoco2 proc~casa_delsoil->fromstos proc~casa_delsoil->iveg proc~casa_delsoil->iveg2 proc~casa_delsoil->klitter_tot proc~casa_delsoil->kmlabp kpocc kpocc proc~casa_delsoil->kpocc kpsorb kpsorb proc~casa_delsoil->kpsorb proc~casa_delsoil->ksoil proc~casa_delsoil->nlitter nlittermin nlittermin proc~casa_delsoil->nlittermin proc~casa_delsoil->nmindep proc~casa_delsoil->nminfix proc~casa_delsoil->nminleach proc~casa_delsoil->nminloss nsimm nsimm proc~casa_delsoil->nsimm nsmin nsmin proc~casa_delsoil->nsmin nsnet nsnet proc~casa_delsoil->nsnet proc~casa_delsoil->nsoil proc~casa_delsoil->nsoilmin proc~casa_delsoil->nupland proc~casa_delsoil->pdep proc~casa_delsoil->pleach proc~casa_delsoil->plitter plittermin plittermin proc~casa_delsoil->plittermin prodptase prodptase proc~casa_delsoil->prodptase psimm psimm proc~casa_delsoil->psimm psmin psmin proc~casa_delsoil->psmin psnet psnet proc~casa_delsoil->psnet proc~casa_delsoil->psoil proc~casa_delsoil->psoillab proc~casa_delsoil->psoilocc proc~casa_delsoil->psoilsorb proc~casa_delsoil->psorbmax proc~casa_delsoil->pupland proc~casa_delsoil->pwea rationcsoilnew rationcsoilnew proc~casa_delsoil->rationcsoilnew rationpsoil rationpsoil proc~casa_delsoil->rationpsoil proc~casa_delsoil->tsoilavg proc~casa_ndummy->cplant rationcplant rationcplant proc~casa_ndummy->rationcplant proc~casa_nuptake->iveg proc~casa_nuptake->iveg2 kminn kminn proc~casa_nuptake->kminn proc~casa_nuptake->nminuptake proc~casa_nuptake->nsoilmin proc~casa_nrequire casa_cnp_module::casa_Nrequire proc~casa_nuptake->proc~casa_nrequire proc~casa_pdummy->nplant rationpplant rationpplant proc~casa_pdummy->rationpplant proc~casa_puptake->iveg kuplabp kuplabp proc~casa_puptake->kuplabp proc~casa_puptake->plabuptake proc~casa_prequire casa_cnp_module::casa_Prequire proc~casa_puptake->proc~casa_prequire proc~casa_puptake->psoillab proc~casa_rplant->cgpp proc~casa_rplant->clabile proc~casa_rplant->cplant proc~casa_rplant->crgplant proc~casa_rplant->crmplant frac_sapwood frac_sapwood proc~casa_rplant->frac_sapwood frec frec proc~casa_rplant->frec proc~casa_rplant->iveg kclabrate kclabrate proc~casa_rplant->kclabrate proc~casa_rplant->nplant proc~vcmax_np casa_cnp_module::vcmax_np proc~casa_rplant->proc~vcmax_np qtemp_max_last_year qtemp_max_last_year proc~casa_rplant->qtemp_max_last_year proc~casa_rplant->rationcplantmax ratiopcplantmax ratiopcplantmax proc~casa_rplant->ratiopcplantmax rmplant rmplant proc~casa_rplant->rmplant proc~casa_rplant->sla tairk tairk proc~casa_rplant->tairk proc~casa_rplant->tsoilavg vcmax vcmax proc~casa_rplant->vcmax vcmax_scalar vcmax_scalar proc~casa_rplant->vcmax_scalar proc~casa_xkn->klitter proc~casa_xkn->clitter proc~casa_xkn->csoil proc~casa_xkn->fromltos proc~casa_xkn->fromstos proc~casa_xkn->iveg proc~casa_xkn->iveg2 proc~casa_xkn->ksoil maxcwd maxcwd proc~casa_xkn->maxcwd maxfinelitter maxfinelitter proc~casa_xkn->maxfinelitter proc~casa_xkn->nlitter proc~casa_xkn->nsoil proc~casa_xkn->nsoilmin rationcsoilmax rationcsoilmax proc~casa_xkn->rationcsoilmax rationcsoilmin rationcsoilmin proc~casa_xkn->rationcsoilmin proc~casa_xkn->rationcsoilnew proc~casa_xnp->cgpp proc~casa_xnp->cnpp proc~casa_xnp->cplant proc~casa_xnp->fharvest proc~casa_xnp->fracclabile proc~casa_xnp->iveg proc~casa_xnp->iveg2 proc~casa_xnp->nplant proc~casa_xnp->nsoilmin proc~casa_xnp->pplant proc~casa_xnp->proc~casa_nrequire proc~casa_xnp->proc~casa_prequire proc~casa_xnp->psoillab xnpmax xnpmax proc~casa_xnp->xnpmax proc~casa_xrateplant->btran ge ge proc~casa_xrateplant->ge proc~casa_xrateplant->iveg proc~casa_xrateplant->iveg2 le le proc~casa_xrateplant->le proc~casa_xrateplant->lnonwood phase phase proc~casa_xrateplant->phase proc~casa_xrateplant->tairk tkshed tkshed proc~casa_xrateplant->tkshed xkleafcoldexp xkleafcoldexp proc~casa_xrateplant->xkleafcoldexp xkleafcoldmax xkleafcoldmax proc~casa_xrateplant->xkleafcoldmax xkleafdryexp xkleafdryexp proc~casa_xrateplant->xkleafdryexp xkleafdrymax xkleafdrymax proc~casa_xrateplant->xkleafdrymax damm_alpha damm_alpha proc~casa_xratesoil->damm_alpha damm_ea damm_ea proc~casa_xratesoil->damm_ea damm_enzpool damm_enzpool proc~casa_xratesoil->damm_enzpool damm_kmcp damm_kmcp proc~casa_xratesoil->damm_kmcp damm_kmo2 damm_kmo2 proc~casa_xratesoil->damm_kmo2 proc~casa_xratesoil->iveg proc~casa_xratesoil->iveg2 proc~casa_xratesoil->moistavg q10soil q10soil proc~casa_xratesoil->q10soil ssat ssat proc~casa_xratesoil->ssat proc~casa_xratesoil->tsoilavg xkoptlitter xkoptlitter proc~casa_xratesoil->xkoptlitter xkoptsoil xkoptsoil proc~casa_xratesoil->xkoptsoil doyphase doyphase proc~phenology->doyphase proc~phenology->phase proc~casa_nrequire->kplant proc~casa_nrequire->cplant proc~casa_nrequire->fraccalloc proc~casa_nrequire->ftransnptol proc~casa_nrequire->iveg proc~casa_nrequire->iveg2 proc~casa_nrequire->nplant proc~casa_nrequire->nsoilmin proc~casa_nrequire->rationcplantmax rationcplantmin rationcplantmin proc~casa_nrequire->rationcplantmin proc~casa_poolzero->clitter proc~casa_poolzero->cplant proc~casa_poolzero->csoil proc~casa_poolzero->nlitter proc~casa_poolzero->nplant proc~casa_poolzero->nsoil proc~casa_prequire->kplant proc~casa_prequire->cplant proc~casa_prequire->fraccalloc proc~casa_prequire->ftranspptol proc~casa_prequire->iveg proc~casa_prequire->iveg2 proc~casa_prequire->nplant proc~casa_prequire->pplant rationpplantmax rationpplantmax proc~casa_prequire->rationpplantmax rationpplantmin rationpplantmin proc~casa_prequire->rationpplantmin proc~casa_wolf->cnpp proc~casa_wolf->cplant proc~casa_wolf->fracnpptop proc~casa_wolf->iveg proc~casa_wolf->iveg2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~biogeochem~~CalledByGraph proc~biogeochem casa_inout::biogeochem proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/biogeochem.html"},{"title":"write_casa_restart_nc – POP","text":"public  subroutine write_casa_restart_nc(casabiome, casamet, casapool, casaflux, casabal, phen) Uses cable_common_module casavariable phenvariable proc~~write_casa_restart_nc~~UsesGraph proc~write_casa_restart_nc casa_inout::write_casa_restart_nc cable_common_module cable_common_module proc~write_casa_restart_nc->cable_common_module module~casavariable casavariable proc~write_casa_restart_nc->module~casavariable module~phenvariable phenvariable proc~write_casa_restart_nc->module~phenvariable cable_def_types_mod cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~casadimension casadimension module~phenvariable->module~casadimension module~casadimension->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(in) :: casabiome type( casa_met ), intent(in) :: casamet type( casa_pool ), intent(in) :: casapool type( casa_flux ), intent(in) :: casaflux type( casa_balance ), intent(in) :: casabal type( phen_variable ), intent(in) :: phen Calls proc~~write_casa_restart_nc~~CallsGraph proc~write_casa_restart_nc casa_inout::write_casa_restart_nc interface~write_netcdf_casa_var casavariable::write_netcdf_casa_var proc~write_casa_restart_nc->interface~write_netcdf_casa_var proc~write_netcdf_phen_var phenvariable::write_netcdf_phen_var proc~write_casa_restart_nc->proc~write_netcdf_phen_var proc~write_netcdf_casabal casavariable::write_netcdf_casabal interface~write_netcdf_casa_var->proc~write_netcdf_casabal proc~write_netcdf_casabiome casavariable::write_netcdf_casabiome interface~write_netcdf_casa_var->proc~write_netcdf_casabiome proc~write_netcdf_casaflux casavariable::write_netcdf_casaflux interface~write_netcdf_casa_var->proc~write_netcdf_casaflux proc~write_netcdf_casamet casavariable::write_netcdf_casamet interface~write_netcdf_casa_var->proc~write_netcdf_casamet proc~write_netcdf_casapool casavariable::write_netcdf_casapool interface~write_netcdf_casa_var->proc~write_netcdf_casapool nc_err nc_err proc~write_netcdf_phen_var->nc_err nf90_close nf90_close proc~write_netcdf_phen_var->nf90_close nf90_create nf90_create proc~write_netcdf_phen_var->nf90_create nf90_def_dim nf90_def_dim proc~write_netcdf_phen_var->nf90_def_dim nf90_def_var nf90_def_var proc~write_netcdf_phen_var->nf90_def_var nf90_enddef nf90_enddef proc~write_netcdf_phen_var->nf90_enddef nf90_put_var nf90_put_var proc~write_netcdf_phen_var->nf90_put_var proc~write_netcdf_casabal->nc_err proc~write_netcdf_casabal->nf90_close proc~write_netcdf_casabal->nf90_create proc~write_netcdf_casabal->nf90_def_dim proc~write_netcdf_casabal->nf90_def_var proc~write_netcdf_casabal->nf90_enddef proc~write_netcdf_casabal->nf90_put_var proc~write_netcdf_casabiome->nc_err proc~write_netcdf_casabiome->nf90_close proc~write_netcdf_casabiome->nf90_create proc~write_netcdf_casabiome->nf90_def_dim proc~write_netcdf_casabiome->nf90_def_var proc~write_netcdf_casabiome->nf90_enddef proc~write_netcdf_casabiome->nf90_put_var proc~write_netcdf_casaflux->nc_err proc~write_netcdf_casaflux->nf90_close proc~write_netcdf_casaflux->nf90_create proc~write_netcdf_casaflux->nf90_def_dim proc~write_netcdf_casaflux->nf90_def_var proc~write_netcdf_casaflux->nf90_enddef proc~write_netcdf_casaflux->nf90_put_var proc~write_netcdf_casamet->nc_err proc~write_netcdf_casamet->nf90_close proc~write_netcdf_casamet->nf90_create proc~write_netcdf_casamet->nf90_def_dim proc~write_netcdf_casamet->nf90_def_var proc~write_netcdf_casamet->nf90_enddef proc~write_netcdf_casamet->nf90_put_var proc~write_netcdf_casapool->nc_err proc~write_netcdf_casapool->nf90_close proc~write_netcdf_casapool->nf90_create proc~write_netcdf_casapool->nf90_def_dim proc~write_netcdf_casapool->nf90_def_var proc~write_netcdf_casapool->nf90_enddef proc~write_netcdf_casapool->nf90_put_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/write_casa_restart_nc.html"},{"title":"read_casa_restart_nc – POP","text":"public  subroutine read_casa_restart_nc(casabiome, casamet, casapool, casaflux, casabal, phen) Uses cable_common_module casavariable phenvariable proc~~read_casa_restart_nc~~UsesGraph proc~read_casa_restart_nc casa_inout::read_casa_restart_nc cable_common_module cable_common_module proc~read_casa_restart_nc->cable_common_module module~casavariable casavariable proc~read_casa_restart_nc->module~casavariable module~phenvariable phenvariable proc~read_casa_restart_nc->module~phenvariable cable_def_types_mod cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~casadimension casadimension module~phenvariable->module~casadimension module~casadimension->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(inout) :: casabiome type( casa_met ), intent(inout) :: casamet type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_balance ), intent(inout) :: casabal type( phen_variable ), intent(inout) :: phen Calls proc~~read_casa_restart_nc~~CallsGraph proc~read_casa_restart_nc casa_inout::read_casa_restart_nc interface~read_netcdf_casa_var casavariable::read_netcdf_casa_var proc~read_casa_restart_nc->interface~read_netcdf_casa_var proc~read_netcdf_phen_var phenvariable::read_netcdf_phen_var proc~read_casa_restart_nc->proc~read_netcdf_phen_var proc~read_netcdf_casabal casavariable::read_netcdf_casabal interface~read_netcdf_casa_var->proc~read_netcdf_casabal proc~read_netcdf_casabiome casavariable::read_netcdf_casabiome interface~read_netcdf_casa_var->proc~read_netcdf_casabiome proc~read_netcdf_casaflux casavariable::read_netcdf_casaflux interface~read_netcdf_casa_var->proc~read_netcdf_casaflux proc~read_netcdf_casamet casavariable::read_netcdf_casamet interface~read_netcdf_casa_var->proc~read_netcdf_casamet proc~read_netcdf_casapool casavariable::read_netcdf_casapool interface~read_netcdf_casa_var->proc~read_netcdf_casapool nc_err nc_err proc~read_netcdf_phen_var->nc_err nf90_close nf90_close proc~read_netcdf_phen_var->nf90_close nf90_get_var nf90_get_var proc~read_netcdf_phen_var->nf90_get_var nf90_inq_varid nf90_inq_varid proc~read_netcdf_phen_var->nf90_inq_varid nf90_open nf90_open proc~read_netcdf_phen_var->nf90_open proc~read_netcdf_casabal->nc_err proc~read_netcdf_casabal->nf90_close proc~read_netcdf_casabal->nf90_get_var proc~read_netcdf_casabal->nf90_inq_varid proc~read_netcdf_casabal->nf90_open proc~read_netcdf_casabiome->nc_err proc~read_netcdf_casabiome->nf90_close proc~read_netcdf_casabiome->nf90_get_var proc~read_netcdf_casabiome->nf90_inq_varid proc~read_netcdf_casabiome->nf90_open proc~read_netcdf_casaflux->nc_err proc~read_netcdf_casaflux->nf90_close proc~read_netcdf_casaflux->nf90_get_var proc~read_netcdf_casaflux->nf90_inq_varid proc~read_netcdf_casaflux->nf90_open proc~read_netcdf_casamet->nc_err proc~read_netcdf_casamet->nf90_close proc~read_netcdf_casamet->nf90_get_var proc~read_netcdf_casamet->nf90_inq_varid proc~read_netcdf_casamet->nf90_open proc~read_netcdf_casapool->nc_err proc~read_netcdf_casapool->nf90_close proc~read_netcdf_casapool->nf90_get_var proc~read_netcdf_casapool->nf90_inq_varid proc~read_netcdf_casapool->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_casa_restart_nc~~CalledByGraph proc~read_casa_restart_nc casa_inout::read_casa_restart_nc proc~casa_init casa_inout::casa_init proc~casa_init->proc~read_casa_restart_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/read_casa_restart_nc.html"},{"title":"write_casa_output_nc – POP","text":"public  subroutine write_casa_output_nc(veg, casamet, casapool, casabal, casaflux, casaonly, ctime, lfinal) Uses casavariable cable_IO_vars_module cable_def_types_mod cable_common_module casadimension netcdf proc~~write_casa_output_nc~~UsesGraph proc~write_casa_output_nc casa_inout::write_casa_output_nc cable_IO_vars_module cable_IO_vars_module proc~write_casa_output_nc->cable_IO_vars_module cable_common_module cable_common_module proc~write_casa_output_nc->cable_common_module cable_def_types_mod cable_def_types_mod proc~write_casa_output_nc->cable_def_types_mod module~casadimension casadimension proc~write_casa_output_nc->module~casadimension module~casavariable casavariable proc~write_casa_output_nc->module~casavariable netcdf netcdf proc~write_casa_output_nc->netcdf module~casadimension->cable_def_types_mod module~casavariable->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(in) :: veg type( casa_met ), intent(in) :: casamet type( casa_pool ), intent(in) :: casapool type( casa_balance ), intent(in) :: casabal type( casa_flux ), intent(in) :: casaflux logical, intent(in) :: casaonly integer, intent(in) :: ctime logical, intent(in) :: lfinal Calls proc~~write_casa_output_nc~~CallsGraph proc~write_casa_output_nc casa_inout::write_casa_output_nc handle_err handle_err proc~write_casa_output_nc->handle_err nf90_close nf90_close proc~write_casa_output_nc->nf90_close nf90_create nf90_create proc~write_casa_output_nc->nf90_create nf90_def_dim nf90_def_dim proc~write_casa_output_nc->nf90_def_dim nf90_def_var nf90_def_var proc~write_casa_output_nc->nf90_def_var nf90_enddef nf90_enddef proc~write_casa_output_nc->nf90_enddef nf90_put_att nf90_put_att proc~write_casa_output_nc->nf90_put_att nf90_put_var nf90_put_var proc~write_casa_output_nc->nf90_put_var patch patch proc~write_casa_output_nc->patch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_casa_output_nc~~CalledByGraph proc~write_casa_output_nc casa_inout::write_casa_output_nc proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~write_casa_output_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/write_casa_output_nc.html"},{"title":"Exponential – POP","text":"public  function Exponential(lambda, x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda integer(kind=i4b), intent(in) :: x Return Value real(kind=dp) Called by proc~~exponential~~CalledByGraph proc~exponential POPModule::Exponential proc~initpop2d_poisson POPModule::InitPOP2D_Poisson proc~initpop2d_poisson->proc~exponential proc~pop_init POPModule::POP_init proc~pop_init->proc~initpop2d_poisson proc~pop_init_single POPModule::POP_init_single proc~pop_init_single->proc~initpop2d_poisson proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~pop_init_single proc~popluc_init POPLUC_Module::POPLUC_Init proc~popluc_init->proc~pop_init_single Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/exponential.html"},{"title":"REALExponential – POP","text":"public  function REALExponential(lambda, x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda real(kind=dp), intent(in) :: x Return Value real(kind=dp) Called by proc~~realexponential~~CalledByGraph proc~realexponential POPModule::REALExponential proc~getuniqueagefrequencies POPModule::GetUniqueAgeFrequencies proc~getuniqueagefrequencies->proc~realexponential proc~interpolate_biomass_1d POPModule::INTERPOLATE_BIOMASS_1D proc~interpolate_biomass_1d->proc~realexponential proc~interpolate_biomass_2d POPModule::INTERPOLATE_BIOMASS_2D proc~interpolate_biomass_2d->proc~realexponential proc~interpolate_firemortality POPModule::INTERPOLATE_FIREMORTALITY proc~interpolate_firemortality->proc~realexponential proc~adjust_pop_for_fire POPModule::ADJUST_POP_FOR_FIRE proc~adjust_pop_for_fire->proc~interpolate_firemortality proc~getdiagnostics POPModule::GetDiagnostics proc~getdiagnostics->proc~interpolate_biomass_1d proc~getdiagnostics->proc~interpolate_biomass_2d proc~popstep POPModule::POPStep proc~popstep->proc~getuniqueagefrequencies proc~popstep->proc~getdiagnostics proc~popdriver casa_cable::POPdriver proc~popdriver->proc~popstep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/realexponential.html"},{"title":"CumExponential – POP","text":"public  function CumExponential(lambda, x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda real(kind=dp), intent(in) :: x Return Value real(kind=dp) Called by proc~~cumexponential~~CalledByGraph proc~cumexponential POPModule::CumExponential proc~getuniqueagefrequencies POPModule::GetUniqueAgeFrequencies proc~getuniqueagefrequencies->proc~cumexponential proc~initpop2d_poisson POPModule::InitPOP2D_Poisson proc~initpop2d_poisson->proc~cumexponential proc~pop_init POPModule::POP_init proc~pop_init->proc~initpop2d_poisson proc~pop_init_single POPModule::POP_init_single proc~pop_init_single->proc~initpop2d_poisson proc~popstep POPModule::POPStep proc~popstep->proc~getuniqueagefrequencies proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~pop_init_single proc~popdriver casa_cable::POPdriver proc~casaonly_luc->proc~popdriver proc~popdriver->proc~popstep proc~popluc_init POPLUC_Module::POPLUC_Init proc~popluc_init->proc~pop_init_single proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/cumexponential.html"},{"title":"Factorial – POP","text":"public  function Factorial(n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=dp) Contents","tags":"","loc":"proc/factorial.html"},{"title":"GetHeight – POP","text":"public  function GetHeight(precip, biomass, density) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: precip real(kind=dp), intent(in) :: biomass real(kind=dp), intent(in) :: density Return Value real(kind=dp) Called by proc~~getheight~~CalledByGraph proc~getheight POPModule::GetHeight proc~get_allometry POPModule::GET_ALLOMETRY proc~get_allometry->proc~getheight proc~getdiagnostics POPModule::GetDiagnostics proc~getdiagnostics->proc~get_allometry proc~layer_recruitment POPModule::layer_recruitment proc~layer_recruitment->proc~get_allometry proc~layer_recruitment_single_patch POPModule::layer_recruitment_single_patch proc~layer_recruitment_single_patch->proc~get_allometry proc~patchannualdynamics POPModule::PatchAnnualDynamics proc~patchannualdynamics->proc~get_allometry proc~patchannualdynamics->proc~layer_recruitment proc~patch_disturb POPModule::Patch_disturb proc~patch_disturb->proc~layer_recruitment_single_patch proc~pop_init POPModule::POP_init proc~pop_init->proc~layer_recruitment_single_patch proc~pop_init_single POPModule::POP_init_single proc~pop_init_single->proc~layer_recruitment_single_patch proc~popstep POPModule::POPStep proc~popstep->proc~getdiagnostics proc~popstep->proc~patchannualdynamics proc~popstep->proc~patch_disturb proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~pop_init_single proc~popdriver casa_cable::POPdriver proc~casaonly_luc->proc~popdriver proc~popdriver->proc~popstep proc~popluc_init POPLUC_Module::POPLUC_Init proc~popluc_init->proc~pop_init_single proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/getheight.html"},{"title":"Area_Triangle – POP","text":"public  function Area_Triangle(x1, y1, x2, y2, x3, y3) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x1 real(kind=dp), intent(in) :: y1 real(kind=dp), intent(in) :: x2 real(kind=dp), intent(in) :: y2 real(kind=dp), intent(in) :: x3 real(kind=dp), intent(in) :: y3 Return Value real(kind=dp) Called by proc~~area_triangle~~CalledByGraph proc~area_triangle POPModule::Area_Triangle proc~interpolate_biomass_2d POPModule::INTERPOLATE_BIOMASS_2D proc~interpolate_biomass_2d->proc~area_triangle proc~getdiagnostics POPModule::GetDiagnostics proc~getdiagnostics->proc~interpolate_biomass_2d proc~popstep POPModule::POPStep proc~popstep->proc~getdiagnostics proc~popdriver casa_cable::POPdriver proc~popdriver->proc~popstep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/area_triangle.html"},{"title":"TopKill_Collins – POP","text":"public  function TopKill_Collins(dbh, FLI) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dbh real(kind=dp), intent(in) :: FLI Return Value real(kind=dp) Called by proc~~topkill_collins~~CalledByGraph proc~topkill_collins POPModule::TopKill_Collins proc~adjust_pop_for_fire POPModule::ADJUST_POP_FOR_FIRE proc~adjust_pop_for_fire->proc~topkill_collins Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/topkill_collins.html"},{"title":"ZeroPOP – POP","text":"public  subroutine ZeroPOP(POP, n) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer, intent(in), optional :: n Called by proc~~zeropop~~CalledByGraph proc~zeropop POPModule::ZeroPOP proc~pop_init POPModule::POP_init proc~pop_init->proc~zeropop proc~pop_init_single POPModule::POP_init_single proc~pop_init_single->proc~zeropop proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~pop_init_single proc~popluc_init POPLUC_Module::POPLUC_Init proc~popluc_init->proc~pop_init_single Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/zeropop.html"},{"title":"InitPOP2D_Poisson – POP","text":"public  subroutine InitPOP2D_Poisson(POP, mean_disturbance_interval, m) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: mean_disturbance_interval (:,:) integer(kind=i4b), intent(in), optional :: m Calls proc~~initpop2d_poisson~~CallsGraph proc~initpop2d_poisson POPModule::InitPOP2D_Poisson pop_grid pop_grid proc~initpop2d_poisson->pop_grid proc~cumexponential POPModule::CumExponential proc~initpop2d_poisson->proc~cumexponential proc~exponential POPModule::Exponential proc~initpop2d_poisson->proc~exponential Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initpop2d_poisson~~CalledByGraph proc~initpop2d_poisson POPModule::InitPOP2D_Poisson proc~pop_init POPModule::POP_init proc~pop_init->proc~initpop2d_poisson proc~pop_init_single POPModule::POP_init_single proc~pop_init_single->proc~initpop2d_poisson proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~pop_init_single proc~popluc_init POPLUC_Module::POPLUC_Init proc~popluc_init->proc~pop_init_single Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/initpop2d_poisson.html"},{"title":"POPStep – POP","text":"public  subroutine POPStep(POP, StemNPP, disturbance_interval, disturbance_intensity, LAI, Cleaf, Croot, NPPtoGPP, StemNPP_av, frac_intensity1, precip) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP real(kind=dp), intent(in) :: StemNPP (:,:) integer(kind=i4b), intent(in) :: disturbance_interval (:,:) real(kind=dp), intent(in) :: disturbance_intensity (:,:) real(kind=dp), intent(in) :: LAI (:) real(kind=dp), intent(in) :: Cleaf (:) real(kind=dp), intent(in) :: Croot (:) real(kind=dp), intent(in) :: NPPtoGPP (:) real(kind=dp), intent(in), optional :: StemNPP_av (:) real(kind=dp), intent(in), optional :: frac_intensity1 (:) real(kind=dp), intent(in), optional :: precip (:) Calls proc~~popstep~~CallsGraph proc~popstep POPModule::POPStep pop_grid pop_grid proc~popstep->pop_grid proc~getdiagnostics POPModule::GetDiagnostics proc~popstep->proc~getdiagnostics proc~getpatchfrequencies POPModule::GetPatchFrequencies proc~popstep->proc~getpatchfrequencies proc~getuniqueagefrequencies POPModule::GetUniqueAgeFrequencies proc~popstep->proc~getuniqueagefrequencies proc~patch_disturb POPModule::Patch_disturb proc~popstep->proc~patch_disturb proc~patch_partial_disturb POPModule::Patch_partial_disturb proc~popstep->proc~patch_partial_disturb proc~patch_partial_disturb2 POPModule::Patch_partial_disturb2 proc~popstep->proc~patch_partial_disturb2 proc~patchannualdynamics POPModule::PatchAnnualDynamics proc~popstep->proc~patchannualdynamics proc~getdiagnostics->pop_grid proc~get_allometry POPModule::GET_ALLOMETRY proc~getdiagnostics->proc~get_allometry proc~interpolate_biomass_1d POPModule::INTERPOLATE_BIOMASS_1D proc~getdiagnostics->proc~interpolate_biomass_1d proc~interpolate_biomass_2d POPModule::INTERPOLATE_BIOMASS_2D proc~getdiagnostics->proc~interpolate_biomass_2d proc~smooth_flux POPModule::SMOOTH_FLUX proc~getdiagnostics->proc~smooth_flux proc~getpatchfrequencies->pop_grid proc~getuniqueagefrequencies->pop_grid proc~cumexponential POPModule::CumExponential proc~getuniqueagefrequencies->proc~cumexponential proc~realexponential POPModule::REALExponential proc~getuniqueagefrequencies->proc~realexponential proc~patch_disturb->pop_grid proc~layer_recruitment_single_patch POPModule::layer_recruitment_single_patch proc~patch_disturb->proc~layer_recruitment_single_patch proc~patch_partial_disturb->pop_grid proc~patch_partial_disturb2->pop_grid proc~patchannualdynamics->pop_grid proc~patchannualdynamics->proc~get_allometry proc~layer_recruitment POPModule::layer_recruitment proc~patchannualdynamics->proc~layer_recruitment proc~allometry POPModule::Allometry proc~get_allometry->proc~allometry proc~getheight POPModule::GetHeight proc~get_allometry->proc~getheight proc~williams_allometry POPModule::Williams_Allometry proc~get_allometry->proc~williams_allometry proc~interpolate_biomass_1d->pop_grid proc~interpolate_biomass_1d->proc~realexponential proc~interpolate_biomass_2d->pop_grid proc~interpolate_biomass_2d->proc~realexponential eq eq proc~interpolate_biomass_2d->eq proc~area_triangle POPModule::Area_Triangle proc~interpolate_biomass_2d->proc~area_triangle proc~layer_recruitment->pop_grid proc~layer_recruitment->proc~get_allometry proc~layer_recruitment_single_patch->pop_grid proc~layer_recruitment_single_patch->proc~get_allometry proc~smooth_flux->pop_grid proc~regress POPModule::REGRESS proc~smooth_flux->proc~regress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~popstep~~CalledByGraph proc~popstep POPModule::POPStep proc~popdriver casa_cable::POPdriver proc~popdriver->proc~popstep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/popstep.html"},{"title":"PatchAnnualDynamics – POP","text":"public  subroutine PatchAnnualDynamics(pop, StemNPP, NPPtoGPP, it, StemNPP_av, precip) assumes crown radius (m) = 0.1492 * dbh (cm) (from G. Cook, pers. comm.) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: pop real(kind=dp), intent(in) :: StemNPP (:,:) real(kind=dp), intent(in) :: NPPtoGPP (:) integer(kind=i4b), intent(in) :: it (:) real(kind=dp), intent(in), optional :: StemNPP_av (:) real(kind=dp), intent(in), optional :: precip (:) Calls proc~~patchannualdynamics~~CallsGraph proc~patchannualdynamics POPModule::PatchAnnualDynamics pop_grid pop_grid proc~patchannualdynamics->pop_grid proc~get_allometry POPModule::GET_ALLOMETRY proc~patchannualdynamics->proc~get_allometry proc~layer_recruitment POPModule::layer_recruitment proc~patchannualdynamics->proc~layer_recruitment proc~allometry POPModule::Allometry proc~get_allometry->proc~allometry proc~getheight POPModule::GetHeight proc~get_allometry->proc~getheight proc~williams_allometry POPModule::Williams_Allometry proc~get_allometry->proc~williams_allometry proc~layer_recruitment->pop_grid proc~layer_recruitment->proc~get_allometry Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~patchannualdynamics~~CalledByGraph proc~patchannualdynamics POPModule::PatchAnnualDynamics proc~popstep POPModule::POPStep proc~popstep->proc~patchannualdynamics proc~popdriver casa_cable::POPdriver proc~popdriver->proc~popstep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/patchannualdynamics.html"},{"title":"GetUniqueAgeFrequencies – POP","text":"public  subroutine GetUniqueAgeFrequencies(POP, disturbance_interval, idisturb) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: disturbance_interval (:,:) integer(kind=i4b), intent(in) :: idisturb Calls proc~~getuniqueagefrequencies~~CallsGraph proc~getuniqueagefrequencies POPModule::GetUniqueAgeFrequencies pop_grid pop_grid proc~getuniqueagefrequencies->pop_grid proc~cumexponential POPModule::CumExponential proc~getuniqueagefrequencies->proc~cumexponential proc~realexponential POPModule::REALExponential proc~getuniqueagefrequencies->proc~realexponential Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~getuniqueagefrequencies~~CalledByGraph proc~getuniqueagefrequencies POPModule::GetUniqueAgeFrequencies proc~popstep POPModule::POPStep proc~popstep->proc~getuniqueagefrequencies proc~popdriver casa_cable::POPdriver proc~popdriver->proc~popstep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/getuniqueagefrequencies.html"},{"title":"GetPatchFrequencies – POP","text":"public  subroutine GetPatchFrequencies(POP) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP Calls proc~~getpatchfrequencies~~CallsGraph proc~getpatchfrequencies POPModule::GetPatchFrequencies pop_grid pop_grid proc~getpatchfrequencies->pop_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~getpatchfrequencies~~CalledByGraph proc~getpatchfrequencies POPModule::GetPatchFrequencies proc~popstep POPModule::POPStep proc~popstep->proc~getpatchfrequencies proc~popdriver casa_cable::POPdriver proc~popdriver->proc~popstep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/getpatchfrequencies.html"},{"title":"GetDiagnostics – POP","text":"public  subroutine GetDiagnostics(POP, LAI, Cleaf, Croot, disturbance_interval, it, precip) assumes crown radius (m) = 0.1492 * dbh (cm) (from G. Cook, pers. comm.) global allometry assumes crown radius (m) = 0.1492 * dbh (cm) (from G. Cook, pers. comm.)\nglobal allometry Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP real(kind=dp), intent(in) :: LAI (:) real(kind=dp), intent(in) :: Cleaf (:) real(kind=dp), intent(in) :: Croot (:) integer(kind=i4b), intent(in) :: disturbance_interval (:,:) integer(kind=i4b), intent(in) :: it (:) real(kind=dp), intent(in), optional :: precip (:) Calls proc~~getdiagnostics~~CallsGraph proc~getdiagnostics POPModule::GetDiagnostics pop_grid pop_grid proc~getdiagnostics->pop_grid proc~get_allometry POPModule::GET_ALLOMETRY proc~getdiagnostics->proc~get_allometry proc~interpolate_biomass_1d POPModule::INTERPOLATE_BIOMASS_1D proc~getdiagnostics->proc~interpolate_biomass_1d proc~interpolate_biomass_2d POPModule::INTERPOLATE_BIOMASS_2D proc~getdiagnostics->proc~interpolate_biomass_2d proc~smooth_flux POPModule::SMOOTH_FLUX proc~getdiagnostics->proc~smooth_flux proc~allometry POPModule::Allometry proc~get_allometry->proc~allometry proc~getheight POPModule::GetHeight proc~get_allometry->proc~getheight proc~williams_allometry POPModule::Williams_Allometry proc~get_allometry->proc~williams_allometry proc~interpolate_biomass_1d->pop_grid proc~realexponential POPModule::REALExponential proc~interpolate_biomass_1d->proc~realexponential proc~interpolate_biomass_2d->pop_grid eq eq proc~interpolate_biomass_2d->eq proc~area_triangle POPModule::Area_Triangle proc~interpolate_biomass_2d->proc~area_triangle proc~interpolate_biomass_2d->proc~realexponential proc~smooth_flux->pop_grid proc~regress POPModule::REGRESS proc~smooth_flux->proc~regress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~getdiagnostics~~CalledByGraph proc~getdiagnostics POPModule::GetDiagnostics proc~popstep POPModule::POPStep proc~popstep->proc~getdiagnostics proc~popdriver casa_cable::POPdriver proc~popdriver->proc~popstep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/getdiagnostics.html"},{"title":"Patch_partial_disturb – POP","text":"public  subroutine Patch_partial_disturb(POP, idisturb, intensity, frac_intensity1) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: idisturb real(kind=dp), intent(in) :: intensity (:,:) real(kind=dp), intent(in), optional :: frac_intensity1 (:) Calls proc~~patch_partial_disturb~~CallsGraph proc~patch_partial_disturb POPModule::Patch_partial_disturb pop_grid pop_grid proc~patch_partial_disturb->pop_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~patch_partial_disturb~~CalledByGraph proc~patch_partial_disturb POPModule::Patch_partial_disturb proc~popstep POPModule::POPStep proc~popstep->proc~patch_partial_disturb proc~popdriver casa_cable::POPdriver proc~popdriver->proc~popstep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/patch_partial_disturb.html"},{"title":"Patch_partial_disturb2 – POP","text":"public  subroutine Patch_partial_disturb2(POP, idisturb) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: idisturb Calls proc~~patch_partial_disturb2~~CallsGraph proc~patch_partial_disturb2 POPModule::Patch_partial_disturb2 pop_grid pop_grid proc~patch_partial_disturb2->pop_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~patch_partial_disturb2~~CalledByGraph proc~patch_partial_disturb2 POPModule::Patch_partial_disturb2 proc~popstep POPModule::POPStep proc~popstep->proc~patch_partial_disturb2 proc~popdriver casa_cable::POPdriver proc~popdriver->proc~popstep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/patch_partial_disturb2.html"},{"title":"Patch_disturb – POP","text":"public  subroutine Patch_disturb(POP, idisturb, precip) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: idisturb real(kind=dp), intent(in), optional :: precip (:) Calls proc~~patch_disturb~~CallsGraph proc~patch_disturb POPModule::Patch_disturb pop_grid pop_grid proc~patch_disturb->pop_grid proc~layer_recruitment_single_patch POPModule::layer_recruitment_single_patch proc~patch_disturb->proc~layer_recruitment_single_patch proc~layer_recruitment_single_patch->pop_grid proc~get_allometry POPModule::GET_ALLOMETRY proc~layer_recruitment_single_patch->proc~get_allometry proc~allometry POPModule::Allometry proc~get_allometry->proc~allometry proc~getheight POPModule::GetHeight proc~get_allometry->proc~getheight proc~williams_allometry POPModule::Williams_Allometry proc~get_allometry->proc~williams_allometry Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~patch_disturb~~CalledByGraph proc~patch_disturb POPModule::Patch_disturb proc~popstep POPModule::POPStep proc~popstep->proc~patch_disturb proc~popdriver casa_cable::POPdriver proc~popdriver->proc~popstep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/patch_disturb.html"},{"title":"layer_recruitment – POP","text":"public  subroutine layer_recruitment(POP, precip) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP real(kind=dp), intent(in), optional :: precip (:) Calls proc~~layer_recruitment~~CallsGraph proc~layer_recruitment POPModule::layer_recruitment pop_grid pop_grid proc~layer_recruitment->pop_grid proc~get_allometry POPModule::GET_ALLOMETRY proc~layer_recruitment->proc~get_allometry proc~allometry POPModule::Allometry proc~get_allometry->proc~allometry proc~getheight POPModule::GetHeight proc~get_allometry->proc~getheight proc~williams_allometry POPModule::Williams_Allometry proc~get_allometry->proc~williams_allometry Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~layer_recruitment~~CalledByGraph proc~layer_recruitment POPModule::layer_recruitment proc~patchannualdynamics POPModule::PatchAnnualDynamics proc~patchannualdynamics->proc~layer_recruitment proc~popstep POPModule::POPStep proc~popstep->proc~patchannualdynamics proc~popdriver casa_cable::POPdriver proc~popdriver->proc~popstep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/layer_recruitment.html"},{"title":"layer_recruitment_single_patch – POP","text":"public  subroutine layer_recruitment_single_patch(POP, index, grid_index, precip) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: index integer(kind=i4b), intent(in) :: grid_index real(kind=dp), intent(in), optional :: precip (:) Calls proc~~layer_recruitment_single_patch~~CallsGraph proc~layer_recruitment_single_patch POPModule::layer_recruitment_single_patch pop_grid pop_grid proc~layer_recruitment_single_patch->pop_grid proc~get_allometry POPModule::GET_ALLOMETRY proc~layer_recruitment_single_patch->proc~get_allometry proc~allometry POPModule::Allometry proc~get_allometry->proc~allometry proc~getheight POPModule::GetHeight proc~get_allometry->proc~getheight proc~williams_allometry POPModule::Williams_Allometry proc~get_allometry->proc~williams_allometry Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~layer_recruitment_single_patch~~CalledByGraph proc~layer_recruitment_single_patch POPModule::layer_recruitment_single_patch proc~patch_disturb POPModule::Patch_disturb proc~patch_disturb->proc~layer_recruitment_single_patch proc~pop_init POPModule::POP_init proc~pop_init->proc~layer_recruitment_single_patch proc~pop_init_single POPModule::POP_init_single proc~pop_init_single->proc~layer_recruitment_single_patch proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~pop_init_single proc~popdriver casa_cable::POPdriver proc~casaonly_luc->proc~popdriver proc~popluc_init POPLUC_Module::POPLUC_Init proc~popluc_init->proc~pop_init_single proc~popstep POPModule::POPStep proc~popstep->proc~patch_disturb proc~popdriver->proc~popstep proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/layer_recruitment_single_patch.html"},{"title":"GET_ALLOMETRY – POP","text":"public  subroutine GET_ALLOMETRY(ALLOM_SWITCH, biomass, density, ht, diam, basal, precip) Arguments Type Intent Optional Attributes Name integer(kind=i4b), intent(in) :: ALLOM_SWITCH real(kind=dp), intent(in) :: biomass real(kind=dp), intent(in) :: density real(kind=dp), intent(out) :: ht real(kind=dp), intent(out) :: diam real(kind=dp), intent(out) :: basal real(kind=dp), intent(in), optional :: precip Calls proc~~get_allometry~~CallsGraph proc~get_allometry POPModule::GET_ALLOMETRY proc~allometry POPModule::Allometry proc~get_allometry->proc~allometry proc~getheight POPModule::GetHeight proc~get_allometry->proc~getheight proc~williams_allometry POPModule::Williams_Allometry proc~get_allometry->proc~williams_allometry Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_allometry~~CalledByGraph proc~get_allometry POPModule::GET_ALLOMETRY proc~getdiagnostics POPModule::GetDiagnostics proc~getdiagnostics->proc~get_allometry proc~layer_recruitment POPModule::layer_recruitment proc~layer_recruitment->proc~get_allometry proc~layer_recruitment_single_patch POPModule::layer_recruitment_single_patch proc~layer_recruitment_single_patch->proc~get_allometry proc~patchannualdynamics POPModule::PatchAnnualDynamics proc~patchannualdynamics->proc~get_allometry proc~patchannualdynamics->proc~layer_recruitment proc~patch_disturb POPModule::Patch_disturb proc~patch_disturb->proc~layer_recruitment_single_patch proc~pop_init POPModule::POP_init proc~pop_init->proc~layer_recruitment_single_patch proc~pop_init_single POPModule::POP_init_single proc~pop_init_single->proc~layer_recruitment_single_patch proc~popstep POPModule::POPStep proc~popstep->proc~getdiagnostics proc~popstep->proc~patchannualdynamics proc~popstep->proc~patch_disturb proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~pop_init_single proc~popdriver casa_cable::POPdriver proc~casaonly_luc->proc~popdriver proc~popdriver->proc~popstep proc~popluc_init POPLUC_Module::POPLUC_Init proc~popluc_init->proc~pop_init_single proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/get_allometry.html"},{"title":"INTERPOLATE_BIOMASS_1D – POP","text":"public  subroutine INTERPOLATE_BIOMASS_1D(POP, disturbance_interval, it, g) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: disturbance_interval (:,:) integer(kind=i4b), intent(in) :: it integer(kind=i4b), intent(in) :: g Calls proc~~interpolate_biomass_1d~~CallsGraph proc~interpolate_biomass_1d POPModule::INTERPOLATE_BIOMASS_1D pop_grid pop_grid proc~interpolate_biomass_1d->pop_grid proc~realexponential POPModule::REALExponential proc~interpolate_biomass_1d->proc~realexponential Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~interpolate_biomass_1d~~CalledByGraph proc~interpolate_biomass_1d POPModule::INTERPOLATE_BIOMASS_1D proc~getdiagnostics POPModule::GetDiagnostics proc~getdiagnostics->proc~interpolate_biomass_1d proc~popstep POPModule::POPStep proc~popstep->proc~getdiagnostics proc~popdriver casa_cable::POPdriver proc~popdriver->proc~popstep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/interpolate_biomass_1d.html"},{"title":"INTERPOLATE_FIREMORTALITY – POP","text":"public  subroutine INTERPOLATE_FIREMORTALITY(POP, disturbance_interval, it, g) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: disturbance_interval (:,:) integer(kind=i4b), intent(in) :: it integer(kind=i4b), intent(in) :: g Calls proc~~interpolate_firemortality~~CallsGraph proc~interpolate_firemortality POPModule::INTERPOLATE_FIREMORTALITY pop_grid pop_grid proc~interpolate_firemortality->pop_grid proc~realexponential POPModule::REALExponential proc~interpolate_firemortality->proc~realexponential Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~interpolate_firemortality~~CalledByGraph proc~interpolate_firemortality POPModule::INTERPOLATE_FIREMORTALITY proc~adjust_pop_for_fire POPModule::ADJUST_POP_FOR_FIRE proc~adjust_pop_for_fire->proc~interpolate_firemortality Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/interpolate_firemortality.html"},{"title":"ADJUST_POP_FOR_FIRE – POP","text":"public  subroutine ADJUST_POP_FOR_FIRE(pop, disturbance_interval, burned_area, FLI) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: pop integer(kind=i4b), intent(in) :: disturbance_interval (:,:) real(kind=dp), intent(in) :: burned_area (:) real(kind=dp), intent(in) :: FLI (:) Calls proc~~adjust_pop_for_fire~~CallsGraph proc~adjust_pop_for_fire POPModule::ADJUST_POP_FOR_FIRE pop_grid pop_grid proc~adjust_pop_for_fire->pop_grid proc~interpolate_firemortality POPModule::INTERPOLATE_FIREMORTALITY proc~adjust_pop_for_fire->proc~interpolate_firemortality proc~topkill_collins POPModule::TopKill_Collins proc~adjust_pop_for_fire->proc~topkill_collins proc~interpolate_firemortality->pop_grid proc~realexponential POPModule::REALExponential proc~interpolate_firemortality->proc~realexponential Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/adjust_pop_for_fire.html"},{"title":"INTERPOLATE_BIOMASS_2D – POP","text":"public  subroutine INTERPOLATE_BIOMASS_2D(POP, disturbance_interval, it, g) Uses mo_utils proc~~interpolate_biomass_2d~~UsesGraph proc~interpolate_biomass_2d POPModule::INTERPOLATE_BIOMASS_2D mo_utils mo_utils proc~interpolate_biomass_2d->mo_utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: disturbance_interval (:,:) integer(kind=i4b), intent(in) :: it integer(kind=i4b), intent(in) :: g Calls proc~~interpolate_biomass_2d~~CallsGraph proc~interpolate_biomass_2d POPModule::INTERPOLATE_BIOMASS_2D eq eq proc~interpolate_biomass_2d->eq pop_grid pop_grid proc~interpolate_biomass_2d->pop_grid proc~area_triangle POPModule::Area_Triangle proc~interpolate_biomass_2d->proc~area_triangle proc~realexponential POPModule::REALExponential proc~interpolate_biomass_2d->proc~realexponential Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~interpolate_biomass_2d~~CalledByGraph proc~interpolate_biomass_2d POPModule::INTERPOLATE_BIOMASS_2D proc~getdiagnostics POPModule::GetDiagnostics proc~getdiagnostics->proc~interpolate_biomass_2d proc~popstep POPModule::POPStep proc~popstep->proc~getdiagnostics proc~popdriver casa_cable::POPdriver proc~popdriver->proc~popstep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/interpolate_biomass_2d.html"},{"title":"SMOOTH_FLUX – POP","text":"public  subroutine SMOOTH_FLUX(POP, g, t) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: g integer(kind=i4b), intent(in) :: t Calls proc~~smooth_flux~~CallsGraph proc~smooth_flux POPModule::SMOOTH_FLUX pop_grid pop_grid proc~smooth_flux->pop_grid proc~regress POPModule::REGRESS proc~smooth_flux->proc~regress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~smooth_flux~~CalledByGraph proc~smooth_flux POPModule::SMOOTH_FLUX proc~getdiagnostics POPModule::GetDiagnostics proc~getdiagnostics->proc~smooth_flux proc~popstep POPModule::POPStep proc~popstep->proc~getdiagnostics proc~popdriver casa_cable::POPdriver proc~popdriver->proc~popstep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/smooth_flux.html"},{"title":"SMOOTH_FLUX_cat – POP","text":"public  subroutine SMOOTH_FLUX_cat(POP, g, t) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: g integer(kind=i4b), intent(in) :: t Calls proc~~smooth_flux_cat~~CallsGraph proc~smooth_flux_cat POPModule::SMOOTH_FLUX_cat pop_grid pop_grid proc~smooth_flux_cat->pop_grid proc~regress POPModule::REGRESS proc~smooth_flux_cat->proc~regress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/smooth_flux_cat.html"},{"title":"REGRESS – POP","text":"public  subroutine REGRESS(x, y, n, a, b, r) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(in) :: y (:) integer(kind=i4b), intent(in) :: n real(kind=dp), intent(out) :: a real(kind=dp), intent(out) :: b real(kind=dp), intent(out) :: r Called by proc~~regress~~CalledByGraph proc~regress POPModule::REGRESS proc~smooth_flux POPModule::SMOOTH_FLUX proc~smooth_flux->proc~regress proc~smooth_flux_cat POPModule::SMOOTH_FLUX_cat proc~smooth_flux_cat->proc~regress proc~getdiagnostics POPModule::GetDiagnostics proc~getdiagnostics->proc~smooth_flux proc~popstep POPModule::POPStep proc~popstep->proc~getdiagnostics proc~popdriver casa_cable::POPdriver proc~popdriver->proc~popstep proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/regress.html"},{"title":"Allometry – POP","text":"public  subroutine Allometry(height, biomass, density, diam, basal) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: height real(kind=dp), intent(in) :: biomass real(kind=dp), intent(in) :: density real(kind=dp), intent(out) :: diam real(kind=dp), intent(out) :: basal Called by proc~~allometry~~CalledByGraph proc~allometry POPModule::Allometry proc~get_allometry POPModule::GET_ALLOMETRY proc~get_allometry->proc~allometry proc~getdiagnostics POPModule::GetDiagnostics proc~getdiagnostics->proc~get_allometry proc~layer_recruitment POPModule::layer_recruitment proc~layer_recruitment->proc~get_allometry proc~layer_recruitment_single_patch POPModule::layer_recruitment_single_patch proc~layer_recruitment_single_patch->proc~get_allometry proc~patchannualdynamics POPModule::PatchAnnualDynamics proc~patchannualdynamics->proc~get_allometry proc~patchannualdynamics->proc~layer_recruitment proc~patch_disturb POPModule::Patch_disturb proc~patch_disturb->proc~layer_recruitment_single_patch proc~pop_init POPModule::POP_init proc~pop_init->proc~layer_recruitment_single_patch proc~pop_init_single POPModule::POP_init_single proc~pop_init_single->proc~layer_recruitment_single_patch proc~popstep POPModule::POPStep proc~popstep->proc~getdiagnostics proc~popstep->proc~patchannualdynamics proc~popstep->proc~patch_disturb proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~pop_init_single proc~popdriver casa_cable::POPdriver proc~casaonly_luc->proc~popdriver proc~popdriver->proc~popstep proc~popluc_init POPLUC_Module::POPLUC_Init proc~popluc_init->proc~pop_init_single proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/allometry.html"},{"title":"Williams_Allometry – POP","text":"public  subroutine Williams_Allometry(agbiomass, density, height, dbh, basal) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: agbiomass real(kind=dp), intent(in) :: density real(kind=dp), intent(out) :: height real(kind=dp), intent(out) :: dbh real(kind=dp), intent(out) :: basal Called by proc~~williams_allometry~~CalledByGraph proc~williams_allometry POPModule::Williams_Allometry proc~get_allometry POPModule::GET_ALLOMETRY proc~get_allometry->proc~williams_allometry proc~getdiagnostics POPModule::GetDiagnostics proc~getdiagnostics->proc~get_allometry proc~layer_recruitment POPModule::layer_recruitment proc~layer_recruitment->proc~get_allometry proc~layer_recruitment_single_patch POPModule::layer_recruitment_single_patch proc~layer_recruitment_single_patch->proc~get_allometry proc~patchannualdynamics POPModule::PatchAnnualDynamics proc~patchannualdynamics->proc~get_allometry proc~patchannualdynamics->proc~layer_recruitment proc~patch_disturb POPModule::Patch_disturb proc~patch_disturb->proc~layer_recruitment_single_patch proc~pop_init POPModule::POP_init proc~pop_init->proc~layer_recruitment_single_patch proc~pop_init_single POPModule::POP_init_single proc~pop_init_single->proc~layer_recruitment_single_patch proc~popstep POPModule::POPStep proc~popstep->proc~getdiagnostics proc~popstep->proc~patchannualdynamics proc~popstep->proc~patch_disturb proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~pop_init_single proc~popdriver casa_cable::POPdriver proc~casaonly_luc->proc~popdriver proc~popdriver->proc~popstep proc~popluc_init POPLUC_Module::POPLUC_Init proc~popluc_init->proc~pop_init_single proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/williams_allometry.html"},{"title":"POP_init – POP","text":"public  subroutine POP_init(POP, disturbance_interval, np, Iwood, precip) Uses POP_Types TypeDef proc~~pop_init~~UsesGraph proc~pop_init POPModule::POP_init module~pop_types POP_Types proc~pop_init->module~pop_types module~typedef TypeDef proc~pop_init->module~typedef module~pop_types->module~typedef module~pop_constants POP_Constants module~pop_types->module~pop_constants module~pop_constants->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: disturbance_interval (:,:) integer(kind=i4b), intent(in) :: np integer(kind=i4b), intent(in) :: Iwood (:) real(kind=dp), intent(in), optional :: precip (:) Calls proc~~pop_init~~CallsGraph proc~pop_init POPModule::POP_init proc~alloc_pop POPModule::alloc_POP proc~pop_init->proc~alloc_pop proc~initpop2d_poisson POPModule::InitPOP2D_Poisson proc~pop_init->proc~initpop2d_poisson proc~layer_recruitment_single_patch POPModule::layer_recruitment_single_patch proc~pop_init->proc~layer_recruitment_single_patch proc~zeropop POPModule::ZeroPOP proc~pop_init->proc~zeropop it_pop it_pop proc~alloc_pop->it_pop iwood iwood proc~alloc_pop->iwood pop_grid pop_grid proc~alloc_pop->pop_grid proc~initpop2d_poisson->pop_grid proc~cumexponential POPModule::CumExponential proc~initpop2d_poisson->proc~cumexponential proc~exponential POPModule::Exponential proc~initpop2d_poisson->proc~exponential proc~layer_recruitment_single_patch->pop_grid proc~get_allometry POPModule::GET_ALLOMETRY proc~layer_recruitment_single_patch->proc~get_allometry proc~allometry POPModule::Allometry proc~get_allometry->proc~allometry proc~getheight POPModule::GetHeight proc~get_allometry->proc~getheight proc~williams_allometry POPModule::Williams_Allometry proc~get_allometry->proc~williams_allometry Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/pop_init.html"},{"title":"POP_init_single – POP","text":"public  subroutine POP_init_single(POP, disturbance_interval, n, precip) Uses POP_Types TypeDef proc~~pop_init_single~~UsesGraph proc~pop_init_single POPModule::POP_init_single module~pop_types POP_Types proc~pop_init_single->module~pop_types module~typedef TypeDef proc~pop_init_single->module~typedef module~pop_types->module~typedef module~pop_constants POP_Constants module~pop_types->module~pop_constants module~pop_constants->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: disturbance_interval (:,:) integer(kind=i4b), intent(in) :: n real(kind=dp), intent(in), optional :: precip (:) Calls proc~~pop_init_single~~CallsGraph proc~pop_init_single POPModule::POP_init_single proc~initpop2d_poisson POPModule::InitPOP2D_Poisson proc~pop_init_single->proc~initpop2d_poisson proc~layer_recruitment_single_patch POPModule::layer_recruitment_single_patch proc~pop_init_single->proc~layer_recruitment_single_patch proc~zeropop POPModule::ZeroPOP proc~pop_init_single->proc~zeropop pop_grid pop_grid proc~initpop2d_poisson->pop_grid proc~cumexponential POPModule::CumExponential proc~initpop2d_poisson->proc~cumexponential proc~exponential POPModule::Exponential proc~initpop2d_poisson->proc~exponential proc~layer_recruitment_single_patch->pop_grid proc~get_allometry POPModule::GET_ALLOMETRY proc~layer_recruitment_single_patch->proc~get_allometry proc~allometry POPModule::Allometry proc~get_allometry->proc~allometry proc~getheight POPModule::GetHeight proc~get_allometry->proc~getheight proc~williams_allometry POPModule::Williams_Allometry proc~get_allometry->proc~williams_allometry Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pop_init_single~~CalledByGraph proc~pop_init_single POPModule::POP_init_single proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~pop_init_single proc~popluc_init POPLUC_Module::POPLUC_Init proc~popluc_init->proc~pop_init_single Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/pop_init_single.html"},{"title":"alloc_POP – POP","text":"public  subroutine alloc_POP(POP, arraysize) Uses POP_Types proc~~alloc_pop~~UsesGraph proc~alloc_pop POPModule::alloc_POP module~pop_types POP_Types proc~alloc_pop->module~pop_types module~pop_constants POP_Constants module~pop_types->module~pop_constants module~typedef TypeDef module~pop_types->module~typedef module~pop_constants->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer, intent(in) :: arraysize Calls proc~~alloc_pop~~CallsGraph proc~alloc_pop POPModule::alloc_POP it_pop it_pop proc~alloc_pop->it_pop iwood iwood proc~alloc_pop->iwood pop_grid pop_grid proc~alloc_pop->pop_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~alloc_pop~~CalledByGraph proc~alloc_pop POPModule::alloc_POP proc~pop_init POPModule::POP_init proc~pop_init->proc~alloc_pop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/alloc_pop.html"},{"title":"vcmax_np – POP","text":"public  function vcmax_np(nleaf, pleaf) Uses cable_def_types_mod proc~~vcmax_np~~UsesGraph proc~vcmax_np casa_cnp_module::vcmax_np cable_def_types_mod cable_def_types_mod proc~vcmax_np->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in) :: nleaf real(kind=r_2), intent(in) :: pleaf Return Value real(kind=r_2) Called by proc~~vcmax_np~~CalledByGraph proc~vcmax_np casa_cnp_module::vcmax_np proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~vcmax_np proc~casa_rplant casa_cnp_module::casa_rplant proc~casa_rplant->proc~vcmax_np proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_rplant proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/vcmax_np.html"},{"title":"casa_xnp – POP","text":"public  subroutine casa_xnp(xnplimit, xNPuptake, veg, casabiome, casapool, casaflux, casamet) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(out), DIMENSION(mp) :: xnplimit real(kind=r_2), intent(out), DIMENSION(mp) :: xNPuptake type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet Calls proc~~casa_xnp~~CallsGraph proc~casa_xnp casa_cnp_module::casa_xnp cgpp cgpp proc~casa_xnp->cgpp cnpp cnpp proc~casa_xnp->cnpp cplant cplant proc~casa_xnp->cplant fharvest fharvest proc~casa_xnp->fharvest fracclabile fracclabile proc~casa_xnp->fracclabile iveg iveg proc~casa_xnp->iveg iveg2 iveg2 proc~casa_xnp->iveg2 nplant nplant proc~casa_xnp->nplant nsoilmin nsoilmin proc~casa_xnp->nsoilmin pplant pplant proc~casa_xnp->pplant proc~casa_nrequire casa_cnp_module::casa_Nrequire proc~casa_xnp->proc~casa_nrequire proc~casa_prequire casa_cnp_module::casa_Prequire proc~casa_xnp->proc~casa_prequire psoillab psoillab proc~casa_xnp->psoillab xnpmax xnpmax proc~casa_xnp->xnpmax proc~casa_nrequire->cplant proc~casa_nrequire->iveg proc~casa_nrequire->iveg2 proc~casa_nrequire->nplant proc~casa_nrequire->nsoilmin fraccalloc fraccalloc proc~casa_nrequire->fraccalloc ftransnptol ftransnptol proc~casa_nrequire->ftransnptol kplant kplant proc~casa_nrequire->kplant rationcplantmax rationcplantmax proc~casa_nrequire->rationcplantmax rationcplantmin rationcplantmin proc~casa_nrequire->rationcplantmin proc~casa_prequire->cplant proc~casa_prequire->iveg proc~casa_prequire->iveg2 proc~casa_prequire->nplant proc~casa_prequire->pplant proc~casa_prequire->fraccalloc ftranspptol ftranspptol proc~casa_prequire->ftranspptol proc~casa_prequire->kplant rationpplantmax rationpplantmax proc~casa_prequire->rationpplantmax rationpplantmin rationpplantmin proc~casa_prequire->rationpplantmin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_xnp~~CalledByGraph proc~casa_xnp casa_cnp_module::casa_xnp proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_xnp proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_xnp.html"},{"title":"casa_allocation – POP","text":"public  subroutine casa_allocation(veg, soil, casabiome, casaflux, casapool, casamet, phen, LALLOC) vh_js !!\nvh_js !!\nas long as biomass is positive, adjust allocation to be\nproportional to stock when NPP -ve (Ticket#108)\nvh !! vh_js !!  Ticket#108 Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_biome ), intent(inout) :: casabiome type( casa_flux ), intent(inout) :: casaflux type( casa_pool ), intent(inout) :: casapool type( casa_met ), intent(inout) :: casamet type( phen_variable ), intent(inout) :: phen integer, intent(in) :: LALLOC Calls proc~~casa_allocation~~CallsGraph proc~casa_allocation casa_cnp_module::casa_allocation btran btran proc~casa_allocation->btran cplant cplant proc~casa_allocation->cplant crmplant crmplant proc~casa_allocation->crmplant fraccalloc fraccalloc proc~casa_allocation->fraccalloc fracnpptop fracnpptop proc~casa_allocation->fracnpptop glai glai proc~casa_allocation->glai glaimax glaimax proc~casa_allocation->glaimax glaimin glaimin proc~casa_allocation->glaimin iveg iveg proc~casa_allocation->iveg kplant_tot kplant_tot proc~casa_allocation->kplant_tot la_to_sa la_to_sa proc~casa_allocation->la_to_sa moistavg moistavg proc~casa_allocation->moistavg proc~casa_wolf casa_cnp_module::casa_wolf proc~casa_allocation->proc~casa_wolf sfc sfc proc~casa_allocation->sfc sla sla proc~casa_allocation->sla swilt swilt proc~casa_allocation->swilt tsoilavg tsoilavg proc~casa_allocation->tsoilavg proc~casa_wolf->cplant proc~casa_wolf->fracnpptop proc~casa_wolf->iveg cnpp cnpp proc~casa_wolf->cnpp iveg2 iveg2 proc~casa_wolf->iveg2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_allocation~~CalledByGraph proc~casa_allocation casa_cnp_module::casa_allocation proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_allocation proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_allocation.html"},{"title":"casa_wolf – POP","text":"public  subroutine casa_wolf(veg, casabiome, casaflux, casapool, casamet) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(in) :: veg type( casa_biome ), intent(in) :: casabiome type( casa_flux ), intent(inout) :: casaflux type( casa_pool ), intent(inout) :: casapool type( casa_met ), intent(in) :: casamet Calls proc~~casa_wolf~~CallsGraph proc~casa_wolf casa_cnp_module::casa_wolf cnpp cnpp proc~casa_wolf->cnpp cplant cplant proc~casa_wolf->cplant fracnpptop fracnpptop proc~casa_wolf->fracnpptop iveg iveg proc~casa_wolf->iveg iveg2 iveg2 proc~casa_wolf->iveg2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_wolf~~CalledByGraph proc~casa_wolf casa_cnp_module::casa_wolf proc~casa_allocation casa_cnp_module::casa_allocation proc~casa_allocation->proc~casa_wolf proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_allocation proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_wolf.html"},{"title":"casa_rplant – POP","text":"public  subroutine casa_rplant(veg, casabiome, casapool, casaflux, casamet, climate) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type(climate_type), intent(in) :: climate Calls proc~~casa_rplant~~CallsGraph proc~casa_rplant casa_cnp_module::casa_rplant cgpp cgpp proc~casa_rplant->cgpp clabile clabile proc~casa_rplant->clabile cplant cplant proc~casa_rplant->cplant crgplant crgplant proc~casa_rplant->crgplant crmplant crmplant proc~casa_rplant->crmplant frac_sapwood frac_sapwood proc~casa_rplant->frac_sapwood frec frec proc~casa_rplant->frec iveg iveg proc~casa_rplant->iveg kclabrate kclabrate proc~casa_rplant->kclabrate nplant nplant proc~casa_rplant->nplant proc~vcmax_np casa_cnp_module::vcmax_np proc~casa_rplant->proc~vcmax_np qtemp_max_last_year qtemp_max_last_year proc~casa_rplant->qtemp_max_last_year rationcplantmax rationcplantmax proc~casa_rplant->rationcplantmax ratiopcplantmax ratiopcplantmax proc~casa_rplant->ratiopcplantmax rmplant rmplant proc~casa_rplant->rmplant sla sla proc~casa_rplant->sla tairk tairk proc~casa_rplant->tairk tsoilavg tsoilavg proc~casa_rplant->tsoilavg vcmax vcmax proc~casa_rplant->vcmax vcmax_scalar vcmax_scalar proc~casa_rplant->vcmax_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_rplant~~CalledByGraph proc~casa_rplant casa_cnp_module::casa_rplant proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_rplant proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_rplant.html"},{"title":"casa_xrateplant – POP","text":"public  subroutine casa_xrateplant(xkleafcold, xkleafdry, xkleaf, veg, casabiome, casamet, phen) Uses mo_utils proc~~casa_xrateplant~~UsesGraph proc~casa_xrateplant casa_cnp_module::casa_xrateplant mo_utils mo_utils proc~casa_xrateplant->mo_utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(out), DIMENSION(mp) :: xkleafcold real(kind=r_2), intent(out), DIMENSION(mp) :: xkleafdry real(kind=r_2), intent(out), DIMENSION(mp) :: xkleaf type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_met ), intent(inout) :: casamet type( phen_variable ), intent(inout) :: phen Calls proc~~casa_xrateplant~~CallsGraph proc~casa_xrateplant casa_cnp_module::casa_xrateplant btran btran proc~casa_xrateplant->btran ge ge proc~casa_xrateplant->ge iveg iveg proc~casa_xrateplant->iveg iveg2 iveg2 proc~casa_xrateplant->iveg2 le le proc~casa_xrateplant->le lnonwood lnonwood proc~casa_xrateplant->lnonwood phase phase proc~casa_xrateplant->phase tairk tairk proc~casa_xrateplant->tairk tkshed tkshed proc~casa_xrateplant->tkshed xkleafcoldexp xkleafcoldexp proc~casa_xrateplant->xkleafcoldexp xkleafcoldmax xkleafcoldmax proc~casa_xrateplant->xkleafcoldmax xkleafdryexp xkleafdryexp proc~casa_xrateplant->xkleafdryexp xkleafdrymax xkleafdrymax proc~casa_xrateplant->xkleafdrymax Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_xrateplant~~CalledByGraph proc~casa_xrateplant casa_cnp_module::casa_xrateplant proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_xrateplant proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_xrateplant.html"},{"title":"casa_xratesoil – POP","text":"public  subroutine casa_xratesoil(xklitter, xksoil, veg, soil, casamet, casabiome) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(out), DIMENSION(mp) :: xklitter real(kind=r_2), intent(out), DIMENSION(mp) :: xksoil type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_met ), intent(inout) :: casamet type( casa_biome ), intent(inout) :: casabiome Calls proc~~casa_xratesoil~~CallsGraph proc~casa_xratesoil casa_cnp_module::casa_xratesoil damm_alpha damm_alpha proc~casa_xratesoil->damm_alpha damm_ea damm_ea proc~casa_xratesoil->damm_ea damm_enzpool damm_enzpool proc~casa_xratesoil->damm_enzpool damm_kmcp damm_kmcp proc~casa_xratesoil->damm_kmcp damm_kmo2 damm_kmo2 proc~casa_xratesoil->damm_kmo2 iveg iveg proc~casa_xratesoil->iveg iveg2 iveg2 proc~casa_xratesoil->iveg2 moistavg moistavg proc~casa_xratesoil->moistavg q10soil q10soil proc~casa_xratesoil->q10soil ssat ssat proc~casa_xratesoil->ssat tsoilavg tsoilavg proc~casa_xratesoil->tsoilavg xkoptlitter xkoptlitter proc~casa_xratesoil->xkoptlitter xkoptsoil xkoptsoil proc~casa_xratesoil->xkoptsoil Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_xratesoil~~CalledByGraph proc~casa_xratesoil casa_cnp_module::casa_xratesoil proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_xratesoil proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_xratesoil.html"},{"title":"casa_coeffplant – POP","text":"public  subroutine casa_coeffplant(xkleafcold, xkleafdry, xkleaf, veg, casabiome, casapool, casaflux, casamet) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in), dimension(mp) :: xkleafcold real(kind=r_2), intent(in), dimension(mp) :: xkleafdry real(kind=r_2), intent(in), dimension(mp) :: xkleaf type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet Calls proc~~casa_coeffplant~~CallsGraph proc~casa_coeffplant casa_cnp_module::casa_coeffplant cplant cplant proc~casa_coeffplant->cplant fracligninplant fracligninplant proc~casa_coeffplant->fracligninplant fromptol fromptol proc~casa_coeffplant->fromptol ftransnptol ftransnptol proc~casa_coeffplant->ftransnptol glai glai proc~casa_coeffplant->glai glaimin glaimin proc~casa_coeffplant->glaimin iveg iveg proc~casa_coeffplant->iveg kplant kplant proc~casa_coeffplant->kplant kplant_fire kplant_fire proc~casa_coeffplant->kplant_fire nplant nplant proc~casa_coeffplant->nplant plantrate plantrate proc~casa_coeffplant->plantrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_coeffplant~~CalledByGraph proc~casa_coeffplant casa_cnp_module::casa_coeffplant proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_coeffplant proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_coeffplant.html"},{"title":"casa_coeffsoil – POP","text":"public  subroutine casa_coeffsoil(xklitter, xksoil, veg, soil, casabiome, casaflux, casamet) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in), dimension(mp) :: xklitter real(kind=r_2), intent(in), dimension(mp) :: xksoil type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_biome ), intent(inout) :: casabiome type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet Calls proc~~casa_coeffsoil~~CallsGraph proc~casa_coeffsoil casa_cnp_module::casa_coeffsoil clay clay proc~casa_coeffsoil->clay fracligninplant fracligninplant proc~casa_coeffsoil->fracligninplant fromltoco2 fromltoco2 proc~casa_coeffsoil->fromltoco2 fromltos fromltos proc~casa_coeffsoil->fromltos fromstoco2 fromstoco2 proc~casa_coeffsoil->fromstoco2 fromstos fromstos proc~casa_coeffsoil->fromstos isorder isorder proc~casa_coeffsoil->isorder iveg iveg proc~casa_coeffsoil->iveg iveg2 iveg2 proc~casa_coeffsoil->iveg2 klitter klitter proc~casa_coeffsoil->klitter klitter_fire klitter_fire proc~casa_coeffsoil->klitter_fire ksoil ksoil proc~casa_coeffsoil->ksoil litterrate litterrate proc~casa_coeffsoil->litterrate silt silt proc~casa_coeffsoil->silt soilrate soilrate proc~casa_coeffsoil->soilrate xkplab xkplab proc~casa_coeffsoil->xkplab xkpocc xkpocc proc~casa_coeffsoil->xkpocc xkpsorb xkpsorb proc~casa_coeffsoil->xkpsorb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_coeffsoil~~CalledByGraph proc~casa_coeffsoil casa_cnp_module::casa_coeffsoil proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_coeffsoil proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_coeffsoil.html"},{"title":"casa_delplant – POP","text":"public  subroutine casa_delplant(veg, casabiome, casapool, casaflux, casamet, cleaf2met, cleaf2str, croot2met, croot2str, cwood2cwd, nleaf2met, nleaf2str, nroot2met, nroot2str, nwood2cwd, pleaf2met, pleaf2str, proot2met, proot2str, pwood2cwd) vh_js !! vh_js !! end of adjustments to avoid negative stocks Ticket#108 Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet real(kind=r_2), intent(out), dimension(mp) :: cleaf2met real(kind=r_2), intent(out), dimension(mp) :: cleaf2str real(kind=r_2), intent(out), dimension(mp) :: croot2met real(kind=r_2), intent(out), dimension(mp) :: croot2str real(kind=r_2), intent(out), dimension(mp) :: cwood2cwd real(kind=r_2), intent(out), dimension(mp) :: nleaf2met real(kind=r_2), intent(out), dimension(mp) :: nleaf2str real(kind=r_2), intent(out), dimension(mp) :: nroot2met real(kind=r_2), intent(out), dimension(mp) :: nroot2str real(kind=r_2), intent(out), dimension(mp) :: nwood2cwd real(kind=r_2), intent(out), dimension(mp) :: pleaf2met real(kind=r_2), intent(out), dimension(mp) :: pleaf2str real(kind=r_2), intent(out), dimension(mp) :: proot2met real(kind=r_2), intent(out), dimension(mp) :: proot2str real(kind=r_2), intent(out), dimension(mp) :: pwood2cwd Calls proc~~casa_delplant~~CallsGraph proc~casa_delplant casa_cnp_module::casa_delplant cgpp cgpp proc~casa_delplant->cgpp charvest charvest proc~casa_delplant->charvest clabloss clabloss proc~casa_delplant->clabloss cnpp cnpp proc~casa_delplant->cnpp cplant cplant proc~casa_delplant->cplant crgplant crgplant proc~casa_delplant->crgplant crmplant crmplant proc~casa_delplant->crmplant dcplantdt dcplantdt proc~casa_delplant->dcplantdt dnplantdt dnplantdt proc~casa_delplant->dnplantdt dpplantdt dpplantdt proc~casa_delplant->dpplantdt fharvest fharvest proc~casa_delplant->fharvest fluxctoco2_plant_fire fluxctoco2_plant_fire proc~casa_delplant->fluxctoco2_plant_fire fluxctolitter fluxctolitter proc~casa_delplant->fluxctolitter fluxfromptoco2 fluxfromptoco2 proc~casa_delplant->fluxfromptoco2 fluxfromptoharvest fluxfromptoharvest proc~casa_delplant->fluxfromptoharvest fluxntolitter fluxntolitter proc~casa_delplant->fluxntolitter fluxptolitter fluxptolitter proc~casa_delplant->fluxptolitter fraccalloc fraccalloc proc~casa_delplant->fraccalloc fracclabile fracclabile proc~casa_delplant->fracclabile fracnalloc fracnalloc proc~casa_delplant->fracnalloc fracpalloc fracpalloc proc~casa_delplant->fracpalloc fromptol fromptol proc~casa_delplant->fromptol fromptol_fire fromptol_fire proc~casa_delplant->fromptol_fire ftransnptol ftransnptol proc~casa_delplant->ftransnptol ftranspptol ftranspptol proc~casa_delplant->ftranspptol iveg iveg proc~casa_delplant->iveg iveg2 iveg2 proc~casa_delplant->iveg2 kplant kplant proc~casa_delplant->kplant kplant_fire kplant_fire proc~casa_delplant->kplant_fire kplant_tot kplant_tot proc~casa_delplant->kplant_tot lnonwood lnonwood proc~casa_delplant->lnonwood nharvest nharvest proc~casa_delplant->nharvest nminuptake nminuptake proc~casa_delplant->nminuptake nplant nplant proc~casa_delplant->nplant pharvest pharvest proc~casa_delplant->pharvest plabuptake plabuptake proc~casa_delplant->plabuptake pplant pplant proc~casa_delplant->pplant Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_delplant~~CalledByGraph proc~casa_delplant casa_cnp_module::casa_delplant proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_delplant proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_delplant.html"},{"title":"casa_delsoil – POP","text":"public  subroutine casa_delsoil(veg, casapool, casaflux, casamet, casabiome) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( casa_biome ), intent(inout) :: casabiome Calls proc~~casa_delsoil~~CallsGraph proc~casa_delsoil casa_cnp_module::casa_delsoil clitter clitter proc~casa_delsoil->clitter cnpp cnpp proc~casa_delsoil->cnpp costnpup costnpup proc~casa_delsoil->costnpup crsoil crsoil proc~casa_delsoil->crsoil csoil csoil proc~casa_delsoil->csoil dpsoillabdt dpsoillabdt proc~casa_delsoil->dpsoillabdt fluxctoco2 fluxctoco2 proc~casa_delsoil->fluxctoco2 fluxctoco2_litter_fire fluxctoco2_litter_fire proc~casa_delsoil->fluxctoco2_litter_fire fluxctolitter fluxctolitter proc~casa_delsoil->fluxctolitter fluxctosoil fluxctosoil proc~casa_delsoil->fluxctosoil fluxfromltoco2 fluxfromltoco2 proc~casa_delsoil->fluxfromltoco2 fluxfromltos fluxfromltos proc~casa_delsoil->fluxfromltos fluxfromstoco2 fluxfromstoco2 proc~casa_delsoil->fluxfromstoco2 fluxfromstos fluxfromstos proc~casa_delsoil->fluxfromstos fluxntolitter fluxntolitter proc~casa_delsoil->fluxntolitter fluxntosoil fluxntosoil proc~casa_delsoil->fluxntosoil fluxptolitter fluxptolitter proc~casa_delsoil->fluxptolitter fluxptosoil fluxptosoil proc~casa_delsoil->fluxptosoil fnminleach fnminleach proc~casa_delsoil->fnminleach fnminloss fnminloss proc~casa_delsoil->fnminloss fpleach fpleach proc~casa_delsoil->fpleach fromltoco2 fromltoco2 proc~casa_delsoil->fromltoco2 fromltos fromltos proc~casa_delsoil->fromltos fromstoco2 fromstoco2 proc~casa_delsoil->fromstoco2 fromstos fromstos proc~casa_delsoil->fromstos iveg iveg proc~casa_delsoil->iveg iveg2 iveg2 proc~casa_delsoil->iveg2 klitter klitter proc~casa_delsoil->klitter klitter_fire klitter_fire proc~casa_delsoil->klitter_fire klitter_tot klitter_tot proc~casa_delsoil->klitter_tot kmlabp kmlabp proc~casa_delsoil->kmlabp kpocc kpocc proc~casa_delsoil->kpocc kpsorb kpsorb proc~casa_delsoil->kpsorb ksoil ksoil proc~casa_delsoil->ksoil nlitter nlitter proc~casa_delsoil->nlitter nlittermin nlittermin proc~casa_delsoil->nlittermin nmindep nmindep proc~casa_delsoil->nmindep nminfix nminfix proc~casa_delsoil->nminfix nminleach nminleach proc~casa_delsoil->nminleach nminloss nminloss proc~casa_delsoil->nminloss nsimm nsimm proc~casa_delsoil->nsimm nsmin nsmin proc~casa_delsoil->nsmin nsnet nsnet proc~casa_delsoil->nsnet nsoil nsoil proc~casa_delsoil->nsoil nsoilmin nsoilmin proc~casa_delsoil->nsoilmin nupland nupland proc~casa_delsoil->nupland pdep pdep proc~casa_delsoil->pdep pleach pleach proc~casa_delsoil->pleach plitter plitter proc~casa_delsoil->plitter plittermin plittermin proc~casa_delsoil->plittermin prodptase prodptase proc~casa_delsoil->prodptase psimm psimm proc~casa_delsoil->psimm psmin psmin proc~casa_delsoil->psmin psnet psnet proc~casa_delsoil->psnet psoil psoil proc~casa_delsoil->psoil psoillab psoillab proc~casa_delsoil->psoillab psoilocc psoilocc proc~casa_delsoil->psoilocc psoilsorb psoilsorb proc~casa_delsoil->psoilsorb psorbmax psorbmax proc~casa_delsoil->psorbmax pupland pupland proc~casa_delsoil->pupland pwea pwea proc~casa_delsoil->pwea rationcsoilnew rationcsoilnew proc~casa_delsoil->rationcsoilnew rationpsoil rationpsoil proc~casa_delsoil->rationpsoil tsoilavg tsoilavg proc~casa_delsoil->tsoilavg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_delsoil~~CalledByGraph proc~casa_delsoil casa_cnp_module::casa_delsoil proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_delsoil proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_delsoil.html"},{"title":"avgsoil – POP","text":"public  subroutine avgsoil(veg, soil, casamet) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_met ), intent(inout) :: casamet Calls proc~~avgsoil~~CallsGraph proc~avgsoil casa_cnp_module::avgsoil btran btran proc~avgsoil->btran moist moist proc~avgsoil->moist moistavg moistavg proc~avgsoil->moistavg tsoilavg tsoilavg proc~avgsoil->tsoilavg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~avgsoil~~CalledByGraph proc~avgsoil casa_cnp_module::avgsoil proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~avgsoil proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/avgsoil.html"},{"title":"casa_xkN – POP","text":"public  subroutine casa_xkN(xkNlimiting, casapool, casaflux, casamet, casabiome, veg) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(inout), DIMENSION(mp) :: xkNlimiting type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( casa_biome ), intent(inout) :: casabiome type(veg_parameter_type), intent(in) :: veg Calls proc~~casa_xkn~~CallsGraph proc~casa_xkn casa_cnp_module::casa_xkN clitter clitter proc~casa_xkn->clitter csoil csoil proc~casa_xkn->csoil fromltos fromltos proc~casa_xkn->fromltos fromstos fromstos proc~casa_xkn->fromstos iveg iveg proc~casa_xkn->iveg iveg2 iveg2 proc~casa_xkn->iveg2 klitter klitter proc~casa_xkn->klitter ksoil ksoil proc~casa_xkn->ksoil maxcwd maxcwd proc~casa_xkn->maxcwd maxfinelitter maxfinelitter proc~casa_xkn->maxfinelitter nlitter nlitter proc~casa_xkn->nlitter nsoil nsoil proc~casa_xkn->nsoil nsoilmin nsoilmin proc~casa_xkn->nsoilmin rationcsoilmax rationcsoilmax proc~casa_xkn->rationcsoilmax rationcsoilmin rationcsoilmin proc~casa_xkn->rationcsoilmin rationcsoilnew rationcsoilnew proc~casa_xkn->rationcsoilnew Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_xkn~~CalledByGraph proc~casa_xkn casa_cnp_module::casa_xkN proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_xkn proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_xkn.html"},{"title":"casa_nuptake – POP","text":"public  subroutine casa_nuptake(veg, xkNlimiting, casabiome, casapool, casaflux, casamet) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg real(kind=r_2), intent(in), DIMENSION(mp) :: xkNlimiting type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet Calls proc~~casa_nuptake~~CallsGraph proc~casa_nuptake casa_cnp_module::casa_nuptake iveg iveg proc~casa_nuptake->iveg iveg2 iveg2 proc~casa_nuptake->iveg2 kminn kminn proc~casa_nuptake->kminn nminuptake nminuptake proc~casa_nuptake->nminuptake nsoilmin nsoilmin proc~casa_nuptake->nsoilmin proc~casa_nrequire casa_cnp_module::casa_Nrequire proc~casa_nuptake->proc~casa_nrequire proc~casa_nrequire->iveg proc~casa_nrequire->iveg2 proc~casa_nrequire->nsoilmin cplant cplant proc~casa_nrequire->cplant fraccalloc fraccalloc proc~casa_nrequire->fraccalloc ftransnptol ftransnptol proc~casa_nrequire->ftransnptol kplant kplant proc~casa_nrequire->kplant nplant nplant proc~casa_nrequire->nplant rationcplantmax rationcplantmax proc~casa_nrequire->rationcplantmax rationcplantmin rationcplantmin proc~casa_nrequire->rationcplantmin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_nuptake~~CalledByGraph proc~casa_nuptake casa_cnp_module::casa_nuptake proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_nuptake proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_nuptake.html"},{"title":"casa_Nrequire – POP","text":"public  subroutine casa_Nrequire(xnCnpp, Nreqmin, Nreqmax, NtransPtoP, veg, casabiome, casapool, casaflux, casamet) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in), DIMENSION(mp) :: xnCnpp real(kind=r_2), intent(inout), DIMENSION(mp,mplant) :: Nreqmin real(kind=r_2), intent(inout), DIMENSION(mp,mplant) :: Nreqmax real(kind=r_2), intent(inout), DIMENSION(mp,mplant) :: NtransPtoP type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet Calls proc~~casa_nrequire~~CallsGraph proc~casa_nrequire casa_cnp_module::casa_Nrequire cplant cplant proc~casa_nrequire->cplant fraccalloc fraccalloc proc~casa_nrequire->fraccalloc ftransnptol ftransnptol proc~casa_nrequire->ftransnptol iveg iveg proc~casa_nrequire->iveg iveg2 iveg2 proc~casa_nrequire->iveg2 kplant kplant proc~casa_nrequire->kplant nplant nplant proc~casa_nrequire->nplant nsoilmin nsoilmin proc~casa_nrequire->nsoilmin rationcplantmax rationcplantmax proc~casa_nrequire->rationcplantmax rationcplantmin rationcplantmin proc~casa_nrequire->rationcplantmin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_nrequire~~CalledByGraph proc~casa_nrequire casa_cnp_module::casa_Nrequire proc~casa_nuptake casa_cnp_module::casa_nuptake proc~casa_nuptake->proc~casa_nrequire proc~casa_xnp casa_cnp_module::casa_xnp proc~casa_xnp->proc~casa_nrequire proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_nuptake proc~biogeochem->proc~casa_xnp proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_nrequire.html"},{"title":"casa_puptake – POP","text":"public  subroutine casa_puptake(veg, xkNlimiting, casabiome, casapool, casaflux, casamet) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg real(kind=r_2), intent(in), DIMENSION(mp) :: xkNlimiting type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet Calls proc~~casa_puptake~~CallsGraph proc~casa_puptake casa_cnp_module::casa_puptake iveg iveg proc~casa_puptake->iveg kuplabp kuplabp proc~casa_puptake->kuplabp plabuptake plabuptake proc~casa_puptake->plabuptake proc~casa_prequire casa_cnp_module::casa_Prequire proc~casa_puptake->proc~casa_prequire psoillab psoillab proc~casa_puptake->psoillab proc~casa_prequire->iveg cplant cplant proc~casa_prequire->cplant fraccalloc fraccalloc proc~casa_prequire->fraccalloc ftranspptol ftranspptol proc~casa_prequire->ftranspptol iveg2 iveg2 proc~casa_prequire->iveg2 kplant kplant proc~casa_prequire->kplant nplant nplant proc~casa_prequire->nplant pplant pplant proc~casa_prequire->pplant rationpplantmax rationpplantmax proc~casa_prequire->rationpplantmax rationpplantmin rationpplantmin proc~casa_prequire->rationpplantmin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_puptake~~CalledByGraph proc~casa_puptake casa_cnp_module::casa_puptake proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_puptake proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_puptake.html"},{"title":"casa_Prequire – POP","text":"public  subroutine casa_Prequire(xpCnpp, Preqmin, Preqmax, PtransPtoP, veg, casabiome, casapool, casaflux, casamet) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in), DIMENSION(mp) :: xpCnpp real(kind=r_2), intent(inout), DIMENSION(mp,mplant) :: Preqmin real(kind=r_2), intent(inout), DIMENSION(mp,mplant) :: Preqmax real(kind=r_2), intent(inout), DIMENSION(mp,mplant) :: PtransPtoP type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet Calls proc~~casa_prequire~~CallsGraph proc~casa_prequire casa_cnp_module::casa_Prequire cplant cplant proc~casa_prequire->cplant fraccalloc fraccalloc proc~casa_prequire->fraccalloc ftranspptol ftranspptol proc~casa_prequire->ftranspptol iveg iveg proc~casa_prequire->iveg iveg2 iveg2 proc~casa_prequire->iveg2 kplant kplant proc~casa_prequire->kplant nplant nplant proc~casa_prequire->nplant pplant pplant proc~casa_prequire->pplant rationpplantmax rationpplantmax proc~casa_prequire->rationpplantmax rationpplantmin rationpplantmin proc~casa_prequire->rationpplantmin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_prequire~~CalledByGraph proc~casa_prequire casa_cnp_module::casa_Prequire proc~casa_puptake casa_cnp_module::casa_puptake proc~casa_puptake->proc~casa_prequire proc~casa_xnp casa_cnp_module::casa_xnp proc~casa_xnp->proc~casa_prequire proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_puptake proc~biogeochem->proc~casa_xnp proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_prequire.html"},{"title":"casa_cnpcycle – POP","text":"public  subroutine casa_cnpcycle(veg, casabiome, casapool, casaflux, casamet) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet Calls proc~~casa_cnpcycle~~CallsGraph proc~casa_cnpcycle casa_cnp_module::casa_cnpcycle clabile clabile proc~casa_cnpcycle->clabile clitter clitter proc~casa_cnpcycle->clitter cplant cplant proc~casa_cnpcycle->cplant csoil csoil proc~casa_cnpcycle->csoil dclabiledt dclabiledt proc~casa_cnpcycle->dclabiledt dclitterdt dclitterdt proc~casa_cnpcycle->dclitterdt dcplantdt dcplantdt proc~casa_cnpcycle->dcplantdt dcsoildt dcsoildt proc~casa_cnpcycle->dcsoildt dnlitterdt dnlitterdt proc~casa_cnpcycle->dnlitterdt dnplantdt dnplantdt proc~casa_cnpcycle->dnplantdt dnsoildt dnsoildt proc~casa_cnpcycle->dnsoildt dnsoilmindt dnsoilmindt proc~casa_cnpcycle->dnsoilmindt dplitterdt dplitterdt proc~casa_cnpcycle->dplitterdt dpplantdt dpplantdt proc~casa_cnpcycle->dpplantdt dpsoildt dpsoildt proc~casa_cnpcycle->dpsoildt dpsoillabdt dpsoillabdt proc~casa_cnpcycle->dpsoillabdt dpsoiloccdt dpsoiloccdt proc~casa_cnpcycle->dpsoiloccdt glai glai proc~casa_cnpcycle->glai glaimax glaimax proc~casa_cnpcycle->glaimax glaimin glaimin proc~casa_cnpcycle->glaimin iveg iveg proc~casa_cnpcycle->iveg iveg2 iveg2 proc~casa_cnpcycle->iveg2 kmlabp kmlabp proc~casa_cnpcycle->kmlabp lat lat proc~casa_cnpcycle->lat lon lon proc~casa_cnpcycle->lon nlitter nlitter proc~casa_cnpcycle->nlitter nplant nplant proc~casa_cnpcycle->nplant nsoil nsoil proc~casa_cnpcycle->nsoil nsoilmin nsoilmin proc~casa_cnpcycle->nsoilmin plitter plitter proc~casa_cnpcycle->plitter pplant pplant proc~casa_cnpcycle->pplant proc~casa_poolzero casa_cnp_module::casa_poolzero proc~casa_cnpcycle->proc~casa_poolzero psoil psoil proc~casa_cnpcycle->psoil psoillab psoillab proc~casa_cnpcycle->psoillab psoilocc psoilocc proc~casa_cnpcycle->psoilocc psorbmax psorbmax proc~casa_cnpcycle->psorbmax rationcplantmax rationcplantmax proc~casa_cnpcycle->rationcplantmax sla sla proc~casa_cnpcycle->sla proc~casa_poolzero->clitter proc~casa_poolzero->cplant proc~casa_poolzero->csoil proc~casa_poolzero->nlitter proc~casa_poolzero->nplant proc~casa_poolzero->nsoil Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_cnpcycle~~CalledByGraph proc~casa_cnpcycle casa_cnp_module::casa_cnpcycle proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_cnpcycle proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_cnpcycle.html"},{"title":"casa_poolzero – POP","text":"public  subroutine casa_poolzero(n, ipool, casapool) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: ipool type( casa_pool ), intent(inout) :: casapool Calls proc~~casa_poolzero~~CallsGraph proc~casa_poolzero casa_cnp_module::casa_poolzero clitter clitter proc~casa_poolzero->clitter cplant cplant proc~casa_poolzero->cplant csoil csoil proc~casa_poolzero->csoil nlitter nlitter proc~casa_poolzero->nlitter nplant nplant proc~casa_poolzero->nplant nsoil nsoil proc~casa_poolzero->nsoil Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_poolzero~~CalledByGraph proc~casa_poolzero casa_cnp_module::casa_poolzero proc~casa_cnpcycle casa_cnp_module::casa_cnpcycle proc~casa_cnpcycle->proc~casa_poolzero proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_cnpcycle proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_poolzero.html"},{"title":"casa_cnpbal – POP","text":"public  subroutine casa_cnpbal(casapool, casaflux, casabal, idoy) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_balance ), intent(inout) :: casabal integer, intent(in) :: idoy Calls proc~~casa_cnpbal~~CallsGraph proc~casa_cnpbal casa_cnp_module::casa_cnpbal clabile clabile proc~casa_cnpbal->clabile clabilelast clabilelast proc~casa_cnpbal->clabilelast clitterlast clitterlast proc~casa_cnpbal->clitterlast cnpp cnpp proc~casa_cnpbal->cnpp cplant cplant proc~casa_cnpbal->cplant cplantlast cplantlast proc~casa_cnpbal->cplantlast crsoil crsoil proc~casa_cnpbal->crsoil fharvest fharvest proc~casa_cnpbal->fharvest fluxctoco2_plant_fire fluxctoco2_plant_fire proc~casa_cnpbal->fluxctoco2_plant_fire fluxctolitter fluxctolitter proc~casa_cnpbal->fluxctolitter fluxfromptoco2 fluxfromptoco2 proc~casa_cnpbal->fluxfromptoco2 fromptol_fire fromptol_fire proc~casa_cnpbal->fromptol_fire klitter klitter proc~casa_cnpbal->klitter klitter_fire klitter_fire proc~casa_cnpbal->klitter_fire klitter_tot klitter_tot proc~casa_cnpbal->klitter_tot kplant kplant proc~casa_cnpbal->kplant kplant_fire kplant_fire proc~casa_cnpbal->kplant_fire kplant_tot kplant_tot proc~casa_cnpbal->kplant_tot nmindep nmindep proc~casa_cnpbal->nmindep nminfix nminfix proc~casa_cnpbal->nminfix nminleach nminleach proc~casa_cnpbal->nminleach nminloss nminloss proc~casa_cnpbal->nminloss nminuptake nminuptake proc~casa_cnpbal->nminuptake nsoilmin nsoilmin proc~casa_cnpbal->nsoilmin nsoilminlast nsoilminlast proc~casa_cnpbal->nsoilminlast nupland nupland proc~casa_cnpbal->nupland pdep pdep proc~casa_cnpbal->pdep plabuptake plabuptake proc~casa_cnpbal->plabuptake pleach pleach proc~casa_cnpbal->pleach ploss ploss proc~casa_cnpbal->ploss psoillab psoillab proc~casa_cnpbal->psoillab psoillablast psoillablast proc~casa_cnpbal->psoillablast psoilocc psoilocc proc~casa_cnpbal->psoilocc psoilocclast psoilocclast proc~casa_cnpbal->psoilocclast psoilsorb psoilsorb proc~casa_cnpbal->psoilsorb psoilsorblast psoilsorblast proc~casa_cnpbal->psoilsorblast pupland pupland proc~casa_cnpbal->pupland pwea pwea proc~casa_cnpbal->pwea Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_cnpbal~~CalledByGraph proc~casa_cnpbal casa_cnp_module::casa_cnpbal proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_cnpbal proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_cnpbal.html"},{"title":"casa_ndummy – POP","text":"public  subroutine casa_ndummy(casapool) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: casapool Calls proc~~casa_ndummy~~CallsGraph proc~casa_ndummy casa_cnp_module::casa_ndummy cplant cplant proc~casa_ndummy->cplant rationcplant rationcplant proc~casa_ndummy->rationcplant Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_ndummy~~CalledByGraph proc~casa_ndummy casa_cnp_module::casa_ndummy proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_ndummy proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_ndummy.html"},{"title":"casa_pdummy – POP","text":"public  subroutine casa_pdummy(casapool) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: casapool Calls proc~~casa_pdummy~~CallsGraph proc~casa_pdummy casa_cnp_module::casa_pdummy nplant nplant proc~casa_pdummy->nplant rationpplant rationpplant proc~casa_pdummy->rationpplant Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~casa_pdummy~~CalledByGraph proc~casa_pdummy casa_cnp_module::casa_pdummy proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~casa_pdummy proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_pdummy.html"},{"title":"phenology – POP","text":"public  subroutine phenology(iday, veg, phen) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iday type(veg_parameter_type), intent(inout) :: veg type( phen_variable ), intent(inout) :: phen Calls proc~~phenology~~CallsGraph proc~phenology casa_cnp_module::phenology doyphase doyphase proc~phenology->doyphase phase phase proc~phenology->phase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~phenology~~CalledByGraph proc~phenology casa_cnp_module::phenology proc~biogeochem casa_inout::biogeochem proc~biogeochem->proc~phenology proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->proc~biogeochem proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~biogeochem proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~biogeochem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/phenology.html"},{"title":"adjust_JV_gm – POP","text":"public  subroutine adjust_JV_gm(veg, p) 1) Calculate An-Ci curve\n2) Exclude negative parts of the An-Ci curve\nAvoid unrealistic Vcmax and Jmax values Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg integer, intent(in) :: p Calls proc~~adjust_jv_gm~~CallsGraph proc~adjust_jv_gm cable_adjust_JV_gm_module::adjust_JV_gm cfrd cfrd proc~adjust_jv_gm->cfrd ejmax ejmax proc~adjust_jv_gm->ejmax frac4 frac4 proc~adjust_jv_gm->frac4 gm gm proc~adjust_jv_gm->gm light_inhibition light_inhibition proc~adjust_jv_gm->light_inhibition lmdif1 lmdif1 proc~adjust_jv_gm->lmdif1 point2constants point2constants proc~adjust_jv_gm->point2constants proc~photosyn25 cable_adjust_JV_gm_module::photosyn25 proc~adjust_jv_gm->proc~photosyn25 vcmax vcmax proc~adjust_jv_gm->vcmax Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~adjust_jv_gm~~CalledByGraph proc~adjust_jv_gm cable_adjust_JV_gm_module::adjust_JV_gm proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~adjust_jv_gm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/adjust_jv_gm.html"},{"title":"photosyn25_f – POP","text":"public  subroutine photosyn25_f(M, N, X, fvec, iflag, Anx, Cix, Rd, Km, gammastar) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N real(kind=dp), intent(inout), dimension(N) :: X real(kind=dp), intent(out), dimension(M) :: fvec integer, intent(in) :: iflag real(kind=dp), intent(in), dimension(M) :: Anx real(kind=dp), intent(in), dimension(M) :: Cix real(kind=dp), intent(in) :: Rd real(kind=dp), intent(in) :: Km real(kind=dp), intent(in) :: gammastar Contents","tags":"","loc":"proc/photosyn25_f.html"},{"title":"photosyn25 – POP","text":"public  subroutine photosyn25(Ciz, nrci, Vcmax25, Jmax25, Rd, Km, gammastar, Anz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(nrci) :: Ciz integer, intent(in) :: nrci real(kind=dp), intent(in) :: Vcmax25 real(kind=dp), intent(in) :: Jmax25 real(kind=dp), intent(in) :: Rd real(kind=dp), intent(in) :: Km real(kind=dp), intent(in) :: gammastar real(kind=dp), intent(out), dimension(nrci) :: Anz Called by proc~~photosyn25~~CalledByGraph proc~photosyn25 cable_adjust_JV_gm_module::photosyn25 proc~adjust_jv_gm cable_adjust_JV_gm_module::adjust_JV_gm proc~adjust_jv_gm->proc~photosyn25 proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~adjust_jv_gm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/photosyn25.html"},{"title":"read_gm_LUT – POP","text":"public  subroutine read_gm_LUT(gm_LUT_file, LUT_VcmaxJmax, LUT_gm, LUT_vcmax, LUT_Rd) Uses netcdf proc~~read_gm_lut~~UsesGraph proc~read_gm_lut cable_adjust_JV_gm_module::read_gm_LUT netcdf netcdf proc~read_gm_lut->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: gm_LUT_file real(kind=dp), intent(out), dimension(:,:,:,:), allocatable :: LUT_VcmaxJmax real(kind=dp), intent(out), dimension(:), allocatable :: LUT_gm real(kind=dp), intent(out), dimension(:), allocatable :: LUT_vcmax real(kind=dp), intent(out), dimension(:), allocatable :: LUT_Rd Calls proc~~read_gm_lut~~CallsGraph proc~read_gm_lut cable_adjust_JV_gm_module::read_gm_LUT nc_abort nc_abort proc~read_gm_lut->nc_abort nf90_close nf90_close proc~read_gm_lut->nf90_close nf90_get_var nf90_get_var proc~read_gm_lut->nf90_get_var nf90_inq_dimid nf90_inq_dimid proc~read_gm_lut->nf90_inq_dimid nf90_inq_varid nf90_inq_varid proc~read_gm_lut->nf90_inq_varid nf90_inquire_dimension nf90_inquire_dimension proc~read_gm_lut->nf90_inquire_dimension nf90_open nf90_open proc~read_gm_lut->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/read_gm_lut.html"},{"title":"find_Vcmax_Jmax_LUT – POP","text":"public  subroutine find_Vcmax_Jmax_LUT(veg, p, LUT_VcmaxJmax, LUT_gm, LUT_vcmax, LUT_Rd) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg integer, intent(in) :: p real(kind=dp), intent(in), dimension(:,:,:,:) :: LUT_VcmaxJmax real(kind=dp), intent(in), dimension(:) :: LUT_gm real(kind=dp), intent(in), dimension(:) :: LUT_vcmax real(kind=dp), intent(in), dimension(:) :: LUT_Rd Calls proc~~find_vcmax_jmax_lut~~CallsGraph proc~find_vcmax_jmax_lut cable_adjust_JV_gm_module::find_Vcmax_Jmax_LUT cfrd cfrd proc~find_vcmax_jmax_lut->cfrd ejmax ejmax proc~find_vcmax_jmax_lut->ejmax ejmaxcc ejmaxcc proc~find_vcmax_jmax_lut->ejmaxcc frac4 frac4 proc~find_vcmax_jmax_lut->frac4 gm gm proc~find_vcmax_jmax_lut->gm light_inhibition light_inhibition proc~find_vcmax_jmax_lut->light_inhibition vcmax vcmax proc~find_vcmax_jmax_lut->vcmax vcmaxcc vcmaxcc proc~find_vcmax_jmax_lut->vcmaxcc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~find_vcmax_jmax_lut~~CalledByGraph proc~find_vcmax_jmax_lut cable_adjust_JV_gm_module::find_Vcmax_Jmax_LUT proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~find_vcmax_jmax_lut Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/find_vcmax_jmax_lut.html"},{"title":"adjust_k_Collatz – POP","text":"public  subroutine adjust_k_Collatz(veg, p) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg integer, intent(in) :: p Calls proc~~adjust_k_collatz~~CallsGraph proc~adjust_k_collatz cable_adjust_JV_gm_module::adjust_k_Collatz c4kci c4kci proc~adjust_k_collatz->c4kci cfrd cfrd proc~adjust_k_collatz->cfrd frac4 frac4 proc~adjust_k_collatz->frac4 gm gm proc~adjust_k_collatz->gm light_inhibition light_inhibition proc~adjust_k_collatz->light_inhibition vcmax vcmax proc~adjust_k_collatz->vcmax Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~adjust_k_collatz~~CalledByGraph proc~adjust_k_collatz cable_adjust_JV_gm_module::adjust_k_Collatz proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->proc~adjust_k_collatz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/adjust_k_collatz.html"},{"title":"bgcdriver – POP","text":"public  subroutine bgcdriver(ktau, kstart, dels, met, ssnow, canopy, veg, soil, climate, casabiome, casapool, casaflux, casamet, casabal, phen, POP, ktauday, idoy, LOY, dump_read, LALLOC, c13o2flux, c13o2pools) Uses casavariable TypeDef cable_c13o2_def casaparm POP_Types cable_phenology_module phenvariable cable_def_types_mod cable_common_module casadimension cable_c13o2 casa_inout proc~~bgcdriver~~UsesGraph proc~bgcdriver casa_cable::bgcdriver cable_c13o2 cable_c13o2 proc~bgcdriver->cable_c13o2 cable_c13o2_def cable_c13o2_def proc~bgcdriver->cable_c13o2_def cable_common_module cable_common_module proc~bgcdriver->cable_common_module cable_def_types_mod cable_def_types_mod proc~bgcdriver->cable_def_types_mod module~cable_phenology_module cable_phenology_module proc~bgcdriver->module~cable_phenology_module module~casa_inout casa_inout proc~bgcdriver->module~casa_inout module~casadimension casadimension proc~bgcdriver->module~casadimension module~casaparm casaparm proc~bgcdriver->module~casaparm module~casavariable casavariable proc~bgcdriver->module~casavariable module~phenvariable phenvariable proc~bgcdriver->module~phenvariable module~pop_types POP_Types proc~bgcdriver->module~pop_types module~typedef TypeDef proc~bgcdriver->module~typedef module~cable_phenology_module->cable_def_types_mod module~cable_phenology_module->module~typedef CABLE_COMMON_MODULE CABLE_COMMON_MODULE module~cable_phenology_module->CABLE_COMMON_MODULE cable_IO_vars_module cable_IO_vars_module module~cable_phenology_module->cable_IO_vars_module module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~phenvariable->module~casadimension module~pop_types->module~typedef module~pop_constants POP_Constants module~pop_types->module~pop_constants module~pop_constants->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ktau integer, intent(in) :: kstart real, intent(in) :: dels type(met_type), intent(inout) :: met type(soil_snow_type), intent(inout) :: ssnow type(canopy_type), intent(inout) :: canopy type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type(climate_type), intent(in) :: climate type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( casa_balance ), intent(inout) :: casabal type( phen_variable ), intent(inout) :: phen type( POP_TYPE ), intent(inout) :: POP integer, intent(in) :: ktauday integer, intent(in) :: idoy integer, intent(in) :: LOY logical, intent(in) :: dump_read integer, intent(in) :: LALLOC type(c13o2_flux), intent(inout) :: c13o2flux type(c13o2_pool), intent(inout) :: c13o2pools Calls proc~~bgcdriver~~CallsGraph proc~bgcdriver casa_cable::bgcdriver c13o2_save_casapool c13o2_save_casapool proc~bgcdriver->c13o2_save_casapool c13o2_update_pools c13o2_update_pools proc~bgcdriver->c13o2_update_pools cplant cplant proc~bgcdriver->cplant crmplant crmplant proc~bgcdriver->crmplant fraccalloc fraccalloc proc~bgcdriver->fraccalloc proc~biogeochem casa_inout::biogeochem proc~bgcdriver->proc~biogeochem proc~cable_phenology_clim cable_phenology_module::cable_phenology_clim proc~bgcdriver->proc~cable_phenology_clim cplant_turnover cplant_turnover proc~biogeochem->cplant_turnover iwood iwood proc~biogeochem->iwood klitter klitter proc~biogeochem->klitter klitter_fire klitter_fire proc~biogeochem->klitter_fire kplant kplant proc~biogeochem->kplant kplant_fire kplant_fire proc~biogeochem->kplant_fire pop_grid pop_grid proc~biogeochem->pop_grid proc~avgsoil casa_cnp_module::avgsoil proc~biogeochem->proc~avgsoil proc~casa_allocation casa_cnp_module::casa_allocation proc~biogeochem->proc~casa_allocation proc~casa_cnpbal casa_cnp_module::casa_cnpbal proc~biogeochem->proc~casa_cnpbal proc~casa_cnpcycle casa_cnp_module::casa_cnpcycle proc~biogeochem->proc~casa_cnpcycle proc~casa_cnpflux casa_inout::casa_cnpflux proc~biogeochem->proc~casa_cnpflux proc~casa_coeffplant casa_cnp_module::casa_coeffplant proc~biogeochem->proc~casa_coeffplant proc~casa_coeffsoil casa_cnp_module::casa_coeffsoil proc~biogeochem->proc~casa_coeffsoil proc~casa_delplant casa_cnp_module::casa_delplant proc~biogeochem->proc~casa_delplant proc~casa_delsoil casa_cnp_module::casa_delsoil proc~biogeochem->proc~casa_delsoil proc~casa_ndummy casa_cnp_module::casa_ndummy proc~biogeochem->proc~casa_ndummy proc~casa_nuptake casa_cnp_module::casa_nuptake proc~biogeochem->proc~casa_nuptake proc~casa_pdummy casa_cnp_module::casa_pdummy proc~biogeochem->proc~casa_pdummy proc~casa_puptake casa_cnp_module::casa_puptake proc~biogeochem->proc~casa_puptake proc~casa_rplant casa_cnp_module::casa_rplant proc~biogeochem->proc~casa_rplant proc~casa_xkn casa_cnp_module::casa_xkN proc~biogeochem->proc~casa_xkn proc~casa_xnp casa_cnp_module::casa_xnp proc~biogeochem->proc~casa_xnp proc~casa_xrateplant casa_cnp_module::casa_xrateplant proc~biogeochem->proc~casa_xrateplant proc~casa_xratesoil casa_cnp_module::casa_xratesoil proc~biogeochem->proc~casa_xratesoil proc~phenology casa_cnp_module::phenology proc~biogeochem->proc~phenology aphen aphen proc~cable_phenology_clim->aphen chilldays chilldays proc~cable_phenology_clim->chilldays doyphase doyphase proc~cable_phenology_clim->doyphase eq eq proc~cable_phenology_clim->eq gdd5 gdd5 proc~cable_phenology_clim->gdd5 ge ge proc~cable_phenology_clim->ge gmd gmd proc~cable_phenology_clim->gmd iveg iveg proc~cable_phenology_clim->iveg patch patch proc~cable_phenology_clim->patch phase phase proc~cable_phenology_clim->phase btran btran proc~avgsoil->btran moist moist proc~avgsoil->moist moistavg moistavg proc~avgsoil->moistavg tsoilavg tsoilavg proc~avgsoil->tsoilavg proc~casa_allocation->cplant proc~casa_allocation->crmplant proc~casa_allocation->fraccalloc proc~casa_allocation->iveg proc~casa_allocation->btran fracnpptop fracnpptop proc~casa_allocation->fracnpptop glai glai proc~casa_allocation->glai glaimax glaimax proc~casa_allocation->glaimax glaimin glaimin proc~casa_allocation->glaimin kplant_tot kplant_tot proc~casa_allocation->kplant_tot la_to_sa la_to_sa proc~casa_allocation->la_to_sa proc~casa_allocation->moistavg proc~casa_wolf casa_cnp_module::casa_wolf proc~casa_allocation->proc~casa_wolf sfc sfc proc~casa_allocation->sfc sla sla proc~casa_allocation->sla swilt swilt proc~casa_allocation->swilt proc~casa_allocation->tsoilavg proc~casa_cnpbal->cplant proc~casa_cnpbal->klitter proc~casa_cnpbal->klitter_fire proc~casa_cnpbal->kplant proc~casa_cnpbal->kplant_fire clabile clabile proc~casa_cnpbal->clabile clabilelast clabilelast proc~casa_cnpbal->clabilelast clitterlast clitterlast proc~casa_cnpbal->clitterlast cnpp cnpp proc~casa_cnpbal->cnpp cplantlast cplantlast proc~casa_cnpbal->cplantlast crsoil crsoil proc~casa_cnpbal->crsoil fharvest fharvest proc~casa_cnpbal->fharvest fluxctoco2_plant_fire fluxctoco2_plant_fire proc~casa_cnpbal->fluxctoco2_plant_fire fluxctolitter fluxctolitter proc~casa_cnpbal->fluxctolitter fluxfromptoco2 fluxfromptoco2 proc~casa_cnpbal->fluxfromptoco2 fromptol_fire fromptol_fire proc~casa_cnpbal->fromptol_fire klitter_tot klitter_tot proc~casa_cnpbal->klitter_tot proc~casa_cnpbal->kplant_tot nmindep nmindep proc~casa_cnpbal->nmindep nminfix nminfix proc~casa_cnpbal->nminfix nminleach nminleach proc~casa_cnpbal->nminleach nminloss nminloss proc~casa_cnpbal->nminloss nminuptake nminuptake proc~casa_cnpbal->nminuptake nsoilmin nsoilmin proc~casa_cnpbal->nsoilmin nsoilminlast nsoilminlast proc~casa_cnpbal->nsoilminlast nupland nupland proc~casa_cnpbal->nupland pdep pdep proc~casa_cnpbal->pdep plabuptake plabuptake proc~casa_cnpbal->plabuptake pleach pleach proc~casa_cnpbal->pleach ploss ploss proc~casa_cnpbal->ploss psoillab psoillab proc~casa_cnpbal->psoillab psoillablast psoillablast proc~casa_cnpbal->psoillablast psoilocc psoilocc proc~casa_cnpbal->psoilocc psoilocclast psoilocclast proc~casa_cnpbal->psoilocclast psoilsorb psoilsorb proc~casa_cnpbal->psoilsorb psoilsorblast psoilsorblast proc~casa_cnpbal->psoilsorblast pupland pupland proc~casa_cnpbal->pupland pwea pwea proc~casa_cnpbal->pwea proc~casa_cnpcycle->cplant proc~casa_cnpcycle->iveg proc~casa_cnpcycle->clabile clitter clitter proc~casa_cnpcycle->clitter csoil csoil proc~casa_cnpcycle->csoil dclabiledt dclabiledt proc~casa_cnpcycle->dclabiledt dclitterdt dclitterdt proc~casa_cnpcycle->dclitterdt dcplantdt dcplantdt proc~casa_cnpcycle->dcplantdt dcsoildt dcsoildt proc~casa_cnpcycle->dcsoildt dnlitterdt dnlitterdt proc~casa_cnpcycle->dnlitterdt dnplantdt dnplantdt proc~casa_cnpcycle->dnplantdt dnsoildt dnsoildt proc~casa_cnpcycle->dnsoildt dnsoilmindt dnsoilmindt proc~casa_cnpcycle->dnsoilmindt dplitterdt dplitterdt proc~casa_cnpcycle->dplitterdt dpplantdt dpplantdt proc~casa_cnpcycle->dpplantdt dpsoildt dpsoildt proc~casa_cnpcycle->dpsoildt dpsoillabdt dpsoillabdt proc~casa_cnpcycle->dpsoillabdt dpsoiloccdt dpsoiloccdt proc~casa_cnpcycle->dpsoiloccdt proc~casa_cnpcycle->glai proc~casa_cnpcycle->glaimax proc~casa_cnpcycle->glaimin iveg2 iveg2 proc~casa_cnpcycle->iveg2 kmlabp kmlabp proc~casa_cnpcycle->kmlabp lat lat proc~casa_cnpcycle->lat lon lon proc~casa_cnpcycle->lon nlitter nlitter proc~casa_cnpcycle->nlitter nplant nplant proc~casa_cnpcycle->nplant nsoil nsoil proc~casa_cnpcycle->nsoil proc~casa_cnpcycle->nsoilmin plitter plitter proc~casa_cnpcycle->plitter pplant pplant proc~casa_cnpcycle->pplant proc~casa_poolzero casa_cnp_module::casa_poolzero proc~casa_cnpcycle->proc~casa_poolzero psoil psoil proc~casa_cnpcycle->psoil proc~casa_cnpcycle->psoillab proc~casa_cnpcycle->psoilocc psorbmax psorbmax proc~casa_cnpcycle->psorbmax rationcplantmax rationcplantmax proc~casa_cnpcycle->rationcplantmax proc~casa_cnpcycle->sla proc~casa_cnpflux->crmplant fcrmleafyear fcrmleafyear proc~casa_cnpflux->fcrmleafyear fcrmrootyear fcrmrootyear proc~casa_cnpflux->fcrmrootyear fcrmwoodyear fcrmwoodyear proc~casa_cnpflux->fcrmwoodyear proc~casa_coeffplant->cplant proc~casa_coeffplant->iveg proc~casa_coeffplant->kplant proc~casa_coeffplant->kplant_fire fracligninplant fracligninplant proc~casa_coeffplant->fracligninplant fromptol fromptol proc~casa_coeffplant->fromptol ftransnptol ftransnptol proc~casa_coeffplant->ftransnptol proc~casa_coeffplant->glai proc~casa_coeffplant->glaimin proc~casa_coeffplant->nplant plantrate plantrate proc~casa_coeffplant->plantrate proc~casa_coeffsoil->iveg proc~casa_coeffsoil->klitter proc~casa_coeffsoil->klitter_fire clay clay proc~casa_coeffsoil->clay proc~casa_coeffsoil->fracligninplant fromltoco2 fromltoco2 proc~casa_coeffsoil->fromltoco2 fromltos fromltos proc~casa_coeffsoil->fromltos fromstoco2 fromstoco2 proc~casa_coeffsoil->fromstoco2 fromstos fromstos proc~casa_coeffsoil->fromstos isorder isorder proc~casa_coeffsoil->isorder proc~casa_coeffsoil->iveg2 ksoil ksoil proc~casa_coeffsoil->ksoil litterrate litterrate proc~casa_coeffsoil->litterrate silt silt proc~casa_coeffsoil->silt soilrate soilrate proc~casa_coeffsoil->soilrate xkplab xkplab proc~casa_coeffsoil->xkplab xkpocc xkpocc proc~casa_coeffsoil->xkpocc xkpsorb xkpsorb proc~casa_coeffsoil->xkpsorb proc~casa_delplant->cplant proc~casa_delplant->crmplant proc~casa_delplant->fraccalloc proc~casa_delplant->iveg proc~casa_delplant->kplant proc~casa_delplant->kplant_fire cgpp cgpp proc~casa_delplant->cgpp charvest charvest proc~casa_delplant->charvest clabloss clabloss proc~casa_delplant->clabloss proc~casa_delplant->cnpp crgplant crgplant proc~casa_delplant->crgplant proc~casa_delplant->dcplantdt proc~casa_delplant->dnplantdt proc~casa_delplant->dpplantdt proc~casa_delplant->fharvest proc~casa_delplant->fluxctoco2_plant_fire proc~casa_delplant->fluxctolitter proc~casa_delplant->fluxfromptoco2 fluxfromptoharvest fluxfromptoharvest proc~casa_delplant->fluxfromptoharvest fluxntolitter fluxntolitter proc~casa_delplant->fluxntolitter fluxptolitter fluxptolitter proc~casa_delplant->fluxptolitter fracclabile fracclabile proc~casa_delplant->fracclabile fracnalloc fracnalloc proc~casa_delplant->fracnalloc fracpalloc fracpalloc proc~casa_delplant->fracpalloc proc~casa_delplant->fromptol proc~casa_delplant->fromptol_fire proc~casa_delplant->ftransnptol ftranspptol ftranspptol proc~casa_delplant->ftranspptol proc~casa_delplant->iveg2 proc~casa_delplant->kplant_tot lnonwood lnonwood proc~casa_delplant->lnonwood nharvest nharvest proc~casa_delplant->nharvest proc~casa_delplant->nminuptake proc~casa_delplant->nplant pharvest pharvest proc~casa_delplant->pharvest proc~casa_delplant->plabuptake proc~casa_delplant->pplant proc~casa_delsoil->iveg proc~casa_delsoil->klitter proc~casa_delsoil->klitter_fire proc~casa_delsoil->clitter proc~casa_delsoil->cnpp costnpup costnpup proc~casa_delsoil->costnpup proc~casa_delsoil->crsoil proc~casa_delsoil->csoil proc~casa_delsoil->dpsoillabdt fluxctoco2 fluxctoco2 proc~casa_delsoil->fluxctoco2 fluxctoco2_litter_fire fluxctoco2_litter_fire proc~casa_delsoil->fluxctoco2_litter_fire proc~casa_delsoil->fluxctolitter fluxctosoil fluxctosoil proc~casa_delsoil->fluxctosoil fluxfromltoco2 fluxfromltoco2 proc~casa_delsoil->fluxfromltoco2 fluxfromltos fluxfromltos proc~casa_delsoil->fluxfromltos fluxfromstoco2 fluxfromstoco2 proc~casa_delsoil->fluxfromstoco2 fluxfromstos fluxfromstos proc~casa_delsoil->fluxfromstos proc~casa_delsoil->fluxntolitter fluxntosoil fluxntosoil proc~casa_delsoil->fluxntosoil proc~casa_delsoil->fluxptolitter fluxptosoil fluxptosoil proc~casa_delsoil->fluxptosoil fnminleach fnminleach proc~casa_delsoil->fnminleach fnminloss fnminloss proc~casa_delsoil->fnminloss fpleach fpleach proc~casa_delsoil->fpleach proc~casa_delsoil->fromltoco2 proc~casa_delsoil->fromltos proc~casa_delsoil->fromstoco2 proc~casa_delsoil->fromstos proc~casa_delsoil->iveg2 proc~casa_delsoil->klitter_tot proc~casa_delsoil->kmlabp kpocc kpocc proc~casa_delsoil->kpocc kpsorb kpsorb proc~casa_delsoil->kpsorb proc~casa_delsoil->ksoil proc~casa_delsoil->nlitter nlittermin nlittermin proc~casa_delsoil->nlittermin proc~casa_delsoil->nmindep proc~casa_delsoil->nminfix proc~casa_delsoil->nminleach proc~casa_delsoil->nminloss nsimm nsimm proc~casa_delsoil->nsimm nsmin nsmin proc~casa_delsoil->nsmin nsnet nsnet proc~casa_delsoil->nsnet proc~casa_delsoil->nsoil proc~casa_delsoil->nsoilmin proc~casa_delsoil->nupland proc~casa_delsoil->pdep proc~casa_delsoil->pleach proc~casa_delsoil->plitter plittermin plittermin proc~casa_delsoil->plittermin prodptase prodptase proc~casa_delsoil->prodptase psimm psimm proc~casa_delsoil->psimm psmin psmin proc~casa_delsoil->psmin psnet psnet proc~casa_delsoil->psnet proc~casa_delsoil->psoil proc~casa_delsoil->psoillab proc~casa_delsoil->psoilocc proc~casa_delsoil->psoilsorb proc~casa_delsoil->psorbmax proc~casa_delsoil->pupland proc~casa_delsoil->pwea rationcsoilnew rationcsoilnew proc~casa_delsoil->rationcsoilnew rationpsoil rationpsoil proc~casa_delsoil->rationpsoil proc~casa_delsoil->tsoilavg proc~casa_ndummy->cplant rationcplant rationcplant proc~casa_ndummy->rationcplant proc~casa_nuptake->iveg proc~casa_nuptake->iveg2 kminn kminn proc~casa_nuptake->kminn proc~casa_nuptake->nminuptake proc~casa_nuptake->nsoilmin proc~casa_nrequire casa_cnp_module::casa_Nrequire proc~casa_nuptake->proc~casa_nrequire proc~casa_pdummy->nplant rationpplant rationpplant proc~casa_pdummy->rationpplant proc~casa_puptake->iveg kuplabp kuplabp proc~casa_puptake->kuplabp proc~casa_puptake->plabuptake proc~casa_prequire casa_cnp_module::casa_Prequire proc~casa_puptake->proc~casa_prequire proc~casa_puptake->psoillab proc~casa_rplant->cplant proc~casa_rplant->crmplant proc~casa_rplant->iveg proc~casa_rplant->cgpp proc~casa_rplant->clabile proc~casa_rplant->crgplant frac_sapwood frac_sapwood proc~casa_rplant->frac_sapwood frec frec proc~casa_rplant->frec kclabrate kclabrate proc~casa_rplant->kclabrate proc~casa_rplant->nplant proc~vcmax_np casa_cnp_module::vcmax_np proc~casa_rplant->proc~vcmax_np qtemp_max_last_year qtemp_max_last_year proc~casa_rplant->qtemp_max_last_year proc~casa_rplant->rationcplantmax ratiopcplantmax ratiopcplantmax proc~casa_rplant->ratiopcplantmax rmplant rmplant proc~casa_rplant->rmplant proc~casa_rplant->sla tairk tairk proc~casa_rplant->tairk proc~casa_rplant->tsoilavg vcmax vcmax proc~casa_rplant->vcmax vcmax_scalar vcmax_scalar proc~casa_rplant->vcmax_scalar proc~casa_xkn->iveg proc~casa_xkn->klitter proc~casa_xkn->clitter proc~casa_xkn->csoil proc~casa_xkn->fromltos proc~casa_xkn->fromstos proc~casa_xkn->iveg2 proc~casa_xkn->ksoil maxcwd maxcwd proc~casa_xkn->maxcwd maxfinelitter maxfinelitter proc~casa_xkn->maxfinelitter proc~casa_xkn->nlitter proc~casa_xkn->nsoil proc~casa_xkn->nsoilmin rationcsoilmax rationcsoilmax proc~casa_xkn->rationcsoilmax rationcsoilmin rationcsoilmin proc~casa_xkn->rationcsoilmin proc~casa_xkn->rationcsoilnew proc~casa_xnp->cplant proc~casa_xnp->iveg proc~casa_xnp->cgpp proc~casa_xnp->cnpp proc~casa_xnp->fharvest proc~casa_xnp->fracclabile proc~casa_xnp->iveg2 proc~casa_xnp->nplant proc~casa_xnp->nsoilmin proc~casa_xnp->pplant proc~casa_xnp->proc~casa_nrequire proc~casa_xnp->proc~casa_prequire proc~casa_xnp->psoillab xnpmax xnpmax proc~casa_xnp->xnpmax proc~casa_xrateplant->ge proc~casa_xrateplant->iveg proc~casa_xrateplant->phase proc~casa_xrateplant->btran proc~casa_xrateplant->iveg2 le le proc~casa_xrateplant->le proc~casa_xrateplant->lnonwood proc~casa_xrateplant->tairk tkshed tkshed proc~casa_xrateplant->tkshed xkleafcoldexp xkleafcoldexp proc~casa_xrateplant->xkleafcoldexp xkleafcoldmax xkleafcoldmax proc~casa_xrateplant->xkleafcoldmax xkleafdryexp xkleafdryexp proc~casa_xrateplant->xkleafdryexp xkleafdrymax xkleafdrymax proc~casa_xrateplant->xkleafdrymax proc~casa_xratesoil->iveg damm_alpha damm_alpha proc~casa_xratesoil->damm_alpha damm_ea damm_ea proc~casa_xratesoil->damm_ea damm_enzpool damm_enzpool proc~casa_xratesoil->damm_enzpool damm_kmcp damm_kmcp proc~casa_xratesoil->damm_kmcp damm_kmo2 damm_kmo2 proc~casa_xratesoil->damm_kmo2 proc~casa_xratesoil->iveg2 proc~casa_xratesoil->moistavg q10soil q10soil proc~casa_xratesoil->q10soil ssat ssat proc~casa_xratesoil->ssat proc~casa_xratesoil->tsoilavg xkoptlitter xkoptlitter proc~casa_xratesoil->xkoptlitter xkoptsoil xkoptsoil proc~casa_xratesoil->xkoptsoil proc~phenology->doyphase proc~phenology->phase proc~casa_nrequire->cplant proc~casa_nrequire->fraccalloc proc~casa_nrequire->iveg proc~casa_nrequire->kplant proc~casa_nrequire->ftransnptol proc~casa_nrequire->iveg2 proc~casa_nrequire->nplant proc~casa_nrequire->nsoilmin proc~casa_nrequire->rationcplantmax rationcplantmin rationcplantmin proc~casa_nrequire->rationcplantmin proc~casa_poolzero->cplant proc~casa_poolzero->clitter proc~casa_poolzero->csoil proc~casa_poolzero->nlitter proc~casa_poolzero->nplant proc~casa_poolzero->nsoil proc~casa_prequire->cplant proc~casa_prequire->fraccalloc proc~casa_prequire->iveg proc~casa_prequire->kplant proc~casa_prequire->ftranspptol proc~casa_prequire->iveg2 proc~casa_prequire->nplant proc~casa_prequire->pplant rationpplantmax rationpplantmax proc~casa_prequire->rationpplantmax rationpplantmin rationpplantmin proc~casa_prequire->rationpplantmin proc~casa_wolf->cplant proc~casa_wolf->iveg proc~casa_wolf->cnpp proc~casa_wolf->fracnpptop proc~casa_wolf->iveg2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/bgcdriver.html"},{"title":"POPdriver – POP","text":"public  subroutine POPdriver(casaflux, casabal, veg, POP) Uses casavariable TypeDef casaparm POP_Types phenvariable cable_def_types_mod POPModule cable_common_module casadimension proc~~popdriver~~UsesGraph proc~popdriver casa_cable::POPdriver cable_common_module cable_common_module proc~popdriver->cable_common_module cable_def_types_mod cable_def_types_mod proc~popdriver->cable_def_types_mod module~casadimension casadimension proc~popdriver->module~casadimension module~casaparm casaparm proc~popdriver->module~casaparm module~casavariable casavariable proc~popdriver->module~casavariable module~phenvariable phenvariable proc~popdriver->module~phenvariable module~pop_types POP_Types proc~popdriver->module~pop_types module~popmodule POPModule proc~popdriver->module~popmodule module~typedef TypeDef proc~popdriver->module~typedef module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~phenvariable->module~casadimension module~pop_types->module~typedef module~pop_constants POP_Constants module~pop_types->module~pop_constants module~popmodule->module~pop_types module~popmodule->module~typedef module~popmodule->module~pop_constants module~pop_constants->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(in) :: casaflux type( casa_balance ), intent(in) :: casabal type(veg_parameter_type), intent(in) :: veg type( POP_TYPE ), intent(inout) :: POP Calls proc~~popdriver~~CallsGraph proc~popdriver casa_cable::POPdriver disturbance_intensity disturbance_intensity proc~popdriver->disturbance_intensity disturbance_interval disturbance_interval proc~popdriver->disturbance_interval proc~popstep POPModule::POPStep proc~popdriver->proc~popstep pop_grid pop_grid proc~popstep->pop_grid proc~getdiagnostics POPModule::GetDiagnostics proc~popstep->proc~getdiagnostics proc~getpatchfrequencies POPModule::GetPatchFrequencies proc~popstep->proc~getpatchfrequencies proc~getuniqueagefrequencies POPModule::GetUniqueAgeFrequencies proc~popstep->proc~getuniqueagefrequencies proc~patch_disturb POPModule::Patch_disturb proc~popstep->proc~patch_disturb proc~patch_partial_disturb POPModule::Patch_partial_disturb proc~popstep->proc~patch_partial_disturb proc~patch_partial_disturb2 POPModule::Patch_partial_disturb2 proc~popstep->proc~patch_partial_disturb2 proc~patchannualdynamics POPModule::PatchAnnualDynamics proc~popstep->proc~patchannualdynamics proc~getdiagnostics->pop_grid proc~get_allometry POPModule::GET_ALLOMETRY proc~getdiagnostics->proc~get_allometry proc~interpolate_biomass_1d POPModule::INTERPOLATE_BIOMASS_1D proc~getdiagnostics->proc~interpolate_biomass_1d proc~interpolate_biomass_2d POPModule::INTERPOLATE_BIOMASS_2D proc~getdiagnostics->proc~interpolate_biomass_2d proc~smooth_flux POPModule::SMOOTH_FLUX proc~getdiagnostics->proc~smooth_flux proc~getpatchfrequencies->pop_grid proc~getuniqueagefrequencies->pop_grid proc~cumexponential POPModule::CumExponential proc~getuniqueagefrequencies->proc~cumexponential proc~realexponential POPModule::REALExponential proc~getuniqueagefrequencies->proc~realexponential proc~patch_disturb->pop_grid proc~layer_recruitment_single_patch POPModule::layer_recruitment_single_patch proc~patch_disturb->proc~layer_recruitment_single_patch proc~patch_partial_disturb->pop_grid proc~patch_partial_disturb2->pop_grid proc~patchannualdynamics->pop_grid proc~patchannualdynamics->proc~get_allometry proc~layer_recruitment POPModule::layer_recruitment proc~patchannualdynamics->proc~layer_recruitment proc~allometry POPModule::Allometry proc~get_allometry->proc~allometry proc~getheight POPModule::GetHeight proc~get_allometry->proc~getheight proc~williams_allometry POPModule::Williams_Allometry proc~get_allometry->proc~williams_allometry proc~interpolate_biomass_1d->pop_grid proc~interpolate_biomass_1d->proc~realexponential proc~interpolate_biomass_2d->pop_grid proc~interpolate_biomass_2d->proc~realexponential eq eq proc~interpolate_biomass_2d->eq proc~area_triangle POPModule::Area_Triangle proc~interpolate_biomass_2d->proc~area_triangle proc~layer_recruitment->pop_grid proc~layer_recruitment->proc~get_allometry proc~layer_recruitment_single_patch->pop_grid proc~layer_recruitment_single_patch->proc~get_allometry proc~smooth_flux->pop_grid proc~regress POPModule::REGRESS proc~smooth_flux->proc~regress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~popdriver~~CalledByGraph proc~popdriver casa_cable::POPdriver proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~popdriver proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~popdriver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/popdriver.html"},{"title":"read_casa_dump – POP","text":"public  subroutine read_casa_dump(ncfile, casamet, casaflux, phen, climate, c13o2flux, ncall, kend, allatonce) Uses casavariable cable_c13o2_def phenvariable cable_def_types_mod cable_common_module casadimension cable_diag_module netcdf proc~~read_casa_dump~~UsesGraph proc~read_casa_dump casa_cable::read_casa_dump cable_c13o2_def cable_c13o2_def proc~read_casa_dump->cable_c13o2_def cable_common_module cable_common_module proc~read_casa_dump->cable_common_module cable_def_types_mod cable_def_types_mod proc~read_casa_dump->cable_def_types_mod cable_diag_module cable_diag_module proc~read_casa_dump->cable_diag_module module~casadimension casadimension proc~read_casa_dump->module~casadimension module~casavariable casavariable proc~read_casa_dump->module~casavariable module~phenvariable phenvariable proc~read_casa_dump->module~phenvariable netcdf netcdf proc~read_casa_dump->netcdf module~casadimension->cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~phenvariable->module~casadimension Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: ncfile type( casa_met ), intent(inout) :: casamet type( casa_flux ), intent(inout) :: casaflux type( phen_variable ), intent(inout) :: phen type(climate_type), intent(inout) :: climate type(c13o2_flux), intent(inout) :: c13o2flux integer, intent(in) :: ncall integer, intent(in) :: kend logical, intent(in) :: allatonce Calls proc~~read_casa_dump~~CallsGraph proc~read_casa_dump casa_cable::read_casa_dump get_var_nc get_var_nc proc~read_casa_dump->get_var_nc nf90_close nf90_close proc~read_casa_dump->nf90_close nf90_open nf90_open proc~read_casa_dump->nf90_open stderr_nc stderr_nc proc~read_casa_dump->stderr_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_casa_dump~~CalledByGraph proc~read_casa_dump casa_cable::read_casa_dump proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->proc~read_casa_dump proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~read_casa_dump Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/read_casa_dump.html"},{"title":"write_casa_dump – POP","text":"public  subroutine write_casa_dump(ncfile, casamet, casaflux, phen, climate, c13o2flux, n_call, kend) Uses casavariable cable_c13o2_def phenvariable cable_def_types_mod cable_common_module casadimension cable_diag_module netcdf proc~~write_casa_dump~~UsesGraph proc~write_casa_dump casa_cable::write_casa_dump cable_c13o2_def cable_c13o2_def proc~write_casa_dump->cable_c13o2_def cable_common_module cable_common_module proc~write_casa_dump->cable_common_module cable_def_types_mod cable_def_types_mod proc~write_casa_dump->cable_def_types_mod cable_diag_module cable_diag_module proc~write_casa_dump->cable_diag_module module~casadimension casadimension proc~write_casa_dump->module~casadimension module~casavariable casavariable proc~write_casa_dump->module~casavariable module~phenvariable phenvariable proc~write_casa_dump->module~phenvariable netcdf netcdf proc~write_casa_dump->netcdf module~casadimension->cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~phenvariable->module~casadimension Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*) :: ncfile type( casa_met ), intent(in) :: casamet type( casa_flux ), intent(in) :: casaflux type( phen_variable ), intent(in) :: phen type(climate_type), intent(in) :: climate type(c13o2_flux), intent(in) :: c13o2flux integer, intent(in) :: n_call integer, intent(in) :: kend Calls proc~~write_casa_dump~~CallsGraph proc~write_casa_dump casa_cable::write_casa_dump def_dims def_dims proc~write_casa_dump->def_dims def_vars def_vars proc~write_casa_dump->def_vars doyphase doyphase proc~write_casa_dump->doyphase nf90_close nf90_close proc~write_casa_dump->nf90_close nf90_create nf90_create proc~write_casa_dump->nf90_create nf90_enddef nf90_enddef proc~write_casa_dump->nf90_enddef put_var_nc put_var_nc proc~write_casa_dump->put_var_nc stderr_nc stderr_nc proc~write_casa_dump->stderr_nc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/write_casa_dump.html"},{"title":"casa_feedback – POP","text":"public  subroutine casa_feedback(ktau, veg, casabiome, casapool, casamet, climate, ktauday) Uses casavariable cable_data_module casaparm cable_adjust_JV_gm_module casa_cnp_module cable_def_types_mod cable_optimise_JV_module cable_common_module casadimension proc~~casa_feedback~~UsesGraph proc~casa_feedback casa_cable::casa_feedback cable_common_module cable_common_module proc~casa_feedback->cable_common_module cable_data_module cable_data_module proc~casa_feedback->cable_data_module cable_def_types_mod cable_def_types_mod proc~casa_feedback->cable_def_types_mod module~cable_adjust_jv_gm_module cable_adjust_JV_gm_module proc~casa_feedback->module~cable_adjust_jv_gm_module module~cable_optimise_jv_module cable_optimise_JV_module proc~casa_feedback->module~cable_optimise_jv_module module~casa_cnp_module casa_cnp_module proc~casa_feedback->module~casa_cnp_module module~casadimension casadimension proc~casa_feedback->module~casadimension module~casaparm casaparm proc~casa_feedback->module~casaparm module~casavariable casavariable proc~casa_feedback->module~casavariable module~cable_adjust_jv_gm_module->cable_data_module module~cable_adjust_jv_gm_module->cable_def_types_mod cable_abort_module cable_abort_module module~cable_adjust_jv_gm_module->cable_abort_module cable_canopy_module cable_canopy_module module~cable_adjust_jv_gm_module->cable_canopy_module minpack minpack module~cable_adjust_jv_gm_module->minpack netcdf netcdf module~cable_adjust_jv_gm_module->netcdf module~cable_optimise_jv_module->cable_common_module module~cable_optimise_jv_module->cable_data_module module~cable_optimise_jv_module->cable_def_types_mod module~typedef TypeDef module~cable_optimise_jv_module->module~typedef module~casa_cnp_module->cable_common_module module~casa_cnp_module->cable_def_types_mod module~casa_cnp_module->module~casadimension module~casa_cnp_module->module~casaparm module~casa_cnp_module->module~casavariable cable_IO_vars_module cable_IO_vars_module module~casa_cnp_module->cable_IO_vars_module module~phenvariable phenvariable module~casa_cnp_module->module~phenvariable module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~phenvariable->module~casadimension Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ktau type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(in) :: casapool type( casa_met ), intent(in) :: casamet type(climate_type), intent(in) :: climate integer, intent(in) :: ktauday Calls proc~~casa_feedback~~CallsGraph proc~casa_feedback casa_cable::casa_feedback cplant cplant proc~casa_feedback->cplant ejmaxcc ejmaxcc proc~casa_feedback->ejmaxcc glai glai proc~casa_feedback->glai glaimin glaimin proc~casa_feedback->glaimin gmmax gmmax proc~casa_feedback->gmmax iveg iveg proc~casa_feedback->iveg iveg2 iveg2 proc~casa_feedback->iveg2 mtemp_max20 mtemp_max20 proc~casa_feedback->mtemp_max20 nintercept nintercept proc~casa_feedback->nintercept nplant nplant proc~casa_feedback->nplant nslope nslope proc~casa_feedback->nslope point2constants point2constants proc~casa_feedback->point2constants pplant pplant proc~casa_feedback->pplant proc~adjust_jv_gm cable_adjust_JV_gm_module::adjust_JV_gm proc~casa_feedback->proc~adjust_jv_gm proc~adjust_k_collatz cable_adjust_JV_gm_module::adjust_k_Collatz proc~casa_feedback->proc~adjust_k_collatz proc~find_vcmax_jmax_lut cable_adjust_JV_gm_module::find_Vcmax_Jmax_LUT proc~casa_feedback->proc~find_vcmax_jmax_lut proc~optimise_jv cable_optimise_JV_module::optimise_JV proc~casa_feedback->proc~optimise_jv proc~vcmax_np casa_cnp_module::vcmax_np proc~casa_feedback->proc~vcmax_np rationcplantmax rationcplantmax proc~casa_feedback->rationcplantmax rationcplantmin rationcplantmin proc~casa_feedback->rationcplantmin rationpplantmax rationpplantmax proc~casa_feedback->rationpplantmax rationpplantmin rationpplantmin proc~casa_feedback->rationpplantmin sla sla proc~casa_feedback->sla vcmax vcmax proc~casa_feedback->vcmax vcmax_scalar vcmax_scalar proc~casa_feedback->vcmax_scalar vcmaxcc vcmaxcc proc~casa_feedback->vcmaxcc proc~adjust_jv_gm->point2constants proc~adjust_jv_gm->vcmax cfrd cfrd proc~adjust_jv_gm->cfrd ejmax ejmax proc~adjust_jv_gm->ejmax frac4 frac4 proc~adjust_jv_gm->frac4 gm gm proc~adjust_jv_gm->gm light_inhibition light_inhibition proc~adjust_jv_gm->light_inhibition lmdif1 lmdif1 proc~adjust_jv_gm->lmdif1 proc~photosyn25 cable_adjust_JV_gm_module::photosyn25 proc~adjust_jv_gm->proc~photosyn25 proc~adjust_k_collatz->vcmax c4kci c4kci proc~adjust_k_collatz->c4kci proc~adjust_k_collatz->cfrd proc~adjust_k_collatz->frac4 proc~adjust_k_collatz->gm proc~adjust_k_collatz->light_inhibition proc~find_vcmax_jmax_lut->ejmaxcc proc~find_vcmax_jmax_lut->vcmax proc~find_vcmax_jmax_lut->vcmaxcc proc~find_vcmax_jmax_lut->cfrd proc~find_vcmax_jmax_lut->ejmax proc~find_vcmax_jmax_lut->frac4 proc~find_vcmax_jmax_lut->gm proc~find_vcmax_jmax_lut->light_inhibition proc~optimise_jv->mtemp_max20 proc~optimise_jv->point2constants proc~optimise_jv->vcmax proc~optimise_jv->vcmaxcc a1gs a1gs proc~optimise_jv->a1gs apar_leaf_shade apar_leaf_shade proc~optimise_jv->apar_leaf_shade apar_leaf_sun apar_leaf_sun proc~optimise_jv->apar_leaf_sun proc~optimise_jv->cfrd cs_shade cs_shade proc~optimise_jv->cs_shade cs_sun cs_sun proc~optimise_jv->cs_sun d0gs d0gs proc~optimise_jv->d0gs dleaf_shade dleaf_shade proc~optimise_jv->dleaf_shade dleaf_sun dleaf_sun proc~optimise_jv->dleaf_sun proc~optimise_jv->ejmax proc~optimise_jv->frac4 mtemp mtemp proc~optimise_jv->mtemp proc~diff_ac_aj cable_optimise_JV_module::diff_Ac_Aj proc~optimise_jv->proc~diff_ac_aj proc~golden cable_optimise_JV_module::golden proc~optimise_jv->proc~golden proc~rtbis cable_optimise_JV_module::rtbis proc~optimise_jv->proc~rtbis proc~total_photosynthesis_cost cable_optimise_JV_module::total_photosynthesis_cost proc~optimise_jv->proc~total_photosynthesis_cost scalex_shade scalex_shade proc~optimise_jv->scalex_shade scalex_sun scalex_sun proc~optimise_jv->scalex_sun tleaf_shade tleaf_shade proc~optimise_jv->tleaf_shade tleaf_sun tleaf_sun proc~optimise_jv->tleaf_sun vcmax_shade vcmax_shade proc~optimise_jv->vcmax_shade vcmax_sun vcmax_sun proc~optimise_jv->vcmax_sun proc~diff_ac_aj->point2constants ej3x ej3x proc~diff_ac_aj->ej3x proc~fabc cable_optimise_JV_module::fabc proc~diff_ac_aj->proc~fabc proc~fabcd cable_optimise_JV_module::fabcd proc~diff_ac_aj->proc~fabcd proc~fam_c3 cable_optimise_JV_module::fAm_c3 proc~diff_ac_aj->proc~fam_c3 proc~fan_c3 cable_optimise_JV_module::fAn_c3 proc~diff_ac_aj->proc~fan_c3 proc~fpq cable_optimise_JV_module::fpq proc~diff_ac_aj->proc~fpq proc~light_inhibition cable_optimise_JV_module::light_inhibition proc~diff_ac_aj->proc~light_inhibition xejmxt3 xejmxt3 proc~diff_ac_aj->xejmxt3 xejmxt3_acclim xejmxt3_acclim proc~diff_ac_aj->xejmxt3_acclim xgmest xgmest proc~diff_ac_aj->xgmest xrdt xrdt proc~diff_ac_aj->xrdt xvcmxt3 xvcmxt3 proc~diff_ac_aj->xvcmxt3 xvcmxt3_acclim xvcmxt3_acclim proc~diff_ac_aj->xvcmxt3_acclim eq eq proc~rtbis->eq ge ge proc~rtbis->ge le le proc~rtbis->le proc~total_photosynthesis_cost->point2constants proc~total_photosynthesis_cost->ej3x proc~total_photosynthesis_cost->proc~fabc proc~total_photosynthesis_cost->proc~fabcd proc~total_photosynthesis_cost->proc~fam_c3 proc~total_photosynthesis_cost->proc~fan_c3 proc~total_photosynthesis_cost->proc~fpq proc~total_photosynthesis_cost->proc~light_inhibition proc~total_photosynthesis_cost->xejmxt3 proc~total_photosynthesis_cost->xejmxt3_acclim proc~total_photosynthesis_cost->xgmest proc~total_photosynthesis_cost->xrdt proc~total_photosynthesis_cost->xvcmxt3 proc~total_photosynthesis_cost->xvcmxt3_acclim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/casa_feedback.html"},{"title":"sumcflux – POP","text":"public  subroutine sumcflux(ktau, kstart, dels, canopy, sum_flux, casaflux, l_vcmaxFeedbk) Uses casavariable casaparm cable_def_types_mod casadimension cable_carbon_module proc~~sumcflux~~UsesGraph proc~sumcflux casa_cable::sumcflux cable_carbon_module cable_carbon_module proc~sumcflux->cable_carbon_module cable_def_types_mod cable_def_types_mod proc~sumcflux->cable_def_types_mod module~casadimension casadimension proc~sumcflux->module~casadimension module~casaparm casaparm proc~sumcflux->module~casaparm module~casavariable casavariable proc~sumcflux->module~casavariable module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ktau integer, intent(in) :: kstart real, intent(in) :: dels type(canopy_type), intent(inout) :: canopy type(sum_flux_type), intent(inout) :: sum_flux type( casa_flux ), intent(inout) :: casaflux logical, intent(in) :: l_vcmaxFeedbk Calls proc~~sumcflux~~CallsGraph proc~sumcflux casa_cable::sumcflux clabloss clabloss proc~sumcflux->clabloss crgplant crgplant proc~sumcflux->crgplant crsoil crsoil proc~sumcflux->crsoil Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/sumcflux.html"},{"title":"totcnppools – POP","text":"public  subroutine totcnppools(kloop, veg, casamet, casapool, bmcplant, bmnplant, bmpplant, bmclitter, bmnlitter, bmplitter, bmcsoil, bmnsoil, bmpsoil, bmnsoilmin, bmpsoillab, bmpsoilsorb, bmpsoilocc, bmarea) Uses casadimension cable_def_types_mod casavariable casaparm proc~~totcnppools~~UsesGraph proc~totcnppools casa_cable::totcnppools cable_def_types_mod cable_def_types_mod proc~totcnppools->cable_def_types_mod module~casadimension casadimension proc~totcnppools->module~casadimension module~casaparm casaparm proc~totcnppools->module~casaparm module~casavariable casavariable proc~totcnppools->module~casavariable module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: kloop type(veg_parameter_type), intent(in) :: veg type( casa_met ), intent(in) :: casamet type( casa_pool ), intent(in) :: casapool real, dimension(5,mvtype,mplant) :: bmcplant real, dimension(5,mvtype,mplant) :: bmnplant real, dimension(5,mvtype,mplant) :: bmpplant real, dimension(5,mvtype,mlitter) :: bmclitter real, dimension(5,mvtype,mlitter) :: bmnlitter real, dimension(5,mvtype,mlitter) :: bmplitter real, dimension(5,mvtype,msoil) :: bmcsoil real, dimension(5,mvtype,msoil) :: bmnsoil real, dimension(5,mvtype,msoil) :: bmpsoil real, dimension(5,mvtype) :: bmnsoilmin real, dimension(5,mvtype) :: bmpsoillab real, dimension(5,mvtype) :: bmpsoilsorb real, dimension(5,mvtype) :: bmpsoilocc real, dimension(mvtype) :: bmarea Calls proc~~totcnppools~~CallsGraph proc~totcnppools casa_cable::totcnppools areacell areacell proc~totcnppools->areacell clitter clitter proc~totcnppools->clitter cplant cplant proc~totcnppools->cplant csoil csoil proc~totcnppools->csoil iveg iveg proc~totcnppools->iveg nlitter nlitter proc~totcnppools->nlitter nplant nplant proc~totcnppools->nplant nsoil nsoil proc~totcnppools->nsoil nsoilmin nsoilmin proc~totcnppools->nsoilmin plitter plitter proc~totcnppools->plitter pplant pplant proc~totcnppools->pplant psoil psoil proc~totcnppools->psoil psoillab psoillab proc~totcnppools->psoillab psoilocc psoilocc proc~totcnppools->psoilocc psoilsorb psoilsorb proc~totcnppools->psoilsorb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/totcnppools.html"},{"title":"analyticpool – POP","text":"public  subroutine analyticpool(veg, soil, casabiome, casapool, casaflux, casamet, casabal, avgcleaf2met, avgcleaf2str, avgcroot2met, avgcroot2str, avgcwood2cwd, avgnleaf2met, avgnleaf2str, avgnroot2met, avgnroot2str, avgnwood2cwd, avgpleaf2met, avgpleaf2str, avgproot2met, avgproot2str, avgpwood2cwd, avgcnpp, avgxkNlimiting, avgxklitter, avgxksoil, avgratioNCsoilmic, avgratioNCsoilslow, avgratioNCsoilpass, avgnsoilmin, avgpsoillab, avgpsoilsorb, avgpsoilocc, avg_c13leaf2met, avg_c13leaf2str, avg_c13root2met, avg_c13root2str, avg_c13wood2cwd, c13o2pools) Uses casavariable cable_c13o2_def casaparm cable_def_types_mod cable_common_module casadimension cable_carbon_module proc~~analyticpool~~UsesGraph proc~analyticpool casa_cable::analyticpool cable_c13o2_def cable_c13o2_def proc~analyticpool->cable_c13o2_def cable_carbon_module cable_carbon_module proc~analyticpool->cable_carbon_module cable_common_module cable_common_module proc~analyticpool->cable_common_module cable_def_types_mod cable_def_types_mod proc~analyticpool->cable_def_types_mod module~casadimension casadimension proc~analyticpool->module~casadimension module~casaparm casaparm proc~analyticpool->module~casaparm module~casavariable casavariable proc~analyticpool->module~casavariable module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. set the following two backflow to set (see Bolker 199x) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(in) :: veg type(soil_parameter_type), intent(in) :: soil type( casa_biome ), intent(in) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(in) :: casamet type( casa_balance ), intent(inout) :: casabal real(kind=r_2), intent(in), dimension(mp) :: avgcleaf2met real(kind=r_2), intent(in), dimension(mp) :: avgcleaf2str real(kind=r_2), intent(in), dimension(mp) :: avgcroot2met real(kind=r_2), intent(in), dimension(mp) :: avgcroot2str real(kind=r_2), intent(in), dimension(mp) :: avgcwood2cwd real(kind=r_2), intent(in), dimension(mp) :: avgnleaf2met real(kind=r_2), intent(in), dimension(mp) :: avgnleaf2str real(kind=r_2), intent(in), dimension(mp) :: avgnroot2met real(kind=r_2), intent(in), dimension(mp) :: avgnroot2str real(kind=r_2), intent(in), dimension(mp) :: avgnwood2cwd real(kind=r_2), intent(in), dimension(mp) :: avgpleaf2met real(kind=r_2), intent(in), dimension(mp) :: avgpleaf2str real(kind=r_2), intent(in), dimension(mp) :: avgproot2met real(kind=r_2), intent(in), dimension(mp) :: avgproot2str real(kind=r_2), intent(in), dimension(mp) :: avgpwood2cwd real(kind=r_2), intent(in), dimension(mp) :: avgcnpp real(kind=r_2), intent(in), dimension(mp) :: avgxkNlimiting real(kind=r_2), intent(in), dimension(mp) :: avgxklitter real(kind=r_2), intent(in), dimension(mp) :: avgxksoil real(kind=r_2), intent(in), dimension(mp) :: avgratioNCsoilmic real(kind=r_2), intent(in), dimension(mp) :: avgratioNCsoilslow real(kind=r_2), intent(in), dimension(mp) :: avgratioNCsoilpass real(kind=r_2), intent(in), dimension(mp) :: avgnsoilmin real(kind=r_2), intent(in), dimension(mp) :: avgpsoillab real(kind=r_2), intent(in), dimension(mp) :: avgpsoilsorb real(kind=r_2), intent(in), dimension(mp) :: avgpsoilocc real(kind=r_2), intent(in), dimension(mp) :: avg_c13leaf2met real(kind=r_2), intent(in), dimension(mp) :: avg_c13leaf2str real(kind=r_2), intent(in), dimension(mp) :: avg_c13root2met real(kind=r_2), intent(in), dimension(mp) :: avg_c13root2str real(kind=r_2), intent(in), dimension(mp) :: avg_c13wood2cwd type(c13o2_pool), intent(inout) :: c13o2pools Calls proc~~analyticpool~~CallsGraph proc~analyticpool casa_cable::analyticpool clay clay proc~analyticpool->clay clitter clitter proc~analyticpool->clitter csoil csoil proc~analyticpool->csoil fracligninplant fracligninplant proc~analyticpool->fracligninplant fromltos fromltos proc~analyticpool->fromltos fromstos fromstos proc~analyticpool->fromstos isorder isorder proc~analyticpool->isorder iveg iveg proc~analyticpool->iveg iveg2 iveg2 proc~analyticpool->iveg2 klitter klitter proc~analyticpool->klitter kmlabp kmlabp proc~analyticpool->kmlabp ksoil ksoil proc~analyticpool->ksoil litterrate litterrate proc~analyticpool->litterrate nlitter nlitter proc~analyticpool->nlitter nsoil nsoil proc~analyticpool->nsoil psoillab psoillab proc~analyticpool->psoillab psorbmax psorbmax proc~analyticpool->psorbmax rationclitter rationclitter proc~analyticpool->rationclitter rationcsoil rationcsoil proc~analyticpool->rationcsoil rationpsoil rationpsoil proc~analyticpool->rationpsoil ratiopclitter ratiopclitter proc~analyticpool->ratiopclitter ratiopcsoil ratiopcsoil proc~analyticpool->ratiopcsoil silt silt proc~analyticpool->silt soilrate soilrate proc~analyticpool->soilrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~analyticpool~~CalledByGraph proc~analyticpool casa_cable::analyticpool proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->proc~analyticpool Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents","tags":"","loc":"proc/analyticpool.html"},{"title":"pop_mpi – POP","text":"Uses POP_Types POP_Constants module~~pop_mpi~~UsesGraph module~pop_mpi pop_mpi module~pop_constants POP_Constants module~pop_mpi->module~pop_constants module~pop_types POP_Types module~pop_mpi->module~pop_types module~typedef TypeDef module~pop_constants->module~typedef module~pop_types->module~pop_constants module~pop_types->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables n_landscape_types n_patch_types n_layer_types n_cohort_types Subroutines create_cohort create_layer create_patch create_pop_gridcell_type Variables Type Visibility Attributes Name Initial integer, public, parameter :: n_landscape_types = 48 integer, public, parameter :: n_patch_types = 28 integer, public, parameter :: n_layer_types = 6 integer, public, parameter :: n_cohort_types = 21 Subroutines public  subroutine create_cohort (cohort_t, comm) Arguments Type Intent Optional Attributes Name integer, intent(out) :: cohort_t integer, intent(in) :: comm public  subroutine create_layer (layer_t, comm) Arguments Type Intent Optional Attributes Name integer, intent(out) :: layer_t integer, intent(in) :: comm public  subroutine create_patch (patch_t, comm) Arguments Type Intent Optional Attributes Name integer, intent(out) :: patch_t integer, intent(in) :: comm public  subroutine create_pop_gridcell_type (gcell_t, comm) Arguments Type Intent Optional Attributes Name integer, intent(out) :: gcell_t integer, intent(in) :: comm","tags":"","loc":"module/pop_mpi.html"},{"title":"cable_casaonly_luc – POP","text":"Contents Subroutines CASAONLY_LUC Subroutines public  subroutine CASAONLY_LUC (dels, kstart, kend, veg, soil, casabiome, casapool, casaflux, casamet, casabal, phen, POP, climate, LALLOC, LUC_EXPT, POPLUC, sum_casapool, sum_casaflux, c13o2flux, c13o2pools, sum_c13o2pools, c13o2luc) CLN  CHARACTER(LEN=99), INTENT(IN)  :: fcnpspin\n vh_js !!\nCLN901  format(A99) Arguments Type Intent Optional Attributes Name real, intent(in) :: dels integer, intent(in) :: kstart integer, intent(in) :: kend type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( casa_balance ), intent(inout) :: casabal type( phen_variable ), intent(inout) :: phen type( POP_TYPE ), intent(inout) :: POP type(climate_TYPE), intent(inout) :: climate integer, intent(in) :: LALLOC type(LUC_EXPT_TYPE), intent(inout) :: LUC_EXPT type( POPLUC_TYPE ), intent(inout) :: POPLUC type( casa_pool ), intent(inout) :: sum_casapool type( casa_flux ), intent(inout) :: sum_casaflux type(c13o2_flux), intent(inout) :: c13o2flux type(c13o2_pool), intent(inout) :: c13o2pools type(c13o2_pool), intent(inout) :: sum_c13o2pools type(c13o2_luc), intent(inout) :: c13o2luc","tags":"","loc":"module/cable_casaonly_luc.html"},{"title":"cable_spincasacnp – POP","text":"Contents Subroutines spincasacnp Subroutines public  subroutine spincasacnp (dels, kstart, kend, mloop, veg, soil, casabiome, casapool, casaflux, casamet, casabal, phen, pop, climate, lalloc, c13o2flux, c13o2pools, BLAZE, SIMFIRE) CLN  character(len=99), intent(in)  :: fcnpspin\n vh_js !!\nCLN  OPEN(91, file=fcnpspin)\nCLN  read(91,*) myearspin\nCLN    CLOSE(91) Read more… Arguments Type Intent Optional Attributes Name real, intent(in) :: dels integer, intent(in) :: kstart integer, intent(in) :: kend integer, intent(in) :: mloop type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( casa_balance ), intent(inout) :: casabal type( phen_variable ), intent(inout) :: phen type( POP_TYPE ), intent(inout) :: pop type(climate_type), intent(inout) :: climate integer, intent(in) :: lalloc type(c13o2_flux), intent(inout) :: c13o2flux type(c13o2_pool), intent(inout) :: c13o2pools type(TYPE_BLAZE), intent(inout) :: BLAZE type(TYPE_SIMFIRE), intent(inout) :: SIMFIRE","tags":"","loc":"module/cable_spincasacnp.html"},{"title":"casadimension – POP","text":"Uses cable_def_types_mod module~~casadimension~~UsesGraph module~casadimension casadimension cable_def_types_mod cable_def_types_mod module~casadimension->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~casadimension~~UsedByGraph module~casadimension casadimension module~casa_cnp_module casa_cnp_module module~casa_cnp_module->module~casadimension module~phenvariable phenvariable module~casa_cnp_module->module~phenvariable module~phenvariable->module~casadimension proc~alloc_casabal casavariable::alloc_casabal proc~alloc_casabal->module~casadimension proc~alloc_casabiome casavariable::alloc_casabiome proc~alloc_casabiome->module~casadimension proc~alloc_casaflux casavariable::alloc_casaflux proc~alloc_casaflux->module~casadimension proc~alloc_casamet casavariable::alloc_casamet proc~alloc_casamet->module~casadimension proc~alloc_casapool casavariable::alloc_casapool proc~alloc_casapool->module~casadimension proc~alloc_phenvariable phenvariable::alloc_phenvariable proc~alloc_phenvariable->module~casadimension proc~analyticpool casa_cable::analyticpool proc~analyticpool->module~casadimension proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->module~casadimension proc~bgcdriver->module~phenvariable proc~biogeochem casa_inout::biogeochem proc~biogeochem->module~casadimension proc~biogeochem->module~casa_cnp_module proc~cable_phenology_clim cable_phenology_module::cable_phenology_clim proc~cable_phenology_clim->module~casadimension proc~cable_phenology_clim->module~phenvariable proc~casa_cnpflux casa_inout::casa_cnpflux proc~casa_cnpflux->module~casadimension proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->module~casadimension proc~casa_feedback->module~casa_cnp_module proc~casa_fluxout casa_inout::casa_fluxout proc~casa_fluxout->module~casadimension proc~casa_fluxout->module~phenvariable proc~casa_init casa_inout::casa_init proc~casa_init->module~casadimension proc~casa_init->module~phenvariable proc~casa_poolout casa_inout::casa_poolout proc~casa_poolout->module~casadimension proc~casa_poolout->module~phenvariable proc~casa_readbiome casa_inout::casa_readbiome proc~casa_readbiome->module~casadimension proc~casa_readbiome->module~phenvariable proc~casa_readphen casa_inout::casa_readphen proc~casa_readphen->module~casadimension proc~casa_readphen->module~phenvariable proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->module~casadimension proc~casaonly_luc->module~phenvariable proc~pop_io cable_pop_io::POP_IO proc~pop_io->module~casadimension proc~popdriver casa_cable::POPdriver proc~popdriver->module~casadimension proc~popdriver->module~phenvariable proc~read_casa_dump casa_cable::read_casa_dump proc~read_casa_dump->module~casadimension proc~read_casa_dump->module~phenvariable proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->module~casadimension proc~spincasacnp->module~phenvariable proc~sumcflux casa_cable::sumcflux proc~sumcflux->module~casadimension proc~totcnppools casa_cable::totcnppools proc~totcnppools->module~casadimension proc~write_casa_dump casa_cable::write_casa_dump proc~write_casa_dump->module~casadimension proc~write_casa_dump->module~phenvariable proc~write_casa_output_nc casa_inout::write_casa_output_nc proc~write_casa_output_nc->module~casadimension proc~read_casa_restart_nc casa_inout::read_casa_restart_nc proc~read_casa_restart_nc->module~phenvariable proc~write_casa_restart_nc casa_inout::write_casa_restart_nc proc~write_casa_restart_nc->module~phenvariable proc~zero_casa_dump casa_inout::zero_casa_dump proc~zero_casa_dump->module~phenvariable Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables mdyear mdmonth mdweek mmyear mt mpftmax mplant mlitter msoil mso mhwp mclear mheights icycle mstart mphase deltcasa deltpool Variables Type Visibility Attributes Name Initial integer, public, parameter :: mdyear = 365 integer, public, parameter :: mdmonth = 30 integer, public, parameter :: mdweek = 7 integer, public, parameter :: mmyear = 12 integer, public, parameter :: mt = 36500 integer, public, parameter :: mpftmax = 2 integer, public, parameter :: mplant = 3 integer, public, parameter :: mlitter = 3 integer, public, parameter :: msoil = 3 integer, public, parameter :: mso = 12 integer, public, parameter :: mhwp = 1 integer, public, parameter :: mclear = 1 integer, public, parameter :: mheights = 10 integer, public :: icycle integer, public, parameter :: mstart = 1 integer, public, parameter :: mphase = 4 real(kind=r_2), public, parameter :: deltcasa = 1.0_r_2/365.0_r_2 real(kind=r_2), public, parameter :: deltpool = 1.0_r_2","tags":"","loc":"module/casadimension.html"},{"title":"casaparm – POP","text":"Uses cable_def_types_mod module~~casaparm~~UsesGraph module~casaparm casaparm cable_def_types_mod cable_def_types_mod module~casaparm->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~casaparm~~UsedByGraph module~casaparm casaparm module~casa_cnp_module casa_cnp_module module~casa_cnp_module->module~casaparm proc~analyticpool casa_cable::analyticpool proc~analyticpool->module~casaparm proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->module~casaparm proc~cable_phenology_clim cable_phenology_module::cable_phenology_clim proc~cable_phenology_clim->module~casaparm proc~casa_cnpflux casa_inout::casa_cnpflux proc~casa_cnpflux->module~casaparm proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->module~casaparm proc~casa_feedback->module~casa_cnp_module proc~casa_fluxout casa_inout::casa_fluxout proc~casa_fluxout->module~casaparm proc~casa_init casa_inout::casa_init proc~casa_init->module~casaparm proc~casa_poolout casa_inout::casa_poolout proc~casa_poolout->module~casaparm proc~casa_readbiome casa_inout::casa_readbiome proc~casa_readbiome->module~casaparm proc~casa_readphen casa_inout::casa_readphen proc~casa_readphen->module~casaparm proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->module~casaparm proc~popdriver casa_cable::POPdriver proc~popdriver->module~casaparm proc~popluc_init POPLUC_Module::POPLUC_Init proc~popluc_init->module~casaparm proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->module~casaparm proc~sumcflux casa_cable::sumcflux proc~sumcflux->module~casaparm proc~totcnppools casa_cable::totcnppools proc~totcnppools->module~casaparm proc~biogeochem casa_inout::biogeochem proc~biogeochem->module~casa_cnp_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables initcasa iceland cropland croplnd2 forest shrub grass icewater LEAF WOOD FROOT METB STR CWD MIC SLOW pass PLAB PSORB POCC z30 R0 S0 fixed_stem Q10alloc ratioNCstrfix ratioNPstrfix fracCbiomass tsoilrefc tkzeroc frootparma frootparmb frootparmc xweightalloc Variables Type Visibility Attributes Name Initial integer, public, parameter :: initcasa = 1 integer, public, parameter :: iceland = 17 integer, public, parameter :: cropland = 9 integer, public, parameter :: croplnd2 = 10 integer, public, parameter :: forest = 3 integer, public, parameter :: shrub = 2 integer, public, parameter :: grass = 1 integer, public, parameter :: icewater = 0 integer, public, parameter :: LEAF = 1 integer, public, parameter :: WOOD = 2 integer, public, parameter :: FROOT = 3 integer, public, parameter :: METB = 1 integer, public, parameter :: STR = 2 integer, public, parameter :: CWD = 3 integer, public, parameter :: MIC = 1 integer, public, parameter :: SLOW = 2 integer, public, parameter :: pass = 3 integer, public, parameter :: PLAB = 1 integer, public, parameter :: PSORB = 2 integer, public, parameter :: POCC = 3 vh_js !! LALLOC moved to bgcdriver to allow for value to be switchable real(kind=r_2), public, parameter :: z30 = 0.3_r_2 real(kind=r_2), public, parameter :: R0 = 0.3_r_2 real(kind=r_2), public, parameter :: S0 = 0.3_r_2 real(kind=r_2), public, parameter :: fixed_stem = 1.0_r_2/3.0_r_2 real(kind=r_2), public, parameter :: Q10alloc = 2.0_r_2 real(kind=r_2), public, parameter :: ratioNCstrfix = 1.0_r_2/150.0_r_2 real(kind=r_2), public, parameter :: ratioNPstrfix = 25.0_r_2 real(kind=r_2), public, parameter :: fracCbiomass = 0.50_r_2 real(kind=r_2), public, parameter :: tsoilrefc = 25.0_r_2 real(kind=r_2), public, parameter :: tkzeroc = 273.15_r_2 real(kind=r_2), public, parameter :: frootparma = 0.3192_r_2 real(kind=r_2), public, parameter :: frootparmb = -0.0485_r_2 real(kind=r_2), public, parameter :: frootparmc = 0.1755_r_2 real(kind=r_2), public, parameter :: xweightalloc = 0.2_r_2","tags":"","loc":"module/casaparm.html"},{"title":"casavariable – POP","text":"Uses cable_def_types_mod module~~casavariable~~UsesGraph module~casavariable casavariable cable_def_types_mod cable_def_types_mod module~casavariable->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~casavariable~~UsedByGraph module~casavariable casavariable module~casa_cnp_module casa_cnp_module module~casa_cnp_module->module~casavariable module~popluc_module POPLUC_Module module~popluc_module->module~casavariable proc~analyticpool casa_cable::analyticpool proc~analyticpool->module~casavariable proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->module~casavariable proc~cable_phenology_clim cable_phenology_module::cable_phenology_clim proc~cable_phenology_clim->module~casavariable proc~casa_cnpflux casa_inout::casa_cnpflux proc~casa_cnpflux->module~casavariable proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->module~casavariable proc~casa_feedback->module~casa_cnp_module proc~casa_fluxout casa_inout::casa_fluxout proc~casa_fluxout->module~casavariable proc~casa_init casa_inout::casa_init proc~casa_init->module~casavariable proc~casa_poolout casa_inout::casa_poolout proc~casa_poolout->module~casavariable proc~casa_readbiome casa_inout::casa_readbiome proc~casa_readbiome->module~casavariable proc~casa_readphen casa_inout::casa_readphen proc~casa_readphen->module~casavariable proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->module~casavariable proc~casaonly_luc->module~popluc_module proc~pop_io cable_pop_io::POP_IO proc~pop_io->module~casavariable proc~popdriver casa_cable::POPdriver proc~popdriver->module~casavariable proc~read_casa_dump casa_cable::read_casa_dump proc~read_casa_dump->module~casavariable proc~read_casa_restart_nc casa_inout::read_casa_restart_nc proc~read_casa_restart_nc->module~casavariable proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->module~casavariable proc~sumcflux casa_cable::sumcflux proc~sumcflux->module~casavariable proc~totcnppools casa_cable::totcnppools proc~totcnppools->module~casavariable proc~write_casa_dump casa_cable::write_casa_dump proc~write_casa_dump->module~casavariable proc~write_casa_output_nc casa_inout::write_casa_output_nc proc~write_casa_output_nc->module~casavariable proc~write_casa_restart_nc casa_inout::write_casa_restart_nc proc~write_casa_restart_nc->module~casavariable proc~zero_casa_dump casa_inout::zero_casa_dump proc~zero_casa_dump->module~casavariable proc~biogeochem casa_inout::biogeochem proc~biogeochem->module~casa_cnp_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables ncasa_biome ncasa_pool ncasa_flux ncasa_met ncasa_bal casa_timeunits casafile Interfaces alloc_casa_var zero_casa_var print_casa_var read_netcdf_casa_var write_netcdf_casa_var Derived Types casa_biome casa_pool casa_flux casa_met casa_balance casafiles_type Subroutines alloc_casabiome alloc_casapool alloc_casaflux alloc_casamet alloc_casabal alloc_sum_casa zero_casabiome zero_casapool zero_casaflux zero_casamet zero_casabal print_casabiome print_casapool print_casaflux print_casamet print_casabal zero_sum_casa update_sum_casa read_netcdf_casabiome read_netcdf_casapool read_netcdf_casaflux read_netcdf_casamet read_netcdf_casabal write_netcdf_casabiome write_netcdf_casapool write_netcdf_casaflux write_netcdf_casamet write_netcdf_casabal Variables Type Visibility Attributes Name Initial integer, public, parameter :: ncasa_biome = 53 integer, public, parameter :: ncasa_pool = 42 integer, public, parameter :: ncasa_flux = 91 integer, public, parameter :: ncasa_met = 47 integer, public, parameter :: ncasa_bal = 47 character(len=200), public :: casa_timeunits type( casafiles_type ), public :: casafile Interfaces public        interface alloc_casa_var private  subroutine alloc_casabiome (casabiome) vh_js !! Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(inout) :: casabiome private  subroutine alloc_casapool (casapool, arraysize) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: casapool integer, intent(in) :: arraysize private  subroutine alloc_casaflux (casaflux, arraysize) Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(inout) :: casaflux integer, intent(in) :: arraysize private  subroutine alloc_casamet (casamet, arraysize) Arguments Type Intent Optional Attributes Name type( casa_met ), intent(inout) :: casamet integer, intent(in) :: arraysize private  subroutine alloc_casabal (casabal, arraysize) Arguments Type Intent Optional Attributes Name type( casa_balance ), intent(inout) :: casabal integer, intent(in) :: arraysize public        interface zero_casa_var private  subroutine zero_casabiome (casabiome) Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(inout) :: casabiome private  subroutine zero_casapool (casapool) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: casapool private  subroutine zero_casaflux (casaflux) Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(inout) :: casaflux private  subroutine zero_casamet (casamet) Arguments Type Intent Optional Attributes Name type( casa_met ), intent(inout) :: casamet private  subroutine zero_casabal (casabal) Arguments Type Intent Optional Attributes Name type( casa_balance ), intent(inout) :: casabal public        interface print_casa_var private  subroutine print_casabiome (casabiome) Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(in) :: casabiome private  subroutine print_casapool (casapool) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(in) :: casapool private  subroutine print_casaflux (casaflux) Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(in) :: casaflux private  subroutine print_casamet (casamet) Arguments Type Intent Optional Attributes Name type( casa_met ), intent(in) :: casamet private  subroutine print_casabal (casabal) Arguments Type Intent Optional Attributes Name type( casa_balance ), intent(in) :: casabal public        interface read_netcdf_casa_var private  subroutine read_netcdf_casabiome (filename, casabiome) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_biome ), intent(inout) :: casabiome private  subroutine read_netcdf_casapool (filename, casapool) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_pool ), intent(inout) :: casapool private  subroutine read_netcdf_casaflux (filename, casaflux) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_flux ), intent(inout) :: casaflux private  subroutine read_netcdf_casamet (filename, casamet) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_met ), intent(inout) :: casamet private  subroutine read_netcdf_casabal (filename, casabal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_balance ), intent(inout) :: casabal public        interface write_netcdf_casa_var private  subroutine write_netcdf_casabiome (filename, casabiome) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_biome ), intent(in) :: casabiome private  subroutine write_netcdf_casapool (filename, casapool) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_pool ), intent(in) :: casapool private  subroutine write_netcdf_casaflux (filename, casaflux) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_flux ), intent(in) :: casaflux private  subroutine write_netcdf_casamet (filename, casamet) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_met ), intent(in) :: casamet private  subroutine write_netcdf_casabal (filename, casabal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_balance ), intent(in) :: casabal Derived Types type, public :: casa_biome Components Type Visibility Attributes Name Initial integer, public, dimension(:), pointer :: ivt2 => null() real(kind=r_2), public, dimension(:), pointer :: xkleafcoldmax => null() real(kind=r_2), public, dimension(:), pointer :: xkleafcoldexp => null() real(kind=r_2), public, dimension(:), pointer :: xkleafdrymax => null() real(kind=r_2), public, dimension(:), pointer :: xkleafdryexp => null() real(kind=r_2), public, dimension(:), pointer :: glaimax => null() real(kind=r_2), public, dimension(:), pointer :: glaimin => null() real(kind=r_2), public, dimension(:), pointer :: sla => null() real(kind=r_2), public, dimension(:), pointer :: ratiofrootleaf => null() real(kind=r_2), public, dimension(:), pointer :: kroot => null() real(kind=r_2), public, dimension(:), pointer :: krootlen => null() real(kind=r_2), public, dimension(:), pointer :: rootdepth => null() real(kind=r_2), public, dimension(:), pointer :: kuptake => null() real(kind=r_2), public, dimension(:), pointer :: kminN => null() real(kind=r_2), public, dimension(:), pointer :: kuplabP => null() real(kind=r_2), public, dimension(:), pointer :: kclabrate => null() real(kind=r_2), public, dimension(:), pointer :: xnpmax => null() real(kind=r_2), public, dimension(:), pointer :: q10soil => null() real(kind=r_2), public, dimension(:), pointer :: xkoptlitter => null() real(kind=r_2), public, dimension(:), pointer :: xkoptsoil => null() real(kind=r_2), public, dimension(:), pointer :: xkplab => null() real(kind=r_2), public, dimension(:), pointer :: xkpsorb => null() real(kind=r_2), public, dimension(:), pointer :: xkpocc => null() real(kind=r_2), public, dimension(:), pointer :: prodptase => null() real(kind=r_2), public, dimension(:), pointer :: costnpup => null() real(kind=r_2), public, dimension(:), pointer :: maxfinelitter => null() real(kind=r_2), public, dimension(:), pointer :: maxcwd => null() real(kind=r_2), public, dimension(:), pointer :: nintercept => null() real(kind=r_2), public, dimension(:), pointer :: nslope => null() real(kind=r_2), public, dimension(:), pointer :: la_to_sa => null() real(kind=r_2), public, dimension(:), pointer :: vcmax_scalar => null() real(kind=r_2), public, dimension(:), pointer :: disturbance_interval => null() real(kind=r_2), public, dimension(:), pointer :: DAMM_EnzPool => null() real(kind=r_2), public, dimension(:), pointer :: DAMM_KMO2 => null() real(kind=r_2), public, dimension(:), pointer :: DAMM_KMcp => null() real(kind=r_2), public, dimension(:), pointer :: DAMM_Ea => null() real(kind=r_2), public, dimension(:), pointer :: DAMM_alpha => null() real(kind=r_2), public, dimension(:,:), pointer :: plantrate => null() real(kind=r_2), public, dimension(:,:), pointer :: rmplant => null() real(kind=r_2), public, dimension(:,:), pointer :: fracnpptoP => null() real(kind=r_2), public, dimension(:,:), pointer :: fraclignin => null() real(kind=r_2), public, dimension(:,:), pointer :: fraclabile => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNCplantmin => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNCplantmax => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNPplantmin => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNPplantmax => null() real(kind=r_2), public, dimension(:,:), pointer :: fracLigninplant => null() real(kind=r_2), public, dimension(:,:), pointer :: ftransNPtoL => null() real(kind=r_2), public, dimension(:,:), pointer :: ftransPPtoL => null() real(kind=r_2), public, dimension(:,:), pointer :: litterrate => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioPcplantmin => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioPcplantmax => null() real(kind=r_2), public, dimension(:,:), pointer :: soilrate => null() type, public :: casa_pool Components Type Visibility Attributes Name Initial real(kind=r_2), public, dimension(:), pointer :: Clabile => null() vh_js !! real(kind=r_2), public, dimension(:), pointer :: dClabiledt => null() vh_js !! real(kind=r_2), public, dimension(:), pointer :: Ctot => null() vh_js !! real(kind=r_2), public, dimension(:), pointer :: Ctot_0 => null() vh_js !! real(kind=r_2), public, dimension(:,:), pointer :: Cplant => null() real(kind=r_2), public, dimension(:,:), pointer :: Nplant => null() real(kind=r_2), public, dimension(:,:), pointer :: Pplant => null() real(kind=r_2), public, dimension(:,:), pointer :: dCplantdt => null() real(kind=r_2), public, dimension(:,:), pointer :: dNplantdt => null() real(kind=r_2), public, dimension(:,:), pointer :: dPplantdt => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNCplant => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNPplant => null() real(kind=r_2), public, dimension(:), pointer :: Nsoilmin => null() real(kind=r_2), public, dimension(:), pointer :: Psoillab => null() real(kind=r_2), public, dimension(:), pointer :: Psoilsorb => null() real(kind=r_2), public, dimension(:), pointer :: Psoilocc => null() real(kind=r_2), public, dimension(:), pointer :: dNsoilmindt => null() real(kind=r_2), public, dimension(:), pointer :: dPsoillabdt => null() real(kind=r_2), public, dimension(:), pointer :: dPsoilsorbdt => null() real(kind=r_2), public, dimension(:), pointer :: dPsoiloccdt => null() real(kind=r_2), public, dimension(:,:), pointer :: Clitter => null() real(kind=r_2), public, dimension(:,:), pointer :: Nlitter => null() real(kind=r_2), public, dimension(:,:), pointer :: Plitter => null() real(kind=r_2), public, dimension(:,:), pointer :: dClitterdt => null() real(kind=r_2), public, dimension(:,:), pointer :: dNlitterdt => null() real(kind=r_2), public, dimension(:,:), pointer :: dPlitterdt => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNClitter => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNPlitter => null() real(kind=r_2), public, dimension(:,:), pointer :: Csoil => null() real(kind=r_2), public, dimension(:,:), pointer :: Nsoil => null() real(kind=r_2), public, dimension(:,:), pointer :: Psoil => null() real(kind=r_2), public, dimension(:,:), pointer :: dCsoildt => null() real(kind=r_2), public, dimension(:,:), pointer :: dNsoildt => null() real(kind=r_2), public, dimension(:,:), pointer :: dPsoildt => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNCsoil => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNCsoilnew => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNPsoil => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNCsoilmin => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioNCsoilmax => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioPCsoil => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioPCplant => null() real(kind=r_2), public, dimension(:,:), pointer :: ratioPClitter => null() type, public :: casa_flux Components Type Visibility Attributes Name Initial real(kind=r_2), public, dimension(:), pointer :: Cgpp => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Cnpp => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Crp => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Crgplant => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Nminfix => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Nminuptake => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Plabuptake => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Clabloss => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: fracClabile => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: stemnpp => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: frac_sapwood => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: sapwood_area => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Charvest => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Nharvest => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: Pharvest => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: fHarvest => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:), pointer :: fcrop => null() vh_js !! the 3 variables below are needed for POP coupling to CASA real(kind=r_2), public, dimension(:,:), pointer :: fracCalloc => null() vh_js !! additional diagnostic real(kind=r_2), public, dimension(:,:), pointer :: fracNalloc => null() vh_js !! additional diagnostic real(kind=r_2), public, dimension(:,:), pointer :: fracPalloc => null() vh_js !! additional diagnostic real(kind=r_2), public, dimension(:,:), pointer :: Crmplant => null() vh_js !! additional diagnostic real(kind=r_2), public, dimension(:,:), pointer :: kplant => null() vh_js !! additional diagnostic real(kind=r_2), public, dimension(:,:), pointer :: Cplant_turnover => null() vh_js !! additional diagnostic real(kind=r_2), public, dimension(:,:,:), pointer :: fromPtoL => null() real(kind=r_2), public, dimension(:), pointer :: Cnep => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Crsoil => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nmindep => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nminloss => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nminleach => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nupland => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nlittermin => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nsmin => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nsimm => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Nsnet => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: fNminloss => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: fNminleach => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Pdep => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Pwea => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Pleach => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Ploss => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Pupland => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Plittermin => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Psmin => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Psimm => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Psnet => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: fPleach => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: kplab => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: kpsorb => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: kpocc => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: kmlabp => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Psorbmax => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Cplant_turnover_disturbance => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Cplant_turnover_crowding => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:), pointer :: Cplant_turnover_resource_limitation => null() additional diagnostics for partitioning biomass turnover real(kind=r_2), public, dimension(:,:), pointer :: klitter => null() real(kind=r_2), public, dimension(:,:), pointer :: ksoil => null() real(kind=r_2), public, dimension(:,:,:), pointer :: fromLtoS => null() real(kind=r_2), public, dimension(:,:,:), pointer :: fromStoS => null() real(kind=r_2), public, dimension(:,:), pointer :: fromLtoCO2 => null() real(kind=r_2), public, dimension(:,:), pointer :: fromStoCO2 => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxCtolitter => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxNtolitter => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxPtolitter => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxCtosoil => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxNtosoil => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxPtosoil => null() real(kind=r_2), public, dimension(:), pointer :: FluxCtoCO2 => null() real(kind=r_2), public, dimension(:), pointer :: FluxCtohwp => null() real(kind=r_2), public, dimension(:), pointer :: FluxNtohwp => null() real(kind=r_2), public, dimension(:), pointer :: FluxPtohwp => null() real(kind=r_2), public, dimension(:), pointer :: FluxCtoclear => null() real(kind=r_2), public, dimension(:), pointer :: FluxNtoclear => null() real(kind=r_2), public, dimension(:), pointer :: FluxPtoclear => null() real(kind=r_2), public, dimension(:), pointer :: CtransferLUC => null() real(kind=r_2), public, dimension(:,:,:), pointer :: fromPtoL_fire => null() real(kind=r_2), public, dimension(:,:), pointer :: klitter_fire => null() real(kind=r_2), public, dimension(:,:), pointer :: klitter_tot => null() real(kind=r_2), public, dimension(:,:), pointer :: kplant_fire => null() real(kind=r_2), public, dimension(:,:), pointer :: kplant_tot => null() real(kind=r_2), public, dimension(:), pointer :: fluxCtoCO2_plant_fire => null() real(kind=r_2), public, dimension(:), pointer :: fluxCtoCO2_litter_fire => null() real(kind=r_2), public, dimension(:,:), pointer :: fluxfromPtoCO2_fire => null() real(kind=r_2), public, dimension(:,:), pointer :: fluxfromLtoCO2_fire => null() real(kind=r_2), public, dimension(:), pointer :: fluxNtoAtm_fire => null() real(kind=r_2), public, dimension(:,:,:), pointer :: FluxFromPtoL => null() real(kind=r_2), public, dimension(:,:,:), pointer :: FluxFromLtoS => null() real(kind=r_2), public, dimension(:,:,:), pointer :: FluxFromStoS => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxFromPtoCO2 => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxFromLtoCO2 => null() real(kind=r_2), public, dimension(:,:), pointer :: FluxFromStoCO2 => null() real(kind=r_2), public, dimension(:), pointer :: FluxFromPtoHarvest => null() type, public :: casa_met Components Type Visibility Attributes Name Initial real(kind=r_2), public, dimension(:), pointer :: glai => null() real(kind=r_2), public, dimension(:), pointer :: Tairk => null() real(kind=r_2), public, dimension(:), pointer :: precip => null() real(kind=r_2), public, dimension(:), pointer :: tsoilavg => null() real(kind=r_2), public, dimension(:), pointer :: moistavg => null() real(kind=r_2), public, dimension(:), pointer :: btran => null() integer, public, dimension(:), pointer :: lnonwood => null() real(kind=r_2), public, dimension(:,:), pointer :: Tsoil => null() real(kind=r_2), public, dimension(:,:), pointer :: moist => null() integer, public, dimension(:), pointer :: iveg2 => null() integer, public, dimension(:), pointer :: ijgcm => null() integer, public, dimension(:), pointer :: isorder => null() real(kind=r_2), public, dimension(:), pointer :: lat => null() real(kind=r_2), public, dimension(:), pointer :: lon => null() real(kind=r_2), public, dimension(:), pointer :: areacell => null() real(kind=r_2), public, dimension(:,:), pointer :: Tairkspin => null() real(kind=r_2), public, dimension(:,:), pointer :: cgppspin => null() real(kind=r_2), public, dimension(:,:), pointer :: crmplantspin_1 => null() real(kind=r_2), public, dimension(:,:), pointer :: crmplantspin_2 => null() real(kind=r_2), public, dimension(:,:), pointer :: crmplantspin_3 => null() real(kind=r_2), public, dimension(:,:), pointer :: Tsoilspin_1 => null() real(kind=r_2), public, dimension(:,:), pointer :: Tsoilspin_2 => null() real(kind=r_2), public, dimension(:,:), pointer :: Tsoilspin_3 => null() real(kind=r_2), public, dimension(:,:), pointer :: Tsoilspin_4 => null() real(kind=r_2), public, dimension(:,:), pointer :: Tsoilspin_5 => null() real(kind=r_2), public, dimension(:,:), pointer :: Tsoilspin_6 => null() real(kind=r_2), public, dimension(:,:), pointer :: moistspin_1 => null() real(kind=r_2), public, dimension(:,:), pointer :: moistspin_2 => null() real(kind=r_2), public, dimension(:,:), pointer :: moistspin_3 => null() real(kind=r_2), public, dimension(:,:), pointer :: moistspin_4 => null() real(kind=r_2), public, dimension(:,:), pointer :: moistspin_5 => null() real(kind=r_2), public, dimension(:,:), pointer :: moistspin_6 => null() real(kind=r_2), public, dimension(:,:), pointer :: mtempspin => null() real(kind=r_2), public, dimension(:,:), pointer :: frecspin => null() real(kind=r_2), public, dimension(:,:), pointer :: cAn12spin => null() real(kind=r_2), public, dimension(:,:), pointer :: cAn13spin => null() real(kind=r_2), public, dimension(:,:), pointer :: dprecip_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: aprecip_av20_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: du10_max_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: drhum_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: dtemp_max_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: dtemp_min_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: KBDI_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: D_MacArthur_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: FFDI_spin => null() real(kind=r_2), public, dimension(:,:), pointer :: last_precip_spin => null() integer, public, dimension(:,:), pointer :: DSLR_spin => null() type, public :: casa_balance Components Type Visibility Attributes Name Initial real(kind=r_2), public, dimension(:), pointer :: FCgppyear => null() real(kind=r_2), public, dimension(:), pointer :: FCnppyear => null() real(kind=r_2), public, dimension(:), pointer :: FCrmleafyear => null() real(kind=r_2), public, dimension(:), pointer :: FCrmwoodyear => null() real(kind=r_2), public, dimension(:), pointer :: FCrmrootyear => null() real(kind=r_2), public, dimension(:), pointer :: FCrgrowyear => null() real(kind=r_2), public, dimension(:), pointer :: FCrpyear => null() real(kind=r_2), public, dimension(:), pointer :: FCrsyear => null() real(kind=r_2), public, dimension(:), pointer :: FCneeyear => null() real(kind=r_2), public, dimension(:), pointer :: dCdtyear => null() real(kind=r_2), public, dimension(:), pointer :: LAImax => null() real(kind=r_2), public, dimension(:), pointer :: Cleafmean => null() real(kind=r_2), public, dimension(:), pointer :: Crootmean => null() real(kind=r_2), public, dimension(:), pointer :: FNdepyear => null() real(kind=r_2), public, dimension(:), pointer :: FNfixyear => null() real(kind=r_2), public, dimension(:), pointer :: FNsnetyear => null() real(kind=r_2), public, dimension(:), pointer :: FNupyear => null() real(kind=r_2), public, dimension(:), pointer :: FNleachyear => null() real(kind=r_2), public, dimension(:), pointer :: FNlossyear => null() real(kind=r_2), public, dimension(:), pointer :: FPweayear => null() real(kind=r_2), public, dimension(:), pointer :: FPdustyear => null() real(kind=r_2), public, dimension(:), pointer :: FPsnetyear => null() real(kind=r_2), public, dimension(:), pointer :: FPupyear => null() real(kind=r_2), public, dimension(:), pointer :: FPleachyear => null() real(kind=r_2), public, dimension(:), pointer :: FPlossyear => null() real(kind=r_2), public, dimension(:,:), pointer :: glaimon => null() real(kind=r_2), public, dimension(:,:), pointer :: glaimonx => null() real(kind=r_2), public, dimension(:,:), pointer :: cplantlast => null() real(kind=r_2), public, dimension(:,:), pointer :: nplantlast => null() real(kind=r_2), public, dimension(:,:), pointer :: pplantlast => null() real(kind=r_2), public, dimension(:,:), pointer :: clitterlast => null() real(kind=r_2), public, dimension(:,:), pointer :: nlitterlast => null() real(kind=r_2), public, dimension(:,:), pointer :: plitterlast => null() real(kind=r_2), public, dimension(:,:), pointer :: csoillast => null() real(kind=r_2), public, dimension(:,:), pointer :: nsoillast => null() real(kind=r_2), public, dimension(:,:), pointer :: psoillast => null() real(kind=r_2), public, dimension(:), pointer :: nsoilminlast => null() real(kind=r_2), public, dimension(:), pointer :: psoillablast => null() real(kind=r_2), public, dimension(:), pointer :: psoilsorblast => null() real(kind=r_2), public, dimension(:), pointer :: psoilocclast => null() real(kind=r_2), public, dimension(:), pointer :: cbalance => null() real(kind=r_2), public, dimension(:), pointer :: nbalance => null() real(kind=r_2), public, dimension(:), pointer :: pbalance => null() real(kind=r_2), public, dimension(:), pointer :: sumcbal => null() real(kind=r_2), public, dimension(:), pointer :: sumnbal => null() real(kind=r_2), public, dimension(:), pointer :: sumpbal => null() real(kind=r_2), public, dimension(:), pointer :: clabilelast => null() type, public :: casafiles_type Components Type Visibility Attributes Name Initial character(len=200), public :: cnpbiome character(len=200), public :: cnppoint character(len=200), public :: cnpepool character(len=200), public :: cnpipool = '' character(len=200), public :: cnpmetin character(len=200), public :: cnpmetout character(len=200), public :: ndep character(len=200), public :: cnpspin character(len=200), public :: dump_cnpspin character(len=200), public :: phen character(len=200), public :: cnpflux logical, public :: l_ndep character(len=200), public :: c2cdumppath = '' character(len=200), public :: out = '' Subroutines private  subroutine alloc_casabiome (casabiome) vh_js !! Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(inout) :: casabiome private  subroutine alloc_casapool (casapool, arraysize) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: casapool integer, intent(in) :: arraysize private  subroutine alloc_casaflux (casaflux, arraysize) Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(inout) :: casaflux integer, intent(in) :: arraysize private  subroutine alloc_casamet (casamet, arraysize) Arguments Type Intent Optional Attributes Name type( casa_met ), intent(inout) :: casamet integer, intent(in) :: arraysize private  subroutine alloc_casabal (casabal, arraysize) Arguments Type Intent Optional Attributes Name type( casa_balance ), intent(inout) :: casabal integer, intent(in) :: arraysize public  subroutine alloc_sum_casa (sum_casapool, sum_casaflux, arraysize) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: sum_casapool type( casa_flux ), intent(inout) :: sum_casaflux integer, intent(in) :: arraysize private  subroutine zero_casabiome (casabiome) Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(inout) :: casabiome private  subroutine zero_casapool (casapool) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: casapool private  subroutine zero_casaflux (casaflux) Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(inout) :: casaflux private  subroutine zero_casamet (casamet) Arguments Type Intent Optional Attributes Name type( casa_met ), intent(inout) :: casamet private  subroutine zero_casabal (casabal) Arguments Type Intent Optional Attributes Name type( casa_balance ), intent(inout) :: casabal private  subroutine print_casabiome (casabiome) Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(in) :: casabiome private  subroutine print_casapool (casapool) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(in) :: casapool private  subroutine print_casaflux (casaflux) Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(in) :: casaflux private  subroutine print_casamet (casamet) Arguments Type Intent Optional Attributes Name type( casa_met ), intent(in) :: casamet private  subroutine print_casabal (casabal) Arguments Type Intent Optional Attributes Name type( casa_balance ), intent(in) :: casabal public  subroutine zero_sum_casa (sum_casapool, sum_casaflux) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: sum_casapool type( casa_flux ), intent(inout) :: sum_casaflux public  subroutine update_sum_casa (sum_casapool, sum_casaflux, casapool, casaflux, sum_now, average_now, nsteps) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: sum_casapool type( casa_flux ), intent(inout) :: sum_casaflux type( casa_pool ), intent(in) :: casapool type( casa_flux ), intent(in) :: casaflux logical, intent(in) :: sum_now logical, intent(in) :: average_now integer, intent(in) :: nsteps private  subroutine read_netcdf_casabiome (filename, casabiome) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_biome ), intent(inout) :: casabiome private  subroutine read_netcdf_casapool (filename, casapool) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_pool ), intent(inout) :: casapool private  subroutine read_netcdf_casaflux (filename, casaflux) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_flux ), intent(inout) :: casaflux private  subroutine read_netcdf_casamet (filename, casamet) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_met ), intent(inout) :: casamet private  subroutine read_netcdf_casabal (filename, casabal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_balance ), intent(inout) :: casabal private  subroutine write_netcdf_casabiome (filename, casabiome) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_biome ), intent(in) :: casabiome private  subroutine write_netcdf_casapool (filename, casapool) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_pool ), intent(in) :: casapool private  subroutine write_netcdf_casaflux (filename, casaflux) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_flux ), intent(in) :: casaflux private  subroutine write_netcdf_casamet (filename, casamet) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_met ), intent(in) :: casamet private  subroutine write_netcdf_casabal (filename, casabal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( casa_balance ), intent(in) :: casabal","tags":"","loc":"module/casavariable.html"},{"title":"phenvariable – POP","text":"Uses casadimension cable_def_types_mod module~~phenvariable~~UsesGraph module~phenvariable phenvariable cable_def_types_mod cable_def_types_mod module~phenvariable->cable_def_types_mod module~casadimension casadimension module~phenvariable->module~casadimension module~casadimension->cable_def_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~phenvariable~~UsedByGraph module~phenvariable phenvariable module~casa_cnp_module casa_cnp_module module~casa_cnp_module->module~phenvariable proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->module~phenvariable proc~cable_phenology_clim cable_phenology_module::cable_phenology_clim proc~cable_phenology_clim->module~phenvariable proc~casa_fluxout casa_inout::casa_fluxout proc~casa_fluxout->module~phenvariable proc~casa_init casa_inout::casa_init proc~casa_init->module~phenvariable proc~casa_poolout casa_inout::casa_poolout proc~casa_poolout->module~phenvariable proc~casa_readbiome casa_inout::casa_readbiome proc~casa_readbiome->module~phenvariable proc~casa_readphen casa_inout::casa_readphen proc~casa_readphen->module~phenvariable proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->module~phenvariable proc~popdriver casa_cable::POPdriver proc~popdriver->module~phenvariable proc~read_casa_dump casa_cable::read_casa_dump proc~read_casa_dump->module~phenvariable proc~read_casa_restart_nc casa_inout::read_casa_restart_nc proc~read_casa_restart_nc->module~phenvariable proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->module~phenvariable proc~write_casa_dump casa_cable::write_casa_dump proc~write_casa_dump->module~phenvariable proc~write_casa_restart_nc casa_inout::write_casa_restart_nc proc~write_casa_restart_nc->module~phenvariable proc~zero_casa_dump casa_inout::zero_casa_dump proc~zero_casa_dump->module~phenvariable proc~biogeochem casa_inout::biogeochem proc~biogeochem->module~casa_cnp_module proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->module~casa_cnp_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables ncasa_phen Derived Types phen_variable Subroutines alloc_phenvariable dealloc_phenvariable print_phenvariable zero_phenvariable read_netcdf_phen_var write_netcdf_phen_var Variables Type Visibility Attributes Name Initial integer, public, parameter :: ncasa_phen = 10 Derived Types type, public :: phen_variable Components Type Visibility Attributes Name Initial integer, public, dimension(:), pointer :: phase => null() real(kind=r_2), public, dimension(:), pointer :: TKshed => null() integer, public, dimension(:,:), pointer :: doyphase => null() real, public, dimension(:), pointer :: phen => null() real, public, dimension(:), pointer :: aphen => null() integer, public, dimension(:,:), pointer :: phasespin => null() integer, public, dimension(:,:), pointer :: doyphasespin_1 => null() integer, public, dimension(:,:), pointer :: doyphasespin_2 => null() integer, public, dimension(:,:), pointer :: doyphasespin_3 => null() integer, public, dimension(:,:), pointer :: doyphasespin_4 => null() Subroutines public  subroutine alloc_phenvariable (phen, arraysize) Arguments Type Intent Optional Attributes Name type( phen_variable ), intent(inout) :: phen integer, intent(in) :: arraysize public  subroutine dealloc_phenvariable (phen) Arguments Type Intent Optional Attributes Name type( phen_variable ), intent(inout) :: phen public  subroutine print_phenvariable (phen) Arguments Type Intent Optional Attributes Name type( phen_variable ), intent(in) :: phen public  subroutine zero_phenvariable (phen) Arguments Type Intent Optional Attributes Name type( phen_variable ), intent(inout) :: phen public  subroutine read_netcdf_phen_var (filename, phen) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( phen_variable ), intent(inout) :: phen public  subroutine write_netcdf_phen_var (filename, phen) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( phen_variable ), intent(in) :: phen","tags":"","loc":"module/phenvariable.html"},{"title":"POPLUC_CONSTANTS – POP","text":"Uses TypeDef module~~popluc_constants~~UsesGraph module~popluc_constants POPLUC_CONSTANTS module~typedef TypeDef module~popluc_constants->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~popluc_constants~~UsedByGraph module~popluc_constants POPLUC_CONSTANTS module~popluc_module POPLUC_Module module~popluc_module->module~popluc_constants module~popluc_types POPLUC_Types module~popluc_module->module~popluc_types module~popluc_types->module~popluc_constants proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->module~popluc_module proc~casaonly_luc->module~popluc_types Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables LENGTH_SECDF_HISTORY AGE_MAX disturbance_interval IFHARVEST ROTATION nLU nTrans Variables Type Visibility Attributes Name Initial integer(kind=i4b), public, parameter :: LENGTH_SECDF_HISTORY = 4000 integer(kind=i4b), public, parameter :: AGE_MAX = 1000 integer(kind=i4b), public, parameter :: disturbance_interval = 100 logical, public, parameter :: IFHARVEST = .FALSE. integer(kind=i4b), public, parameter :: ROTATION = 70 integer(kind=i4b), public, parameter :: nLU = 3 integer(kind=i4b), public, parameter :: nTrans = 4","tags":"","loc":"module/popluc_constants.html"},{"title":"POPLUC_Types – POP","text":"Uses POPLUC_CONSTANTS TypeDef module~~popluc_types~~UsesGraph module~popluc_types POPLUC_Types module~popluc_constants POPLUC_CONSTANTS module~popluc_types->module~popluc_constants module~typedef TypeDef module~popluc_types->module~typedef module~popluc_constants->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~popluc_types~~UsedByGraph module~popluc_types POPLUC_Types module~popluc_module POPLUC_Module module~popluc_module->module~popluc_types proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->module~popluc_types proc~casaonly_luc->module~popluc_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Derived Types POPLUC_TYPE Derived Types type, public :: POPLUC_TYPE Components Type Visibility Attributes Name Initial integer(kind=i4b), public, POINTER :: it integer(kind=i4b), public, POINTER :: np integer(kind=i4b), public, POINTER :: firstyear integer(kind=i4b), public, POINTER :: thisyear integer(kind=i4b), public, DIMENSION(:), POINTER :: n_event => null() real(kind=dp), public, DIMENSION(:), POINTER :: latitude => null() real(kind=dp), public, DIMENSION(:), POINTER :: longitude => null() real(kind=dp), public, DIMENSION(:), POINTER :: primf => null() real(kind=dp), public, DIMENSION(:), POINTER :: secdf => null() real(kind=dp), public, DIMENSION(:), POINTER :: grass => null() real(kind=dp), public, DIMENSION(:), POINTER :: ptos => null() real(kind=dp), public, DIMENSION(:), POINTER :: ptog => null() real(kind=dp), public, DIMENSION(:), POINTER :: stog => null() real(kind=dp), public, DIMENSION(:), POINTER :: gtop => null() real(kind=dp), public, DIMENSION(:), POINTER :: gtos => null() real(kind=dp), public, DIMENSION(:), POINTER :: frac_primf => null() real(kind=dp), public, DIMENSION(:), POINTER :: frac_forest => null() real(kind=dp), public, DIMENSION(:), POINTER :: crop => null() real(kind=dp), public, DIMENSION(:), POINTER :: past => null() real(kind=dp), public, DIMENSION(:), POINTER :: ptoc => null() real(kind=dp), public, DIMENSION(:), POINTER :: ptoq => null() real(kind=dp), public, DIMENSION(:), POINTER :: stoc => null() real(kind=dp), public, DIMENSION(:), POINTER :: stoq => null() real(kind=dp), public, DIMENSION(:), POINTER :: qtos => null() real(kind=dp), public, DIMENSION(:), POINTER :: ctos => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: freq_age_primary => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: freq_age_secondary => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: biomass_age_primary => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: biomass_age_secondary => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: age_history_secdf => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: area_history_secdf => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: FNEP => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: Clitt => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: Csoil => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: Cbiomass => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: FHarvest => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: FClearance => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: FTransferNet => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: FTransferGross => null() real(kind=dp), public, DIMENSION(:), POINTER :: pharv => null() real(kind=dp), public, DIMENSION(:), POINTER :: smharv => null() real(kind=dp), public, DIMENSION(:), POINTER :: syharv => null() real(kind=dp), public, DIMENSION(:), POINTER :: AgProd => null() real(kind=dp), public, DIMENSION(:), POINTER :: AgProdLoss => null() real(kind=dp), public, DIMENSION(:), POINTER :: FAg => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: HarvProd => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: ClearProd => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: fracHarvProd => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: fracClearProd => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: HarvProdLoss => null() real(kind=dp), public, DIMENSION(:,:), POINTER :: ClearProdLoss => null() real(kind=dp), public, DIMENSION(:), POINTER :: fracHarvResid => null() real(kind=dp), public, DIMENSION(:), POINTER :: fracHarvSecResid => null() real(kind=dp), public, DIMENSION(:), POINTER :: fracClearResid => null() real(kind=dp), public, DIMENSION(:), POINTER :: kSecHarv => null() real(kind=dp), public, DIMENSION(:), POINTER :: kNatDist => null() real(kind=dp), public, DIMENSION(:), POINTER :: kExpand1 => null() real(kind=dp), public, DIMENSION(:), POINTER :: kExpand2 => null() real(kind=dp), public, DIMENSION(:), POINTER :: kClear => null() real(kind=dp), public, DIMENSION(:), POINTER :: cRelClear => null() real(kind=dp), public, dimension(:), pointer :: FluxPHarvResidtoLitter => null() real(kind=dp), public, dimension(:), pointer :: FluxSHarvResidtoLitter => null() real(kind=dp), public, dimension(:), pointer :: FluxPClearResidtoLitter => null() real(kind=dp), public, dimension(:), pointer :: FluxSClearResidtoLitter => null() real(kind=dp), public, dimension(:), pointer :: dcSHarvClear => null()","tags":"","loc":"module/popluc_types.html"},{"title":"POPLUC_Module – POP","text":"Exponential distribution\n Returns probability of a given time-between-events (x)\n Given a Poisson process with expected frequency (events per unit time) lambda\n Reference: http://en.wikipedia.org/wiki/Exponential_distribution\n Use to determine average age (x, years) of patches with a given random disturbance\n frequency lambda (disturbances per year) Uses casavariable TypeDef cable_IO_vars_module POPLUC_Types POP_Types CABLE_LUC_EXPT POPModule cable_common_module POPLUC_CONSTANTS module~~popluc_module~~UsesGraph module~popluc_module POPLUC_Module CABLE_LUC_EXPT CABLE_LUC_EXPT module~popluc_module->CABLE_LUC_EXPT cable_IO_vars_module cable_IO_vars_module module~popluc_module->cable_IO_vars_module cable_common_module cable_common_module module~popluc_module->cable_common_module module~casavariable casavariable module~popluc_module->module~casavariable module~pop_types POP_Types module~popluc_module->module~pop_types module~popluc_constants POPLUC_CONSTANTS module~popluc_module->module~popluc_constants module~popluc_types POPLUC_Types module~popluc_module->module~popluc_types module~popmodule POPModule module~popluc_module->module~popmodule module~typedef TypeDef module~popluc_module->module~typedef cable_def_types_mod cable_def_types_mod module~casavariable->cable_def_types_mod module~pop_types->module~typedef module~pop_constants POP_Constants module~pop_types->module~pop_constants module~popluc_constants->module~typedef module~popluc_types->module~popluc_constants module~popluc_types->module~typedef module~popmodule->module~pop_types module~popmodule->module~typedef module~popmodule->module~pop_constants module~pop_constants->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~popluc_module~~UsedByGraph module~popluc_module POPLUC_Module proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->module~popluc_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables kHarvProd kClearProd kAgProd Functions REALExponential Subroutines zero_popluc print_popluc execute_luc_event calculate_weights INCREMENT_AGE POPLUCStep POPLUC_weights_transfer POP_LUC_CASA_transfer POPLUC_Init POPLUC_set_patchfrac POPLUC_set_params alloc_POPLUC WRITE_LUC_OUTPUT_NC WRITE_LUC_RESTART_NC READ_LUC_RESTART_NC WRITE_LUC_OUTPUT_GRID_NC Variables Type Visibility Attributes Name Initial real(kind=dp), public, dimension(3) :: kHarvProd real(kind=dp), public, dimension(3) :: kClearProd real(kind=dp), public :: kAgProd Functions public  function REALExponential (lambda, x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda real(kind=dp), intent(in) :: x Return Value real(kind=dp) Subroutines public  subroutine zero_popluc (popluc) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: popluc public  subroutine print_popluc (popluc) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(in) :: popluc public  subroutine execute_luc_event (from_state, to_state, frac_change_grid, g, POPLUC) Arguments Type Intent Optional Attributes Name character(len=5), intent(in) :: from_state character(len=5), intent(in) :: to_state real(kind=dp), intent(inout) :: frac_change_grid integer(kind=i4b), intent(in) :: g type( POPLUC_TYPE ), intent(inout) :: POPLUC public  subroutine calculate_weights (POPLUC, g) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC integer(kind=i4b), intent(in) :: g public  subroutine INCREMENT_AGE (POPLUC, g) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC integer(kind=i4b), intent(in) :: g public  subroutine POPLUCStep (POPLUC, year) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC integer(kind=i4b), intent(in) :: year public  subroutine POPLUC_weights_transfer (POPLUC, POP, LUC_EXPT) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(in) :: POPLUC type( POP_TYPE ), intent(inout) :: POP type(LUC_EXPT_TYPE), intent(in) :: LUC_EXPT public  subroutine POP_LUC_CASA_transfer (POPLUC, POP, LUC_EXPT, casapool, casabal, casaflux, ktauday) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC type( POP_TYPE ), intent(inout) :: POP type(LUC_EXPT_TYPE), intent(in) :: LUC_EXPT type( casa_pool ), intent(inout) :: casapool type( casa_balance ), intent(inout) :: casabal type( casa_flux ), intent(inout) :: casaflux integer, intent(in) :: ktauday public  subroutine POPLUC_Init (POPLUC, LUC_EXPT, casapool, casaflux, casabiome, veg, POP, np) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC type(LUC_EXPT_TYPE), intent(in) :: LUC_EXPT type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_biome ), intent(in) :: casabiome type(veg_parameter_type), intent(in) :: veg type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: np public  subroutine POPLUC_set_patchfrac (POPLUC, LUC_EXPT) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(in) :: POPLUC type(LUC_EXPT_TYPE), intent(in) :: LUC_EXPT public  subroutine POPLUC_set_params (POPLUC, LUC_EXPT) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC type(LUC_EXPT_TYPE), intent(in) :: LUC_EXPT public  subroutine alloc_POPLUC (POPLUC, arraysize) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC integer, intent(in) :: arraysize public  subroutine WRITE_LUC_OUTPUT_NC (POPLUC, ctime, FINAL) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(in) :: POPLUC integer, intent(in) :: ctime logical, intent(in) :: FINAL public  subroutine WRITE_LUC_RESTART_NC (POPLUC) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(in) :: POPLUC public  subroutine READ_LUC_RESTART_NC (POPLUC) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(inout) :: POPLUC public  subroutine WRITE_LUC_OUTPUT_GRID_NC (POPLUC, ctime, FINAL) Arguments Type Intent Optional Attributes Name type( POPLUC_TYPE ), intent(in) :: POPLUC integer, intent(in) :: ctime logical, intent(in) :: FINAL","tags":"","loc":"module/popluc_module.html"},{"title":"cable_pop_io – POP","text":"Contents Subroutines POP_IO Subroutines public  subroutine POP_IO (POP, casamet, YEAR, ACTION, CF) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP type( casa_met ), intent(in) :: casamet integer, intent(in) :: YEAR character(len=*), intent(in) :: ACTION logical, intent(in) :: CF","tags":"","loc":"module/cable_pop_io.html"},{"title":"cable_optimise_JV_module – POP","text":"Uses cable_common_module TypeDef cable_def_types_mod cable_data_module module~~cable_optimise_jv_module~~UsesGraph module~cable_optimise_jv_module cable_optimise_JV_module cable_common_module cable_common_module module~cable_optimise_jv_module->cable_common_module cable_data_module cable_data_module module~cable_optimise_jv_module->cable_data_module cable_def_types_mod cable_def_types_mod module~cable_optimise_jv_module->cable_def_types_mod module~typedef TypeDef module~cable_optimise_jv_module->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~cable_optimise_jv_module~~UsedByGraph module~cable_optimise_jv_module cable_optimise_JV_module proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->module~cable_optimise_jv_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables C APAR Dleaf Tleaf cs scalex fwsoil g0 Anet vcmax00 bjv g1 kc0 ko0 ekc eko gam0 egam alpha gm0 a1 D0 qs qm qb convex Neff relcost_J Rd0 Tgrowth Thome nt kk coord Functions light_inhibition total_photosynthesis_cost total_photosynthesis diff_Ac_Aj golden rtbis Subroutines optimise_JV fAn_c3 fabc fabcd fpq fAm_c3 total_An_Ac_Aj Variables Type Visibility Attributes Name Initial type(icanopy_type), public :: C real, public, ALLOCATABLE :: APAR (:) real, public, ALLOCATABLE :: Dleaf (:) real, public, ALLOCATABLE :: Tleaf (:) real, public, ALLOCATABLE :: cs (:) real, public, ALLOCATABLE :: scalex (:) real, public, ALLOCATABLE :: fwsoil (:) real, public, ALLOCATABLE :: g0 (:) real, public :: Anet real, public :: vcmax00 real, public :: bjv real, public :: g1 real, public :: kc0 real, public :: ko0 real, public :: ekc real, public :: eko real, public :: gam0 real, public :: egam real, public :: alpha real, public :: gm0 real, public :: a1 real, public :: D0 real, public :: qs real, public :: qm real, public :: qb real, public :: convex real, public :: Neff real, public :: relcost_J real, public :: Rd0 real, public :: Tgrowth real, public :: Thome integer, public :: nt integer, public :: kk logical, public, parameter :: coord = .FALSE. Functions public  function light_inhibition (APAR) result(xrd) Arguments Type Intent Optional Attributes Name real, intent(in) :: APAR Return Value real public  function total_photosynthesis_cost (bjv) Arguments Type Intent Optional Attributes Name real, intent(in) :: bjv Return Value real public  function total_photosynthesis (bjv) Arguments Type Intent Optional Attributes Name real, intent(in) :: bjv Return Value real public  function diff_Ac_Aj (bjv) Arguments Type Intent Optional Attributes Name real, intent(in) :: bjv Return Value real public  function golden (ax, bx, cx, func, tol, xmin) Arguments Type Intent Optional Attributes Name real, intent(in) :: ax real, intent(in) :: bx real, intent(in) :: cx public  function func(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real real, intent(in) :: tol real, intent(out) :: xmin Return Value real public  function rtbis (func, x1, x2, xacc) Arguments Type Intent Optional Attributes Name public  function func(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real real, intent(in) :: x1 real, intent(in) :: x2 real, intent(in) :: xacc Return Value real Subroutines public  subroutine optimise_JV (veg, climate, ktauday, bjv, relcostJ) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type(climate_type), intent(in) :: climate integer, intent(in) :: ktauday real, intent(in), DIMENSION(mp) :: bjv real, intent(in), DIMENSION(mp) :: relcostJ public  subroutine fAn_c3 (a, b, c, A2) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in) :: a real(kind=r_2), intent(in) :: b real(kind=r_2), intent(in) :: c real(kind=r_2), intent(out) :: A2 public  subroutine fabc (Cs, g0, x, gamm, beta, Gammastar, Rd, a, b, c) Arguments Type Intent Optional Attributes Name real, intent(in) :: Cs real, intent(in) :: g0 real, intent(in) :: x real, intent(in) :: gamm real, intent(in) :: beta real, intent(in) :: Gammastar real, intent(in) :: Rd real(kind=r_2), intent(out) :: a real(kind=r_2), intent(out) :: b real(kind=r_2), intent(out) :: c public  subroutine fabcd (Cs, g0, x, gamm, beta, Gammastar, Rd, gm, a, b, c1, d) Arguments Type Intent Optional Attributes Name real, intent(in) :: Cs real, intent(in) :: g0 real, intent(in) :: x real, intent(in) :: gamm real, intent(in) :: beta real, intent(in) :: Gammastar real, intent(in) :: Rd real, intent(in) :: gm real(kind=r_2), intent(out) :: a real(kind=r_2), intent(out) :: b real(kind=r_2), intent(out) :: c1 real(kind=r_2), intent(out) :: d public  subroutine fpq (a, b, c, d, p, q) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in) :: a real(kind=r_2), intent(in) :: b real(kind=r_2), intent(in) :: c real(kind=r_2), intent(in) :: d real(kind=r_2), intent(out) :: p real(kind=r_2), intent(out) :: q public  subroutine fAm_c3 (a, b, c1, d, p, q, Am) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in) :: a real(kind=r_2), intent(in) :: b real(kind=r_2), intent(in) :: c1 real(kind=r_2), intent(in) :: d real(kind=r_2), intent(in) :: p real(kind=r_2), intent(in) :: q real(kind=r_2), intent(out) :: Am public  subroutine total_An_Ac_Aj (bjv, total_An, total_Ac, total_Aj) Arguments Type Intent Optional Attributes Name real, intent(in) :: bjv real, intent(out) :: total_An real, intent(out) :: total_Ac real, intent(out) :: total_Aj","tags":"","loc":"module/cable_optimise_jv_module.html"},{"title":"cable_phenology_module – POP","text":"Uses CABLE_COMMON_MODULE cable_IO_vars_module cable_def_types_mod TypeDef module~~cable_phenology_module~~UsesGraph module~cable_phenology_module cable_phenology_module CABLE_COMMON_MODULE CABLE_COMMON_MODULE module~cable_phenology_module->CABLE_COMMON_MODULE cable_IO_vars_module cable_IO_vars_module module~cable_phenology_module->cable_IO_vars_module cable_def_types_mod cable_def_types_mod module~cable_phenology_module->cable_def_types_mod module~typedef TypeDef module~cable_phenology_module->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~cable_phenology_module~~UsedByGraph module~cable_phenology_module cable_phenology_module proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->module~cable_phenology_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Subroutines cable_phenology_clim Subroutines public  subroutine cable_phenology_clim (veg, climate, phen) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(in) :: veg type(climate_type), intent(in) :: climate type( phen_variable ), intent(inout) :: phen","tags":"","loc":"module/cable_phenology_module.html"},{"title":"casa_inout – POP","text":"Used by module~~casa_inout~~UsedByGraph module~casa_inout casa_inout proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->module~casa_inout proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->module~casa_inout proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->module~casa_inout Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Subroutines zero_casa_dump casa_readbiome casa_readphen casa_init casa_poolout casa_fluxout casa_cnpflux biogeochem write_casa_restart_nc read_casa_restart_nc write_casa_output_nc Subroutines public  subroutine zero_casa_dump (casamet, phen) Arguments Type Intent Optional Attributes Name type( casa_met ), intent(inout) :: casamet type( phen_variable ), intent(inout) :: phen public  subroutine casa_readbiome (veg, soil, casabiome, casapool, casaflux, casamet, phen) vh_js !!\nvh_js !!\nvh_js Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( phen_variable ), intent(inout) :: phen public  subroutine casa_readphen (veg, casamet, phen) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(in) :: veg type( casa_met ), intent(in) :: casamet type( phen_variable ), intent(inout) :: phen public  subroutine casa_init (casabiome, casamet, casaflux, casapool, casabal, phen) for first time reading file *_1220.csv  (BP may2010) Read more… Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(inout) :: casabiome type( casa_met ), intent(inout) :: casamet type( casa_flux ), intent(inout) :: casaflux type( casa_pool ), intent(inout) :: casapool type( casa_balance ), intent(inout) :: casabal type( phen_variable ), intent(inout) :: phen public  subroutine casa_poolout (ktau, veg, soil, casabiome, casapool, casaflux, casamet, casabal, phen) vh_js  !! Arguments Type Intent Optional Attributes Name integer, intent(in) :: ktau type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( casa_balance ), intent(inout) :: casabal type( phen_variable ), intent(inout) :: phen public  subroutine casa_fluxout (myear, veg, soil, casabal, casamet) Arguments Type Intent Optional Attributes Name integer, intent(in) :: myear type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_balance ), intent(inout) :: casabal type( casa_met ), intent(inout) :: casamet public  subroutine casa_cnpflux (casaflux, casapool, casabal, zeroflux) Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(inout) :: casaflux type( casa_pool ), intent(in) :: casapool type( casa_balance ), intent(inout) :: casabal logical, intent(in) :: zeroflux public  subroutine biogeochem (idoy, LALLOC, veg, soil, casabiome, casapool, casaflux, casamet, casabal, phen, POP, climate, xnplimit, xkNlimiting, xklitter, xksoil, xkleaf, xkleafcold, xkleafdry, cleaf2met, cleaf2str, croot2met, croot2str, cwood2cwd, nleaf2met, nleaf2str, nroot2met, nroot2str, nwood2cwd, pleaf2met, pleaf2str, proot2met, proot2str, pwood2cwd) vh_js !! Arguments Type Intent Optional Attributes Name integer, intent(in) :: idoy integer, intent(in) :: LALLOC type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( casa_balance ), intent(inout) :: casabal type( phen_variable ), intent(inout) :: phen type( POP_TYPE ), intent(in) :: POP type(climate_TYPE), intent(in) :: climate real(kind=r_2), intent(out), dimension(mp) :: xnplimit real(kind=r_2), intent(out), dimension(mp) :: xkNlimiting real(kind=r_2), intent(out), dimension(mp) :: xklitter real(kind=r_2), intent(out), dimension(mp) :: xksoil real(kind=r_2), intent(out), dimension(mp) :: xkleaf real(kind=r_2), intent(out), dimension(mp) :: xkleafcold real(kind=r_2), intent(out), dimension(mp) :: xkleafdry real(kind=r_2), intent(out), dimension(mp) :: cleaf2met real(kind=r_2), intent(out), dimension(mp) :: cleaf2str real(kind=r_2), intent(out), dimension(mp) :: croot2met real(kind=r_2), intent(out), dimension(mp) :: croot2str real(kind=r_2), intent(out), dimension(mp) :: cwood2cwd real(kind=r_2), intent(out), dimension(mp) :: nleaf2met real(kind=r_2), intent(out), dimension(mp) :: nleaf2str real(kind=r_2), intent(out), dimension(mp) :: nroot2met real(kind=r_2), intent(out), dimension(mp) :: nroot2str real(kind=r_2), intent(out), dimension(mp) :: nwood2cwd real(kind=r_2), intent(out), dimension(mp) :: pleaf2met real(kind=r_2), intent(out), dimension(mp) :: pleaf2str real(kind=r_2), intent(out), dimension(mp) :: proot2met real(kind=r_2), intent(out), dimension(mp) :: proot2str real(kind=r_2), intent(out), dimension(mp) :: pwood2cwd public  subroutine write_casa_restart_nc (casabiome, casamet, casapool, casaflux, casabal, phen) Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(in) :: casabiome type( casa_met ), intent(in) :: casamet type( casa_pool ), intent(in) :: casapool type( casa_flux ), intent(in) :: casaflux type( casa_balance ), intent(in) :: casabal type( phen_variable ), intent(in) :: phen public  subroutine read_casa_restart_nc (casabiome, casamet, casapool, casaflux, casabal, phen) Arguments Type Intent Optional Attributes Name type( casa_biome ), intent(inout) :: casabiome type( casa_met ), intent(inout) :: casamet type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_balance ), intent(inout) :: casabal type( phen_variable ), intent(inout) :: phen public  subroutine write_casa_output_nc (veg, casamet, casapool, casabal, casaflux, casaonly, ctime, lfinal) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(in) :: veg type( casa_met ), intent(in) :: casamet type( casa_pool ), intent(in) :: casapool type( casa_balance ), intent(in) :: casabal type( casa_flux ), intent(in) :: casaflux logical, intent(in) :: casaonly integer, intent(in) :: ctime logical, intent(in) :: lfinal","tags":"","loc":"module/casa_inout.html"},{"title":"TypeDef – POP","text":"Used by module~~typedef~~UsedByGraph module~typedef TypeDef module~cable_optimise_jv_module cable_optimise_JV_module module~cable_optimise_jv_module->module~typedef module~cable_phenology_module cable_phenology_module module~cable_phenology_module->module~typedef module~pop_constants POP_Constants module~pop_constants->module~typedef module~pop_types POP_Types module~pop_types->module~typedef module~pop_types->module~pop_constants module~popluc_constants POPLUC_CONSTANTS module~popluc_constants->module~typedef module~popluc_module POPLUC_Module module~popluc_module->module~typedef module~popluc_module->module~pop_types module~popluc_module->module~popluc_constants module~popluc_types POPLUC_Types module~popluc_module->module~popluc_types module~popmodule POPModule module~popluc_module->module~popmodule module~popluc_types->module~typedef module~popluc_types->module~popluc_constants module~popmodule->module~typedef module~popmodule->module~pop_constants module~popmodule->module~pop_types proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->module~typedef proc~bgcdriver->module~cable_phenology_module proc~bgcdriver->module~pop_types proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->module~typedef proc~casaonly_luc->module~pop_types proc~casaonly_luc->module~popluc_module proc~casaonly_luc->module~popluc_types proc~casaonly_luc->module~popmodule proc~pop_init POPModule::POP_init proc~pop_init->module~typedef proc~pop_init->module~pop_types proc~pop_init_single POPModule::POP_init_single proc~pop_init_single->module~typedef proc~pop_init_single->module~pop_types proc~pop_io cable_pop_io::POP_IO proc~pop_io->module~typedef proc~pop_io->module~pop_constants proc~pop_io->module~pop_types proc~popdriver casa_cable::POPdriver proc~popdriver->module~typedef proc~popdriver->module~pop_types proc~popdriver->module~popmodule proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->module~typedef proc~spincasacnp->module~pop_constants proc~spincasacnp->module~pop_types module~pop_mpi pop_mpi module~pop_mpi->module~pop_constants module~pop_mpi->module~pop_types proc~alloc_pop POPModule::alloc_POP proc~alloc_pop->module~pop_types proc~biogeochem casa_inout::biogeochem proc~biogeochem->module~pop_types proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->module~cable_optimise_jv_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables i4b i2b i1b sp dp lgt Variables Type Visibility Attributes Name Initial integer, public, parameter :: i4b = SELECTED_INT_KIND(9) integer, public, parameter :: i2b = SELECTED_INT_KIND(4) integer, public, parameter :: i1b = SELECTED_INT_KIND(2) integer, public, parameter :: sp = KIND(1.0) integer, public, parameter :: dp = KIND(1.0d0) integer, public, parameter :: lgt = KIND(.TRUE.)","tags":"","loc":"module/typedef.html"},{"title":"POP_Constants – POP","text":"Uses TypeDef module~~pop_constants~~UsesGraph module~pop_constants POP_Constants module~typedef TypeDef module~pop_constants->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pop_constants~~UsedByGraph module~pop_constants POP_Constants module~pop_mpi pop_mpi module~pop_mpi->module~pop_constants module~pop_types POP_Types module~pop_mpi->module~pop_types module~pop_types->module~pop_constants module~popmodule POPModule module~popmodule->module~pop_constants module~popmodule->module~pop_types proc~pop_io cable_pop_io::POP_IO proc~pop_io->module~pop_constants proc~pop_io->module~pop_types proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->module~pop_constants proc~spincasacnp->module~pop_types module~popluc_module POPLUC_Module module~popluc_module->module~pop_types module~popluc_module->module~popmodule proc~alloc_pop POPModule::alloc_POP proc~alloc_pop->module~pop_types proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->module~pop_types proc~biogeochem casa_inout::biogeochem proc~biogeochem->module~pop_types proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->module~pop_types proc~casaonly_luc->module~popmodule proc~casaonly_luc->module~popluc_module proc~pop_init POPModule::POP_init proc~pop_init->module~pop_types proc~pop_init_single POPModule::POP_init_single proc~pop_init_single->module~pop_types proc~popdriver casa_cable::POPdriver proc~popdriver->module~pop_types proc~popdriver->module~popmodule Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables FULTON_ALPHA DENSINDIV_MAX DENSINDIV_MIN Kbiometric WD GROWTH_EFFICIENCY_MIN Pmort MORT_MAX THETA_recruit CMASS_STEM_INIT POWERbiomass POWERGrowthEfficiency CrowdingFactor ALPHA_CPC k_allom1 k_rp ksapwood Q rshootfrac shootfrac CtoNw CtoNl CtoNr N_EXTENT EPS NLAYER NCOHORT_MAX NDISTURB PATCH_REPS NAGE_MAX PATCH_REPS1 PATCH_REPS2 NPATCH NPATCH1D NPATCH2D HEIGHT_BINS BIN_POWER TIMEBASE_FACTOR PI ALLOM_SWITCH MAX_HEIGHT_SWITCH RESOURCE_SWITCH RECRUIT_SWITCH INTERP_SWITCH SMOOTH_SWITCH NYEAR_WINDOW NYEAR_SMOOTH NYEAR_HISTORY AGEMAX Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: FULTON_ALPHA = 3.5_dp real(kind=dp), public, parameter :: DENSINDIV_MAX = 0.2_dp real(kind=dp), public, parameter :: DENSINDIV_MIN = 1.0e-9_dp real(kind=dp), public, parameter :: Kbiometric = 50.0_dp real(kind=dp), public, parameter :: WD = 300.0_dp real(kind=dp), public, parameter :: GROWTH_EFFICIENCY_MIN = 0.009_dp real(kind=dp), public, parameter :: Pmort = 5.0_dp real(kind=dp), public, parameter :: MORT_MAX = 0.3_dp real(kind=dp), public, parameter :: THETA_recruit = 0.95_dp real(kind=dp), public, parameter :: CMASS_STEM_INIT = 1.0e-4_dp real(kind=dp), public, parameter :: POWERbiomass = 0.67_dp real(kind=dp), public, parameter :: POWERGrowthEfficiency = 0.67_dp real(kind=dp), public, parameter :: CrowdingFactor = 0.043_dp real(kind=dp), public, parameter :: ALPHA_CPC = 3.5_dp real(kind=dp), public, parameter :: k_allom1 = 200.0_dp real(kind=dp), public, parameter :: k_rp = 1.67_dp real(kind=dp), public, parameter :: ksapwood = 0.05_dp real(kind=dp), public, parameter :: Q = 7.0_dp real, public, parameter :: rshootfrac = 0.63 real(kind=dp), public, parameter :: shootfrac = real(rshootfrac, dp) real(kind=dp), public, parameter :: CtoNw = 400.0_dp real(kind=dp), public, parameter :: CtoNl = 60.0_dp real(kind=dp), public, parameter :: CtoNr = 70.0_dp real(kind=dp), public, parameter :: N_EXTENT = 2.0_dp real(kind=dp), public, parameter :: EPS = 1.0e-12_dp integer(kind=i4b), public, parameter :: NLAYER = 1 integer(kind=i4b), public, parameter :: NCOHORT_MAX = 20 integer(kind=i4b), public, parameter :: NDISTURB = 1 integer(kind=i4b), public, parameter :: PATCH_REPS = 10 integer(kind=i4b), public, parameter :: NAGE_MAX = 1 integer(kind=i4b), public, parameter :: PATCH_REPS1 = 60 integer(kind=i4b), public, parameter :: PATCH_REPS2 = 1 integer(kind=i4b), public, parameter :: NPATCH = PATCH_REPS1*PATCH_REPS2 integer(kind=i4b), public, parameter :: NPATCH1D = NPATCH integer(kind=i4b), public, parameter :: NPATCH2D = NPATCH integer(kind=i4b), public, parameter :: HEIGHT_BINS = 12 real(kind=dp), public, parameter :: BIN_POWER = 1.4_dp integer(kind=i4b), public, parameter :: TIMEBASE_FACTOR = 50 real(kind=dp), public, parameter :: PI = 3.14159265358979323846264_dp integer(kind=i4b), public, parameter :: ALLOM_SWITCH = 2 integer(kind=i4b), public, parameter :: MAX_HEIGHT_SWITCH = 2 integer(kind=i4b), public, parameter :: RESOURCE_SWITCH = 1 integer(kind=i4b), public, parameter :: RECRUIT_SWITCH = 1 integer(kind=i4b), public, parameter :: INTERP_SWITCH = 1 integer(kind=i4b), public, parameter :: SMOOTH_SWITCH = 0 integer(kind=i4b), public, parameter :: NYEAR_WINDOW = 5 integer(kind=i4b), public, parameter :: NYEAR_SMOOTH = 2*NYEAR_WINDOW+1 integer(kind=i4b), public, parameter :: NYEAR_HISTORY = NYEAR_SMOOTH-NYEAR_WINDOW integer(kind=i4b), public, parameter :: AGEMAX = 1000","tags":"","loc":"module/pop_constants.html"},{"title":"POP_Types – POP","text":"Uses POP_Constants TypeDef module~~pop_types~~UsesGraph module~pop_types POP_Types module~pop_constants POP_Constants module~pop_types->module~pop_constants module~typedef TypeDef module~pop_types->module~typedef module~pop_constants->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pop_types~~UsedByGraph module~pop_types POP_Types module~pop_mpi pop_mpi module~pop_mpi->module~pop_types module~popluc_module POPLUC_Module module~popluc_module->module~pop_types module~popmodule POPModule module~popluc_module->module~popmodule module~popmodule->module~pop_types proc~alloc_pop POPModule::alloc_POP proc~alloc_pop->module~pop_types proc~bgcdriver casa_cable::bgcdriver proc~bgcdriver->module~pop_types proc~biogeochem casa_inout::biogeochem proc~biogeochem->module~pop_types proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->module~pop_types proc~casaonly_luc->module~popluc_module proc~casaonly_luc->module~popmodule proc~pop_init POPModule::POP_init proc~pop_init->module~pop_types proc~pop_init_single POPModule::POP_init_single proc~pop_init_single->module~pop_types proc~pop_io cable_pop_io::POP_IO proc~pop_io->module~pop_types proc~popdriver casa_cable::POPdriver proc~popdriver->module~pop_types proc~popdriver->module~popmodule proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->module~pop_types Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Derived Types Cohort Layer Patch Landscape POP_TYPE Derived Types type, public :: Cohort Components Type Visibility Attributes Name Initial integer(kind=i4b), public :: id integer(kind=i4b), public :: age real(kind=dp), public :: biomass real(kind=dp), public :: density real(kind=dp), public :: frac_resource_uptake real(kind=dp), public :: frac_light_uptake real(kind=dp), public :: frac_interception real(kind=dp), public :: frac_respiration real(kind=dp), public :: frac_NPP real(kind=dp), public :: respiration_scalar real(kind=dp), public :: crown_area real(kind=dp), public :: Pgap real(kind=dp), public :: height real(kind=dp), public :: diameter real(kind=dp), public :: sapwood real(kind=dp), public :: heartwood real(kind=dp), public :: sapwood_area real(kind=dp), public :: basal_area real(kind=dp), public :: LAI real(kind=dp), public :: Cleaf real(kind=dp), public :: Croot type, public :: Layer Components Type Visibility Attributes Name Initial type( Cohort ), public, DIMENSION(NCOHORT_MAX) :: Cohort integer(kind=i4b), public :: ncohort real(kind=dp), public :: biomass real(kind=dp), public :: density real(kind=dp), public :: hmean real(kind=dp), public :: hmax type, public :: Patch Components Type Visibility Attributes Name Initial type( Layer ), public, DIMENSION(NLAYER) :: Layer real(kind=dp), public :: factor_recruit real(kind=dp), public :: pgap real(kind=dp), public :: lai real(kind=dp), public :: biomass real(kind=dp), public :: biomass_old real(kind=dp), public :: sapwood real(kind=dp), public :: heartwood real(kind=dp), public :: sapwood_old real(kind=dp), public :: sapwood_area real(kind=dp), public :: sapwood_area_old real(kind=dp), public :: stress_mortality real(kind=dp), public :: fire_mortality real(kind=dp), public :: cat_mortality real(kind=dp), public :: crowding_mortality real(kind=dp), public :: cpc real(kind=dp), public :: mortality real(kind=dp), public :: sapwood_loss real(kind=dp), public :: sapwood_area_loss real(kind=dp), public :: growth real(kind=dp), public :: area_growth integer(kind=i4b), public :: disturbance_interval (NDISTURB) integer(kind=i4b), public :: first_disturbance_year (NDISTURB) integer(kind=i4b), public :: age (NDISTURB) integer(kind=i4b), public :: id real(kind=dp), public :: frac_NPP real(kind=dp), public :: frac_respiration real(kind=dp), public :: frac_light_uptake real(kind=dp), public :: fire_top_kill_density type, public :: Landscape Components Type Visibility Attributes Name Initial type( Patch ), public, DIMENSION(NPATCH2D) :: patch real(kind=dp), public, DIMENSION(NPATCH2D) :: freq real(kind=dp), public, DIMENSION(NPATCH2D) :: freq_old real(kind=dp), public, DIMENSION(NPATCH2D) :: fire_freq real(kind=dp), public, DIMENSION(NPATCH2D) :: fire_freq_old real(kind=dp), public, DIMENSION(NPATCH2D) :: cat_freq real(kind=dp), public, DIMENSION(NPATCH2D) :: cat_freq_old real(kind=dp), public, DIMENSION(NPATCH2D,NDISTURB) :: freq_ranked_age_unique integer(kind=i4b), public, DIMENSION(NPATCH2D, NDISTURB) :: ranked_age_unique integer(kind=i4b), public, DIMENSION(NDISTURB) :: n_age real(kind=dp), public, DIMENSION(NLAYER) :: biomass real(kind=dp), public, DIMENSION(NLAYER) :: density real(kind=dp), public, DIMENSION(NLAYER) :: hmean real(kind=dp), public, DIMENSION(NLAYER) :: hmax real(kind=dp), public, DIMENSION(HEIGHT_BINS) :: cmass_stem_bin real(kind=dp), public, DIMENSION(HEIGHT_BINS) :: densindiv_bin real(kind=dp), public, DIMENSION(HEIGHT_BINS) :: height_bin real(kind=dp), public, DIMENSION(HEIGHT_BINS) :: diameter_bin character(len=100), public, DIMENSION(HEIGHT_BINS) :: bin_labels real(kind=dp), public :: cmass_sum real(kind=dp), public :: cmass_sum_old real(kind=dp), public :: cheartwood_sum real(kind=dp), public :: csapwood_sum real(kind=dp), public :: csapwood_sum_old real(kind=dp), public :: densindiv real(kind=dp), public :: height_mean real(kind=dp), public :: height_max real(kind=dp), public :: basal_area real(kind=dp), public :: sapwood_loss real(kind=dp), public :: sapwood_area_loss real(kind=dp), public :: stress_mortality real(kind=dp), public :: crowding_mortality real(kind=dp), public :: fire_mortality real(kind=dp), public :: cat_mortality real(kind=dp), public :: res_mortality real(kind=dp), public :: growth real(kind=dp), public :: area_growth real(kind=dp), public :: crown_cover real(kind=dp), public :: crown_area real(kind=dp), public :: crown_volume real(kind=dp), public :: sapwood_area real(kind=dp), public :: sapwood_area_old real(kind=dp), public :: Kclump integer(kind=i4b), public :: npatch_active integer(kind=i4b), public :: LU real(kind=dp), public :: smoothing_buffer real(kind=dp), public :: smoothing_buffer_cat real(kind=dp), public :: fire_mortality_smoothed real(kind=dp), public :: cat_mortality_smoothed real(kind=dp), public, DIMENSION(NYEAR_HISTORY) :: fire_mortality_history real(kind=dp), public, DIMENSION(NYEAR_HISTORY) :: cat_mortality_history real(kind=dp), public, DIMENSION(AGEMAX) :: freq_age real(kind=dp), public, DIMENSION(AGEMAX) :: biomass_age type, public :: POP_TYPE Components Type Visibility Attributes Name Initial type( Landscape ), public, DIMENSION(:), ALLOCATABLE :: pop_grid integer, public, DIMENSION(:), Allocatable :: it_pop integer, public :: np integer, public, DIMENSION(:), Allocatable :: Iwood","tags":"","loc":"module/pop_types.html"},{"title":"POPModule – POP","text":"Exponential distribution\n Returns probability of a given time-between-events (x)\n Given a Poisson process with expected frequency (events per unit time) lambda\n Reference: http://en.wikipedia.org/wiki/Exponential_distribution\n Use to determine average age (x, years) of patches with a given random disturbance\n frequency lambda (disturbances per year) Exponential distribution\n Returns probability of a given time-between-events (x)\n Given a Poisson process with expected frequency (events per unit time) lambda\n Reference: http://en.wikipedia.org/wiki/Exponential_distribution\n Use to determine average age (x, years) of patches with a given random disturbance\n frequency lambda (disturbances per year) ALLOMETRY TOP-END ALLOMETRY STARTS HERE Tree height based on precipitation and Gary Cook Top-End allometry\n Bisection solution for tree height (m) based on modified height-DBH relationship\n from Garry Cook (pers. comm. 15/4/2013)\n \"I have been using H=0.054xExp(0.0014xRF)xD + 4.05 exp(-0.00032 rf) with Rf in mm, D in cm and height in m.\"\n Since the above expression does not go to zero at diameter=0 it is linked to a simple linear equation\n for initial height growth (H=50*D with D in m) using a non-rectangular hyperbola to smooth between the two\n Mathematical derivation: see POP documentation\n Arguments:\n precip  = annual precipitation (mm)\n biomass = tree stem C biomass across patch (kgC/m2)\n density = tree density (indiv/m2) Uses POP_Types POP_Constants TypeDef module~~popmodule~~UsesGraph module~popmodule POPModule module~pop_constants POP_Constants module~popmodule->module~pop_constants module~pop_types POP_Types module~popmodule->module~pop_types module~typedef TypeDef module~popmodule->module~typedef module~pop_constants->module~typedef module~pop_types->module~pop_constants module~pop_types->module~typedef Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~popmodule~~UsedByGraph module~popmodule POPModule module~popluc_module POPLUC_Module module~popluc_module->module~popmodule proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->module~popmodule proc~casaonly_luc->module~popluc_module proc~popdriver casa_cable::POPdriver proc~popdriver->module~popmodule Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Functions Exponential REALExponential CumExponential Factorial GetHeight Area_Triangle TopKill_Collins Subroutines ZeroPOP InitPOP2D_Poisson POPStep PatchAnnualDynamics GetUniqueAgeFrequencies GetPatchFrequencies GetDiagnostics Patch_partial_disturb Patch_partial_disturb2 Patch_disturb layer_recruitment layer_recruitment_single_patch GET_ALLOMETRY INTERPOLATE_BIOMASS_1D INTERPOLATE_FIREMORTALITY ADJUST_POP_FOR_FIRE INTERPOLATE_BIOMASS_2D SMOOTH_FLUX SMOOTH_FLUX_cat REGRESS Allometry Williams_Allometry POP_init POP_init_single alloc_POP Functions public  function Exponential (lambda, x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda integer(kind=i4b), intent(in) :: x Return Value real(kind=dp) public  function REALExponential (lambda, x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda real(kind=dp), intent(in) :: x Return Value real(kind=dp) public  function CumExponential (lambda, x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda real(kind=dp), intent(in) :: x Return Value real(kind=dp) public  function Factorial (n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=dp) public  function GetHeight (precip, biomass, density) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: precip real(kind=dp), intent(in) :: biomass real(kind=dp), intent(in) :: density Return Value real(kind=dp) public  function Area_Triangle (x1, y1, x2, y2, x3, y3) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x1 real(kind=dp), intent(in) :: y1 real(kind=dp), intent(in) :: x2 real(kind=dp), intent(in) :: y2 real(kind=dp), intent(in) :: x3 real(kind=dp), intent(in) :: y3 Return Value real(kind=dp) public  function TopKill_Collins (dbh, FLI) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dbh real(kind=dp), intent(in) :: FLI Return Value real(kind=dp) Subroutines public  subroutine ZeroPOP (POP, n) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer, intent(in), optional :: n public  subroutine InitPOP2D_Poisson (POP, mean_disturbance_interval, m) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: mean_disturbance_interval (:,:) integer(kind=i4b), intent(in), optional :: m public  subroutine POPStep (POP, StemNPP, disturbance_interval, disturbance_intensity, LAI, Cleaf, Croot, NPPtoGPP, StemNPP_av, frac_intensity1, precip) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP real(kind=dp), intent(in) :: StemNPP (:,:) integer(kind=i4b), intent(in) :: disturbance_interval (:,:) real(kind=dp), intent(in) :: disturbance_intensity (:,:) real(kind=dp), intent(in) :: LAI (:) real(kind=dp), intent(in) :: Cleaf (:) real(kind=dp), intent(in) :: Croot (:) real(kind=dp), intent(in) :: NPPtoGPP (:) real(kind=dp), intent(in), optional :: StemNPP_av (:) real(kind=dp), intent(in), optional :: frac_intensity1 (:) real(kind=dp), intent(in), optional :: precip (:) public  subroutine PatchAnnualDynamics (pop, StemNPP, NPPtoGPP, it, StemNPP_av, precip) assumes crown radius (m) = 0.1492 * dbh (cm) (from G. Cook, pers. comm.) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: pop real(kind=dp), intent(in) :: StemNPP (:,:) real(kind=dp), intent(in) :: NPPtoGPP (:) integer(kind=i4b), intent(in) :: it (:) real(kind=dp), intent(in), optional :: StemNPP_av (:) real(kind=dp), intent(in), optional :: precip (:) public  subroutine GetUniqueAgeFrequencies (POP, disturbance_interval, idisturb) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: disturbance_interval (:,:) integer(kind=i4b), intent(in) :: idisturb public  subroutine GetPatchFrequencies (POP) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP public  subroutine GetDiagnostics (POP, LAI, Cleaf, Croot, disturbance_interval, it, precip) assumes crown radius (m) = 0.1492 * dbh (cm) (from G. Cook, pers. comm.) Read more… Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP real(kind=dp), intent(in) :: LAI (:) real(kind=dp), intent(in) :: Cleaf (:) real(kind=dp), intent(in) :: Croot (:) integer(kind=i4b), intent(in) :: disturbance_interval (:,:) integer(kind=i4b), intent(in) :: it (:) real(kind=dp), intent(in), optional :: precip (:) public  subroutine Patch_partial_disturb (POP, idisturb, intensity, frac_intensity1) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: idisturb real(kind=dp), intent(in) :: intensity (:,:) real(kind=dp), intent(in), optional :: frac_intensity1 (:) public  subroutine Patch_partial_disturb2 (POP, idisturb) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: idisturb public  subroutine Patch_disturb (POP, idisturb, precip) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: idisturb real(kind=dp), intent(in), optional :: precip (:) public  subroutine layer_recruitment (POP, precip) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP real(kind=dp), intent(in), optional :: precip (:) public  subroutine layer_recruitment_single_patch (POP, index, grid_index, precip) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: index integer(kind=i4b), intent(in) :: grid_index real(kind=dp), intent(in), optional :: precip (:) public  subroutine GET_ALLOMETRY (ALLOM_SWITCH, biomass, density, ht, diam, basal, precip) Arguments Type Intent Optional Attributes Name integer(kind=i4b), intent(in) :: ALLOM_SWITCH real(kind=dp), intent(in) :: biomass real(kind=dp), intent(in) :: density real(kind=dp), intent(out) :: ht real(kind=dp), intent(out) :: diam real(kind=dp), intent(out) :: basal real(kind=dp), intent(in), optional :: precip public  subroutine INTERPOLATE_BIOMASS_1D (POP, disturbance_interval, it, g) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: disturbance_interval (:,:) integer(kind=i4b), intent(in) :: it integer(kind=i4b), intent(in) :: g public  subroutine INTERPOLATE_FIREMORTALITY (POP, disturbance_interval, it, g) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: disturbance_interval (:,:) integer(kind=i4b), intent(in) :: it integer(kind=i4b), intent(in) :: g public  subroutine ADJUST_POP_FOR_FIRE (pop, disturbance_interval, burned_area, FLI) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: pop integer(kind=i4b), intent(in) :: disturbance_interval (:,:) real(kind=dp), intent(in) :: burned_area (:) real(kind=dp), intent(in) :: FLI (:) public  subroutine INTERPOLATE_BIOMASS_2D (POP, disturbance_interval, it, g) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: disturbance_interval (:,:) integer(kind=i4b), intent(in) :: it integer(kind=i4b), intent(in) :: g public  subroutine SMOOTH_FLUX (POP, g, t) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: g integer(kind=i4b), intent(in) :: t public  subroutine SMOOTH_FLUX_cat (POP, g, t) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: g integer(kind=i4b), intent(in) :: t public  subroutine REGRESS (x, y, n, a, b, r) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(in) :: y (:) integer(kind=i4b), intent(in) :: n real(kind=dp), intent(out) :: a real(kind=dp), intent(out) :: b real(kind=dp), intent(out) :: r public  subroutine Allometry (height, biomass, density, diam, basal) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: height real(kind=dp), intent(in) :: biomass real(kind=dp), intent(in) :: density real(kind=dp), intent(out) :: diam real(kind=dp), intent(out) :: basal public  subroutine Williams_Allometry (agbiomass, density, height, dbh, basal) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: agbiomass real(kind=dp), intent(in) :: density real(kind=dp), intent(out) :: height real(kind=dp), intent(out) :: dbh real(kind=dp), intent(out) :: basal public  subroutine POP_init (POP, disturbance_interval, np, Iwood, precip) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: disturbance_interval (:,:) integer(kind=i4b), intent(in) :: np integer(kind=i4b), intent(in) :: Iwood (:) real(kind=dp), intent(in), optional :: precip (:) public  subroutine POP_init_single (POP, disturbance_interval, n, precip) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer(kind=i4b), intent(in) :: disturbance_interval (:,:) integer(kind=i4b), intent(in) :: n real(kind=dp), intent(in), optional :: precip (:) public  subroutine alloc_POP (POP, arraysize) Arguments Type Intent Optional Attributes Name type( POP_TYPE ), intent(inout) :: POP integer, intent(in) :: arraysize","tags":"","loc":"module/popmodule.html"},{"title":"casa_cnp_module – POP","text":"Uses casavariable cable_IO_vars_module casaparm phenvariable cable_def_types_mod cable_common_module casadimension module~~casa_cnp_module~~UsesGraph module~casa_cnp_module casa_cnp_module cable_IO_vars_module cable_IO_vars_module module~casa_cnp_module->cable_IO_vars_module cable_common_module cable_common_module module~casa_cnp_module->cable_common_module cable_def_types_mod cable_def_types_mod module~casa_cnp_module->cable_def_types_mod module~casadimension casadimension module~casa_cnp_module->module~casadimension module~casaparm casaparm module~casa_cnp_module->module~casaparm module~casavariable casavariable module~casa_cnp_module->module~casavariable module~phenvariable phenvariable module~casa_cnp_module->module~phenvariable module~casadimension->cable_def_types_mod module~casaparm->cable_def_types_mod module~casavariable->cable_def_types_mod module~phenvariable->cable_def_types_mod module~phenvariable->module~casadimension Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~casa_cnp_module~~UsedByGraph module~casa_cnp_module casa_cnp_module proc~biogeochem casa_inout::biogeochem proc~biogeochem->module~casa_cnp_module proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->module~casa_cnp_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables zero one Functions vcmax_np Subroutines casa_xnp casa_allocation casa_wolf casa_rplant casa_xrateplant casa_xratesoil casa_coeffplant casa_coeffsoil casa_delplant casa_delsoil avgsoil casa_xkN casa_nuptake casa_Nrequire casa_puptake casa_Prequire casa_cnpcycle casa_poolzero casa_cnpbal casa_ndummy casa_pdummy phenology Variables Type Visibility Attributes Name Initial real(kind=r_2), public, parameter :: zero = 0.0_r_2 real(kind=r_2), public, parameter :: one = 1.0_r_2 Functions public  function vcmax_np (nleaf, pleaf) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in) :: nleaf real(kind=r_2), intent(in) :: pleaf Return Value real(kind=r_2) Subroutines public  subroutine casa_xnp (xnplimit, xNPuptake, veg, casabiome, casapool, casaflux, casamet) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(out), DIMENSION(mp) :: xnplimit real(kind=r_2), intent(out), DIMENSION(mp) :: xNPuptake type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet public  subroutine casa_allocation (veg, soil, casabiome, casaflux, casapool, casamet, phen, LALLOC) vh_js !!\nvh_js !!\nas long as biomass is positive, adjust allocation to be\nproportional to stock when NPP -ve (Ticket#108)\nvh !! Read more… Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_biome ), intent(inout) :: casabiome type( casa_flux ), intent(inout) :: casaflux type( casa_pool ), intent(inout) :: casapool type( casa_met ), intent(inout) :: casamet type( phen_variable ), intent(inout) :: phen integer, intent(in) :: LALLOC public  subroutine casa_wolf (veg, casabiome, casaflux, casapool, casamet) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(in) :: veg type( casa_biome ), intent(in) :: casabiome type( casa_flux ), intent(inout) :: casaflux type( casa_pool ), intent(inout) :: casapool type( casa_met ), intent(in) :: casamet public  subroutine casa_rplant (veg, casabiome, casapool, casaflux, casamet, climate) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type(climate_type), intent(in) :: climate public  subroutine casa_xrateplant (xkleafcold, xkleafdry, xkleaf, veg, casabiome, casamet, phen) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(out), DIMENSION(mp) :: xkleafcold real(kind=r_2), intent(out), DIMENSION(mp) :: xkleafdry real(kind=r_2), intent(out), DIMENSION(mp) :: xkleaf type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_met ), intent(inout) :: casamet type( phen_variable ), intent(inout) :: phen public  subroutine casa_xratesoil (xklitter, xksoil, veg, soil, casamet, casabiome) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(out), DIMENSION(mp) :: xklitter real(kind=r_2), intent(out), DIMENSION(mp) :: xksoil type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_met ), intent(inout) :: casamet type( casa_biome ), intent(inout) :: casabiome public  subroutine casa_coeffplant (xkleafcold, xkleafdry, xkleaf, veg, casabiome, casapool, casaflux, casamet) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in), dimension(mp) :: xkleafcold real(kind=r_2), intent(in), dimension(mp) :: xkleafdry real(kind=r_2), intent(in), dimension(mp) :: xkleaf type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet public  subroutine casa_coeffsoil (xklitter, xksoil, veg, soil, casabiome, casaflux, casamet) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in), dimension(mp) :: xklitter real(kind=r_2), intent(in), dimension(mp) :: xksoil type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_biome ), intent(inout) :: casabiome type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet public  subroutine casa_delplant (veg, casabiome, casapool, casaflux, casamet, cleaf2met, cleaf2str, croot2met, croot2str, cwood2cwd, nleaf2met, nleaf2str, nroot2met, nroot2str, nwood2cwd, pleaf2met, pleaf2str, proot2met, proot2str, pwood2cwd) vh_js !! Read more… Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet real(kind=r_2), intent(out), dimension(mp) :: cleaf2met real(kind=r_2), intent(out), dimension(mp) :: cleaf2str real(kind=r_2), intent(out), dimension(mp) :: croot2met real(kind=r_2), intent(out), dimension(mp) :: croot2str real(kind=r_2), intent(out), dimension(mp) :: cwood2cwd real(kind=r_2), intent(out), dimension(mp) :: nleaf2met real(kind=r_2), intent(out), dimension(mp) :: nleaf2str real(kind=r_2), intent(out), dimension(mp) :: nroot2met real(kind=r_2), intent(out), dimension(mp) :: nroot2str real(kind=r_2), intent(out), dimension(mp) :: nwood2cwd real(kind=r_2), intent(out), dimension(mp) :: pleaf2met real(kind=r_2), intent(out), dimension(mp) :: pleaf2str real(kind=r_2), intent(out), dimension(mp) :: proot2met real(kind=r_2), intent(out), dimension(mp) :: proot2str real(kind=r_2), intent(out), dimension(mp) :: pwood2cwd public  subroutine casa_delsoil (veg, casapool, casaflux, casamet, casabiome) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( casa_biome ), intent(inout) :: casabiome public  subroutine avgsoil (veg, soil, casamet) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type( casa_met ), intent(inout) :: casamet public  subroutine casa_xkN (xkNlimiting, casapool, casaflux, casamet, casabiome, veg) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(inout), DIMENSION(mp) :: xkNlimiting type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( casa_biome ), intent(inout) :: casabiome type(veg_parameter_type), intent(in) :: veg public  subroutine casa_nuptake (veg, xkNlimiting, casabiome, casapool, casaflux, casamet) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg real(kind=r_2), intent(in), DIMENSION(mp) :: xkNlimiting type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet public  subroutine casa_Nrequire (xnCnpp, Nreqmin, Nreqmax, NtransPtoP, veg, casabiome, casapool, casaflux, casamet) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in), DIMENSION(mp) :: xnCnpp real(kind=r_2), intent(inout), DIMENSION(mp,mplant) :: Nreqmin real(kind=r_2), intent(inout), DIMENSION(mp,mplant) :: Nreqmax real(kind=r_2), intent(inout), DIMENSION(mp,mplant) :: NtransPtoP type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet public  subroutine casa_puptake (veg, xkNlimiting, casabiome, casapool, casaflux, casamet) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg real(kind=r_2), intent(in), DIMENSION(mp) :: xkNlimiting type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet public  subroutine casa_Prequire (xpCnpp, Preqmin, Preqmax, PtransPtoP, veg, casabiome, casapool, casaflux, casamet) Arguments Type Intent Optional Attributes Name real(kind=r_2), intent(in), DIMENSION(mp) :: xpCnpp real(kind=r_2), intent(inout), DIMENSION(mp,mplant) :: Preqmin real(kind=r_2), intent(inout), DIMENSION(mp,mplant) :: Preqmax real(kind=r_2), intent(inout), DIMENSION(mp,mplant) :: PtransPtoP type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet public  subroutine casa_cnpcycle (veg, casabiome, casapool, casaflux, casamet) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet public  subroutine casa_poolzero (n, ipool, casapool) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: ipool type( casa_pool ), intent(inout) :: casapool public  subroutine casa_cnpbal (casapool, casaflux, casabal, idoy) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_balance ), intent(inout) :: casabal integer, intent(in) :: idoy public  subroutine casa_ndummy (casapool) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: casapool public  subroutine casa_pdummy (casapool) Arguments Type Intent Optional Attributes Name type( casa_pool ), intent(inout) :: casapool public  subroutine phenology (iday, veg, phen) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iday type(veg_parameter_type), intent(inout) :: veg type( phen_variable ), intent(inout) :: phen","tags":"","loc":"module/casa_cnp_module.html"},{"title":"cable_adjust_JV_gm_module – POP","text":"Uses cable_data_module minpack cable_abort_module cable_def_types_mod cable_canopy_module netcdf module~~cable_adjust_jv_gm_module~~UsesGraph module~cable_adjust_jv_gm_module cable_adjust_JV_gm_module cable_abort_module cable_abort_module module~cable_adjust_jv_gm_module->cable_abort_module cable_canopy_module cable_canopy_module module~cable_adjust_jv_gm_module->cable_canopy_module cable_data_module cable_data_module module~cable_adjust_jv_gm_module->cable_data_module cable_def_types_mod cable_def_types_mod module~cable_adjust_jv_gm_module->cable_def_types_mod minpack minpack module~cable_adjust_jv_gm_module->minpack netcdf netcdf module~cable_adjust_jv_gm_module->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~cable_adjust_jv_gm_module~~UsedByGraph module~cable_adjust_jv_gm_module cable_adjust_JV_gm_module proc~casa_feedback casa_cable::casa_feedback proc~casa_feedback->module~cable_adjust_jv_gm_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables C nrci nrcic4 gmmax25 Vcmax25Ci Jmax25Ci Vcmax25Cc Jmax25Cc k25Ci k25Cc Rd Kc_ci Ko_ci gammastar_ci Km_ci Kc_cc Ko_cc gammastar_cc Km_cc LUT_VcmaxJmax LUT_gm LUT_Vcmax LUT_Rd Subroutines adjust_JV_gm photosyn25_f photosyn25 read_gm_LUT find_Vcmax_Jmax_LUT adjust_k_Collatz Variables Type Visibility Attributes Name Initial type(icanopy_type), public :: C integer, public, parameter :: nrci = 3000 integer, public, parameter :: nrcic4 = 1200 real(kind=dp), public :: gmmax25 real(kind=dp), public :: Vcmax25Ci real(kind=dp), public :: Jmax25Ci real(kind=dp), public :: Vcmax25Cc real(kind=dp), public :: Jmax25Cc real(kind=dp), public :: k25Ci real(kind=dp), public :: k25Cc real(kind=dp), public :: Rd real(kind=dp), public :: Kc_ci real(kind=dp), public :: Ko_ci real(kind=dp), public :: gammastar_ci real(kind=dp), public :: Km_ci real(kind=dp), public :: Kc_cc real(kind=dp), public :: Ko_cc real(kind=dp), public :: gammastar_cc real(kind=dp), public :: Km_cc real(kind=dp), public, dimension(:,:,:,:), allocatable :: LUT_VcmaxJmax real(kind=dp), public, dimension(:), allocatable :: LUT_gm real(kind=dp), public, dimension(:), allocatable :: LUT_Vcmax real(kind=dp), public, dimension(:), allocatable :: LUT_Rd Subroutines public  subroutine adjust_JV_gm (veg, p) 1) Calculate An-Ci curve\n2) Exclude negative parts of the An-Ci curve\nAvoid unrealistic Vcmax and Jmax values Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg integer, intent(in) :: p public  subroutine photosyn25_f (M, N, X, fvec, iflag, Anx, Cix, Rd, Km, gammastar) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N real(kind=dp), intent(inout), dimension(N) :: X real(kind=dp), intent(out), dimension(M) :: fvec integer, intent(in) :: iflag real(kind=dp), intent(in), dimension(M) :: Anx real(kind=dp), intent(in), dimension(M) :: Cix real(kind=dp), intent(in) :: Rd real(kind=dp), intent(in) :: Km real(kind=dp), intent(in) :: gammastar public  subroutine photosyn25 (Ciz, nrci, Vcmax25, Jmax25, Rd, Km, gammastar, Anz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(nrci) :: Ciz integer, intent(in) :: nrci real(kind=dp), intent(in) :: Vcmax25 real(kind=dp), intent(in) :: Jmax25 real(kind=dp), intent(in) :: Rd real(kind=dp), intent(in) :: Km real(kind=dp), intent(in) :: gammastar real(kind=dp), intent(out), dimension(nrci) :: Anz public  subroutine read_gm_LUT (gm_LUT_file, LUT_VcmaxJmax, LUT_gm, LUT_vcmax, LUT_Rd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: gm_LUT_file real(kind=dp), intent(out), dimension(:,:,:,:), allocatable :: LUT_VcmaxJmax real(kind=dp), intent(out), dimension(:), allocatable :: LUT_gm real(kind=dp), intent(out), dimension(:), allocatable :: LUT_vcmax real(kind=dp), intent(out), dimension(:), allocatable :: LUT_Rd public  subroutine find_Vcmax_Jmax_LUT (veg, p, LUT_VcmaxJmax, LUT_gm, LUT_vcmax, LUT_Rd) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg integer, intent(in) :: p real(kind=dp), intent(in), dimension(:,:,:,:) :: LUT_VcmaxJmax real(kind=dp), intent(in), dimension(:) :: LUT_gm real(kind=dp), intent(in), dimension(:) :: LUT_vcmax real(kind=dp), intent(in), dimension(:) :: LUT_Rd public  subroutine adjust_k_Collatz (veg, p) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(inout) :: veg integer, intent(in) :: p","tags":"","loc":"module/cable_adjust_jv_gm_module.html"},{"title":"casa_cable – POP","text":"Used by module~~casa_cable~~UsedByGraph module~casa_cable casa_cable proc~casaonly_luc cable_casaonly_luc::CASAONLY_LUC proc~casaonly_luc->module~casa_cable proc~spincasacnp cable_spincasacnp::spincasacnp proc~spincasacnp->module~casa_cable Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Subroutines bgcdriver POPdriver read_casa_dump write_casa_dump casa_feedback sumcflux totcnppools analyticpool Subroutines public  subroutine bgcdriver (ktau, kstart, dels, met, ssnow, canopy, veg, soil, climate, casabiome, casapool, casaflux, casamet, casabal, phen, POP, ktauday, idoy, LOY, dump_read, LALLOC, c13o2flux, c13o2pools) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ktau integer, intent(in) :: kstart real, intent(in) :: dels type(met_type), intent(inout) :: met type(soil_snow_type), intent(inout) :: ssnow type(canopy_type), intent(inout) :: canopy type(veg_parameter_type), intent(inout) :: veg type(soil_parameter_type), intent(inout) :: soil type(climate_type), intent(in) :: climate type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(inout) :: casamet type( casa_balance ), intent(inout) :: casabal type( phen_variable ), intent(inout) :: phen type( POP_TYPE ), intent(inout) :: POP integer, intent(in) :: ktauday integer, intent(in) :: idoy integer, intent(in) :: LOY logical, intent(in) :: dump_read integer, intent(in) :: LALLOC type(c13o2_flux), intent(inout) :: c13o2flux type(c13o2_pool), intent(inout) :: c13o2pools public  subroutine POPdriver (casaflux, casabal, veg, POP) Arguments Type Intent Optional Attributes Name type( casa_flux ), intent(in) :: casaflux type( casa_balance ), intent(in) :: casabal type(veg_parameter_type), intent(in) :: veg type( POP_TYPE ), intent(inout) :: POP public  subroutine read_casa_dump (ncfile, casamet, casaflux, phen, climate, c13o2flux, ncall, kend, allatonce) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: ncfile type( casa_met ), intent(inout) :: casamet type( casa_flux ), intent(inout) :: casaflux type( phen_variable ), intent(inout) :: phen type(climate_type), intent(inout) :: climate type(c13o2_flux), intent(inout) :: c13o2flux integer, intent(in) :: ncall integer, intent(in) :: kend logical, intent(in) :: allatonce public  subroutine write_casa_dump (ncfile, casamet, casaflux, phen, climate, c13o2flux, n_call, kend) Arguments Type Intent Optional Attributes Name character(len=*) :: ncfile type( casa_met ), intent(in) :: casamet type( casa_flux ), intent(in) :: casaflux type( phen_variable ), intent(in) :: phen type(climate_type), intent(in) :: climate type(c13o2_flux), intent(in) :: c13o2flux integer, intent(in) :: n_call integer, intent(in) :: kend public  subroutine casa_feedback (ktau, veg, casabiome, casapool, casamet, climate, ktauday) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ktau type(veg_parameter_type), intent(inout) :: veg type( casa_biome ), intent(inout) :: casabiome type( casa_pool ), intent(in) :: casapool type( casa_met ), intent(in) :: casamet type(climate_type), intent(in) :: climate integer, intent(in) :: ktauday public  subroutine sumcflux (ktau, kstart, dels, canopy, sum_flux, casaflux, l_vcmaxFeedbk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ktau integer, intent(in) :: kstart real, intent(in) :: dels type(canopy_type), intent(inout) :: canopy type(sum_flux_type), intent(inout) :: sum_flux type( casa_flux ), intent(inout) :: casaflux logical, intent(in) :: l_vcmaxFeedbk public  subroutine totcnppools (kloop, veg, casamet, casapool, bmcplant, bmnplant, bmpplant, bmclitter, bmnlitter, bmplitter, bmcsoil, bmnsoil, bmpsoil, bmnsoilmin, bmpsoillab, bmpsoilsorb, bmpsoilocc, bmarea) Arguments Type Intent Optional Attributes Name integer, intent(in) :: kloop type(veg_parameter_type), intent(in) :: veg type( casa_met ), intent(in) :: casamet type( casa_pool ), intent(in) :: casapool real, dimension(5,mvtype,mplant) :: bmcplant real, dimension(5,mvtype,mplant) :: bmnplant real, dimension(5,mvtype,mplant) :: bmpplant real, dimension(5,mvtype,mlitter) :: bmclitter real, dimension(5,mvtype,mlitter) :: bmnlitter real, dimension(5,mvtype,mlitter) :: bmplitter real, dimension(5,mvtype,msoil) :: bmcsoil real, dimension(5,mvtype,msoil) :: bmnsoil real, dimension(5,mvtype,msoil) :: bmpsoil real, dimension(5,mvtype) :: bmnsoilmin real, dimension(5,mvtype) :: bmpsoillab real, dimension(5,mvtype) :: bmpsoilsorb real, dimension(5,mvtype) :: bmpsoilocc real, dimension(mvtype) :: bmarea public  subroutine analyticpool (veg, soil, casabiome, casapool, casaflux, casamet, casabal, avgcleaf2met, avgcleaf2str, avgcroot2met, avgcroot2str, avgcwood2cwd, avgnleaf2met, avgnleaf2str, avgnroot2met, avgnroot2str, avgnwood2cwd, avgpleaf2met, avgpleaf2str, avgproot2met, avgproot2str, avgpwood2cwd, avgcnpp, avgxkNlimiting, avgxklitter, avgxksoil, avgratioNCsoilmic, avgratioNCsoilslow, avgratioNCsoilpass, avgnsoilmin, avgpsoillab, avgpsoilsorb, avgpsoilocc, avg_c13leaf2met, avg_c13leaf2str, avg_c13root2met, avg_c13root2str, avg_c13wood2cwd, c13o2pools) set the following two backflow to set (see Bolker 199x) Arguments Type Intent Optional Attributes Name type(veg_parameter_type), intent(in) :: veg type(soil_parameter_type), intent(in) :: soil type( casa_biome ), intent(in) :: casabiome type( casa_pool ), intent(inout) :: casapool type( casa_flux ), intent(inout) :: casaflux type( casa_met ), intent(in) :: casamet type( casa_balance ), intent(inout) :: casabal real(kind=r_2), intent(in), dimension(mp) :: avgcleaf2met real(kind=r_2), intent(in), dimension(mp) :: avgcleaf2str real(kind=r_2), intent(in), dimension(mp) :: avgcroot2met real(kind=r_2), intent(in), dimension(mp) :: avgcroot2str real(kind=r_2), intent(in), dimension(mp) :: avgcwood2cwd real(kind=r_2), intent(in), dimension(mp) :: avgnleaf2met real(kind=r_2), intent(in), dimension(mp) :: avgnleaf2str real(kind=r_2), intent(in), dimension(mp) :: avgnroot2met real(kind=r_2), intent(in), dimension(mp) :: avgnroot2str real(kind=r_2), intent(in), dimension(mp) :: avgnwood2cwd real(kind=r_2), intent(in), dimension(mp) :: avgpleaf2met real(kind=r_2), intent(in), dimension(mp) :: avgpleaf2str real(kind=r_2), intent(in), dimension(mp) :: avgproot2met real(kind=r_2), intent(in), dimension(mp) :: avgproot2str real(kind=r_2), intent(in), dimension(mp) :: avgpwood2cwd real(kind=r_2), intent(in), dimension(mp) :: avgcnpp real(kind=r_2), intent(in), dimension(mp) :: avgxkNlimiting real(kind=r_2), intent(in), dimension(mp) :: avgxklitter real(kind=r_2), intent(in), dimension(mp) :: avgxksoil real(kind=r_2), intent(in), dimension(mp) :: avgratioNCsoilmic real(kind=r_2), intent(in), dimension(mp) :: avgratioNCsoilslow real(kind=r_2), intent(in), dimension(mp) :: avgratioNCsoilpass real(kind=r_2), intent(in), dimension(mp) :: avgnsoilmin real(kind=r_2), intent(in), dimension(mp) :: avgpsoillab real(kind=r_2), intent(in), dimension(mp) :: avgpsoilsorb real(kind=r_2), intent(in), dimension(mp) :: avgpsoilocc real(kind=r_2), intent(in), dimension(mp) :: avg_c13leaf2met real(kind=r_2), intent(in), dimension(mp) :: avg_c13leaf2str real(kind=r_2), intent(in), dimension(mp) :: avg_c13root2met real(kind=r_2), intent(in), dimension(mp) :: avg_c13root2str real(kind=r_2), intent(in), dimension(mp) :: avg_c13wood2cwd type(c13o2_pool), intent(inout) :: c13o2pools","tags":"","loc":"module/casa_cable.html"},{"title":"pop_mpi.F90 – POP","text":"This file depends on sourcefile~~pop_mpi.f90~~EfferentGraph sourcefile~pop_mpi.f90 pop_mpi.F90 sourcefile~pop.f90 POP.F90 sourcefile~pop_mpi.f90->sourcefile~pop.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules pop_mpi Source Code pop_mpi.F90 Source Code MODULE pop_mpi USE POP_Types USE POP_Constants , ONLY : NCOHORT_MAX , NLAYER , HEIGHT_BINS , NDISTURB , NPATCH , NPATCH2D , & NYEAR_HISTORY , AGEMAX ! Total number of type_landscape variables to be communicated INTEGER , PARAMETER :: n_landscape_types = 48 ! Total number of type_patch variables to be communicated INTEGER , PARAMETER :: n_patch_types = 28 ! Total number of type_layer variables to be communicated INTEGER , PARAMETER :: n_layer_types = 6 ! Total number of type_cohort variables to be communicated INTEGER , PARAMETER :: n_cohort_types = 21 CONTAINS ! create MPI datatype that describes a variable of type cohort ! SUBROUTINE create_cohort ( cohort_t , comm ) USE MPI IMPLICIT NONE ! the new MPI derived datatype: INTEGER , INTENT ( OUT ) :: cohort_t ! communicator for error-messages INTEGER , INTENT ( IN ) :: comm ! temp instance of Cohort for computing displacements TYPE ( Cohort ) :: tmp_coh ( 2 ) ! temp variables for computing displacements and extents INTEGER ( KIND = MPI_ADDRESS_KIND ) :: a1 , a2 ! temp variable for setting a type's extent INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text ! temp variable for lower bound parameter when setting extent INTEGER ( KIND = MPI_ADDRESS_KIND ) :: lb INTEGER :: tmp_t ! displacement, block length and block type arrays for ! for all fields in Type(Patch) INTEGER ( KIND = MPI_ADDRESS_KIND ), DIMENSION (:), ALLOCATABLE :: disp INTEGER , DIMENSION (:), ALLOCATABLE :: blen , btype INTEGER :: ierr , bidx ALLOCATE ( disp ( n_cohort_types ) ) ALLOCATE ( blen ( n_cohort_types ) ) ALLOCATE ( btype ( n_cohort_types ) ) bidx = 0 lb = 0 ! all displacements computed relative to start of first cohort CALL MPI_Get_Address ( tmp_coh ( 1 ), a1 , ierr ) bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% id , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_INTEGER bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% age , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_INTEGER bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% biomass , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% density , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% frac_resource_uptake , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% frac_light_uptake , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% frac_interception , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% frac_respiration , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% frac_NPP , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% respiration_scalar , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% crown_area , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% Pgap , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% height , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% diameter , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% sapwood , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% heartwood , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% sapwood_area , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% basal_area , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% LAI , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% Cleaf , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_coh ( 1 )% Croot , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE IF ( bidx . NE . n_cohort_types ) THEN WRITE ( * , * ) \"Error in pop_mpi layer. bidx \" , bidx , \" != n_cohort_types \" ,& n_cohort_types CALL MPI_ABORT ( comm , 119 , ierr ) ENDIF CALL MPI_Type_create_struct ( n_cohort_types , blen , disp , btype , tmp_t , ierr ) CALL MPI_Type_commit ( tmp_t , ierr ) ! make sure the type has correct extent for use in arrays CALL MPI_Get_Address ( tmp_coh ( 2 ), a2 , ierr ) text = a2 - a1 CALL MPI_Type_create_resized ( tmp_t , lb , text , cohort_t , ierr ) CALL MPI_Type_commit ( cohort_t , ierr ) DEALLOCATE ( disp ) DEALLOCATE ( blen ) DEALLOCATE ( btype ) RETURN END SUBROUTINE create_cohort ! create MPI datatype that describes a variable of type layer ! SUBROUTINE create_layer ( layer_t , comm ) USE MPI IMPLICIT NONE ! the new MPI derived datatype: INTEGER , INTENT ( OUT ) :: layer_t ! communicator for error-messages INTEGER , INTENT ( IN ) :: comm ! temp instance of Cohort for computing displacements TYPE ( Layer ) :: tmp_layer ( 2 ) ! temp variables for computing displacements and extents INTEGER ( KIND = MPI_ADDRESS_KIND ) :: a1 , a2 ! temp variable for setting a type's extent INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text ! temp variable for lower bound parameter when setting extent INTEGER ( KIND = MPI_ADDRESS_KIND ) :: lb INTEGER :: tmp_t , cohort_t ! displacement, block length and block type arrays for ! for all fields in Type(Layer) INTEGER ( KIND = MPI_ADDRESS_KIND ), DIMENSION (:), ALLOCATABLE :: disp INTEGER , DIMENSION (:), ALLOCATABLE :: blen , btype INTEGER :: ierr , bidx ALLOCATE ( disp ( n_layer_types ) ) ALLOCATE ( blen ( n_layer_types ) ) ALLOCATE ( btype ( n_layer_types ) ) lb = 0 bidx = 0 ! create MPI derived datatype for Type(Cohort) CALL create_cohort ( cohort_t , comm ) CALL MPI_Get_Address ( tmp_layer ( 1 ), a1 , ierr ) bidx = bidx + 1 CALL MPI_Get_Address ( tmp_layer ( 1 )% cohort , a2 , ierr ) disp ( bidx ) = a2 - a1 ! always send all cohort array, even if ncohort < ncohort_max ! it's a bit inefficient, but makes the code much simpler blen ( bidx ) = NCOHORT_MAX btype ( bidx ) = cohort_t ! Scalar INTEGER bidx = bidx + 1 CALL MPI_Get_Address ( tmp_layer ( 1 )% ncohort , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_INTEGER ! Scalar REAL bidx = bidx + 1 CALL MPI_Get_Address ( tmp_layer ( 1 )% biomass , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_layer ( 1 )% density , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_layer ( 1 )% hmean , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_layer ( 1 )% hmax , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE IF ( bidx . NE . n_layer_types ) THEN WRITE ( * , * ) \"Error in pop_mpi layer. bidx \" , bidx , \" != n_layer_types \" ,& n_layer_types CALL MPI_ABORT ( comm , 120 , ierr ) ENDIF CALL MPI_Type_create_struct ( n_layer_types , blen , disp , btype , tmp_t , ierr ) CALL MPI_Type_commit ( tmp_t , ierr ) ! make sure the type has correct extent for use in arrays CALL MPI_Get_Address ( tmp_layer ( 2 ), a2 , ierr ) text = a2 - a1 CALL MPI_Type_create_resized ( tmp_t , lb , text , layer_t , ierr ) CALL MPI_Type_commit ( layer_t , ierr ) DEALLOCATE ( disp ) DEALLOCATE ( blen ) DEALLOCATE ( btype ) RETURN END SUBROUTINE create_layer ! create MPI datatype that describes a variable of type patch ! SUBROUTINE create_patch ( patch_t , comm ) USE MPI IMPLICIT NONE ! the new MPI derived datatype: INTEGER , INTENT ( OUT ) :: patch_t ! communicator for error-messages INTEGER , INTENT ( IN ) :: comm ! temp instance of Cohort for computing displacements TYPE ( patch ) :: tmp_patch ( 2 ) ! temp variables for computing displacements and extents INTEGER ( KIND = MPI_ADDRESS_KIND ) :: a1 , a2 ! temp variable for setting a type's extent INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text ! temp variable for lower bound parameter when setting extent INTEGER ( KIND = MPI_ADDRESS_KIND ) :: lb INTEGER :: tmp_t , layer_t ! displacement, block length and block type arrays for ! for all fields in Type(Patch) INTEGER ( KIND = MPI_ADDRESS_KIND ), DIMENSION (:), ALLOCATABLE :: disp INTEGER , DIMENSION (:), ALLOCATABLE :: blen , btype INTEGER :: ierr , bidx ALLOCATE ( disp ( n_patch_types ) ) ALLOCATE ( blen ( n_patch_types ) ) ALLOCATE ( btype ( n_patch_types ) ) bidx = 0 lb = 0 ! create MPI derived datatype for Type(Layer) CALL create_layer ( layer_t , comm ) CALL MPI_Get_Address ( tmp_patch ( 1 ), a1 , ierr ) bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% Layer , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NLAYER btype ( bidx ) = layer_t ! Scalar REAL bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% factor_recruit , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% pgap , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% lai , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% biomass , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% biomass_old , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% sapwood , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% heartwood , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% sapwood_old , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% sapwood_area , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% sapwood_area_old , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% stress_mortality , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% fire_mortality , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% cat_mortality , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% crowding_mortality , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% cpc , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% mortality , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% sapwood_loss , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% sapwood_area_loss , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% growth , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% area_growth , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% frac_NPP , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% frac_respiration , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% frac_light_uptake , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE ! Scalar INTEGER bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% id , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_INTEGER ! INTEGER NDISTURB bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% disturbance_interval ( 1 ), a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NDISTURB btype ( bidx ) = MPI_INTEGER bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% first_disturbance_year ( 1 ), a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NDISTURB btype ( bidx ) = MPI_INTEGER bidx = bidx + 1 CALL MPI_Get_Address ( tmp_patch ( 1 )% age ( 1 ), a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NDISTURB btype ( bidx ) = MPI_INTEGER IF ( bidx . NE . n_patch_types ) THEN WRITE ( * , * ) \"Error in pop_mpi patch. bidx \" , bidx , \" != n_patch_types \" ,& n_patch_types CALL MPI_ABORT ( comm , 121 , ierr ) ENDIF CALL MPI_Type_create_struct ( n_patch_types , blen , disp , btype , tmp_t , ierr ) CALL MPI_Type_commit ( tmp_t , ierr ) ! make sure the type has correct extent for use in arrays CALL MPI_Get_Address ( tmp_patch ( 2 ), a2 , ierr ) text = a2 - a1 CALL MPI_Type_create_resized ( tmp_t , lb , text , patch_t , ierr ) CALL MPI_Type_commit ( patch_t , ierr ) DEALLOCATE ( disp ) DEALLOCATE ( blen ) DEALLOCATE ( btype ) RETURN END SUBROUTINE create_patch ! create MPI datatype that describes a single grid cell variable of type landscape ! SUBROUTINE create_pop_gridcell_type ( gcell_t , comm ) ! Level one ! here Landscape-types are addressed as well as patches generated USE MPI IMPLICIT NONE ! the new MPI derived datatype: INTEGER , INTENT ( OUT ) :: gcell_t ! communicator for error-messages INTEGER , INTENT ( IN ) :: comm ! temp instance of Cohort for computing displacements TYPE ( Landscape ) :: tmp_grid ( 2 ) ! temp variables for computing displacements and extents INTEGER ( KIND = MPI_ADDRESS_KIND ) :: a1 , a2 ! temp variable for setting a type's extent INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text ! temp variable for lower bound parameter when setting extent INTEGER ( KIND = MPI_ADDRESS_KIND ) :: lb INTEGER :: tmp_t , patch_t ! displacement, block length and block type arrays for ! for all fields in Type(Patch) INTEGER ( KIND = MPI_ADDRESS_KIND ), DIMENSION (:), ALLOCATABLE :: disp INTEGER , DIMENSION (:), ALLOCATABLE :: blen , btype INTEGER :: ierr , bidx ALLOCATE ( disp ( n_landscape_types ) ) ALLOCATE ( blen ( n_landscape_types ) ) ALLOCATE ( btype ( n_landscape_types ) ) lb = 0 bidx = 0 ! create MPI derived datatype for Type(Patch) CALL create_patch ( patch_t , comm ) ! compute displacements for the new derived type CALL MPI_Get_Address ( tmp_grid ( 1 ), a1 , ierr ) ! NPATCH2D bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% patch , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NPATCH2D btype ( bidx ) = patch_t bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% freq , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NPATCH2D btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% freq_old , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NPATCH2D btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% fire_freq , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NPATCH2D btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% fire_freq_old , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NPATCH2D btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% cat_freq , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NPATCH2D btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% cat_freq_old , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NPATCH2D btype ( bidx ) = MPI_DOUBLE ! NPATCH2D * NDISTURB bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% freq_ranked_age_unique , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NPATCH2D * NDISTURB btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% ranked_age_unique , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NPATCH2D * NDISTURB btype ( bidx ) = MPI_INTEGER ! NDISTURB bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% n_age , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NPATCH2D btype ( bidx ) = MPI_INTEGER ! NLAYER bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% biomass , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NLAYER btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% density , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NPATCH2D btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% hmean , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NLAYER btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% hmax , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NLAYER btype ( bidx ) = MPI_DOUBLE ! HEIGHT_BINS bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% cmass_stem_bin , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = HEIGHT_BINS btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% densindiv_bin , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = HEIGHT_BINS btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% height_bin , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = HEIGHT_BINS btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% diameter_bin , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = HEIGHT_BINS btype ( bidx ) = MPI_DOUBLE ! NYEAR_HISTORY bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% fire_mortality_history , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = NYEAR_HISTORY btype ( bidx ) = MPI_DOUBLE ! AGEMAX bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% freq_age , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = AGEMAX btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% biomass_age , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = AGEMAX btype ( bidx ) = MPI_DOUBLE ! Scalars REAL bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% cmass_sum , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% cmass_sum_old , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% cheartwood_sum , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% csapwood_sum , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% csapwood_sum_old , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% densindiv , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% height_mean , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% height_max , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% basal_area , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% sapwood_loss , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% sapwood_area_loss , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% stress_mortality , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% crowding_mortality , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% fire_mortality , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% cat_mortality , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% res_mortality , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% growth , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% area_growth , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% crown_cover , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% crown_area , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% crown_volume , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% sapwood_area , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% sapwood_area_old , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% Kclump , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% smoothing_buffer , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% fire_mortality_smoothed , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_DOUBLE ! Scalar Integer ! bidx = bidx + 1 ! CALL MPI_Get_Address (tmp_grid(1)%npatch_active, a2, ierr) ! disp (bidx) = a2 - a1 ! blen (bidx) = 1 ! btype(bidx) = MPI_INTEGER bidx = bidx + 1 CALL MPI_Get_Address ( tmp_grid ( 1 )% LU , a2 , ierr ) disp ( bidx ) = a2 - a1 blen ( bidx ) = 1 btype ( bidx ) = MPI_INTEGER IF ( bidx . NE . n_landscape_types ) THEN WRITE ( * , * ) \"Error in pop_mpi landscape. bidx \" , bidx , \" != n_landscape_types \" ,& n_landscape_types CALL MPI_ABORT ( comm , 122 , ierr ) ENDIF CALL MPI_Type_create_struct ( n_landscape_types , blen , disp , btype , tmp_t , ierr ) CALL MPI_Type_commit ( tmp_t , ierr ) ! make sure the type has correct extent for use in arrays CALL MPI_Get_Address ( tmp_grid ( 2 ), a2 , ierr ) text = a2 - a1 CALL MPI_Type_create_resized ( tmp_t , lb , text , gcell_t , ierr ) CALL MPI_Type_commit ( gcell_t , ierr ) DEALLOCATE ( disp ) DEALLOCATE ( blen ) DEALLOCATE ( btype ) RETURN END SUBROUTINE create_pop_gridcell_type END MODULE pop_mpi","tags":"","loc":"sourcefile/pop_mpi.f90.html"},{"title":"CASAONLY_LUC.F90 – POP","text":"This file depends on sourcefile~~casaonly_luc.f90~~EfferentGraph sourcefile~casaonly_luc.f90 CASAONLY_LUC.F90 sourcefile~casa_cable.f90 casa_cable.F90 sourcefile~casaonly_luc.f90->sourcefile~casa_cable.f90 sourcefile~casa_inout.f90 casa_inout.F90 sourcefile~casaonly_luc.f90->sourcefile~casa_inout.f90 sourcefile~casa_variable.f90 casa_variable.F90 sourcefile~casaonly_luc.f90->sourcefile~casa_variable.f90 sourcefile~pop.f90 POP.F90 sourcefile~casaonly_luc.f90->sourcefile~pop.f90 sourcefile~popluc.f90 POPLUC.F90 sourcefile~casaonly_luc.f90->sourcefile~popluc.f90 sourcefile~casa_cable.f90->sourcefile~casa_inout.f90 sourcefile~casa_cable.f90->sourcefile~casa_variable.f90 sourcefile~casa_cable.f90->sourcefile~pop.f90 sourcefile~cable_adjustjvgm.f90 cable_adjustJVgm.F90 sourcefile~casa_cable.f90->sourcefile~cable_adjustjvgm.f90 sourcefile~cable_optimisejvratio.f90 cable_optimiseJVratio.F90 sourcefile~casa_cable.f90->sourcefile~cable_optimisejvratio.f90 sourcefile~cable_phenology.f90 cable_phenology.F90 sourcefile~casa_cable.f90->sourcefile~cable_phenology.f90 sourcefile~casa_cnp.f90 casa_cnp.F90 sourcefile~casa_cable.f90->sourcefile~casa_cnp.f90 sourcefile~casa_inout.f90->sourcefile~casa_variable.f90 sourcefile~casa_inout.f90->sourcefile~pop.f90 sourcefile~casa_inout.f90->sourcefile~casa_cnp.f90 sourcefile~popluc.f90->sourcefile~casa_variable.f90 sourcefile~popluc.f90->sourcefile~pop.f90 sourcefile~cable_optimisejvratio.f90->sourcefile~pop.f90 sourcefile~cable_phenology.f90->sourcefile~casa_variable.f90 sourcefile~cable_phenology.f90->sourcefile~pop.f90 sourcefile~casa_cnp.f90->sourcefile~casa_variable.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules cable_casaonly_luc Source Code CASAONLY_LUC.F90 Source Code module cable_casaonly_luc implicit none contains SUBROUTINE CASAONLY_LUC ( dels , kstart , kend , veg , soil , casabiome , casapool , & casaflux , casamet , casabal , phen , POP , climate , LALLOC , LUC_EXPT , POPLUC , & sum_casapool , sum_casaflux , c13o2flux , c13o2pools , sum_c13o2pools , c13o2luc ) USE cable_def_types_mod USE cable_carbon_module USE cable_common_module , ONLY : CABLE_USER , is_casa_time USE cable_IO_vars_module , ONLY : logn , landpt USE casadimension USE casaparm USE casavariable USE phenvariable USE POP_Types , Only : POP_TYPE USE POPMODULE , ONLY : POP_init_single ! use cable_pop_io,         only: pop_io USE TypeDef , ONLY : dp USE CABLE_LUC_EXPT , ONLY : LUC_EXPT_TYPE , read_LUH2 , & ptos , ptog , stog , gtos , pharv , smharv , syharv , & ptoc , ptoq , stoc , stoq , ctos , qtos USE POPLUC_Types USE POPLUC_Module , ONLY : POPLUCStep , POPLUC_weights_Transfer , & ! WRITE_LUC_OUTPUT_NC, & POP_LUC_CASA_transfer , WRITE_LUC_RESTART_NC , & POPLUC_set_patchfrac use casa_cable , only : POPdriver , read_casa_dump use casa_inout , only : biogeochem ! , write_casa_output_nc ! 13C use cable_c13o2_def , only : c13o2_flux , c13o2_pool , c13o2_luc , c13o2_update_sum_pools , c13o2_zero_sum_pools use cable_c13o2 , only : c13o2_save_casapool , c13o2_update_pools , c13o2_save_luc , c13o2_update_luc ! , & ! c13o2_create_output, c13o2_write_output, c13o2_close_output, & ! c13o2_nvars_output, & ! c13o2_print_delta_pools, c13o2_print_delta_luc use mo_utils , only : eq IMPLICIT NONE !!CLN  CHARACTER(LEN=99), INTENT(IN)  :: fcnpspin REAL , INTENT ( IN ) :: dels INTEGER , INTENT ( IN ) :: kstart INTEGER , INTENT ( IN ) :: kend INTEGER , INTENT ( IN ) :: LALLOC TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil ! soil parameters TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal TYPE ( phen_variable ), INTENT ( INOUT ) :: phen TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP TYPE ( climate_TYPE ), INTENT ( INOUT ) :: climate TYPE ( LUC_EXPT_TYPE ), INTENT ( INOUT ) :: LUC_EXPT TYPE ( POPLUC_TYPE ), INTENT ( INOUT ) :: POPLUC TYPE ( casa_pool ), INTENT ( INOUT ) :: sum_casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: sum_casaflux ! 13C type ( c13o2_flux ), intent ( inout ) :: c13o2flux type ( c13o2_pool ), intent ( inout ) :: c13o2pools type ( c13o2_pool ), intent ( inout ) :: sum_c13o2pools type ( c13o2_luc ), intent ( inout ) :: c13o2luc ! local variables INTEGER :: myearspin , nyear , yyyy , nyear_dump CHARACTER ( LEN = 99 ) :: ncfile CHARACTER ( LEN = 4 ) :: cyear INTEGER :: ktau , ktauday , nday , idoy real ( r_2 ), dimension ( mp ) :: cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd real ( r_2 ), dimension ( mp ) :: nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd real ( r_2 ), dimension ( mp ) :: pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd real ( r_2 ), dimension ( mp ) :: xnplimit , xkNlimiting , xklitter , xksoil , xkleaf , xkleafcold , xkleafdry ! more variables to store the spinup pool size over the last 10 loops. Added by Yp Wang 30 Nov 2012 integer :: k , j , l ! integer :: ctime INTEGER , allocatable :: Iw (:) ! array of indices corresponding to woody (shrub or forest) tiles INTEGER :: count_sum_casa ! number of time steps over which casa pools & !and fluxes are aggregated (for output) ! 13C real ( dp ), dimension ( c13o2pools % ntile , c13o2pools % npools ) :: casasave real ( dp ), dimension ( c13o2luc % nland , c13o2luc % npools ) :: lucsave ! integer :: c13o2_file_id ! character(len=40), dimension(c13o2_nvars_output) :: c13o2_vars ! integer,           dimension(c13o2_nvars_output) :: c13o2_var_ids logical :: first_casa_write if (. NOT . Allocated ( Iw )) allocate ( Iw ( POP % np )) !! vh_js !! IF ( cable_user % CALL_POP ) THEN Iw = POP % Iwood ENDIF CALL zero_sum_casa ( sum_casapool , sum_casaflux ) ! 13C if ( cable_user % c13o2 ) call c13o2_zero_sum_pools ( sum_c13o2pools ) ktauday = int ( 2 4.0 * 360 0.0 / dels ) nday = ( kend - kstart + 1 ) / ktauday ! ctime   = 0 first_casa_write = . true . count_sum_casa = 0 myearspin = cable_user % yearend - cable_user % yearstart + 1 yyyy = cable_user % yearstart - 1 do nyear = 1 , myearspin yyyy = yyyy + 1 write ( * , * ) 'casaonly_LUC' , yyyy nyear_dump = mod ( nyear , cable_user % casa_spin_endyear - cable_user % casa_spin_startyear + 1 ) if ( nyear_dump == 0 ) & nyear_dump = cable_user % casa_spin_endyear - cable_user % casa_spin_startyear + 1 write ( cyear , fmt = \"(i4)\" ) cable_user % casa_spin_startyear + nyear_dump - 1 ncfile = trim ( casafile % c2cdumppath ) // 'c2c_' // cyear // '_dump.nc' call read_casa_dump ( trim ( ncfile ), casamet , casaflux , phen , climate , c13o2flux , 1 , 1 , . true .) !!CLN901  format(A99) do idoy = 1 , mdyear ktau = ( idoy - 1 ) * ktauday + ktauday ! ctime = ctime + 1 casamet % tairk (:) = casamet % Tairkspin (:, idoy ) casamet % tsoil (:, 1 ) = casamet % Tsoilspin_1 (:, idoy ) casamet % tsoil (:, 2 ) = casamet % Tsoilspin_2 (:, idoy ) casamet % tsoil (:, 3 ) = casamet % Tsoilspin_3 (:, idoy ) casamet % tsoil (:, 4 ) = casamet % Tsoilspin_4 (:, idoy ) casamet % tsoil (:, 5 ) = casamet % Tsoilspin_5 (:, idoy ) casamet % tsoil (:, 6 ) = casamet % Tsoilspin_6 (:, idoy ) casamet % moist (:, 1 ) = casamet % moistspin_1 (:, idoy ) casamet % moist (:, 2 ) = casamet % moistspin_2 (:, idoy ) casamet % moist (:, 3 ) = casamet % moistspin_3 (:, idoy ) casamet % moist (:, 4 ) = casamet % moistspin_4 (:, idoy ) casamet % moist (:, 5 ) = casamet % moistspin_5 (:, idoy ) casamet % moist (:, 6 ) = casamet % moistspin_6 (:, idoy ) casaflux % cgpp (:) = casamet % cgppspin (:, idoy ) casaflux % crmplant (:, 1 ) = casamet % crmplantspin_1 (:, idoy ) casaflux % crmplant (:, 2 ) = casamet % crmplantspin_2 (:, idoy ) casaflux % crmplant (:, 3 ) = casamet % crmplantspin_3 (:, idoy ) phen % phase (:) = phen % phasespin (:, idoy ) phen % doyphase (:, 1 ) = phen % doyphasespin_1 (:, idoy ) phen % doyphase (:, 2 ) = phen % doyphasespin_2 (:, idoy ) phen % doyphase (:, 3 ) = phen % doyphasespin_3 (:, idoy ) phen % doyphase (:, 4 ) = phen % doyphasespin_4 (:, idoy ) climate % qtemp_max_last_year (:) = real ( casamet % mtempspin (:, idoy )) climate % frec (:) = real ( casamet % frecspin (:, idoy )) ! 13C if ( cable_user % c13o2 ) then c13o2flux % cAn12 (:) = casamet % cAn12spin (:, idoy ) c13o2flux % cAn (:) = casamet % cAn13spin (:, idoy ) endif ! BLAZE if ( cable_user % call_blaze ) then climate % dprecip (:) = real ( casamet % dprecip_spin (:, idoy )) climate % aprecip_av20 (:) = real ( casamet % aprecip_av20_spin (:, idoy )) climate % du10_max (:) = real ( casamet % du10_max_spin (:, idoy )) climate % drhum (:) = real ( casamet % drhum_spin (:, idoy )) climate % dtemp_max (:) = real ( casamet % dtemp_max_spin (:, idoy )) climate % dtemp_min (:) = real ( casamet % dtemp_max_spin (:, idoy )) climate % KBDI (:) = real ( casamet % KBDI_spin (:, idoy )) climate % D_MacArthur (:) = real ( casamet % D_MacArthur_spin (:, idoy )) climate % FFDI (:) = real ( casamet % FFDI_spin (:, idoy )) climate % DSLR (:) = casamet % DSLR_spin (:, idoy ) climate % last_precip (:) = real ( casamet % last_precip_spin (:, idoy )) endif ! 13C if ( cable_user % c13o2 ) call c13o2_save_casapool ( casapool , casasave ) CALL biogeochem ( idoy , LALLOC , veg , soil , casabiome , casapool , casaflux , & casamet , casabal , phen , POP , climate , xnplimit , xkNlimiting , xklitter , & xksoil , xkleaf , xkleafcold , xkleafdry ,& cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd , & nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd , & pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd ) ! 13C if ( cable_user % c13o2 ) call c13o2_update_pools ( casasave , casaflux , c13o2flux , c13o2pools ) ! update time-aggregates of casa pools and fluxes CALL update_sum_casa ( sum_casapool , sum_casaflux , casapool , casaflux , & & . TRUE . , . FALSE ., 1 ) ! 13C if ( cable_user % c13o2 ) & call c13o2_update_sum_pools ( sum_c13o2pools , c13o2pools , . true ., . false ., 1 ) count_sum_casa = count_sum_casa + 1 ! accumulate annual variables for use in POP IF ( idoy == 1 ) THEN ! (assumes 70% of wood NPP is allocated above ground) casaflux % stemnpp = casaflux % cnpp * casaflux % fracCalloc (:, 2 ) * 0.7_dp casabal % LAImax = casamet % glai casabal % Cleafmean = casapool % cplant (:, 1 ) / real ( mdyear , dp ) / 100 0._dp casabal % Crootmean = casapool % cplant (:, 3 ) / real ( mdyear , dp ) / 100 0._dp ELSE casaflux % stemnpp = casaflux % stemnpp + casaflux % cnpp * casaflux % fracCalloc (:, 2 ) * 0.7_dp casabal % LAImax = max ( casamet % glai , casabal % LAImax ) casabal % Cleafmean = casabal % Cleafmean + casapool % cplant (:, 1 ) / real ( mdyear , dp ) / 100 0._dp casabal % Crootmean = casabal % Crootmean + casapool % cplant (:, 3 ) / real ( mdyear , dp ) / 100 0._dp ENDIF IF ( CABLE_USER % POPLUC ) THEN IF ( idoy == mdyear ) THEN ! end of year LUC_EXPT % CTSTEP = yyyy - LUC_EXPT % FirstYear + 1 CALL READ_LUH2 ( LUC_EXPT ) DO k = 1 , mland POPLUC % ptos ( k ) = real ( LUC_EXPT % INPUT ( ptos )% VAL ( k ), dp ) POPLUC % ptog ( k ) = real ( LUC_EXPT % INPUT ( ptog )% VAL ( k ), dp ) POPLUC % stog ( k ) = real ( LUC_EXPT % INPUT ( stog )% VAL ( k ), dp ) POPLUC % gtop ( k ) = 0.0_dp POPLUC % gtos ( k ) = real ( LUC_EXPT % INPUT ( gtos )% VAL ( k ), dp ) POPLUC % pharv ( k ) = real ( LUC_EXPT % INPUT ( pharv )% VAL ( k ), dp ) POPLUC % smharv ( k ) = real ( LUC_EXPT % INPUT ( smharv )% VAL ( k ), dp ) POPLUC % syharv ( k ) = real ( LUC_EXPT % INPUT ( syharv )% VAL ( k ), dp ) POPLUC % ptoc ( k ) = real ( LUC_EXPT % INPUT ( ptoc )% VAL ( k ), dp ) POPLUC % ptoq ( k ) = real ( LUC_EXPT % INPUT ( ptoq )% VAL ( k ), dp ) POPLUC % stoc ( k ) = real ( LUC_EXPT % INPUT ( stoc )% VAL ( k ), dp ) POPLUC % stoq ( k ) = real ( LUC_EXPT % INPUT ( stoq )% VAL ( k ), dp ) POPLUC % ctos ( k ) = real ( LUC_EXPT % INPUT ( ctos )% VAL ( k ), dp ) POPLUC % qtos ( k ) = real ( LUC_EXPT % INPUT ( qtos )% VAL ( k ), dp ) POPLUC % thisyear = yyyy ENDDO !stop ! set landuse index for secondary forest POP landscapes DO k = 1 , POP % np IF ( yyyy . eq . LUC_EXPT % YearStart ) THEN if ( veg % iLU ( POP % Iwood ( k )). eq . 2 ) then POP % pop_grid ( k )% LU = 2 endif endif ENDDO ! zero secondary forest tiles in POP where secondary forest area is zero DO k = 1 , mland if ( eq (( POPLUC % primf ( k ) - POPLUC % frac_forest ( k )), 0.0_dp ) & . and . (. not . LUC_EXPT % prim_only ( k )) ) then j = landpt ( k )% cstart + 1 do l = 1 , size ( POP % Iwood ) if ( POP % Iwood ( l ) == j ) then CALL POP_init_single ( POP , veg % disturbance_interval , l ) exit endif enddo casapool % cplant ( j , leaf ) = 0.01_dp casapool % nplant ( j , leaf ) = casabiome % ratioNCplantmin ( veg % iveg ( j ), leaf ) * casapool % cplant ( j , leaf ) casapool % pplant ( j , leaf ) = casabiome % ratioPCplantmin ( veg % iveg ( j ), leaf ) * casapool % cplant ( j , leaf ) casapool % cplant ( j , froot ) = 0.01_dp casapool % nplant ( j , froot ) = casabiome % ratioNCplantmin ( veg % iveg ( j ), froot ) * casapool % cplant ( j , froot ) casapool % pplant ( j , froot ) = casabiome % ratioPCplantmin ( veg % iveg ( j ), froot ) * casapool % cplant ( j , froot ) casapool % cplant ( j , wood ) = 0.01_dp casapool % nplant ( j , wood ) = casabiome % ratioNCplantmin ( veg % iveg ( j ), wood ) * casapool % cplant ( j , wood ) casapool % pplant ( j , wood ) = casabiome % ratioPCplantmin ( veg % iveg ( j ), wood ) * casapool % cplant ( j , wood ) casaflux % frac_sapwood ( j ) = 1.0_dp ! 13C if ( cable_user % c13o2 ) then c13o2pools % cplant ( j , leaf ) = 0.01_dp ! * vpdbc13 / vpdbc13 ! Divide by 13C c13o2pools % cplant ( j , wood ) = 0.01_dp ! * vpdbc13 / vpdbc13 ! so that about same numerical precision as 12C c13o2pools % cplant ( j , froot ) = 0.01_dp ! * vpdbc13 / vpdbc13 ! endif endif ENDDO CALL POPLUCStep ( POPLUC , yyyy ) CALL POPLUC_weights_transfer ( POPLUC , POP , LUC_EXPT ) CALL POPdriver ( casaflux , casabal , veg , POP ) !MC CALL POP_IO( pop, casamet, YYYY, 'WRITE_EPI', & !      ( YYYY.EQ.cable_user%YearEnd ) ) ! 13C if ( cable_user % c13o2 ) call c13o2_save_luc ( casapool , popluc , casasave , lucsave ) CALL POP_LUC_CASA_transfer ( POPLUC , POP , LUC_EXPT , casapool , casabal , casaflux , ktauday ) ! 13C #ifdef __C13DEBUG__ if ( cable_user % c13o2 ) & call c13o2_update_luc ( casasave , lucsave , popluc , luc_expt % prim_only , c13o2pools , c13o2luc , casapool ) #else if ( cable_user % c13o2 ) call c13o2_update_luc ( casasave , lucsave , popluc , luc_expt % prim_only , c13o2pools , c13o2luc ) #endif !MC CALL WRITE_LUC_OUTPUT_NC(POPLUC, YYYY, (YYYY.EQ.cable_user%YearEnd)) CALL POPLUC_set_patchfrac ( POPLUC , LUC_EXPT ) ENDIF ! end of year ELSE IF ( idoy == mdyear ) THEN ! end of year CALL POPdriver ( casaflux , casabal , veg , POP ) endif ! CALL POP_IO( pop, casamet, YYYY, 'WRITE_EPI', & !         ( YYYY.EQ.cable_user%YearEnd ) ) ENDIF ! IF (CABLE_USER%POPLUC) IF ( IS_CASA_TIME ( \"write\" , yyyy , ktau , kstart , 0 , ktauday , logn ) ) THEN CALL update_sum_casa ( sum_casapool , sum_casaflux , casapool , casaflux , & . FALSE . , . TRUE . , count_sum_casa ) ! 13C if ( cable_user % c13o2 ) then call c13o2_update_sum_pools ( sum_c13o2pools , c13o2pools , . false ., . true ., count_sum_casa ) endif !MC CALL WRITE_CASA_OUTPUT_NC( veg, casamet, sum_casapool, casabal, sum_casaflux, & !      .true., ctime, ( idoy.eq.mdyear .AND. YYYY .EQ. cable_user%YearEnd ) ) ! 13C ! if (cable_user%c13o2) then !    if (first_casa_write) then !       call c13o2_create_output(casamet, sum_c13o2pools, c13o2_file_id, c13o2_vars, c13o2_var_ids) !       first_casa_write = .false. !    endif !    call c13o2_write_output(c13o2_file_id, c13o2_vars, c13o2_var_ids, ctime, sum_c13o2pools) !    if ( (idoy == mdyear) .and. (YYYY == cable_user%YearEnd) ) & !         call c13o2_close_output(c13o2_file_id) ! end if count_sum_casa = 0 CALL zero_sum_casa ( sum_casapool , sum_casaflux ) if ( cable_user % c13o2 ) call c13o2_zero_sum_pools ( sum_c13o2pools ) ENDIF enddo ! idoy enddo ! nyear IF ( CABLE_USER % POPLUC ) CALL WRITE_LUC_RESTART_NC ( POPLUC ) END SUBROUTINE CASAONLY_LUC end module cable_casaonly_luc","tags":"","loc":"sourcefile/casaonly_luc.f90.html"},{"title":"spincasacnp.F90 – POP","text":"This file depends on sourcefile~~spincasacnp.f90~~EfferentGraph sourcefile~spincasacnp.f90 spincasacnp.F90 sourcefile~casa_cable.f90 casa_cable.F90 sourcefile~spincasacnp.f90->sourcefile~casa_cable.f90 sourcefile~casa_inout.f90 casa_inout.F90 sourcefile~spincasacnp.f90->sourcefile~casa_inout.f90 sourcefile~casa_variable.f90 casa_variable.F90 sourcefile~spincasacnp.f90->sourcefile~casa_variable.f90 sourcefile~pop.f90 POP.F90 sourcefile~spincasacnp.f90->sourcefile~pop.f90 sourcefile~casa_cable.f90->sourcefile~casa_inout.f90 sourcefile~casa_cable.f90->sourcefile~casa_variable.f90 sourcefile~casa_cable.f90->sourcefile~pop.f90 sourcefile~cable_adjustjvgm.f90 cable_adjustJVgm.F90 sourcefile~casa_cable.f90->sourcefile~cable_adjustjvgm.f90 sourcefile~cable_optimisejvratio.f90 cable_optimiseJVratio.F90 sourcefile~casa_cable.f90->sourcefile~cable_optimisejvratio.f90 sourcefile~cable_phenology.f90 cable_phenology.F90 sourcefile~casa_cable.f90->sourcefile~cable_phenology.f90 sourcefile~casa_cnp.f90 casa_cnp.F90 sourcefile~casa_cable.f90->sourcefile~casa_cnp.f90 sourcefile~casa_inout.f90->sourcefile~casa_variable.f90 sourcefile~casa_inout.f90->sourcefile~pop.f90 sourcefile~casa_inout.f90->sourcefile~casa_cnp.f90 sourcefile~cable_optimisejvratio.f90->sourcefile~pop.f90 sourcefile~cable_phenology.f90->sourcefile~casa_variable.f90 sourcefile~cable_phenology.f90->sourcefile~pop.f90 sourcefile~casa_cnp.f90->sourcefile~casa_variable.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules cable_spincasacnp Source Code spincasacnp.F90 Source Code module cable_spincasacnp implicit none contains SUBROUTINE spincasacnp ( dels , kstart , kend , mloop , veg , soil , casabiome , casapool , & casaflux , casamet , casabal , phen , POP , climate , LALLOC , c13o2flux , c13o2pools , & BLAZE , SIMFIRE ) USE cable_def_types_mod USE cable_carbon_module USE cable_common_module , ONLY : CABLE_USER USE casadimension USE casaparm ! e.g. leaf USE casavariable USE phenvariable USE POP_Types , Only : POP_TYPE USE POP_Constants , ONLY : rshootfrac ! use cable_pop_io,        only: pop_io use casa_cable , only : POPdriver , read_casa_dump , analyticpool use casa_inout , only : casa_fluxout , biogeochem , write_casa_output_nc use TypeDef , only : dp ! 13C use cable_c13o2_def , only : c13o2_pool , c13o2_flux use cable_c13o2 , only : c13o2_save_casapool , c13o2_update_pools , & c13o2_create_output , c13o2_write_output , c13o2_close_output , & c13o2_nvars_output , c13o2_sanity_pools use mo_isotope , only : isoratio use blaze_drv , only : blaze_driver USE BLAZE_MOD , ONLY : TYPE_BLAZE , BLAZE_ACCOUNTING , WRITE_BLAZE_OUTPUT_NC USE SIMFIRE_MOD , ONLY : TYPE_SIMFIRE implicit none !!CLN  character(len=99), intent(in)  :: fcnpspin real , intent ( in ) :: dels integer , intent ( in ) :: kstart integer , intent ( in ) :: kend integer , intent ( in ) :: mloop integer , intent ( in ) :: lalloc type ( veg_parameter_type ), intent ( inout ) :: veg ! vegetation parameters type ( soil_parameter_type ), intent ( inout ) :: soil ! soil parameters type ( casa_biome ), intent ( inout ) :: casabiome type ( casa_pool ), intent ( inout ) :: casapool type ( casa_flux ), intent ( inout ) :: casaflux type ( casa_met ), intent ( inout ) :: casamet type ( casa_balance ), intent ( inout ) :: casabal type ( phen_variable ), intent ( inout ) :: phen type ( pop_type ), intent ( inout ) :: pop type ( climate_type ), intent ( inout ) :: climate ! 13C type ( c13o2_flux ), intent ( inout ) :: c13o2flux type ( c13o2_pool ), intent ( inout ) :: c13o2pools ! BLAZE type ( TYPE_BLAZE ), intent ( inout ) :: BLAZE type ( TYPE_SIMFIRE ), intent ( inout ) :: SIMFIRE ! type(casa_met) :: casaspin ! local variables real ( r_2 ), dimension (:), allocatable , save :: avg_cleaf2met , avg_cleaf2str , avg_croot2met , avg_croot2str , avg_cwood2cwd real ( r_2 ), dimension (:), allocatable , save :: avg_nleaf2met , avg_nleaf2str , avg_nroot2met , avg_nroot2str , avg_nwood2cwd real ( r_2 ), dimension (:), allocatable , save :: avg_pleaf2met , avg_pleaf2str , avg_proot2met , avg_proot2str , avg_pwood2cwd real ( r_2 ), dimension (:), allocatable , save :: avg_cgpp , avg_cnpp , avg_nuptake , avg_puptake real ( r_2 ), dimension (:), allocatable , save :: avg_nsoilmin , avg_psoillab , avg_psoilsorb , avg_psoilocc !chris 12/oct/2012 for spin up casa real ( r_2 ), dimension (:), allocatable , save :: avg_ratioNCsoilmic , avg_ratioNCsoilslow , avg_ratioNCsoilpass real ( r_2 ), dimension (:), allocatable , save :: avg_xnplimit , avg_xkNlimiting , avg_xklitter , avg_xksoil ! local variables integer :: myearspin , nyear , nloop1 character ( len = 99 ) :: ncfile character ( len = 4 ) :: cyear integer :: ktau , ktauday , nday , idoy , ktauy , nloop , LOY , YYYY real ( r_2 ), dimension ( mp ) :: cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd real ( r_2 ), dimension ( mp ) :: nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd real ( r_2 ), dimension ( mp ) :: pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd real ( r_2 ), dimension ( mp ) :: xnplimit , xkNlimiting , xklitter , xksoil , xkleaf , xkleafcold , xkleafdry ! more variables to store the spinup pool size over the last 10 loops. Added by Yp Wang 30 Nov 2012 real ( dp ), allocatable , save :: LAImax (:), Cleafmean (:), Crootmean (:) real ( dp ), allocatable :: NPPtoGPP (:) integer , allocatable :: Iw (:) ! array of indices corresponding to woody (shrub or forest) tiles integer :: ctime real ( dp ) :: rday ! 13C real ( dp ), dimension ( c13o2pools % ntile , c13o2pools % npools ) :: casasave integer :: c13o2_file_id character ( len = 40 ), dimension ( c13o2_nvars_output ) :: c13o2_vars integer , dimension ( c13o2_nvars_output ) :: c13o2_var_ids real ( r_2 ), dimension (:), allocatable :: avg_c13leaf2met , avg_c13leaf2str , avg_c13root2met , & avg_c13root2str , avg_c13wood2cwd if (. not . allocated ( LAIMax )) allocate ( LAIMax ( mp )) if (. not . allocated ( Cleafmean )) allocate ( Cleafmean ( mp )) if (. not . allocated ( Crootmean )) allocate ( Crootmean ( mp )) if (. not . allocated ( NPPtoGPP )) allocate ( NPPtoGPP ( mp )) if (. not . allocated ( Iw )) allocate ( Iw ( POP % np )) ctime = 0 LOY = 365 !! vh_js !! if ( cable_user % CALL_POP ) Iw = POP % Iwood ktauday = int ( 2 4.0 * 360 0.0 / dels ) nday = ( kend - kstart + 1 ) / ktauday !chris 12/oct/2012 for spin up casa if (. not .( allocated ( avg_cleaf2met ))) & allocate ( avg_cleaf2met ( mp ), avg_cleaf2str ( mp ), avg_croot2met ( mp ), avg_croot2str ( mp ), avg_cwood2cwd ( mp ), & avg_nleaf2met ( mp ), avg_nleaf2str ( mp ), avg_nroot2met ( mp ), avg_nroot2str ( mp ), avg_nwood2cwd ( mp ), & avg_pleaf2met ( mp ), avg_pleaf2str ( mp ), avg_proot2met ( mp ), avg_proot2str ( mp ), avg_pwood2cwd ( mp ), & avg_cgpp ( mp ), avg_cnpp ( mp ), avg_nuptake ( mp ), avg_puptake ( mp ), & avg_xnplimit ( mp ), avg_xkNlimiting ( mp ), avg_xklitter ( mp ), avg_xksoil ( mp ), & avg_rationcsoilmic ( mp ), avg_rationcsoilslow ( mp ), avg_rationcsoilpass ( mp ), & avg_nsoilmin ( mp ), avg_psoillab ( mp ), avg_psoilsorb ( mp ), avg_psoilocc ( mp )) ! 13C - allocate in any case even if cable_user%c13o2==.false. to pass to analytic soil and litter pools allocate ( avg_c13leaf2met ( mp )) allocate ( avg_c13leaf2str ( mp )) allocate ( avg_c13root2met ( mp )) allocate ( avg_c13root2str ( mp )) allocate ( avg_c13wood2cwd ( mp )) !!CLN  OPEN(91, file=fcnpspin) !!CLN  read(91,*) myearspin myearspin = CABLE_USER % CASA_SPIN_ENDYEAR - CABLE_USER % CASA_SPIN_STARTYEAR + 1 ! compute the mean fluxes and residence time of each carbon pool avg_cleaf2met = 0.0_dp avg_cleaf2str = 0.0_dp avg_croot2met = 0.0_dp avg_croot2str = 0.0_dp avg_cwood2cwd = 0.0_dp avg_nleaf2met = 0.0_dp avg_nleaf2str = 0.0_dp avg_nroot2met = 0.0_dp avg_nroot2str = 0.0_dp avg_nwood2cwd = 0.0_dp avg_pleaf2met = 0.0_dp avg_pleaf2str = 0.0_dp avg_proot2met = 0.0_dp avg_proot2str = 0.0_dp avg_pwood2cwd = 0.0_dp avg_cgpp = 0.0_dp avg_cnpp = 0.0_dp avg_nuptake = 0.0_dp avg_puptake = 0.0_dp avg_xnplimit = 0.0_dp avg_xkNlimiting = 0.0_dp avg_xklitter = 0.0_dp avg_xksoil = 0.0_dp avg_nsoilmin = 0.0_dp avg_psoillab = 0.0_dp avg_psoilsorb = 0.0_dp avg_psoilocc = 0.0_dp avg_rationcsoilmic = 0.0_dp avg_rationcsoilslow = 0.0_dp avg_rationcsoilpass = 0.0_dp ! 13C if ( cable_user % c13o2 ) then avg_c13leaf2met = 0.0_dp avg_c13leaf2str = 0.0_dp avg_c13root2met = 0.0_dp avg_c13root2str = 0.0_dp avg_c13wood2cwd = 0.0_dp endif !   write(600,*) 'csoil3 init: ', casapool%csoil(3,:) !   write(600,*) 'csoil1 init: ', casapool%csoil(1,:) do nyear = 1 , myearspin write ( cyear , FMT = \"(I4)\" ) CABLE_USER % CASA_SPIN_STARTYEAR + nyear - 1 YYYY = CABLE_USER % CASA_SPIN_STARTYEAR + nyear - 1 ncfile = trim ( casafile % c2cdumppath ) // 'c2c_' // cyear // '_dump.nc' call read_casa_dump ( ncfile , casamet , casaflux , phen , climate , c13o2flux , ktau , kend , . true .) do idoy = 1 , mdyear ktau = ( idoy - 1 ) * ktauday + 1 casamet % tairk (:) = casamet % Tairkspin (:, idoy ) casamet % tsoil (:, 1 ) = casamet % Tsoilspin_1 (:, idoy ) casamet % tsoil (:, 2 ) = casamet % Tsoilspin_2 (:, idoy ) casamet % tsoil (:, 3 ) = casamet % Tsoilspin_3 (:, idoy ) casamet % tsoil (:, 4 ) = casamet % Tsoilspin_4 (:, idoy ) casamet % tsoil (:, 5 ) = casamet % Tsoilspin_5 (:, idoy ) casamet % tsoil (:, 6 ) = casamet % Tsoilspin_6 (:, idoy ) casamet % moist (:, 1 ) = casamet % moistspin_1 (:, idoy ) casamet % moist (:, 2 ) = casamet % moistspin_2 (:, idoy ) casamet % moist (:, 3 ) = casamet % moistspin_3 (:, idoy ) casamet % moist (:, 4 ) = casamet % moistspin_4 (:, idoy ) casamet % moist (:, 5 ) = casamet % moistspin_5 (:, idoy ) casamet % moist (:, 6 ) = casamet % moistspin_6 (:, idoy ) casaflux % cgpp (:) = casamet % cgppspin (:, idoy ) casaflux % crmplant (:, 1 ) = casamet % crmplantspin_1 (:, idoy ) casaflux % crmplant (:, 2 ) = casamet % crmplantspin_2 (:, idoy ) casaflux % crmplant (:, 3 ) = casamet % crmplantspin_3 (:, idoy ) phen % phase (:) = phen % phasespin (:, idoy ) phen % doyphase (:, 1 ) = phen % doyphasespin_1 (:, idoy ) phen % doyphase (:, 2 ) = phen % doyphasespin_2 (:, idoy ) phen % doyphase (:, 3 ) = phen % doyphasespin_3 (:, idoy ) phen % doyphase (:, 4 ) = phen % doyphasespin_4 (:, idoy ) climate % qtemp_max_last_year (:) = real ( casamet % mtempspin (:, idoy )) climate % frec (:) = real ( casamet % frecspin (:, idoy )) ! casaflux%Nmindep and casaflux%Pdep set in read_casa_dump ! 13C if ( cable_user % c13o2 ) then c13o2flux % cAn12 (:) = casamet % cAn12spin (:, idoy ) c13o2flux % cAn (:) = casamet % cAn13spin (:, idoy ) endif ! 13C if ( cable_user % c13o2 ) call c13o2_save_casapool ( casapool , casasave ) call biogeochem ( idoy , LALLOC , veg , soil , casabiome , casapool , casaflux , & casamet , casabal , phen , POP , climate , xnplimit , xkNlimiting , xklitter , & xksoil , xkleaf , xkleafcold , xkleafdry , & cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd , & nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd , & pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd ) ! 13C if ( cable_user % c13o2 ) then avg_c13leaf2met (:) = avg_c13leaf2met (:) + & cleaf2met (:) * isoratio ( c13o2pools % cplant (:, leaf ), casasave (:, leaf ), 0.0_dp , tiny ( 1.0_dp )) ! 1.0_dp avg_c13leaf2str (:) = avg_c13leaf2str (:) + & cleaf2str (:) * isoratio ( c13o2pools % cplant (:, leaf ), casasave (:, leaf ), 0.0_dp , tiny ( 1.0_dp )) avg_c13root2met (:) = avg_c13root2met (:) + & croot2met (:) * isoratio ( c13o2pools % cplant (:, froot ), casasave (:, froot ), 0.0_dp , tiny ( 1.0_dp )) avg_c13root2str (:) = avg_c13root2str (:) + & croot2str (:) * isoratio ( c13o2pools % cplant (:, froot ), casasave (:, froot ), 0.0_dp , tiny ( 1.0_dp )) avg_c13wood2cwd (:) = avg_c13wood2cwd (:) + & cwood2cwd (:) * isoratio ( c13o2pools % cplant (:, wood ), casasave (:, wood ), 0.0_dp , tiny ( 1.0_dp )) call c13o2_update_pools ( casasave , casaflux , c13o2flux , c13o2pools ) call c13o2_sanity_pools ( casapool , casaflux , c13o2pools ) endif if ( cable_user % CALL_BLAZE ) then CALL BLAZE_ACCOUNTING ( BLAZE , climate , ktau , dels , YYYY , idoy ) call blaze_driver ( blaze % ncells , blaze , simfire , casapool , casaflux , & casamet , climate , rshootfrac , idoy , YYYY , 1 , POP , veg ) endif if ( cable_user % CALL_POP . and . ( POP % np . gt . 0 )) then ! CALL_POP if ( cable_user % CALL_POP ) then ! accumulate input variables for POP ! accumulate annual variables for use in POP if ( mod ( ktau / ktauday , LOY ) == 1 ) then ! (assumes 70% of wood NPP is allocated above ground) casaflux % stemnpp = casaflux % cnpp * casaflux % fracCalloc (:, 2 ) * 0.7_dp casabal % LAImax = casamet % glai casabal % Cleafmean = casapool % cplant (:, 1 ) / real ( LOY , dp ) / 100 0._dp casabal % Crootmean = casapool % cplant (:, 3 ) / real ( LOY , dp ) / 100 0._dp else casaflux % stemnpp = casaflux % stemnpp + casaflux % cnpp * casaflux % fracCalloc (:, 2 ) * 0.7_dp casabal % LAImax = max ( casamet % glai , casabal % LAImax ) casabal % Cleafmean = casabal % Cleafmean + casapool % cplant (:, 1 ) / real ( LOY , dp ) / 100 0.0_dp casabal % Crootmean = casabal % Crootmean + casapool % cplant (:, 3 ) / real ( LOY , dp ) / 100 0.0_dp endif else casaflux % stemnpp = 0.0_dp endif ! CALL_POP !CALL WRITE_CASA_OUTPUT_NC (veg, casamet, casapool, casabal, casaflux, & !            .true., ctime, .FALSE.  ) !            ctime = ctime+1 if ( idoy == mdyear ) then ! end of year call POPdriver ( casaflux , casabal , veg , POP ) !MC - ToDo - update 13CO2 harvest ! CALL POP_IO( pop, casamet, nyear, 'WRITE_EPI', & !     (.FALSE.)) ! CALL WRITE_CASA_OUTPUT_NC (veg, casamet, casapool, casabal, casaflux, & !     .true., ctime, .FALSE.  ) ! ctime = ctime+1 endif ! end of year else ! (cable_user%CALL_POP .and. (POP%np.gt.0)) ! if (idoy==mdyear) then ! end of year !    ! call write_casa_output_nc(veg, casamet, casapool, casabal, casaflux, .true., ctime, .false.) !    ctime = ctime + 1 ! endif  ! end of year casaflux % stemnpp = 0.0_dp endif ! (cable_user%CALL_POP .and. (POP%np.gt.0)) ! WHERE(xkNlimiting .eq. 0)  !Chris Lu 4/June/2012 !    xkNlimiting = 0.001 ! END WHERE ! nptx = 8173 avg_cleaf2met = avg_cleaf2met + cleaf2met avg_cleaf2str = avg_cleaf2str + cleaf2str avg_croot2met = avg_croot2met + croot2met avg_croot2str = avg_croot2str + croot2str avg_cwood2cwd = avg_cwood2cwd + cwood2cwd avg_nleaf2met = avg_nleaf2met + nleaf2met avg_nleaf2str = avg_nleaf2str + nleaf2str avg_nroot2met = avg_nroot2met + nroot2met avg_nroot2str = avg_nroot2str + nroot2str avg_nwood2cwd = avg_nwood2cwd + nwood2cwd avg_pleaf2met = avg_pleaf2met + pleaf2met avg_pleaf2str = avg_pleaf2str + pleaf2str avg_proot2met = avg_proot2met + proot2met avg_proot2str = avg_proot2str + proot2str avg_pwood2cwd = avg_pwood2cwd + pwood2cwd avg_cgpp = avg_cgpp + casaflux % cgpp avg_cnpp = avg_cnpp + casaflux % cnpp avg_nuptake = avg_nuptake + casaflux % Nminuptake avg_puptake = avg_puptake + casaflux % Plabuptake avg_xnplimit = avg_xnplimit + xnplimit avg_xkNlimiting = avg_xkNlimiting + xkNlimiting avg_xklitter = avg_xklitter + xklitter avg_xksoil = avg_xksoil + xksoil avg_nsoilmin = avg_nsoilmin + casapool % nsoilmin avg_psoillab = avg_psoillab + casapool % psoillab avg_psoilsorb = avg_psoilsorb + casapool % psoilsorb avg_psoilocc = avg_psoilocc + casapool % psoilocc avg_rationcsoilmic = avg_rationcsoilmic + casapool % ratioNCsoilnew (:, mic ) avg_rationcsoilslow = avg_rationcsoilslow + casapool % ratioNCsoilnew (:, slow ) avg_rationcsoilpass = avg_rationcsoilpass + casapool % ratioNCsoilnew (:, pass ) enddo ! idoy enddo ! nyear !!CLN    CLOSE(91) ! average rday = 1.0_dp / real ( nday * myearspin , dp ) avg_cleaf2met = avg_cleaf2met * rday avg_cleaf2str = avg_cleaf2str * rday avg_croot2met = avg_croot2met * rday avg_croot2str = avg_croot2str * rday avg_cwood2cwd = avg_cwood2cwd * rday avg_nleaf2met = avg_nleaf2met * rday avg_nleaf2str = avg_nleaf2str * rday avg_nroot2met = avg_nroot2met * rday avg_nroot2str = avg_nroot2str * rday avg_nwood2cwd = avg_nwood2cwd * rday avg_pleaf2met = avg_pleaf2met * rday avg_pleaf2str = avg_pleaf2str * rday avg_proot2met = avg_proot2met * rday avg_proot2str = avg_proot2str * rday avg_pwood2cwd = avg_pwood2cwd * rday avg_cgpp = avg_cgpp * rday avg_cnpp = avg_cnpp * rday avg_nuptake = avg_nuptake * rday avg_puptake = avg_puptake * rday avg_xnplimit = avg_xnplimit * rday avg_xkNlimiting = avg_xkNlimiting * rday avg_xklitter = avg_xklitter * rday avg_xksoil = avg_xksoil * rday avg_nsoilmin = avg_nsoilmin * rday avg_psoillab = avg_psoillab * rday avg_psoilsorb = avg_psoilsorb * rday avg_psoilocc = avg_psoilocc * rday avg_rationcsoilmic = avg_rationcsoilmic * rday avg_rationcsoilslow = avg_rationcsoilslow * rday avg_rationcsoilpass = avg_rationcsoilpass * rday ! 13C if ( cable_user % c13o2 ) then avg_c13leaf2met = avg_c13leaf2met * rday avg_c13leaf2str = avg_c13leaf2str * rday avg_c13root2met = avg_c13root2met * rday avg_c13root2str = avg_c13root2str * rday avg_c13wood2cwd = avg_c13wood2cwd * rday endif !write(600,*) 'pmet pre-analytic: ' ,  casapool%plitter(1,metb) !write(600,*) 'nmet pre-analytic: ' ,  casapool%nlitter(1,metb) !write(600,*) 'csoil3 pre-analytic: ', casapool%csoil(3,:) !write(600,*) 'csoil1 pre-analytic: ', casapool%csoil(1,:) call analyticpool ( veg , soil , casabiome , casapool , & casaflux , casamet , casabal , & avg_cleaf2met , avg_cleaf2str , avg_croot2met , avg_croot2str , avg_cwood2cwd , & avg_nleaf2met , avg_nleaf2str , avg_nroot2met , avg_nroot2str , avg_nwood2cwd , & avg_pleaf2met , avg_pleaf2str , avg_proot2met , avg_proot2str , avg_pwood2cwd , & avg_cnpp , & avg_xkNlimiting , avg_xklitter , avg_xksoil , & avg_ratioNCsoilmic , avg_ratioNCsoilslow , avg_ratioNCsoilpass , & avg_nsoilmin , avg_psoillab , avg_psoilsorb , avg_psoilocc , & avg_c13leaf2met , avg_c13leaf2str , avg_c13root2met , & avg_c13root2str , avg_c13wood2cwd , c13o2pools ) if ( cable_user % c13o2 ) call c13o2_sanity_pools ( casapool , casaflux , c13o2pools ) !write(600,*) 'csoil3 post-analytic: ', casapool%csoil(3,:) !write(600,*) 'csoil1 post-analytic: ', casapool%csoil(1,:) !write(600,*) 'pmet post analytic: ', avg_pleaf2met, avg_proot2met, casaflux%klitter(1,metb), casapool%plitter(1,metb) ! write(600,*) 'nmet post analytic: ', avg_nleaf2met, avg_nroot2met, casaflux%klitter(1,metb), casapool%nlitter(1,metb) !$  call totcnppools(1,veg,casamet,casapool,bmcplant,bmnplant,bmpplant,bmclitter,bmnlitter,bmplitter, & !$       bmcsoil,bmnsoil,bmpsoil,bmnsoilmin,bmpsoillab,bmpsoilsorb,bmpsoilocc,bmarea) nloop1 = max ( 1 , mloop - 3 ) DO nloop = 1 , mloop !!CLN  OPEN(91,file=fcnpspin) !!CLN  read(91,*) ctime = 0 DO nyear = 1 , myearspin !!CLN      read(91,901) ncfile !write(*,*) 'spincasa CYEAR', CYEAR, ncfile WRITE ( CYEAR , FMT = \"(I4)\" ) CABLE_USER % CASA_SPIN_STARTYEAR + nyear - 1 ncfile = TRIM ( casafile % c2cdumppath ) // 'c2c_' // CYEAR // '_dump.nc' YYYY = CABLE_USER % CASA_SPIN_STARTYEAR + nyear - 1 call read_casa_dump ( ncfile , casamet , casaflux , phen , climate , c13o2flux , ktau , kend , . TRUE .) DO idoy = 1 , mdyear ctime = ctime + 1 ktauy = idoy * ktauday ktau = ( idoy - 1 ) * ktauday + 1 casamet % tairk (:) = casamet % Tairkspin (:, idoy ) casamet % tsoil (:, 1 ) = casamet % Tsoilspin_1 (:, idoy ) casamet % tsoil (:, 2 ) = casamet % Tsoilspin_2 (:, idoy ) casamet % tsoil (:, 3 ) = casamet % Tsoilspin_3 (:, idoy ) casamet % tsoil (:, 4 ) = casamet % Tsoilspin_4 (:, idoy ) casamet % tsoil (:, 5 ) = casamet % Tsoilspin_5 (:, idoy ) casamet % tsoil (:, 6 ) = casamet % Tsoilspin_6 (:, idoy ) casamet % moist (:, 1 ) = casamet % moistspin_1 (:, idoy ) casamet % moist (:, 2 ) = casamet % moistspin_2 (:, idoy ) casamet % moist (:, 3 ) = casamet % moistspin_3 (:, idoy ) casamet % moist (:, 4 ) = casamet % moistspin_4 (:, idoy ) casamet % moist (:, 5 ) = casamet % moistspin_5 (:, idoy ) casamet % moist (:, 6 ) = casamet % moistspin_6 (:, idoy ) casaflux % cgpp (:) = casamet % cgppspin (:, idoy ) casaflux % crmplant (:, 1 ) = casamet % crmplantspin_1 (:, idoy ) casaflux % crmplant (:, 2 ) = casamet % crmplantspin_2 (:, idoy ) casaflux % crmplant (:, 3 ) = casamet % crmplantspin_3 (:, idoy ) phen % phase (:) = phen % phasespin (:, idoy ) phen % doyphase (:, 1 ) = phen % doyphasespin_1 (:, idoy ) phen % doyphase (:, 2 ) = phen % doyphasespin_2 (:, idoy ) phen % doyphase (:, 3 ) = phen % doyphasespin_3 (:, idoy ) phen % doyphase (:, 4 ) = phen % doyphasespin_4 (:, idoy ) climate % qtemp_max_last_year (:) = real ( casamet % mtempspin (:, idoy )) climate % frec (:) = real ( casamet % frecspin (:, idoy )) ! 13C if ( cable_user % c13o2 ) then c13o2flux % cAn12 (:) = casamet % cAn12spin (:, idoy ) c13o2flux % cAn (:) = casamet % cAn13spin (:, idoy ) endif ! BLAZE if ( cable_user % call_blaze ) then climate % dprecip (:) = real ( casamet % dprecip_spin (:, idoy )) climate % aprecip_av20 (:) = real ( casamet % aprecip_av20_spin (:, idoy )) climate % du10_max (:) = real ( casamet % du10_max_spin (:, idoy )) climate % drhum (:) = real ( casamet % drhum_spin (:, idoy )) climate % dtemp_max (:) = real ( casamet % dtemp_max_spin (:, idoy )) climate % dtemp_min (:) = real ( casamet % dtemp_max_spin (:, idoy )) climate % KBDI (:) = real ( casamet % KBDI_spin (:, idoy )) climate % D_MacArthur (:) = real ( casamet % D_MacArthur_spin (:, idoy )) climate % FFDI (:) = real ( casamet % FFDI_spin (:, idoy )) climate % DSLR (:) = casamet % DSLR_spin (:, idoy ) climate % last_precip (:) = real ( casamet % last_precip_spin (:, idoy )) endif ! if (nloop==1 .and. nyear==1) then !    write(6002, \"(200e16.6)\") casamet%tairk(3), casamet%tsoil(3,:),  casamet%moist(3,:), & !         casaflux%cgpp(3) ,casaflux%crmplant(3,1), real(phen%phase(3)) ,  & !         real(phen%doyphase(3,:)), climate%qtemp_max_last_year(3) ! endif ! 13C if ( cable_user % c13o2 ) call c13o2_save_casapool ( casapool , casasave ) call biogeochem ( idoy , LALLOC , veg , soil , casabiome , casapool , casaflux , & casamet , casabal , phen , POP , climate , xnplimit , xkNlimiting , xklitter , xksoil , xkleaf ,& xkleafcold , xkleafdry ,& cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd , & nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd , & pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd ) ! 13C if ( cable_user % c13o2 ) then call c13o2_update_pools ( casasave , casaflux , c13o2flux , c13o2pools ) call c13o2_sanity_pools ( casapool , casaflux , c13o2pools ) endif if ( cable_user % CALL_BLAZE ) then CALL BLAZE_ACCOUNTING ( BLAZE , climate , ktau , dels , YYYY , idoy ) call blaze_driver ( blaze % ncells , blaze , simfire , casapool , casaflux , & casamet , climate , rshootfrac , idoy , YYYY , 1 , POP , veg ) if ( nloop == mloop ) then if ( nyear == myearspin . and . idoy == mdyear ) then call write_blaze_output_nc ( BLAZE , . true .) else call write_blaze_output_nc ( BLAZE , . false .) endif endif endif !MC - Should this be nyear==myearspin instead of nyear==1? if ( nloop == mloop . and . nyear == myearspin ) then ! CALL WRITE_CASA_OUTPUT_NC( veg, casamet, casapool, casabal, casaflux, & !      .true., ctime,  idoy.eq.mdyear ) CALL WRITE_CASA_OUTPUT_NC ( veg , casamet , casapool , casabal , casaflux , & . true ., ctime , idoy . eq . mdyear ) ! 13C if ( cable_user % c13o2 ) then if ( idoy == 1 ) then call c13o2_create_output ( casamet , c13o2pools , c13o2_file_id , c13o2_vars , c13o2_var_ids ) endif call c13o2_write_output ( c13o2_file_id , c13o2_vars , c13o2_var_ids , ctime , c13o2pools ) end if endif ! 13C if ( cable_user % c13o2 ) then if ( ( nloop . eq . mloop ) . and . ( nyear . eq . myearspin ) . and . ( idoy . eq . mdyear ) ) & call c13o2_close_output ( c13o2_file_id ) end if IF ( cable_user % CALL_POP . and . POP % np . gt . 0 ) THEN ! CALL_POP IF ( cable_user % CALL_POP ) THEN ! accumulate input variables for POP ! accumulate annual variables for use in POP IF ( MOD ( ktau / ktauday , LOY ) == 1 ) THEN ! (assumes 70% of wood NPP is allocated above ground) casaflux % stemnpp = casaflux % cnpp * casaflux % fracCalloc (:, 2 ) * 0.7_dp casabal % LAImax = casamet % glai casabal % Cleafmean = casapool % cplant (:, 1 ) / real ( LOY , dp ) / 100 0.0_dp casabal % Crootmean = casapool % cplant (:, 3 ) / real ( LOY , dp ) / 100 0.0_dp ELSE casaflux % stemnpp = casaflux % stemnpp + casaflux % cnpp * casaflux % fracCalloc (:, 2 ) * 0.7_dp casabal % LAImax = max ( casamet % glai , casabal % LAImax ) casabal % Cleafmean = casabal % Cleafmean + casapool % cplant (:, 1 ) / real ( LOY , dp ) / 100 0.0_dp casabal % Crootmean = casabal % Crootmean + casapool % cplant (:, 3 ) / real ( LOY , dp ) / 100 0.0_dp ENDIF ELSE casaflux % stemnpp = 0.0_dp ENDIF ! CALL_POP IF ( idoy == mdyear ) THEN ! end of year !MC - ToDo - update 13CO2 harvest CALL POPdriver ( casaflux , casabal , veg , POP ) ! CALL POP_IO( pop, casamet, NYEAR, 'WRITE_EPI', & !     (nloop.eq.mloop .and. nyear.eq.myearspin) ) ! CALL WRITE_CASA_OUTPUT_NC(veg, casamet, casapool, casabal, casaflux, & !     .TRUE., ctime, & !     (nloop.eq.mloop .and. nyear.eq.myearspin.and.idoy.eq.mdyear)) ! ctime = ctime + 1 ENDIF ! end of year ELSE ! IF(idoy==mdyear) THEN ! end of year !     CALL WRITE_CASA_OUTPUT_NC (veg, casamet, casapool, casabal, casaflux, & !         .TRUE., ctime, & !         (nloop.eq.mloop .and. nyear.eq.myearspin.and.idoy.eq.mdyear)  ) !     ctime = ctime+1 ! ENDIF ! end of year casaflux % stemnpp = 0.0_dp ENDIF ! CALL_POP ENDDO ! end of idoy ENDDO ! end of nyear ENDDO ! end of nloop CALL casa_fluxout ( CABLE_USER % CASA_SPIN_STARTYEAR + myearspin - 1 , veg , soil , casabal , casamet ) END SUBROUTINE spincasacnp end module cable_spincasacnp","tags":"","loc":"sourcefile/spincasacnp.f90.html"},{"title":"casa_variable.F90 – POP","text":"Files dependent on this one sourcefile~~casa_variable.f90~~AfferentGraph sourcefile~casa_variable.f90 casa_variable.F90 sourcefile~cable_phenology.f90 cable_phenology.F90 sourcefile~cable_phenology.f90->sourcefile~casa_variable.f90 sourcefile~casa_cable.f90 casa_cable.F90 sourcefile~casa_cable.f90->sourcefile~casa_variable.f90 sourcefile~casa_cable.f90->sourcefile~cable_phenology.f90 sourcefile~casa_cnp.f90 casa_cnp.F90 sourcefile~casa_cable.f90->sourcefile~casa_cnp.f90 sourcefile~casa_inout.f90 casa_inout.F90 sourcefile~casa_cable.f90->sourcefile~casa_inout.f90 sourcefile~casa_cnp.f90->sourcefile~casa_variable.f90 sourcefile~casa_inout.f90->sourcefile~casa_variable.f90 sourcefile~casa_inout.f90->sourcefile~casa_cnp.f90 sourcefile~casaonly_luc.f90 CASAONLY_LUC.F90 sourcefile~casaonly_luc.f90->sourcefile~casa_variable.f90 sourcefile~casaonly_luc.f90->sourcefile~casa_cable.f90 sourcefile~casaonly_luc.f90->sourcefile~casa_inout.f90 sourcefile~popluc.f90 POPLUC.F90 sourcefile~casaonly_luc.f90->sourcefile~popluc.f90 sourcefile~pop_io.f90 pop_io.F90 sourcefile~pop_io.f90->sourcefile~casa_variable.f90 sourcefile~popluc.f90->sourcefile~casa_variable.f90 sourcefile~spincasacnp.f90 spincasacnp.F90 sourcefile~spincasacnp.f90->sourcefile~casa_variable.f90 sourcefile~spincasacnp.f90->sourcefile~casa_cable.f90 sourcefile~spincasacnp.f90->sourcefile~casa_inout.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules casadimension casaparm casavariable phenvariable Source Code casa_variable.F90 Source Code ! ============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: defines/allocates variables for CASA-CNP ! ! Contact: Yingping.Wang@csiro.au ! ! History: Developed for offline CASA-CNP, code revision likely to better !          suit ACCESS and to merge more consistently with CABLE code ! ! ! ============================================================================== ! casa_variable.f90 ! ! the following modules are used when \"casacnp\" is coupled to \"cable\" !   casadimension !   casaparm !   casavariable with subroutine alloc_casa_var !   phenvariable with subroutine alloc_phenvariable module casadimension use cable_def_types_mod , only : r_2 implicit none public integer , parameter :: mdyear = 365 ! days per year integer , parameter :: mdmonth = 30 ! days per month integer , parameter :: mdweek = 7 ! days per week integer , parameter :: mmyear = 12 ! month per year integer , parameter :: mt = 36500 ! integration time step integer , parameter :: mpftmax = 2 ! max. PFT/cell integer , parameter :: mplant = 3 ! plant pools integer , parameter :: mlitter = 3 ! litter pools integer , parameter :: msoil = 3 ! soil pools integer , parameter :: mso = 12 ! soil order number integer , parameter :: mhwp = 1 ! harvested wood pools integer , parameter :: mclear = 1 ! forest clearing pools integer , parameter :: mheights = 10 ! height clas ! BP put icycle into namelist file integer :: icycle ! INTEGER, PARAMETER :: icycle=3    ! =1 for C, =2 for C+N; =3 for C+N+P integer , parameter :: mstart = 1 ! starting time step integer , parameter :: mphase = 4 ! phen. phases real ( r_2 ), parameter :: deltcasa = 1.0_r_2 / 36 5.0_r_2 ! fraction 1 day of year real ( r_2 ), parameter :: deltpool = 1.0_r_2 ! pool delt(1day) end module casadimension ! ------------------------------------------------------------------ module casaparm use cable_def_types_mod , only : r_2 ! use casadimension, only: deltcasa implicit none public integer , parameter :: initcasa = 1 ! =0 spin; 1 restart file integer , parameter :: iceland = 17 !=13 for casa vegtype =15 for IGBP vegtype integer , parameter :: cropland = 9 ! 12 and 14 for IGBP vegtype integer , parameter :: croplnd2 = 10 ! ditto integer , parameter :: forest = 3 integer , parameter :: shrub = 2 integer , parameter :: grass = 1 integer , parameter :: icewater = 0 integer , parameter :: LEAF = 1 integer , parameter :: WOOD = 2 integer , parameter :: FROOT = 3 ! integer, parameter :: LABILE = 4 integer , parameter :: METB = 1 integer , parameter :: STR = 2 integer , parameter :: CWD = 3 integer , parameter :: MIC = 1 integer , parameter :: SLOW = 2 integer , parameter :: pass = 3 integer , parameter :: PLAB = 1 integer , parameter :: PSORB = 2 integer , parameter :: POCC = 3 !! vh_js !! LALLOC moved to bgcdriver to allow for value to be switchable ! integer, parameter :: LALLOC = 0  ! 0 constant; 1 variable real ( r_2 ), parameter :: z30 = 0.3_r_2 real ( r_2 ), parameter :: R0 = 0.3_r_2 real ( r_2 ), parameter :: S0 = 0.3_r_2 real ( r_2 ), parameter :: fixed_stem = 1.0_r_2 / 3.0_r_2 real ( r_2 ), parameter :: Q10alloc = 2.0_r_2 real ( r_2 ), parameter :: ratioNCstrfix = 1.0_r_2 / 15 0.0_r_2 real ( r_2 ), parameter :: ratioNPstrfix = 2 5.0_r_2 real ( r_2 ), parameter :: fracCbiomass = 0.50_r_2 real ( r_2 ), parameter :: tsoilrefc = 2 5.0_r_2 real ( r_2 ), parameter :: tkzeroc = 27 3.15_r_2 real ( r_2 ), parameter :: frootparma = 0.3192_r_2 real ( r_2 ), parameter :: frootparmb =- 0.0485_r_2 real ( r_2 ), parameter :: frootparmc = 0.1755_r_2 real ( r_2 ), parameter :: xweightalloc = 0.2_r_2 !  real(r_2), parameter :: xkplab  = 0.5_r_2 * deltcasa !  real(r_2), parameter :: xkpsorb = 0.01_r_2 * deltcasa !  real(r_2), parameter :: xkpocc  = 0.01_r_2 * deltcasa end module casaparm ! ------------------------------------------------------------------ module casavariable use cable_def_types_mod , only : r_2 implicit none private ! types public :: casa_balance public :: casa_biome public :: casa_flux public :: casa_met public :: casa_pool public :: casafiles_type ! routines on types public :: alloc_casa_var public :: print_casa_var public :: read_netcdf_casa_var public :: write_netcdf_casa_var public :: zero_casa_var ! routines on sum variables public :: alloc_sum_casa public :: update_sum_casa public :: zero_sum_casa ! public variables public :: casa_timeunits public :: casafile ! number of variables in type definitions ! used in write_netcdf and in MPI code integer , parameter , public :: ncasa_biome = 53 integer , parameter , public :: ncasa_pool = 42 integer , parameter , public :: ncasa_flux = 91 integer , parameter , public :: ncasa_met = 47 integer , parameter , public :: ncasa_bal = 47 ! private section character ( len = 200 ) :: casa_timeunits type casa_biome integer , dimension (:), pointer :: & ivt2 => null () real ( r_2 ), dimension (:), pointer :: & xkleafcoldmax => null (), & xkleafcoldexp => null (), & xkleafdrymax => null (), & xkleafdryexp => null (), & glaimax => null (), & glaimin => null (), & sla => null (), & ratiofrootleaf => null (), & kroot => null (), & krootlen => null (), & rootdepth => null (), & kuptake => null (), & kminN => null (), & kuplabP => null (), & kclabrate => null (), & xnpmax => null (), & q10soil => null (), & xkoptlitter => null (), & xkoptsoil => null (), & xkplab => null (), & xkpsorb => null (), & xkpocc => null (), & prodptase => null (), & costnpup => null (), & maxfinelitter => null (), & maxcwd => null (), & nintercept => null (), & nslope => null (), & la_to_sa => null (), & vcmax_scalar => null (), & disturbance_interval => null (), & DAMM_EnzPool => null (), & DAMM_KMO2 => null (), & DAMM_KMcp => null (), & DAMM_Ea => null (), & DAMM_alpha => null () real ( r_2 ), dimension (:,:), pointer :: & plantrate => null (), & rmplant => null (), & fracnpptoP => null (), & fraclignin => null (), & fraclabile => null (), & ratioNCplantmin => null (), & ratioNCplantmax => null (), & ratioNPplantmin => null (), & ratioNPplantmax => null (), & fracLigninplant => null (), & ftransNPtoL => null (), & ftransPPtoL => null (), & litterrate => null (), & ratioPcplantmin => null (), & ratioPcplantmax => null () real ( r_2 ), dimension (:,:), pointer :: & soilrate => null () end type casa_biome type casa_pool real ( r_2 ), dimension (:), pointer :: & Clabile => null (), & dClabiledt => null (), & Ctot => null (), & !! vh_js !! Ctot_0 => null () real ( r_2 ), dimension (:,:), pointer :: & Cplant => null (), & Nplant => null (), & Pplant => null (), & dCplantdt => null (), & dNplantdt => null (), & dPplantdt => null (), & ratioNCplant => null (), & ratioNPplant => null () real ( r_2 ), dimension (:), pointer :: & Nsoilmin => null (), & Psoillab => null (), & Psoilsorb => null (), & Psoilocc => null (), & dNsoilmindt => null (), & dPsoillabdt => null (), & dPsoilsorbdt => null (), & dPsoiloccdt => null () real ( r_2 ), dimension (:,:), pointer :: & Clitter => null (), & Nlitter => null (), & Plitter => null (), & dClitterdt => null (), & dNlitterdt => null (), & dPlitterdt => null (), & ratioNClitter => null (), & ratioNPlitter => null () real ( r_2 ), dimension (:,:), pointer :: & Csoil => null (), & Nsoil => null (), & Psoil => null (), & dCsoildt => null (), & dNsoildt => null (), & dPsoildt => null (), & ratioNCsoil => null (), & ratioNCsoilnew => null (), & ratioNPsoil => null (), & ratioNCsoilmin => null (), & ratioNCsoilmax => null (), & ratioPCsoil => null (), & ratioPCplant => null (), & ratioPClitter => null () end type casa_pool type casa_flux real ( r_2 ), dimension (:), pointer :: & Cgpp => null (), & Cnpp => null (), & Crp => null (), & Crgplant => null (), & Nminfix => null (), & Nminuptake => null (), & Plabuptake => null (), & Clabloss => null (), & fracClabile => null (), & !! vh_js !! the 3 variables below are needed for POP coupling to CASA stemnpp => null (), & frac_sapwood => null (), & sapwood_area => null (), & Charvest => null (), & ! leaf biomass removed due to crop or pasture management Nharvest => null (), & ! leaf N removed due to crop or pasture management Pharvest => null (), & ! leaf P removed due to crop or pasture management fHarvest => null (), & ! fraction leaf biomass removed due to crop or pasture management fcrop => null () ! fraction of 'grass' that is crop real ( r_2 ), dimension (:,:), pointer :: & fracCalloc => null (), & fracNalloc => null (), & fracPalloc => null (), & Crmplant => null (), & kplant => null (), & !! vh_js !! additional diagnostic Cplant_turnover => null () real ( r_2 ), dimension (:,:,:), pointer :: & fromPtoL => null () real ( r_2 ), dimension (:), pointer :: & Cnep => null (), & Crsoil => null (), & Nmindep => null (), & Nminloss => null (), & Nminleach => null (), & Nupland => null (), & Nlittermin => null (), & Nsmin => null (), & Nsimm => null (), & Nsnet => null (), & fNminloss => null (), & fNminleach => null (), & Pdep => null (), & Pwea => null (), & Pleach => null (), & Ploss => null (), & Pupland => null (), & Plittermin => null (), & Psmin => null (), & Psimm => null (), & Psnet => null (), & fPleach => null (), & kplab => null (), & kpsorb => null (), & kpocc => null (), & kmlabp => null (), & Psorbmax => null (), & !! additional diagnostics for partitioning biomass turnover Cplant_turnover_disturbance => null (), & Cplant_turnover_crowding => null (), & Cplant_turnover_resource_limitation => null () real ( r_2 ), dimension (:,:), pointer :: klitter => null () real ( r_2 ), dimension (:,:), pointer :: ksoil => null () real ( r_2 ), dimension (:,:,:), pointer :: fromLtoS => null () real ( r_2 ), dimension (:,:,:), pointer :: fromStoS => null () real ( r_2 ), dimension (:,:), pointer :: fromLtoCO2 => null () real ( r_2 ), dimension (:,:), pointer :: fromStoCO2 => null () real ( r_2 ), dimension (:,:), pointer :: FluxCtolitter => null () real ( r_2 ), dimension (:,:), pointer :: FluxNtolitter => null () real ( r_2 ), dimension (:,:), pointer :: FluxPtolitter => null () real ( r_2 ), dimension (:,:), pointer :: FluxCtosoil => null () real ( r_2 ), dimension (:,:), pointer :: FluxNtosoil => null () real ( r_2 ), dimension (:,:), pointer :: FluxPtosoil => null () real ( r_2 ), dimension (:), pointer :: FluxCtoCO2 => null () real ( r_2 ), dimension (:), pointer :: FluxCtohwp => null () real ( r_2 ), dimension (:), pointer :: FluxNtohwp => null () real ( r_2 ), dimension (:), pointer :: FluxPtohwp => null () real ( r_2 ), dimension (:), pointer :: FluxCtoclear => null () real ( r_2 ), dimension (:), pointer :: FluxNtoclear => null () real ( r_2 ), dimension (:), pointer :: FluxPtoclear => null () real ( r_2 ), dimension (:), pointer :: CtransferLUC => null () !CVH variables inherited from BLAZE real ( r_2 ), dimension (:,:,:), pointer :: fromPtoL_fire => null () real ( r_2 ), dimension (:,:), pointer :: klitter_fire => null () ! sum of fire turnover and non-fire turnover (litter) real ( r_2 ), dimension (:,:), pointer :: klitter_tot => null () real ( r_2 ), dimension (:,:), pointer :: kplant_fire => null () ! sum of fire turnover and non-fire turnover (plants) real ( r_2 ), dimension (:,:), pointer :: kplant_tot => null () !CVH diagnostic: CO2 emissions from fire real ( r_2 ), dimension (:), pointer :: fluxCtoCO2_plant_fire => null () real ( r_2 ), dimension (:), pointer :: fluxCtoCO2_litter_fire => null () ! contribution to fire emissions from individual plant pools real ( r_2 ), dimension (:,:), pointer :: fluxfromPtoCO2_fire => null () ! contribution to fire emissions from individual litter pools real ( r_2 ), dimension (:,:), pointer :: fluxfromLtoCO2_fire => null () real ( r_2 ), dimension (:), pointer :: fluxNtoAtm_fire => null () ! real(r_2), dimension(:,:,:),pointer  :: fire_mortality_vs_height => null() ! Diagnostic fluxes for use in 13C real ( r_2 ), dimension (:,:,:), pointer :: FluxFromPtoL => null () real ( r_2 ), dimension (:,:,:), pointer :: FluxFromLtoS => null () real ( r_2 ), dimension (:,:,:), pointer :: FluxFromStoS => null () real ( r_2 ), dimension (:,:), pointer :: FluxFromPtoCO2 => null () real ( r_2 ), dimension (:,:), pointer :: FluxFromLtoCO2 => null () real ( r_2 ), dimension (:,:), pointer :: FluxFromStoCO2 => null () real ( r_2 ), dimension (:), pointer :: FluxFromPtoHarvest => null () end type casa_flux type casa_met real ( r_2 ), dimension (:), pointer :: & glai => null (), & Tairk => null (), & precip => null (), & tsoilavg => null (), & moistavg => null (), & btran => null () integer , dimension (:), pointer :: & lnonwood => null () real ( r_2 ), dimension (:,:), pointer :: & Tsoil => null (), & moist => null () integer , dimension (:), pointer :: & iveg2 => null (), & ijgcm => null (), & isorder => null () real ( r_2 ), dimension (:), pointer :: & lat => null (), & lon => null (), & areacell => null () ! added yp wang 5/nov/2012 real ( r_2 ), dimension (:,:), pointer :: & Tairkspin => null (), & cgppspin => null (), & crmplantspin_1 => null (), & crmplantspin_2 => null (), & crmplantspin_3 => null (), & Tsoilspin_1 => null (), & Tsoilspin_2 => null (), & Tsoilspin_3 => null (), & Tsoilspin_4 => null (), & Tsoilspin_5 => null (), & Tsoilspin_6 => null (), & moistspin_1 => null (), & moistspin_2 => null (), & moistspin_3 => null (), & moistspin_4 => null (), & moistspin_5 => null (), & moistspin_6 => null (), & mtempspin => null (), & frecspin => null () ! 13C real ( r_2 ), dimension (:,:), pointer :: & ! daily cumulated total 12CO2 net assimilation in [g(C)/m2] cAn12spin => null () real ( r_2 ), dimension (:,:), pointer :: & ! daily cumulated total 13CO2 net assimilation in [g(13C)/m2] cAn13spin => null () ! BLAZE real ( r_2 ), dimension (:,:), pointer :: & dprecip_spin => null (), & aprecip_av20_spin => null (), & du10_max_spin => null (), & drhum_spin => null (), & dtemp_max_spin => null (), & dtemp_min_spin => null (), & KBDI_spin => null (), & D_MacArthur_spin => null (), & FFDI_spin => null (), & last_precip_spin => null () integer , dimension (:,:), pointer :: & DSLR_spin => null () end type casa_met type casa_balance real ( r_2 ), dimension (:), pointer :: & FCgppyear => null (), & FCnppyear => null (), & FCrmleafyear => null (), & FCrmwoodyear => null (), & FCrmrootyear => null (), & FCrgrowyear => null (), & FCrpyear => null (), & FCrsyear => null (), & FCneeyear => null (), & dCdtyear => null (), & LAImax => null (), & Cleafmean => null (), & Crootmean => null (), & FNdepyear => null (), & FNfixyear => null (), & FNsnetyear => null (), & FNupyear => null (), & FNleachyear => null (), & FNlossyear => null (), & FPweayear => null (), & FPdustyear => null (), & FPsnetyear => null (), & FPupyear => null (), & FPleachyear => null (), & FPlossyear => null () real ( r_2 ), dimension (:,:), pointer :: & glaimon => null (), & glaimonx => null () real ( r_2 ), dimension (:,:), pointer :: & cplantlast => null (), & nplantlast => null (), & pplantlast => null () real ( r_2 ), dimension (:,:), pointer :: & clitterlast => null (), & nlitterlast => null (), & plitterlast => null () real ( r_2 ), dimension (:,:), pointer :: & csoillast => null (), & nsoillast => null (), & psoillast => null () real ( r_2 ), dimension (:), pointer :: & nsoilminlast => null (), & psoillablast => null (), & psoilsorblast => null (), & psoilocclast => null (), & cbalance => null (), & nbalance => null (), & pbalance => null (), & sumcbal => null (), & sumnbal => null (), & sumpbal => null () real ( r_2 ), dimension (:), pointer :: & clabilelast => null () end type casa_balance ! The following declarations are removed and have to be passed using ! parameter list for each subroutine (BP apr2010) !  TYPE (casa_biome)              :: casabiome !  TYPE (casa_pool)               :: casapool !  TYPE (casa_flux)               :: casaflux !  TYPE (casa_met)                :: casamet !  TYPE (casa_balance)            :: casabal ! Added filename type for casaCNP (BP apr2010) type casafiles_type character ( LEN = 200 ) :: cnpbiome ! file for biome-specific BGC parameters character ( LEN = 200 ) :: cnppoint ! file for point-specific BGC inputs character ( LEN = 200 ) :: cnpepool ! file for end-of-run pool sizes character ( LEN = 200 ) :: cnpipool = '' ! file for inital pool sizes character ( LEN = 200 ) :: cnpmetin ! met file for spin up character ( LEN = 200 ) :: cnpmetout ! met file for spin up character ( LEN = 200 ) :: ndep ! N deposition input file ! added yp wang character ( LEN = 200 ) :: cnpspin ! input file for spin up character ( LEN = 200 ) :: dump_cnpspin ! name of dump file for spinning casa-cnp character ( LEN = 200 ) :: phen ! leaf phenology datafile character ( LEN = 200 ) :: cnpflux ! modelled mean yearly CNP fluxes logical :: l_ndep ! added vh character ( LEN = 200 ) :: c2cdumppath = '' ! cable2casa dump for casa spinup character ( LEN = 200 ) :: out = '' ! casa output file end type casafiles_type type ( casafiles_type ) :: casafile interface alloc_casa_var module procedure & alloc_casabiome , & alloc_casapool , & alloc_casaflux , & alloc_casamet , & alloc_casabal end interface alloc_casa_var interface zero_casa_var module procedure & zero_casabiome , & zero_casapool , & zero_casaflux , & zero_casamet , & zero_casabal end interface zero_casa_var interface print_casa_var module procedure & print_casabiome , & print_casapool , & print_casaflux , & print_casamet , & print_casabal end interface print_casa_var interface read_netcdf_casa_var module procedure & read_netcdf_casabiome , & read_netcdf_casapool , & read_netcdf_casaflux , & read_netcdf_casamet , & read_netcdf_casabal end interface read_netcdf_casa_var interface write_netcdf_casa_var module procedure & write_netcdf_casabiome , & write_netcdf_casapool , & write_netcdf_casaflux , & write_netcdf_casamet , & write_netcdf_casabal end interface write_netcdf_casa_var contains ! ------------------------------------------------------------------ subroutine alloc_casabiome ( casabiome ) use cable_def_types_mod , only : mvtype use casadimension , only : mplant , mlitter , msoil , mso implicit none type ( casa_biome ), intent ( inout ) :: casabiome allocate ( & casabiome % ivt2 ( mvtype ), & casabiome % xkleafcoldmax ( mvtype ), & casabiome % xkleafcoldexp ( mvtype ), & casabiome % xkleafdrymax ( mvtype ), & casabiome % xkleafdryexp ( mvtype ), & casabiome % glaimax ( mvtype ), & casabiome % glaimin ( mvtype ), & casabiome % sla ( mvtype ), & casabiome % ratiofrootleaf ( mvtype ), & casabiome % kroot ( mvtype ), & casabiome % krootlen ( mvtype ), & casabiome % rootdepth ( mvtype ), & casabiome % kuptake ( mvtype ), & casabiome % kminN ( mvtype ), & casabiome % KuplabP ( mvtype ), & casabiome % kclabrate ( mvtype ), & casabiome % xnpmax ( mvtype ), & casabiome % q10soil ( mvtype ), & casabiome % xkoptlitter ( mvtype ), & casabiome % xkoptsoil ( mvtype ), & casabiome % xkplab ( mso ), & casabiome % xkpsorb ( mso ), & casabiome % xkpocc ( mso ), & casabiome % prodptase ( mvtype ), & casabiome % costnpup ( mvtype ), & casabiome % maxfinelitter ( mvtype ), & casabiome % maxcwd ( mvtype ), & casabiome % nintercept ( mvtype ), & casabiome % nslope ( mvtype ), & casabiome % la_to_sa ( mvtype ), & casabiome % vcmax_scalar ( mvtype ), & casabiome % disturbance_interval ( mvtype ), & casabiome % DAMM_EnzPool ( mvtype ), & casabiome % DAMM_KMO2 ( mvtype ), & casabiome % DAMM_KMcp ( mvtype ), & casabiome % DAMM_Ea ( mvtype ), & casabiome % DAMM_alpha ( mvtype ), & casabiome % plantrate ( mvtype , mplant ), & casabiome % rmplant ( mvtype , mplant ), & casabiome % fracnpptoP ( mvtype , mplant ), & casabiome % fraclignin ( mvtype , mplant ), & casabiome % fraclabile ( mvtype , mplant ), & casabiome % ratioNCplantmin ( mvtype , mplant ), & casabiome % ratioNCplantmax ( mvtype , mplant ), & casabiome % ratioNPplantmin ( mvtype , mplant ), & casabiome % ratioNPplantmax ( mvtype , mplant ), & casabiome % fracLigninplant ( mvtype , mplant ), & casabiome % ftransNPtoL ( mvtype , mplant ), & casabiome % ftransPPtoL ( mvtype , mplant ), & casabiome % litterrate ( mvtype , mlitter ), & !  casabiome%ratioPcplantmax(mvtype,leaf), & !  casabiome%ratioPcplantmin(mvtype,leaf) & !! vh_js !! casabiome % ratioPcplantmax ( mvtype , mplant ), & casabiome % ratioPcplantmin ( mvtype , mplant ), & casabiome % soilrate ( mvtype , msoil ) & ) end subroutine alloc_casabiome subroutine alloc_casapool ( casapool , arraysize ) use casadimension , only : mplant , mlitter , msoil implicit none type ( casa_pool ), intent ( inout ) :: casapool integer , intent ( in ) :: arraysize allocate ( & casapool % Clabile ( arraysize ), & casapool % dClabiledt ( arraysize ), & casapool % Ctot ( arraysize ), & casapool % Ctot_0 ( arraysize ), & casapool % Cplant ( arraysize , mplant ), & casapool % Nplant ( arraysize , mplant ), & casapool % Pplant ( arraysize , mplant ), & casapool % dCplantdt ( arraysize , mplant ), & casapool % dNplantdt ( arraysize , mplant ), & casapool % dPplantdt ( arraysize , mplant ), & casapool % ratioNCplant ( arraysize , mplant ), & casapool % ratioNPplant ( arraysize , mplant ), & casapool % Nsoilmin ( arraysize ), & casapool % Psoillab ( arraysize ), & casapool % Psoilsorb ( arraysize ), & casapool % Psoilocc ( arraysize ), & casapool % dNsoilmindt ( arraysize ), & casapool % dPsoillabdt ( arraysize ), & casapool % dPsoilsorbdt ( arraysize ), & casapool % dPsoiloccdt ( arraysize ), & casapool % Clitter ( arraysize , mlitter ), & casapool % Nlitter ( arraysize , mlitter ), & casapool % Plitter ( arraysize , mlitter ), & casapool % dClitterdt ( arraysize , mlitter ), & casapool % dNlitterdt ( arraysize , mlitter ), & casapool % dPlitterdt ( arraysize , mlitter ), & casapool % ratioNClitter ( arraysize , mlitter ), & casapool % ratioNPlitter ( arraysize , mlitter ), & casapool % Csoil ( arraysize , msoil ), & casapool % Nsoil ( arraysize , msoil ), & casapool % Psoil ( arraysize , msoil ), & casapool % dCsoildt ( arraysize , msoil ), & casapool % dNsoildt ( arraysize , msoil ), & casapool % dPsoildt ( arraysize , msoil ), & casapool % ratioNCsoil ( arraysize , msoil ), & casapool % ratioNPsoil ( arraysize , msoil ), & casapool % ratioNCsoilnew ( arraysize , msoil ), & casapool % ratioNCsoilmin ( arraysize , msoil ), & casapool % ratioNCsoilmax ( arraysize , msoil ), & casapool % ratioPCsoil ( arraysize , msoil ), & casapool % ratioPCplant ( arraysize , mplant ), & casapool % ratioPClitter ( arraysize , mlitter ) & ) end subroutine alloc_casapool subroutine alloc_casaflux ( casaflux , arraysize ) use casadimension , only : mplant , mlitter , msoil implicit none type ( casa_flux ), intent ( inout ) :: casaflux integer , intent ( in ) :: arraysize allocate ( & casaflux % Cgpp ( arraysize ), & casaflux % Cnpp ( arraysize ), & casaflux % Crp ( arraysize ), & casaflux % Crgplant ( arraysize ), & casaflux % Nminfix ( arraysize ), & casaflux % Nminuptake ( arraysize ), & casaflux % Plabuptake ( arraysize ), & casaflux % Clabloss ( arraysize ), & casaflux % fracClabile ( arraysize ), & casaflux % stemnpp ( arraysize ), & casaflux % frac_sapwood ( arraysize ), & casaflux % sapwood_area ( arraysize ), & casaflux % Charvest ( arraysize ), & casaflux % Nharvest ( arraysize ), & casaflux % Pharvest ( arraysize ), & casaflux % fharvest ( arraysize ), & casaflux % fcrop ( arraysize ), & casaflux % fracCalloc ( arraysize , mplant ), & casaflux % fracNalloc ( arraysize , mplant ), & casaflux % fracPalloc ( arraysize , mplant ), & casaflux % Crmplant ( arraysize , mplant ), & casaflux % kplant ( arraysize , mplant ), & casaflux % Cplant_turnover ( arraysize , mplant ), & casaflux % fromPtoL ( arraysize , mlitter , mplant ), & casaflux % Cnep ( arraysize ), & casaflux % Crsoil ( arraysize ), & casaflux % Nmindep ( arraysize ), & casaflux % Nminloss ( arraysize ), & casaflux % Nminleach ( arraysize ), & casaflux % Nupland ( arraysize ), & casaflux % Nlittermin ( arraysize ), & casaflux % Nsmin ( arraysize ), & casaflux % Nsimm ( arraysize ), & casaflux % Nsnet ( arraysize ), & casaflux % fNminloss ( arraysize ), & casaflux % fNminleach ( arraysize ), & casaflux % Pdep ( arraysize ), & casaflux % Pwea ( arraysize ), & casaflux % Pleach ( arraysize ), & casaflux % Ploss ( arraysize ), & casaflux % Pupland ( arraysize ), & casaflux % Plittermin ( arraysize ), & casaflux % Psmin ( arraysize ), & casaflux % Psimm ( arraysize ), & casaflux % Psnet ( arraysize ), & casaflux % fPleach ( arraysize ), & casaflux % kplab ( arraysize ), & casaflux % kpsorb ( arraysize ), & casaflux % kpocc ( arraysize ), & casaflux % kmlabP ( arraysize ), & casaflux % Psorbmax ( arraysize ), & casaflux % Cplant_turnover_disturbance ( arraysize ), & casaflux % Cplant_turnover_crowding ( arraysize ), & casaflux % Cplant_turnover_resource_limitation ( arraysize ), & casaflux % klitter ( arraysize , mlitter ), & casaflux % ksoil ( arraysize , msoil ), & casaflux % fromLtoS ( arraysize , msoil , mlitter ), & casaflux % fromStoS ( arraysize , msoil , msoil ), & casaflux % fromLtoCO2 ( arraysize , mlitter ), & casaflux % fromStoCO2 ( arraysize , msoil ), & casaflux % FluxCtolitter ( arraysize , mlitter ), & casaflux % FluxNtolitter ( arraysize , mlitter ), & casaflux % FluxPtolitter ( arraysize , mlitter ), & casaflux % FluxCtosoil ( arraysize , msoil ), & casaflux % FluxNtosoil ( arraysize , msoil ), & casaflux % FluxPtosoil ( arraysize , msoil ), & casaflux % FluxCtoCO2 ( arraysize ), & casaflux % FluxCtohwp ( arraysize ), & casaflux % FluxNtohwp ( arraysize ), & casaflux % FluxPtohwp ( arraysize ), & casaflux % FluxCtoclear ( arraysize ), & casaflux % FluxNtoclear ( arraysize ), & casaflux % FluxPtoclear ( arraysize ), & casaflux % CtransferLUC ( arraysize ), & casaflux % fromPtoL_fire ( arraysize , mlitter , mplant ), & casaflux % klitter_fire ( arraysize , mlitter ), & casaflux % klitter_tot ( arraysize , mlitter ), & casaflux % kplant_fire ( arraysize , mplant ), & casaflux % kplant_tot ( arraysize , mplant ), & casaflux % FluxCtoCO2_plant_fire ( arraysize ), & casaflux % FluxCtoCO2_litter_fire ( arraysize ), & casaflux % fluxfromPtoCO2_fire ( arraysize , mplant ), & casaflux % fluxfromLtoCO2_fire ( arraysize , mlitter ), & casaflux % FluxNtoAtm_fire ( arraysize ), & ! casabal%fire_mortality_vs_height(arraysize,mheights,2) ) casaflux % FluxFromPtoL ( arraysize , mplant , mlitter ), & casaflux % FluxFromLtoS ( arraysize , mlitter , msoil ), & casaflux % FluxFromStoS ( arraysize , msoil , msoil ), & casaflux % FluxFromPtoCO2 ( arraysize , mplant ), & casaflux % FluxFromLtoCO2 ( arraysize , mlitter ), & casaflux % FluxFromStoCO2 ( arraysize , msoil ), & casaflux % FluxFromPtoHarvest ( arraysize )) end subroutine alloc_casaflux subroutine alloc_casamet ( casamet , arraysize ) use cable_def_types_mod , only : ms use casadimension , only : mdyear implicit none type ( casa_met ), intent ( inout ) :: casamet integer , intent ( in ) :: arraysize allocate ( & casamet % glai ( arraysize ), & casamet % Tairk ( arraysize ), & casamet % precip ( arraysize ), & casamet % tsoilavg ( arraysize ), & casamet % moistavg ( arraysize ), & casamet % btran ( arraysize ), & casamet % lnonwood ( arraysize ), & casamet % Tsoil ( arraysize , ms ), & casamet % moist ( arraysize , ms ), & casamet % iveg2 ( arraysize ), & casamet % ijgcm ( arraysize ), & casamet % isorder ( arraysize ), & casamet % lat ( arraysize ), & casamet % lon ( arraysize ), & casamet % areacell ( arraysize ), & casamet % Tairkspin ( arraysize , mdyear ), & casamet % cgppspin ( arraysize , mdyear ), & casamet % crmplantspin_1 ( arraysize , mdyear ), & casamet % crmplantspin_2 ( arraysize , mdyear ), & casamet % crmplantspin_3 ( arraysize , mdyear ), & casamet % Tsoilspin_1 ( arraysize , mdyear ), & casamet % Tsoilspin_2 ( arraysize , mdyear ), & casamet % Tsoilspin_3 ( arraysize , mdyear ), & casamet % Tsoilspin_4 ( arraysize , mdyear ), & casamet % Tsoilspin_5 ( arraysize , mdyear ), & casamet % Tsoilspin_6 ( arraysize , mdyear ), & casamet % moistspin_1 ( arraysize , mdyear ), & casamet % moistspin_2 ( arraysize , mdyear ), & casamet % moistspin_3 ( arraysize , mdyear ), & casamet % moistspin_4 ( arraysize , mdyear ), & casamet % moistspin_5 ( arraysize , mdyear ), & casamet % moistspin_6 ( arraysize , mdyear ), & casamet % mtempspin ( arraysize , mdyear ), & casamet % frecspin ( arraysize , mdyear ), & casamet % cAn12spin ( arraysize , mdyear ), & casamet % cAn13spin ( arraysize , mdyear ), & casamet % dprecip_spin ( arraysize , mdyear ), & casamet % aprecip_av20_spin ( arraysize , mdyear ), & casamet % du10_max_spin ( arraysize , mdyear ), & casamet % drhum_spin ( arraysize , mdyear ), & casamet % dtemp_max_spin ( arraysize , mdyear ), & casamet % dtemp_min_spin ( arraysize , mdyear ), & casamet % KBDI_spin ( arraysize , mdyear ), & casamet % D_MacArthur_spin ( arraysize , mdyear ), & casamet % FFDI_spin ( arraysize , mdyear ), & casamet % last_precip_spin ( arraysize , mdyear ), & casamet % DSLR_spin ( arraysize , mdyear )) end subroutine alloc_casamet subroutine alloc_casabal ( casabal , arraysize ) use casadimension , only : mplant , mlitter , msoil implicit none type ( casa_balance ), intent ( inout ) :: casabal integer , intent ( in ) :: arraysize allocate ( & casabal % FCgppyear ( arraysize ), & casabal % FCnppyear ( arraysize ), & casabal % FCrmleafyear ( arraysize ), & casabal % FCrmwoodyear ( arraysize ), & casabal % FCrmrootyear ( arraysize ), & casabal % FCrgrowyear ( arraysize ), & casabal % FCrpyear ( arraysize ), & casabal % FCrsyear ( arraysize ), & casabal % FCneeyear ( arraysize ), & casabal % dCdtyear ( arraysize ), & casabal % LAImax ( arraysize ), & casabal % Cleafmean ( arraysize ), & casabal % Crootmean ( arraysize ), & casabal % FNdepyear ( arraysize ), & casabal % FNfixyear ( arraysize ), & casabal % FNsnetyear ( arraysize ), & casabal % FNupyear ( arraysize ), & casabal % FNleachyear ( arraysize ), & casabal % FNlossyear ( arraysize ), & casabal % FPweayear ( arraysize ), & casabal % FPdustyear ( arraysize ), & casabal % FPsnetyear ( arraysize ), & casabal % FPupyear ( arraysize ), & casabal % FPleachyear ( arraysize ), & casabal % FPlossyear ( arraysize ), & casabal % glaimon ( arraysize , 12 ), & casabal % glaimonx ( arraysize , 12 ), & casabal % cplantlast ( arraysize , mplant ), & casabal % nplantlast ( arraysize , mplant ), & casabal % pplantlast ( arraysize , mplant ), & casabal % clitterlast ( arraysize , mlitter ), & casabal % nlitterlast ( arraysize , mlitter ), & casabal % plitterlast ( arraysize , mlitter ), & casabal % csoillast ( arraysize , msoil ), & casabal % nsoillast ( arraysize , msoil ), & casabal % psoillast ( arraysize , msoil ), & casabal % nsoilminlast ( arraysize ), & casabal % psoillablast ( arraysize ), & casabal % psoilsorblast ( arraysize ), & casabal % psoilocclast ( arraysize ), & casabal % cbalance ( arraysize ), & casabal % nbalance ( arraysize ), & casabal % pbalance ( arraysize ), & casabal % sumcbal ( arraysize ), & casabal % sumnbal ( arraysize ), & casabal % sumpbal ( arraysize ), & casabal % clabilelast ( arraysize )) end subroutine alloc_casabal ! ------------------------------------------------------------------ subroutine alloc_sum_casa ( sum_casapool , sum_casaflux , arraysize ) implicit none type ( casa_pool ), intent ( inout ) :: sum_casapool type ( casa_flux ), intent ( inout ) :: sum_casaflux integer , intent ( in ) :: arraysize call alloc_casapool ( sum_casapool , arraysize ) call alloc_casaflux ( sum_casaflux , arraysize ) end subroutine alloc_sum_casa ! ------------------------------------------------------------------ subroutine zero_casabiome ( casabiome ) use cable_def_types_mod , only : r_2 implicit none type ( casa_biome ), intent ( inout ) :: casabiome casabiome % ivt2 = 0 casabiome % xkleafcoldmax = 0.0_r_2 casabiome % xkleafcoldexp = 0.0_r_2 casabiome % xkleafdrymax = 0.0_r_2 casabiome % xkleafdryexp = 0.0_r_2 casabiome % glaimax = 0.0_r_2 casabiome % glaimin = 0.0_r_2 casabiome % sla = 0.0_r_2 casabiome % ratiofrootleaf = 0.0_r_2 casabiome % kroot = 0.0_r_2 casabiome % krootlen = 0.0_r_2 casabiome % rootdepth = 0.0_r_2 casabiome % kuptake = 0.0_r_2 casabiome % kminN = 0.0_r_2 casabiome % kuplabP = 0.0_r_2 casabiome % kclabrate = 0.0_r_2 casabiome % xnpmax = 0.0_r_2 casabiome % q10soil = 0.0_r_2 casabiome % xkoptlitter = 0.0_r_2 casabiome % xkoptsoil = 0.0_r_2 casabiome % xkplab = 0.0_r_2 casabiome % xkpsorb = 0.0_r_2 casabiome % xkpocc = 0.0_r_2 casabiome % prodptase = 0.0_r_2 casabiome % costnpup = 0.0_r_2 casabiome % maxfinelitter = 0.0_r_2 casabiome % maxcwd = 0.0_r_2 casabiome % nintercept = 0.0_r_2 casabiome % nslope = 0.0_r_2 casabiome % la_to_sa = 0.0_r_2 casabiome % vcmax_scalar = 0.0_r_2 casabiome % disturbance_interval = 0.0_r_2 casabiome % DAMM_EnzPool = 0.0_r_2 casabiome % DAMM_KMO2 = 0.0_r_2 casabiome % DAMM_KMcp = 0.0_r_2 casabiome % DAMM_Ea = 0.0_r_2 casabiome % DAMM_alpha = 0.0_r_2 casabiome % plantrate = 0.0_r_2 casabiome % rmplant = 0.0_r_2 casabiome % fracnpptoP = 0.0_r_2 casabiome % fraclignin = 0.0_r_2 casabiome % fraclabile = 0.0_r_2 casabiome % ratioNCplantmin = 0.0_r_2 casabiome % ratioNCplantmax = 0.0_r_2 casabiome % ratioNPplantmin = 0.0_r_2 casabiome % ratioNPplantmax = 0.0_r_2 casabiome % fracLigninplant = 0.0_r_2 casabiome % ftransNPtoL = 0.0_r_2 casabiome % ftransPPtoL = 0.0_r_2 casabiome % litterrate = 0.0_r_2 casabiome % ratioPcplantmin = 0.0_r_2 casabiome % ratioPcplantmax = 0.0_r_2 casabiome % soilrate = 0.0_r_2 end subroutine zero_casabiome subroutine zero_casapool ( casapool ) use cable_def_types_mod , only : r_2 implicit none type ( casa_pool ), intent ( inout ) :: casapool casapool % Clabile = 0.0_r_2 casapool % dClabiledt = 0.0_r_2 casapool % Ctot = 0.0_r_2 casapool % Ctot_0 = 0.0_r_2 casapool % Cplant = 0.0_r_2 casapool % Nplant = 0.0_r_2 casapool % Pplant = 0.0_r_2 casapool % dCplantdt = 0.0_r_2 casapool % dNplantdt = 0.0_r_2 casapool % dPplantdt = 0.0_r_2 casapool % ratioNCplant = 0.0_r_2 casapool % ratioNPplant = 0.0_r_2 casapool % Nsoilmin = 0.0_r_2 casapool % Psoillab = 0.0_r_2 casapool % Psoilsorb = 0.0_r_2 casapool % Psoilocc = 0.0_r_2 casapool % dNsoilmindt = 0.0_r_2 casapool % dPsoillabdt = 0.0_r_2 casapool % dPsoilsorbdt = 0.0_r_2 casapool % dPsoiloccdt = 0.0_r_2 casapool % Clitter = 0.0_r_2 casapool % Nlitter = 0.0_r_2 casapool % Plitter = 0.0_r_2 casapool % dClitterdt = 0.0_r_2 casapool % dNlitterdt = 0.0_r_2 casapool % dPlitterdt = 0.0_r_2 casapool % ratioNClitter = 0.0_r_2 casapool % ratioNPlitter = 0.0_r_2 casapool % Csoil = 0.0_r_2 casapool % Nsoil = 0.0_r_2 casapool % Psoil = 0.0_r_2 casapool % dCsoildt = 0.0_r_2 casapool % dNsoildt = 0.0_r_2 casapool % dPsoildt = 0.0_r_2 casapool % ratioNCsoil = 0.0_r_2 casapool % ratioNCsoilnew = 0.0_r_2 casapool % ratioNPsoil = 0.0_r_2 casapool % ratioNCsoilmin = 0.0_r_2 casapool % ratioNCsoilmax = 0.0_r_2 casapool % ratioPCsoil = 0.0_r_2 casapool % ratioPCplant = 0.0_r_2 casapool % ratioPClitter = 0.0_r_2 end subroutine zero_casapool subroutine zero_casaflux ( casaflux ) use cable_def_types_mod , only : r_2 implicit none type ( casa_flux ), intent ( inout ) :: casaflux casaflux % Cgpp = 0.0_r_2 casaflux % Cnpp = 0.0_r_2 casaflux % Crp = 0.0_r_2 casaflux % Crgplant = 0.0_r_2 casaflux % Nminfix = 0.0_r_2 casaflux % Nminuptake = 0.0_r_2 casaflux % Plabuptake = 0.0_r_2 casaflux % Clabloss = 0.0_r_2 casaflux % fracClabile = 0.0_r_2 casaflux % stemnpp = 0.0_r_2 casaflux % frac_sapwood = 0.0_r_2 casaflux % sapwood_area = 0.0_r_2 casaflux % Charvest = 0.0_r_2 casaflux % Nharvest = 0.0_r_2 casaflux % Pharvest = 0.0_r_2 casaflux % fHarvest = 0.0_r_2 casaflux % fcrop = 0.0_r_2 casaflux % fracCalloc = 0.0_r_2 casaflux % fracNalloc = 0.0_r_2 casaflux % fracPalloc = 0.0_r_2 casaflux % Crmplant = 0.0_r_2 casaflux % kplant = 0.0_r_2 casaflux % Cplant_turnover = 0.0_r_2 casaflux % fromPtoL = 0.0_r_2 casaflux % Cnep = 0.0_r_2 casaflux % Crsoil = 0.0_r_2 casaflux % Nmindep = 0.0_r_2 casaflux % Nminloss = 0.0_r_2 casaflux % Nminleach = 0.0_r_2 casaflux % Nupland = 0.0_r_2 casaflux % Nlittermin = 0.0_r_2 casaflux % Nsmin = 0.0_r_2 casaflux % Nsimm = 0.0_r_2 casaflux % Nsnet = 0.0_r_2 casaflux % fNminloss = 0.0_r_2 casaflux % fNminleach = 0.0_r_2 casaflux % Pdep = 0.0_r_2 casaflux % Pwea = 0.0_r_2 casaflux % Pleach = 0.0_r_2 casaflux % Ploss = 0.0_r_2 casaflux % Pupland = 0.0_r_2 casaflux % Plittermin = 0.0_r_2 casaflux % Psmin = 0.0_r_2 casaflux % Psimm = 0.0_r_2 casaflux % Psnet = 0.0_r_2 casaflux % fPleach = 0.0_r_2 casaflux % kplab = 0.0_r_2 casaflux % kpsorb = 0.0_r_2 casaflux % kpocc = 0.0_r_2 casaflux % kmlabp = 0.0_r_2 casaflux % Psorbmax = 0.0_r_2 casaflux % Cplant_turnover_disturbance = 0.0_r_2 casaflux % Cplant_turnover_crowding = 0.0_r_2 casaflux % Cplant_turnover_resource_limitation = 0.0_r_2 casaflux % klitter = 0.0_r_2 casaflux % ksoil = 0.0_r_2 casaflux % fromLtoS = 0.0_r_2 casaflux % fromStoS = 0.0_r_2 casaflux % fromLtoCO2 = 0.0_r_2 casaflux % fromStoCO2 = 0.0_r_2 casaflux % FluxCtolitter = 0.0_r_2 casaflux % FluxNtolitter = 0.0_r_2 casaflux % FluxPtolitter = 0.0_r_2 casaflux % FluxCtosoil = 0.0_r_2 casaflux % FluxNtosoil = 0.0_r_2 casaflux % FluxPtosoil = 0.0_r_2 casaflux % FluxCtoCO2 = 0.0_r_2 casaflux % FluxCtohwp = 0.0_r_2 casaflux % FluxNtohwp = 0.0_r_2 casaflux % FluxPtohwp = 0.0_r_2 casaflux % FluxCtoclear = 0.0_r_2 casaflux % FluxNtoclear = 0.0_r_2 casaflux % FluxPtoclear = 0.0_r_2 casaflux % CtransferLUC = 0.0_r_2 casaflux % fromPtoL_fire = 0.0_r_2 casaflux % klitter_fire = 0.0_r_2 casaflux % klitter_tot = 0.0_r_2 casaflux % kplant_fire = 0.0_r_2 casaflux % kplant_tot = 0.0_r_2 casaflux % fluxCtoCO2_plant_fire = 0.0_r_2 casaflux % fluxCtoCO2_litter_fire = 0.0_r_2 casaflux % fluxfromPtoCO2_fire = 0.0_r_2 casaflux % fluxfromLtoCO2_fire = 0.0_r_2 casaflux % fluxNtoAtm_fire = 0.0_r_2 ! casaflux%fire_mortality_vs_height = 0.0_r_2 casaflux % FluxFromPtoL = 0.0_r_2 casaflux % FluxFromLtoS = 0.0_r_2 casaflux % FluxFromStoS = 0.0_r_2 casaflux % FluxFromPtoCO2 = 0.0_r_2 casaflux % FluxFromLtoCO2 = 0.0_r_2 casaflux % FluxFromStoCO2 = 0.0_r_2 casaflux % FluxFromPtoHarvest = 0.0_r_2 end subroutine zero_casaflux subroutine zero_casamet ( casamet ) use cable_def_types_mod , only : r_2 implicit none type ( casa_met ), intent ( inout ) :: casamet casamet % glai = 0.0_r_2 casamet % Tairk = 0.0_r_2 casamet % precip = 0.0_r_2 casamet % tsoilavg = 0.0_r_2 casamet % moistavg = 0.0_r_2 casamet % btran = 0.0_r_2 casamet % lnonwood = 0 casamet % Tsoil = 0.0_r_2 casamet % moist = 0.0_r_2 casamet % iveg2 = 0 casamet % ijgcm = 0 casamet % isorder = 0 casamet % lat = 0.0_r_2 casamet % lon = 0.0_r_2 casamet % areacell = 0.0_r_2 casamet % Tairkspin = 0.0_r_2 casamet % cgppspin = 0.0_r_2 casamet % crmplantspin_1 = 0.0_r_2 casamet % crmplantspin_2 = 0.0_r_2 casamet % crmplantspin_3 = 0.0_r_2 casamet % Tsoilspin_1 = 0.0_r_2 casamet % Tsoilspin_2 = 0.0_r_2 casamet % Tsoilspin_3 = 0.0_r_2 casamet % Tsoilspin_4 = 0.0_r_2 casamet % Tsoilspin_5 = 0.0_r_2 casamet % Tsoilspin_6 = 0.0_r_2 casamet % moistspin_1 = 0.0_r_2 casamet % moistspin_2 = 0.0_r_2 casamet % moistspin_3 = 0.0_r_2 casamet % moistspin_4 = 0.0_r_2 casamet % moistspin_5 = 0.0_r_2 casamet % moistspin_6 = 0.0_r_2 casamet % mtempspin = 0.0_r_2 casamet % frecspin = 0.0_r_2 casamet % cAn12spin = 0.0_r_2 casamet % cAn13spin = 0.0_r_2 casamet % dprecip_spin = 0.0_r_2 casamet % aprecip_av20_spin = 0.0_r_2 casamet % du10_max_spin = 0.0_r_2 casamet % drhum_spin = 0.0_r_2 casamet % dtemp_max_spin = 0.0_r_2 casamet % dtemp_min_spin = 0.0_r_2 casamet % KBDI_spin = 0.0_r_2 casamet % D_MacArthur_spin = 0.0_r_2 casamet % FFDI_spin = 0.0_r_2 casamet % last_precip_spin = 0.0_r_2 casamet % DSLR_spin = 0 end subroutine zero_casamet subroutine zero_casabal ( casabal ) use cable_def_types_mod , only : r_2 implicit none type ( casa_balance ), intent ( inout ) :: casabal casabal % FCgppyear = 0.0_r_2 casabal % FCnppyear = 0.0_r_2 casabal % FCrmleafyear = 0.0_r_2 casabal % FCrmwoodyear = 0.0_r_2 casabal % FCrmrootyear = 0.0_r_2 casabal % FCrgrowyear = 0.0_r_2 casabal % FCrpyear = 0.0_r_2 casabal % FCrsyear = 0.0_r_2 casabal % FCneeyear = 0.0_r_2 casabal % dCdtyear = 0.0_r_2 casabal % LAImax = 0.0_r_2 casabal % Cleafmean = 0.0_r_2 casabal % Crootmean = 0.0_r_2 casabal % FNdepyear = 0.0_r_2 casabal % FNfixyear = 0.0_r_2 casabal % FNsnetyear = 0.0_r_2 casabal % FNupyear = 0.0_r_2 casabal % FNleachyear = 0.0_r_2 casabal % FNlossyear = 0.0_r_2 casabal % FPweayear = 0.0_r_2 casabal % FPdustyear = 0.0_r_2 casabal % FPsnetyear = 0.0_r_2 casabal % FPupyear = 0.0_r_2 casabal % FPleachyear = 0.0_r_2 casabal % FPlossyear = 0.0_r_2 casabal % glaimon = 0.0_r_2 casabal % glaimonx = 0.0_r_2 casabal % cplantlast = 0.0_r_2 casabal % nplantlast = 0.0_r_2 casabal % pplantlast = 0.0_r_2 casabal % clitterlast = 0.0_r_2 casabal % nlitterlast = 0.0_r_2 casabal % plitterlast = 0.0_r_2 casabal % csoillast = 0.0_r_2 casabal % nsoillast = 0.0_r_2 casabal % psoillast = 0.0_r_2 casabal % nsoilminlast = 0.0_r_2 casabal % psoillablast = 0.0_r_2 casabal % psoilsorblast = 0.0_r_2 casabal % psoilocclast = 0.0_r_2 casabal % cbalance = 0.0_r_2 casabal % nbalance = 0.0_r_2 casabal % pbalance = 0.0_r_2 casabal % sumcbal = 0.0_r_2 casabal % sumnbal = 0.0_r_2 casabal % sumpbal = 0.0_r_2 casabal % clabilelast = 0.0_r_2 end subroutine zero_casabal ! ------------------------------------------------------------------ subroutine print_casabiome ( casabiome ) implicit none type ( casa_biome ), intent ( in ) :: casabiome write ( * , * ) 'ivt2 ' , casabiome % ivt2 write ( * , * ) 'xkleafcoldmax ' , casabiome % xkleafcoldmax write ( * , * ) 'xkleafcoldexp ' , casabiome % xkleafcoldexp write ( * , * ) 'xkleafdrymax ' , casabiome % xkleafdrymax write ( * , * ) 'xkleafdryexp ' , casabiome % xkleafdryexp write ( * , * ) 'glaimax ' , casabiome % glaimax write ( * , * ) 'glaimin ' , casabiome % glaimin write ( * , * ) 'sla ' , casabiome % sla write ( * , * ) 'ratiofrootleaf ' , casabiome % ratiofrootleaf write ( * , * ) 'kroot ' , casabiome % kroot write ( * , * ) 'krootlen ' , casabiome % krootlen write ( * , * ) 'rootdepth ' , casabiome % rootdepth write ( * , * ) 'kuptake ' , casabiome % kuptake write ( * , * ) 'kminN ' , casabiome % kminN write ( * , * ) 'KuplabP ' , casabiome % KuplabP write ( * , * ) 'kclabrate ' , casabiome % kclabrate write ( * , * ) 'xnpmax ' , casabiome % xnpmax write ( * , * ) 'q10soil ' , casabiome % q10soil write ( * , * ) 'xkoptlitter ' , casabiome % xkoptlitter write ( * , * ) 'xkoptsoil ' , casabiome % xkoptsoil write ( * , * ) 'xkplab ' , casabiome % xkplab write ( * , * ) 'xkpsorb ' , casabiome % xkpsorb write ( * , * ) 'xkpocc ' , casabiome % xkpocc write ( * , * ) 'prodptase ' , casabiome % prodptase write ( * , * ) 'costnpup ' , casabiome % costnpup write ( * , * ) 'maxfinelitter ' , casabiome % maxfinelitter write ( * , * ) 'maxcwd ' , casabiome % maxcwd write ( * , * ) 'nintercept ' , casabiome % nintercept write ( * , * ) 'nslope ' , casabiome % nslope write ( * , * ) 'plantrate ' , casabiome % plantrate write ( * , * ) 'rmplant ' , casabiome % rmplant write ( * , * ) 'fracnpptoP ' , casabiome % fracnpptoP write ( * , * ) 'fraclignin ' , casabiome % fraclignin write ( * , * ) 'fraclabile ' , casabiome % fraclabile write ( * , * ) 'ratioNCplantmin ' , casabiome % ratioNCplantmin write ( * , * ) 'ratioNCplantmax ' , casabiome % ratioNCplantmax write ( * , * ) 'ratioNPplantmin ' , casabiome % ratioNPplantmin write ( * , * ) 'ratioNPplantmax ' , casabiome % ratioNPplantmax write ( * , * ) 'fracLigninplant ' , casabiome % fracLigninplant write ( * , * ) 'ftransNPtoL ' , casabiome % ftransNPtoL write ( * , * ) 'ftransPPtoL ' , casabiome % ftransPPtoL write ( * , * ) 'litterrate ' , casabiome % litterrate write ( * , * ) 'soilrate ' , casabiome % soilrate write ( * , * ) 'ratioPcplantmax ' , casabiome % ratioPcplantmax write ( * , * ) 'ratioPcplantmin ' , casabiome % ratioPcplantmin write ( * , * ) 'la_to_sa ' , casabiome % la_to_sa write ( * , * ) 'vcmax_scalar ' , casabiome % vcmax_scalar write ( * , * ) 'disturbance_interval ' , casabiome % disturbance_interval write ( * , * ) 'DAMM_EnzPool ' , casabiome % DAMM_EnzPool write ( * , * ) 'DAMM_KMO2 ' , casabiome % DAMM_KMO2 write ( * , * ) 'DAMM_KMcp ' , casabiome % DAMM_KMcp write ( * , * ) 'DAMM_Ea ' , casabiome % DAMM_Ea write ( * , * ) 'DAMM_alpha ' , casabiome % DAMM_alpha end subroutine print_casabiome subroutine print_casapool ( casapool ) implicit none type ( casa_pool ), intent ( in ) :: casapool write ( * , * ) 'Clabile ' , casapool % Clabile write ( * , * ) 'dClabiledt ' , casapool % dClabiledt write ( * , * ) 'Cplant ' , casapool % Cplant write ( * , * ) 'Nplant ' , casapool % Nplant write ( * , * ) 'Pplant ' , casapool % Pplant write ( * , * ) 'dCplantdt ' , casapool % dCplantdt write ( * , * ) 'dNplantdt ' , casapool % dNplantdt write ( * , * ) 'dPplantdt ' , casapool % dPplantdt write ( * , * ) 'ratioNCplant ' , casapool % ratioNCplant write ( * , * ) 'ratioNPplant ' , casapool % ratioNPplant write ( * , * ) 'Nsoilmin ' , casapool % Nsoilmin write ( * , * ) 'Psoillab ' , casapool % Psoillab write ( * , * ) 'Psoilsorb ' , casapool % Psoilsorb write ( * , * ) 'Psoilocc ' , casapool % Psoilocc write ( * , * ) 'dNsoilmindt ' , casapool % dNsoilmindt write ( * , * ) 'dPsoillabdt ' , casapool % dPsoillabdt write ( * , * ) 'dPsoilsorbdt ' , casapool % dPsoilsorbdt write ( * , * ) 'dPsoiloccdt ' , casapool % dPsoiloccdt write ( * , * ) 'Clitter ' , casapool % Clitter write ( * , * ) 'Nlitter ' , casapool % Nlitter write ( * , * ) 'Plitter ' , casapool % Plitter write ( * , * ) 'dClitterdt ' , casapool % dClitterdt write ( * , * ) 'dNlitterdt ' , casapool % dNlitterdt write ( * , * ) 'dPlitterdt ' , casapool % dPlitterdt write ( * , * ) 'ratioNClitter ' , casapool % ratioNClitter write ( * , * ) 'ratioNPlitter ' , casapool % ratioNPlitter write ( * , * ) 'Csoil ' , casapool % Csoil write ( * , * ) 'Nsoil ' , casapool % Nsoil write ( * , * ) 'Psoil ' , casapool % Psoil write ( * , * ) 'dCsoildt ' , casapool % dCsoildt write ( * , * ) 'dNsoildt ' , casapool % dNsoildt write ( * , * ) 'dPsoildt ' , casapool % dPsoildt write ( * , * ) 'ratioNCsoil ' , casapool % ratioNCsoil write ( * , * ) 'ratioNPsoil ' , casapool % ratioNPsoil write ( * , * ) 'ratioNCsoilnew ' , casapool % ratioNCsoilnew write ( * , * ) 'ratioNCsoilmin ' , casapool % ratioNCsoilmin write ( * , * ) 'ratioNCsoilmax ' , casapool % ratioNCsoilmax write ( * , * ) 'ratioPCsoil ' , casapool % ratioPCsoil write ( * , * ) 'ratioPCplant ' , casapool % ratioPCplant write ( * , * ) 'ratioPClitter ' , casapool % ratioPClitter write ( * , * ) 'Ctot_0 ' , casapool % Ctot_0 write ( * , * ) 'Ctot ' , casapool % Ctot end subroutine print_casapool subroutine print_casaflux ( casaflux ) implicit none type ( casa_flux ), intent ( in ) :: casaflux write ( * , * ) 'Cgpp ' , casaflux % Cgpp write ( * , * ) 'Cnpp ' , casaflux % Cnpp write ( * , * ) 'Crp ' , casaflux % Crp write ( * , * ) 'Crgplant ' , casaflux % Crgplant write ( * , * ) 'Nminfix ' , casaflux % Nminfix write ( * , * ) 'Nminuptake ' , casaflux % Nminuptake write ( * , * ) 'Plabuptake ' , casaflux % Plabuptake write ( * , * ) 'Clabloss ' , casaflux % Clabloss write ( * , * ) 'fracClabile ' , casaflux % fracClabile write ( * , * ) 'fracCalloc ' , casaflux % fracCalloc write ( * , * ) 'fracNalloc ' , casaflux % fracNalloc write ( * , * ) 'fracPalloc ' , casaflux % fracPalloc write ( * , * ) 'kplant ' , casaflux % kplant write ( * , * ) 'Crmplant ' , casaflux % Crmplant write ( * , * ) 'fromPtoL ' , casaflux % fromPtoL write ( * , * ) 'Cnep ' , casaflux % Cnep write ( * , * ) 'Crsoil ' , casaflux % Crsoil write ( * , * ) 'Nmindep ' , casaflux % Nmindep write ( * , * ) 'Nminloss ' , casaflux % Nminloss write ( * , * ) 'Nminleach ' , casaflux % Nminleach write ( * , * ) 'Nupland ' , casaflux % Nupland write ( * , * ) 'Nlittermin ' , casaflux % Nlittermin write ( * , * ) 'Nsmin ' , casaflux % Nsmin write ( * , * ) 'Nsimm ' , casaflux % Nsimm write ( * , * ) 'Nsnet ' , casaflux % Nsnet write ( * , * ) 'fNminloss ' , casaflux % fNminloss write ( * , * ) 'fNminleach ' , casaflux % fNminleach write ( * , * ) 'Pdep ' , casaflux % Pdep write ( * , * ) 'Pwea ' , casaflux % Pwea write ( * , * ) 'Pleach ' , casaflux % Pleach write ( * , * ) 'Ploss ' , casaflux % Ploss write ( * , * ) 'Pupland ' , casaflux % Pupland write ( * , * ) 'Plittermin ' , casaflux % Plittermin write ( * , * ) 'Psmin ' , casaflux % Psmin write ( * , * ) 'Psimm ' , casaflux % Psimm write ( * , * ) 'Psnet ' , casaflux % Psnet write ( * , * ) 'fPleach ' , casaflux % fPleach write ( * , * ) 'kplab ' , casaflux % kplab write ( * , * ) 'kpsorb ' , casaflux % kpsorb write ( * , * ) 'kpocc ' , casaflux % kpocc write ( * , * ) 'kmlabP ' , casaflux % kmlabP write ( * , * ) 'Psorbmax ' , casaflux % Psorbmax write ( * , * ) 'klitter ' , casaflux % klitter write ( * , * ) 'ksoil ' , casaflux % ksoil write ( * , * ) 'fromLtoS ' , casaflux % fromLtoS write ( * , * ) 'fromStoS ' , casaflux % fromStoS write ( * , * ) 'fromLtoCO2 ' , casaflux % fromLtoCO2 write ( * , * ) 'fromStoCO2 ' , casaflux % fromStoCO2 write ( * , * ) 'stemnpp ' , casaflux % stemnpp write ( * , * ) 'frac_sapwood ' , casaflux % frac_sapwood write ( * , * ) 'sapwood_area ' , casaflux % sapwood_area write ( * , * ) 'fharvest ' , casaflux % fharvest write ( * , * ) 'Charvest ' , casaflux % Charvest write ( * , * ) 'Nharvest ' , casaflux % Nharvest write ( * , * ) 'Pharvest ' , casaflux % Pharvest write ( * , * ) 'fcrop ' , casaflux % fcrop write ( * , * ) 'Cplant_turnover ' , casaflux % Cplant_turnover write ( * , * ) 'Cplant_turnover_disturbance ' , casaflux % Cplant_turnover_disturbance write ( * , * ) 'Cplant_turnover_crowding ' , casaflux % Cplant_turnover_crowding write ( * , * ) 'Cplant_turnover_resource_limitation ' , casaflux % Cplant_turnover_resource_limitation write ( * , * ) 'fromPtoL_fire ' , casaflux % fromPtoL_fire write ( * , * ) 'kplant_fire ' , casaflux % kplant_fire write ( * , * ) 'klitter_fire ' , casaflux % klitter_fire write ( * , * ) 'kplant_tot ' , casaflux % kplant_tot write ( * , * ) 'klitter_tot ' , casaflux % klitter_tot write ( * , * ) 'FluxCtoCO2_plant_fire ' , casaflux % FluxCtoCO2_plant_fire write ( * , * ) 'FluxCtoCO2_litter_fire ' , casaflux % FluxCtoCO2_litter_fire write ( * , * ) 'fluxfromPtoCO2_fire ' , casaflux % fluxfromPtoCO2_fire write ( * , * ) 'fluxfromLtoCO2_fire ' , casaflux % fluxfromLtoCO2_fire write ( * , * ) 'FluxNtoAtm_fire ' , casaflux % FluxNtoAtm_fire write ( * , * ) 'FluxCtolitter ' , casaflux % FluxCtolitter write ( * , * ) 'FluxNtolitter ' , casaflux % FluxNtolitter write ( * , * ) 'FluxPtolitter ' , casaflux % FluxPtolitter write ( * , * ) 'FluxCtosoil ' , casaflux % FluxCtosoil write ( * , * ) 'FluxNtosoil ' , casaflux % FluxNtosoil write ( * , * ) 'FluxPtosoil ' , casaflux % FluxPtosoil write ( * , * ) 'FluxCtohwp ' , casaflux % FluxCtohwp write ( * , * ) 'FluxNtohwp ' , casaflux % FluxNtohwp write ( * , * ) 'FluxPtohwp ' , casaflux % FluxPtohwp write ( * , * ) 'FluxCtoclear ' , casaflux % FluxCtoclear write ( * , * ) 'FluxNtoclear ' , casaflux % FluxNtoclear write ( * , * ) 'FluxPtoclear ' , casaflux % FluxPtoclear write ( * , * ) 'CtransferLUC ' , casaflux % CtransferLUC write ( * , * ) 'FluxCtoco2 ' , casaflux % FluxCtoco2 write ( * , * ) 'FluxFromPtoL ' , casaflux % FluxFromPtoL write ( * , * ) 'FluxFromLtoS ' , casaflux % FluxFromLtoS write ( * , * ) 'FluxFromStoS ' , casaflux % FluxFromStoS write ( * , * ) 'FluxFromPtoCO2 ' , casaflux % FluxFromPtoCO2 write ( * , * ) 'FluxFromLtoCO2 ' , casaflux % FluxFromLtoCO2 write ( * , * ) 'FluxFromStoCO2 ' , casaflux % FluxFromStoCO2 write ( * , * ) 'FluxFromPtoHarvest ' , casaflux % FluxFromPtoHarvest end subroutine print_casaflux subroutine print_casamet ( casamet ) implicit none type ( casa_met ), intent ( in ) :: casamet write ( * , * ) 'glai ' , casamet % glai write ( * , * ) 'lnonwood ' , casamet % lnonwood write ( * , * ) 'Tairk ' , casamet % Tairk write ( * , * ) 'precip ' , casamet % precip write ( * , * ) 'tsoilavg ' , casamet % tsoilavg write ( * , * ) 'moistavg ' , casamet % moistavg write ( * , * ) 'btran ' , casamet % btran write ( * , * ) 'Tsoil ' , casamet % Tsoil write ( * , * ) 'moist ' , casamet % moist write ( * , * ) 'iveg2 ' , casamet % iveg2 write ( * , * ) 'ijgcm ' , casamet % ijgcm write ( * , * ) 'isorder ' , casamet % isorder write ( * , * ) 'lat ' , casamet % lat write ( * , * ) 'lon ' , casamet % lon write ( * , * ) 'areacell ' , casamet % areacell write ( * , * ) 'Tairkspin ' , casamet % Tairkspin write ( * , * ) 'cgppspin ' , casamet % cgppspin write ( * , * ) 'crmplantspin_1 ' , casamet % crmplantspin_1 write ( * , * ) 'crmplantspin_2 ' , casamet % crmplantspin_2 write ( * , * ) 'crmplantspin_3 ' , casamet % crmplantspin_3 write ( * , * ) 'Tsoilspin_1 ' , casamet % Tsoilspin_1 write ( * , * ) 'Tsoilspin_2 ' , casamet % Tsoilspin_2 write ( * , * ) 'Tsoilspin_3 ' , casamet % Tsoilspin_3 write ( * , * ) 'Tsoilspin_4 ' , casamet % Tsoilspin_4 write ( * , * ) 'Tsoilspin_5 ' , casamet % Tsoilspin_5 write ( * , * ) 'Tsoilspin_6 ' , casamet % Tsoilspin_6 write ( * , * ) 'moistspin_1 ' , casamet % moistspin_1 write ( * , * ) 'moistspin_2 ' , casamet % moistspin_2 write ( * , * ) 'moistspin_3 ' , casamet % moistspin_3 write ( * , * ) 'moistspin_4 ' , casamet % moistspin_4 write ( * , * ) 'moistspin_5 ' , casamet % moistspin_5 write ( * , * ) 'moistspin_6 ' , casamet % moistspin_6 write ( * , * ) 'mtempspin ' , casamet % mtempspin write ( * , * ) 'cAn12spin ' , casamet % cAn12spin write ( * , * ) 'cAn13spin ' , casamet % cAn13spin end subroutine print_casamet subroutine print_casabal ( casabal ) implicit none type ( casa_balance ), intent ( in ) :: casabal write ( * , * ) 'FCgppyear ' , casabal % FCgppyear write ( * , * ) 'FCnppyear ' , casabal % FCnppyear write ( * , * ) 'FCrpyear ' , casabal % FCrpyear write ( * , * ) 'FCrmleafyear ' , casabal % FCrmleafyear write ( * , * ) 'FCrmwoodyear ' , casabal % FCrmwoodyear write ( * , * ) 'FCrmrootyear ' , casabal % FCrmrootyear write ( * , * ) 'FCrgrowyear ' , casabal % FCrgrowyear write ( * , * ) 'FCrsyear ' , casabal % FCrsyear write ( * , * ) 'FCneeyear ' , casabal % FCneeyear write ( * , * ) 'FNdepyear ' , casabal % FNdepyear write ( * , * ) 'FNfixyear ' , casabal % FNfixyear write ( * , * ) 'FNsnetyear ' , casabal % FNsnetyear write ( * , * ) 'FNupyear ' , casabal % FNupyear write ( * , * ) 'FNleachyear ' , casabal % FNleachyear write ( * , * ) 'FNlossyear ' , casabal % FNlossyear write ( * , * ) 'FPweayear ' , casabal % FPweayear write ( * , * ) 'FPdustyear ' , casabal % FPdustyear write ( * , * ) 'FPsnetyear ' , casabal % FPsnetyear write ( * , * ) 'FPupyear ' , casabal % FPupyear write ( * , * ) 'FPleachyear ' , casabal % FPleachyear write ( * , * ) 'FPlossyear ' , casabal % FPlossyear write ( * , * ) 'dCdtyear ' , casabal % dCdtyear write ( * , * ) 'LAImax ' , casabal % LAImax write ( * , * ) 'Cleafmean ' , casabal % Cleafmean write ( * , * ) 'Crootmean ' , casabal % Crootmean write ( * , * ) 'glaimon ' , casabal % glaimon write ( * , * ) 'glaimonx ' , casabal % glaimonx write ( * , * ) 'cplantlast ' , casabal % cplantlast write ( * , * ) 'nplantlast ' , casabal % nplantlast write ( * , * ) 'pplantlast ' , casabal % pplantlast write ( * , * ) 'clitterlast ' , casabal % clitterlast write ( * , * ) 'nlitterlast ' , casabal % nlitterlast write ( * , * ) 'plitterlast ' , casabal % plitterlast write ( * , * ) 'csoillast ' , casabal % csoillast write ( * , * ) 'nsoillast ' , casabal % nsoillast write ( * , * ) 'psoillast ' , casabal % psoillast write ( * , * ) 'nsoilminlast ' , casabal % nsoilminlast write ( * , * ) 'psoillablast ' , casabal % psoillablast write ( * , * ) 'psoilsorblast ' , casabal % psoilsorblast write ( * , * ) 'psoilocclast ' , casabal % psoilocclast write ( * , * ) 'cbalance ' , casabal % cbalance write ( * , * ) 'nbalance ' , casabal % nbalance write ( * , * ) 'pbalance ' , casabal % pbalance write ( * , * ) 'sumcbal ' , casabal % sumcbal write ( * , * ) 'sumnbal ' , casabal % sumnbal write ( * , * ) 'sumpbal ' , casabal % sumpbal write ( * , * ) 'clabilelast ' , casabal % clabilelast end subroutine print_casabal ! ------------------------------------------------------------------ subroutine zero_sum_casa ( sum_casapool , sum_casaflux ) implicit none type ( casa_pool ), intent ( inout ) :: sum_casapool type ( casa_flux ), intent ( inout ) :: sum_casaflux call zero_casapool ( sum_casapool ) call zero_casaflux ( sum_casaflux ) end subroutine zero_sum_casa subroutine update_sum_casa ( sum_casapool , sum_casaflux , casapool , casaflux , sum_now , average_now , nsteps ) use cable_def_types_mod , only : r_2 implicit none type ( casa_pool ), intent ( inout ) :: sum_casapool type ( casa_flux ), intent ( inout ) :: sum_casaflux type ( casa_pool ), intent ( in ) :: casapool type ( casa_flux ), intent ( in ) :: casaflux logical , intent ( in ) :: sum_now , average_now integer , intent ( in ) :: nsteps real ( r_2 ) :: rnsteps rnsteps = 1.0 / real ( nsteps , r_2 ) if ( sum_now ) then sum_casapool % Clabile = sum_casapool % Clabile + casapool % Clabile sum_casapool % dClabiledt = sum_casapool % Clabile + casapool % Clabile sum_casapool % Cplant = sum_casapool % Cplant + casapool % Cplant sum_casapool % Nplant = sum_casapool % Nplant + casapool % Nplant sum_casapool % Pplant = sum_casapool % Pplant + casapool % Pplant sum_casapool % dCplantdt = sum_casapool % dCplantdt + casapool % dCplantdt sum_casapool % dNplantdt = sum_casapool % dNplantdt + casapool % dNplantdt sum_casapool % dPplantdt = sum_casapool % dPplantdt + casapool % dPplantdt sum_casapool % ratioNCplant = sum_casapool % ratioNCplant + casapool % ratioNCplant sum_casapool % ratioNPplant = sum_casapool % ratioNPplant + casapool % ratioNPplant sum_casapool % Nsoilmin = sum_casapool % Nsoilmin + casapool % Nsoilmin sum_casapool % Psoillab = sum_casapool % Psoillab + casapool % Psoillab sum_casapool % Psoilsorb = sum_casapool % Psoilsorb + casapool % Psoilsorb sum_casapool % Psoilocc = sum_casapool % Psoilocc + casapool % Psoilocc sum_casapool % dNsoilmindt = sum_casapool % dNsoilmindt + casapool % dNsoilmindt sum_casapool % dPsoillabdt = sum_casapool % dPsoillabdt + casapool % dPsoillabdt sum_casapool % dPsoilsorbdt = sum_casapool % dPsoilsorbdt + casapool % dPsoilsorbdt sum_casapool % dPsoiloccdt = sum_casapool % dPsoiloccdt + casapool % dPsoiloccdt sum_casapool % Clitter = sum_casapool % Clitter + casapool % Clitter sum_casapool % Nlitter = sum_casapool % Nlitter + casapool % Nlitter sum_casapool % Plitter = sum_casapool % Plitter + casapool % Plitter sum_casapool % dClitterdt = sum_casapool % dClitterdt + casapool % dClitterdt sum_casapool % dNlitterdt = sum_casapool % dNlitterdt + casapool % dNlitterdt sum_casapool % dPlitterdt = sum_casapool % dPlitterdt + casapool % dPlitterdt sum_casapool % ratioNClitter = sum_casapool % ratioNClitter + casapool % ratioNClitter sum_casapool % ratioNPlitter = sum_casapool % ratioNPlitter + casapool % ratioNPlitter sum_casapool % Csoil = sum_casapool % Csoil + casapool % Csoil sum_casapool % Nsoil = sum_casapool % Nsoil + casapool % Nsoil sum_casapool % Psoil = sum_casapool % Psoil + casapool % Psoil sum_casapool % dCsoildt = sum_casapool % dCsoildt + casapool % dCsoildt sum_casapool % dNsoildt = sum_casapool % dNsoildt + casapool % dNsoildt sum_casapool % dPsoildt = sum_casapool % dPsoildt + casapool % dPsoildt sum_casapool % ratioNCsoil = sum_casapool % ratioNCsoil + casapool % ratioNCsoil sum_casapool % ratioNPsoil = sum_casapool % ratioNPsoil + casapool % ratioNPsoil sum_casapool % ratioNCsoilnew = sum_casapool % ratioNCsoilnew + casapool % ratioNCsoilnew sum_casapool % ratioNCsoilmin = sum_casapool % ratioNCsoilmin + casapool % ratioNCsoilmin sum_casapool % ratioNCsoilmax = sum_casapool % ratioNCsoilmax + casapool % ratioNCsoilmax sum_casapool % ratioPcsoil = sum_casapool % ratioPcsoil + casapool % ratioPcsoil sum_casapool % ratioPcplant = sum_casapool % ratioPcplant + casapool % ratioPcplant sum_casapool % ratioPclitter = sum_casapool % ratioPclitter + casapool % ratioPclitter sum_casaflux % Cgpp = sum_casaflux % Cgpp + casaflux % Cgpp sum_casaflux % Cnpp = sum_casaflux % Cnpp + casaflux % Cnpp sum_casaflux % Crp = sum_casaflux % Crp + casaflux % Crp sum_casaflux % Crgplant = sum_casaflux % Crgplant + casaflux % Crgplant sum_casaflux % Nminfix = sum_casaflux % Nminfix + casaflux % Nminfix sum_casaflux % Nminuptake = sum_casaflux % Nminuptake + casaflux % Nminuptake sum_casaflux % Plabuptake = sum_casaflux % Plabuptake + casaflux % Plabuptake sum_casaflux % Clabloss = sum_casaflux % Clabloss + casaflux % Clabloss sum_casaflux % fracClabile = sum_casaflux % fracClabile + casaflux % fracClabile ! sum_casaflux%fracCalloc(:,1) = sum_casaflux%fracCalloc(:,1) + casaflux%fracCalloc(:,1) ! sum_casaflux%fracCalloc(:,2) = sum_casaflux%fracCalloc(:,2) + casaflux%fracCalloc(:,2) ! sum_casaflux%fracCalloc(:,3) = sum_casaflux%fracCalloc(:,3) + casaflux%fracCalloc(:,3) sum_casaflux % fracCalloc (:, 1 ) = sum_casaflux % fracCalloc (:, 1 ) + casaflux % fracCalloc (:, 1 ) * casaflux % Cnpp sum_casaflux % fracCalloc (:, 2 ) = sum_casaflux % fracCalloc (:, 2 ) + casaflux % fracCalloc (:, 2 ) * casaflux % Cnpp sum_casaflux % fracCalloc (:, 3 ) = sum_casaflux % fracCalloc (:, 3 ) + casaflux % fracCalloc (:, 3 ) * casaflux % Cnpp sum_casaflux % fracNalloc = sum_casaflux % fracNalloc + casaflux % fracNalloc sum_casaflux % fracPalloc = sum_casaflux % fracPalloc + casaflux % fracPalloc sum_casaflux % Crmplant = sum_casaflux % Crmplant + casaflux % Crmplant ! sum_casaflux%kplant          = sum_casaflux%kplant          + casaflux%kplant sum_casaflux % kplant = sum_casaflux % kplant + casaflux % kplant * casapool % Cplant sum_casaflux % fromPtoL = sum_casaflux % fromPtoL + casaflux % fromPtoL sum_casaflux % Cnep = sum_casaflux % Cnep + casaflux % Cnep sum_casaflux % Crsoil = sum_casaflux % Crsoil + casaflux % Crsoil sum_casaflux % Nmindep = sum_casaflux % Nmindep + casaflux % Nmindep sum_casaflux % Nminloss = sum_casaflux % Nminloss + casaflux % Nminloss sum_casaflux % Nminleach = sum_casaflux % Nminleach + casaflux % Nminleach sum_casaflux % Nupland = sum_casaflux % Nupland + casaflux % Nupland sum_casaflux % Nlittermin = sum_casaflux % Nlittermin + casaflux % Nlittermin sum_casaflux % Nsmin = sum_casaflux % Nsmin + casaflux % Nsmin sum_casaflux % Nsimm = sum_casaflux % Nsimm + casaflux % Nsimm sum_casaflux % Nsnet = sum_casaflux % Nsnet + casaflux % Nsnet sum_casaflux % fNminloss = sum_casaflux % fNminloss + casaflux % fNminloss sum_casaflux % fNminleach = sum_casaflux % fNminleach + casaflux % fNminleach sum_casaflux % Pdep = sum_casaflux % Pdep + casaflux % Pdep sum_casaflux % Pwea = sum_casaflux % Pwea + casaflux % Pwea sum_casaflux % Pleach = sum_casaflux % Pleach + casaflux % Pleach sum_casaflux % Ploss = sum_casaflux % Ploss + casaflux % Ploss sum_casaflux % Pupland = sum_casaflux % Pupland + casaflux % Pupland sum_casaflux % Plittermin = sum_casaflux % Plittermin + casaflux % Plittermin sum_casaflux % Psmin = sum_casaflux % Psmin + casaflux % Psmin sum_casaflux % Psimm = sum_casaflux % Psimm + casaflux % Psimm sum_casaflux % Psnet = sum_casaflux % Psnet + casaflux % Psnet sum_casaflux % fPleach = sum_casaflux % fPleach + casaflux % fPleach sum_casaflux % kplab = sum_casaflux % kplab + casaflux % kplab sum_casaflux % kpsorb = sum_casaflux % kpsorb + casaflux % kpsorb sum_casaflux % kpocc = sum_casaflux % kpocc + casaflux % kpocc sum_casaflux % kmlabP = sum_casaflux % kmlabP + casaflux % kmlabP sum_casaflux % Psorbmax = sum_casaflux % Psorbmax + casaflux % Psorbmax sum_casaflux % klitter = sum_casaflux % klitter + casaflux % klitter sum_casaflux % ksoil = sum_casaflux % ksoil + casaflux % ksoil sum_casaflux % fromLtoS = sum_casaflux % fromLtoS + casaflux % fromLtoS sum_casaflux % fromStoS = sum_casaflux % fromStoS + casaflux % fromStoS sum_casaflux % fromLtoCO2 = sum_casaflux % fromLtoCO2 + casaflux % fromLtoCO2 sum_casaflux % fromStoCO2 = sum_casaflux % fromStoCO2 + casaflux % fromStoCO2 sum_casaflux % stemnpp = sum_casaflux % stemnpp + casaflux % stemnpp sum_casaflux % frac_sapwood = sum_casaflux % frac_sapwood + casaflux % frac_sapwood sum_casaflux % sapwood_area = sum_casaflux % sapwood_area + casaflux % sapwood_area sum_casaflux % Cplant_turnover = & sum_casaflux % Cplant_turnover + casaflux % Cplant_turnover sum_casaflux % Cplant_turnover_disturbance = & sum_casaflux % Cplant_turnover_disturbance + casaflux % Cplant_turnover_disturbance sum_casaflux % Cplant_turnover_crowding = & sum_casaflux % Cplant_turnover_crowding + casaflux % Cplant_turnover_crowding sum_casaflux % Cplant_turnover_resource_limitation = & sum_casaflux % Cplant_turnover_resource_limitation + casaflux % Cplant_turnover_resource_limitation sum_casaflux % FluxCtolitter = sum_casaflux % FluxCtolitter + casaflux % FluxCtolitter sum_casaflux % FluxNtolitter = sum_casaflux % FluxNtolitter + casaflux % FluxNtolitter sum_casaflux % FluxPtolitter = sum_casaflux % FluxPtolitter + casaflux % FluxPtolitter sum_casaflux % FluxCtosoil = sum_casaflux % FluxCtosoil + casaflux % FluxCtosoil sum_casaflux % FluxNtosoil = sum_casaflux % FluxNtosoil + casaflux % FluxNtosoil sum_casaflux % FluxPtosoil = sum_casaflux % FluxPtosoil + casaflux % FluxPtosoil sum_casaflux % FluxCtoco2 = sum_casaflux % FluxCtoco2 + casaflux % FluxCtoco2 sum_casaflux % fromPtoL_fire = sum_casaflux % fromPtoL_fire + casaflux % fromPtoL_fire sum_casaflux % kplant_fire = sum_casaflux % kplant_fire + casaflux % kplant_fire sum_casaflux % klitter_fire = sum_casaflux % klitter_fire + casaflux % klitter_fire sum_casaflux % kplant_tot = sum_casaflux % kplant_tot + casaflux % kplant_tot sum_casaflux % klitter_tot = sum_casaflux % klitter_tot + casaflux % klitter_tot sum_casaflux % FluxCtoCO2_plant_fire = sum_casaflux % FluxCtoCO2_plant_fire + & casaflux % FluxCtoCO2_plant_fire sum_casaflux % FluxCtoCO2_litter_fire = sum_casaflux % FluxCtoCO2_litter_fire + & casaflux % FluxCtoCO2_litter_fire sum_casaflux % fluxfromPtoCO2_fire = sum_casaflux % fluxfromPtoCO2_fire + & casaflux % fluxfromPtoCO2_fire sum_casaflux % fluxfromLtoCO2_fire = sum_casaflux % fluxfromLtoCO2_fire + & casaflux % fluxfromLtoCO2_fire sum_casaflux % FluxNtoAtm_fire = sum_casaflux % FluxNtoAtm_fire + & casaflux % FluxNtoAtm_fire sum_casaflux % FluxFromPtoL = sum_casaflux % FluxFromPtoL + casaflux % FluxFromPtoL sum_casaflux % FluxFromLtoS = sum_casaflux % FluxFromLtoS + casaflux % FluxFromLtoS sum_casaflux % FluxFromStoS = sum_casaflux % FluxFromStoS + casaflux % FluxFromStoS sum_casaflux % FluxFromPtoCO2 = sum_casaflux % FluxFromPtoCO2 + casaflux % FluxFromPtoCO2 sum_casaflux % FluxFromLtoCO2 = sum_casaflux % FluxFromLtoCO2 + casaflux % FluxFromLtoCO2 sum_casaflux % FluxFromStoCO2 = sum_casaflux % FluxFromStoCO2 + casaflux % FluxFromStoCO2 sum_casaflux % FluxFromPtoHarvest = sum_casaflux % FluxFromPtoHarvest + & casaflux % FluxFromPtoHarvest endif ! sum_now if ( average_now ) then ! sum_casaflux%fracCalloc = sum_casaflux%fracCalloc * rnsteps where ( sum_casaflux % Cnpp > 1.e-12_r_2 ) sum_casaflux % fracCalloc (:, 1 ) = sum_casaflux % fracCalloc (:, 1 ) / sum_casaflux % Cnpp sum_casaflux % fracCalloc (:, 2 ) = sum_casaflux % fracCalloc (:, 2 ) / sum_casaflux % Cnpp sum_casaflux % fracCalloc (:, 3 ) = sum_casaflux % fracCalloc (:, 3 ) / sum_casaflux % Cnpp elsewhere sum_casaflux % fracCalloc (:, 1 ) = 0.0_r_2 sum_casaflux % fracCalloc (:, 2 ) = 0.0_r_2 sum_casaflux % fracCalloc (:, 3 ) = 0.0_r_2 endwhere ! sum_casaflux%kplant = sum_casaflux%kplant * rnsteps where ( sum_casapool % Cplant > 1.e-12_r_2 ) sum_casaflux % kplant = sum_casaflux % kplant / sum_casapool % Cplant elsewhere sum_casaflux % kplant = 0.0_r_2 endwhere sum_casapool % Clabile = sum_casapool % Clabile * rnsteps sum_casapool % dClabiledt = sum_casapool % Clabile * rnsteps sum_casapool % Cplant = sum_casapool % Cplant * rnsteps sum_casapool % Nplant = sum_casapool % Nplant * rnsteps sum_casapool % Pplant = sum_casapool % Pplant * rnsteps sum_casapool % dCplantdt = sum_casapool % dCplantdt * rnsteps sum_casapool % dNplantdt = sum_casapool % dNplantdt * rnsteps sum_casapool % dPplantdt = sum_casapool % dPplantdt * rnsteps sum_casapool % ratioNCplant = sum_casapool % ratioNCplant * rnsteps sum_casapool % ratioNPplant = sum_casapool % ratioNPplant * rnsteps sum_casapool % Nsoilmin = sum_casapool % Nsoilmin * rnsteps sum_casapool % Psoillab = sum_casapool % Psoillab * rnsteps sum_casapool % Psoilsorb = sum_casapool % Psoilsorb * rnsteps sum_casapool % Psoilocc = sum_casapool % Psoilocc * rnsteps sum_casapool % dNsoilmindt = sum_casapool % dNsoilmindt * rnsteps sum_casapool % dPsoillabdt = sum_casapool % dPsoillabdt * rnsteps sum_casapool % dPsoilsorbdt = sum_casapool % dPsoilsorbdt * rnsteps sum_casapool % dPsoiloccdt = sum_casapool % dPsoiloccdt * rnsteps sum_casapool % Clitter = sum_casapool % Clitter * rnsteps sum_casapool % Nlitter = sum_casapool % Nlitter * rnsteps sum_casapool % Plitter = sum_casapool % Plitter * rnsteps sum_casapool % dClitterdt = sum_casapool % dClitterdt * rnsteps sum_casapool % dNlitterdt = sum_casapool % dNlitterdt * rnsteps sum_casapool % dPlitterdt = sum_casapool % dPlitterdt * rnsteps sum_casapool % ratioNClitter = sum_casapool % ratioNClitter * rnsteps sum_casapool % ratioNPlitter = sum_casapool % ratioNPlitter * rnsteps sum_casapool % Csoil = sum_casapool % Csoil * rnsteps sum_casapool % Nsoil = sum_casapool % Nsoil * rnsteps sum_casapool % Psoil = sum_casapool % Psoil * rnsteps sum_casapool % dCsoildt = sum_casapool % dCsoildt * rnsteps sum_casapool % dNsoildt = sum_casapool % dNsoildt * rnsteps sum_casapool % dPsoildt = sum_casapool % dPsoildt * rnsteps sum_casapool % ratioNCsoil = sum_casapool % ratioNCsoil * rnsteps sum_casapool % ratioNPsoil = sum_casapool % ratioNPsoil * rnsteps sum_casapool % ratioNCsoilnew = sum_casapool % ratioNCsoilnew * rnsteps sum_casapool % ratioNCsoilmin = sum_casapool % ratioNCsoilmin * rnsteps sum_casapool % ratioNCsoilmax = sum_casapool % ratioNCsoilmax * rnsteps sum_casapool % ratioPCsoil = sum_casapool % ratioPCsoil * rnsteps sum_casapool % ratioPCplant = sum_casapool % ratioPCplant * rnsteps sum_casapool % ratioPClitter = sum_casapool % ratioPClitter * rnsteps sum_casaflux % Cgpp = sum_casaflux % Cgpp * rnsteps sum_casaflux % Cnpp = sum_casaflux % Cnpp * rnsteps sum_casaflux % Crp = sum_casaflux % Crp * rnsteps sum_casaflux % Crgplant = sum_casaflux % Crgplant * rnsteps sum_casaflux % Nminfix = sum_casaflux % Nminfix * rnsteps sum_casaflux % Nminuptake = sum_casaflux % Nminuptake * rnsteps sum_casaflux % Plabuptake = sum_casaflux % Plabuptake * rnsteps sum_casaflux % Clabloss = sum_casaflux % Clabloss * rnsteps sum_casaflux % fracClabile = sum_casaflux % fracClabile * rnsteps sum_casaflux % fracNalloc = sum_casaflux % fracNalloc * rnsteps sum_casaflux % fracPalloc = sum_casaflux % fracPalloc * rnsteps sum_casaflux % Crmplant = sum_casaflux % Crmplant * rnsteps sum_casaflux % fromPtoL = sum_casaflux % fromPtoL * rnsteps sum_casaflux % Cnep = sum_casaflux % Cnep * rnsteps sum_casaflux % Crsoil = sum_casaflux % Crsoil * rnsteps sum_casaflux % Nmindep = sum_casaflux % Nmindep * rnsteps sum_casaflux % Nminloss = sum_casaflux % Nminloss * rnsteps sum_casaflux % Nminleach = sum_casaflux % Nminleach * rnsteps sum_casaflux % Nupland = sum_casaflux % Nupland * rnsteps sum_casaflux % Nlittermin = sum_casaflux % Nlittermin * rnsteps sum_casaflux % Nsmin = sum_casaflux % Nsmin * rnsteps sum_casaflux % Nsimm = sum_casaflux % Nsimm * rnsteps sum_casaflux % Nsnet = sum_casaflux % Nsnet * rnsteps sum_casaflux % fNminloss = sum_casaflux % fNminloss * rnsteps sum_casaflux % fNminleach = sum_casaflux % fNminleach * rnsteps sum_casaflux % Pdep = sum_casaflux % Pdep * rnsteps sum_casaflux % Pwea = sum_casaflux % Pwea * rnsteps sum_casaflux % Pleach = sum_casaflux % Pleach * rnsteps sum_casaflux % Ploss = sum_casaflux % Ploss * rnsteps sum_casaflux % Pupland = sum_casaflux % Pupland * rnsteps sum_casaflux % Plittermin = sum_casaflux % Plittermin * rnsteps sum_casaflux % Psmin = sum_casaflux % Psmin * rnsteps sum_casaflux % Psimm = sum_casaflux % Psimm * rnsteps sum_casaflux % Psnet = sum_casaflux % Psnet * rnsteps sum_casaflux % fPleach = sum_casaflux % fPleach * rnsteps sum_casaflux % kplab = sum_casaflux % kplab * rnsteps sum_casaflux % kpsorb = sum_casaflux % kpsorb * rnsteps sum_casaflux % kpocc = sum_casaflux % kpocc * rnsteps sum_casaflux % kmlabP = sum_casaflux % kmlabP * rnsteps sum_casaflux % Psorbmax = sum_casaflux % Psorbmax * rnsteps sum_casaflux % klitter = sum_casaflux % klitter * rnsteps sum_casaflux % ksoil = sum_casaflux % ksoil * rnsteps sum_casaflux % fromLtoS = sum_casaflux % fromLtoS * rnsteps sum_casaflux % fromStoS = sum_casaflux % fromStoS * rnsteps sum_casaflux % fromLtoCO2 = sum_casaflux % fromLtoCO2 * rnsteps sum_casaflux % fromStoCO2 = sum_casaflux % fromStoCO2 * rnsteps sum_casaflux % stemnpp = sum_casaflux % stemnpp * rnsteps sum_casaflux % frac_sapwood = sum_casaflux % frac_sapwood * rnsteps sum_casaflux % sapwood_area = sum_casaflux % sapwood_area * rnsteps sum_casaflux % Cplant_turnover = & sum_casaflux % Cplant_turnover * rnsteps sum_casaflux % Cplant_turnover_disturbance = & casaflux % Cplant_turnover_disturbance * rnsteps sum_casaflux % Cplant_turnover_crowding = & sum_casaflux % Cplant_turnover_crowding * rnsteps sum_casaflux % Cplant_turnover_resource_limitation = & sum_casaflux % Cplant_turnover_resource_limitation * rnsteps sum_casaflux % FluxCtolitter = sum_casaflux % FluxCtolitter * rnsteps sum_casaflux % FluxNtolitter = sum_casaflux % FluxNtolitter * rnsteps sum_casaflux % FluxPtolitter = sum_casaflux % FluxPtolitter * rnsteps sum_casaflux % FluxCtosoil = sum_casaflux % FluxCtosoil * rnsteps sum_casaflux % FluxNtosoil = sum_casaflux % FluxNtosoil * rnsteps sum_casaflux % FluxPtosoil = sum_casaflux % FluxPtosoil * rnsteps sum_casaflux % FluxCtoco2 = sum_casaflux % FluxCtoco2 * rnsteps sum_casaflux % fromPtoL_fire = sum_casaflux % fromPtoL_fire * rnsteps sum_casaflux % kplant_fire = sum_casaflux % kplant_fire * rnsteps sum_casaflux % klitter_fire = sum_casaflux % klitter_fire * rnsteps sum_casaflux % kplant_tot = sum_casaflux % kplant_tot * rnsteps sum_casaflux % klitter_tot = sum_casaflux % klitter_tot * rnsteps sum_casaflux % FluxCtoCO2_plant_fire = sum_casaflux % FluxCtoCO2_plant_fire * rnsteps sum_casaflux % FluxCtoCO2_litter_fire = sum_casaflux % FluxCtoCO2_litter_fire * rnsteps sum_casaflux % fluxfromPtoCO2_fire = sum_casaflux % fluxfromPtoCO2_fire * rnsteps sum_casaflux % fluxfromLtoCO2_fire = sum_casaflux % fluxfromLtoCO2_fire * rnsteps sum_casaflux % FluxNtoAtm_fire = sum_casaflux % FluxNtoAtm_fire * rnsteps sum_casaflux % FluxFromPtoL = sum_casaflux % FluxFromPtoL * rnsteps sum_casaflux % FluxFromLtoS = sum_casaflux % FluxFromLtoS * rnsteps sum_casaflux % FluxFromStoS = sum_casaflux % FluxFromStoS * rnsteps sum_casaflux % FluxFromPtoCO2 = sum_casaflux % FluxFromPtoCO2 * rnsteps sum_casaflux % FluxFromLtoCO2 = sum_casaflux % FluxFromLtoCO2 * rnsteps sum_casaflux % FluxFromStoCO2 = sum_casaflux % FluxFromStoCO2 * rnsteps sum_casaflux % FluxFromPtoHarvest = sum_casaflux % FluxFromPtoHarvest * rnsteps endif ! average_now end subroutine update_sum_casa ! ------------------------------------------------------------------ subroutine read_netcdf_casabiome ( filename , casabiome ) use netcdf , only : nf90_open , nf90_nowrite , & nf90_inq_varid , nf90_get_var , nf90_close #ifdef __MPI__ use mpi , only : MPI_Abort #endif use cable_def_types_mod , only : nc_err implicit none character ( len =* ), intent ( in ) :: filename type ( casa_biome ), intent ( inout ) :: casabiome logical :: existfile integer :: fid , vid #ifdef __MPI__ integer :: ierr #endif ! open netCDF file inquire ( file = trim ( filename ), exist = existfile ) if (. not . existfile ) then write ( * , * ) filename , ' does not exist!' #ifdef __MPI__ call MPI_Abort ( 0 , 173 , ierr ) #else stop 173 #endif endif ! open netCDF file call nc_err ( nf90_open ( trim ( filename ), nf90_nowrite , fid )) ! read variables ! integer vectors call nc_err ( nf90_inq_varid ( fid , 'ivt2' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % ivt2 )) ! double vectors call nc_err ( nf90_inq_varid ( fid , 'xkleafcoldmax' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % xkleafcoldmax )) call nc_err ( nf90_inq_varid ( fid , 'xkleafcoldexp' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % xkleafcoldexp )) call nc_err ( nf90_inq_varid ( fid , 'xkleafdrymax' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % xkleafdrymax )) call nc_err ( nf90_inq_varid ( fid , 'xkleafdryexp' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % xkleafdryexp )) call nc_err ( nf90_inq_varid ( fid , 'glaimax' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % glaimax )) call nc_err ( nf90_inq_varid ( fid , 'glaimin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % glaimin )) call nc_err ( nf90_inq_varid ( fid , 'sla' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % sla )) call nc_err ( nf90_inq_varid ( fid , 'ratiofrootleaf' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % ratiofrootleaf )) call nc_err ( nf90_inq_varid ( fid , 'kroot' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % kroot )) call nc_err ( nf90_inq_varid ( fid , 'krootlen' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % krootlen )) call nc_err ( nf90_inq_varid ( fid , 'rootdepth' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % rootdepth )) call nc_err ( nf90_inq_varid ( fid , 'kuptake' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % kuptake )) call nc_err ( nf90_inq_varid ( fid , 'kminn' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % kminn )) call nc_err ( nf90_inq_varid ( fid , 'kuplabp' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % kuplabp )) call nc_err ( nf90_inq_varid ( fid , 'kclabrate' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % kclabrate )) call nc_err ( nf90_inq_varid ( fid , 'xnpmax' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % xnpmax )) call nc_err ( nf90_inq_varid ( fid , 'q10soil' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % q10soil )) call nc_err ( nf90_inq_varid ( fid , 'xkoptlitter' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % xkoptlitter )) call nc_err ( nf90_inq_varid ( fid , 'xkoptsoil' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % xkoptsoil )) call nc_err ( nf90_inq_varid ( fid , 'xkplab' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % xkplab )) call nc_err ( nf90_inq_varid ( fid , 'xkpsorb' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % xkpsorb )) call nc_err ( nf90_inq_varid ( fid , 'xkpocc' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % xkpocc )) call nc_err ( nf90_inq_varid ( fid , 'prodptase' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % prodptase )) call nc_err ( nf90_inq_varid ( fid , 'costnpup' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % costnpup )) call nc_err ( nf90_inq_varid ( fid , 'maxfinelitter' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % maxfinelitter )) call nc_err ( nf90_inq_varid ( fid , 'maxcwd' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % maxcwd )) call nc_err ( nf90_inq_varid ( fid , 'nintercept' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % nintercept )) call nc_err ( nf90_inq_varid ( fid , 'nslope' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % nslope )) call nc_err ( nf90_inq_varid ( fid , 'la_to_sa' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % la_to_sa )) call nc_err ( nf90_inq_varid ( fid , 'vcmax_scalar' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % vcmax_scalar )) call nc_err ( nf90_inq_varid ( fid , 'disturbance_interval' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % disturbance_interval )) call nc_err ( nf90_inq_varid ( fid , 'damm_enzpool' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % damm_enzpool )) call nc_err ( nf90_inq_varid ( fid , 'damm_kmo2' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % damm_kmo2 )) call nc_err ( nf90_inq_varid ( fid , 'damm_kmcp' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % damm_kmcp )) call nc_err ( nf90_inq_varid ( fid , 'damm_ea' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % damm_ea )) call nc_err ( nf90_inq_varid ( fid , 'damm_alpha' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % damm_alpha )) ! double arrays call nc_err ( nf90_inq_varid ( fid , 'plantrate' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % plantrate )) call nc_err ( nf90_inq_varid ( fid , 'rmplant' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % rmplant )) call nc_err ( nf90_inq_varid ( fid , 'fracnpptop' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % fracnpptop )) call nc_err ( nf90_inq_varid ( fid , 'fraclignin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % fraclignin )) call nc_err ( nf90_inq_varid ( fid , 'fraclabile' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % fraclabile )) call nc_err ( nf90_inq_varid ( fid , 'rationcplantmin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % rationcplantmin )) call nc_err ( nf90_inq_varid ( fid , 'rationcplantmax' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % rationcplantmax )) call nc_err ( nf90_inq_varid ( fid , 'rationpplantmin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % rationpplantmin )) call nc_err ( nf90_inq_varid ( fid , 'rationpplantmax' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % rationpplantmax )) call nc_err ( nf90_inq_varid ( fid , 'fracligninplant' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % fracligninplant )) call nc_err ( nf90_inq_varid ( fid , 'ftransnptol' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % ftransnptol )) call nc_err ( nf90_inq_varid ( fid , 'ftranspptol' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % ftranspptol )) call nc_err ( nf90_inq_varid ( fid , 'litterrate' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % litterrate )) call nc_err ( nf90_inq_varid ( fid , 'ratiopcplantmin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % ratiopcplantmin )) call nc_err ( nf90_inq_varid ( fid , 'ratiopcplantmax' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % ratiopcplantmax )) call nc_err ( nf90_inq_varid ( fid , 'soilrate' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabiome % soilrate )) ! close NetCDF file call nc_err ( nf90_close ( fid )) end subroutine read_netcdf_casabiome subroutine read_netcdf_casapool ( filename , casapool ) use netcdf , only : nf90_open , nf90_nowrite , & nf90_inq_varid , nf90_get_var , nf90_close #ifdef __MPI__ use mpi , only : MPI_Abort #endif use cable_def_types_mod , only : nc_err implicit none character ( len =* ), intent ( in ) :: filename type ( casa_pool ), intent ( inout ) :: casapool logical :: existfile integer :: fid , vid #ifdef __MPI__ integer :: ierr #endif ! open netCDF file inquire ( file = trim ( filename ), exist = existfile ) if (. not . existfile ) then write ( * , * ) filename , ' does not exist!' #ifdef __MPI__ call MPI_Abort ( 0 , 174 , ierr ) #else stop 174 #endif endif ! open netCDF file call nc_err ( nf90_open ( trim ( filename ), nf90_nowrite , fid )) ! read variables call nc_err ( nf90_inq_varid ( fid , 'clabile' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % clabile )) call nc_err ( nf90_inq_varid ( fid , 'dclabiledt' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % dclabiledt )) call nc_err ( nf90_inq_varid ( fid , 'ctot' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % ctot )) call nc_err ( nf90_inq_varid ( fid , 'ctot_0' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % ctot_0 )) call nc_err ( nf90_inq_varid ( fid , 'cplant' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % cplant )) call nc_err ( nf90_inq_varid ( fid , 'nplant' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % nplant )) call nc_err ( nf90_inq_varid ( fid , 'pplant' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % pplant )) call nc_err ( nf90_inq_varid ( fid , 'dcplantdt' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % dcplantdt )) call nc_err ( nf90_inq_varid ( fid , 'dnplantdt' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % dnplantdt )) call nc_err ( nf90_inq_varid ( fid , 'dpplantdt' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % dpplantdt )) call nc_err ( nf90_inq_varid ( fid , 'rationcplant' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % rationcplant )) call nc_err ( nf90_inq_varid ( fid , 'rationpplant' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % rationpplant )) call nc_err ( nf90_inq_varid ( fid , 'nsoilmin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % nsoilmin )) call nc_err ( nf90_inq_varid ( fid , 'psoillab' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % psoillab )) call nc_err ( nf90_inq_varid ( fid , 'psoilsorb' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % psoilsorb )) call nc_err ( nf90_inq_varid ( fid , 'psoilocc' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % psoilocc )) call nc_err ( nf90_inq_varid ( fid , 'dnsoilmindt' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % dnsoilmindt )) call nc_err ( nf90_inq_varid ( fid , 'dpsoillabdt' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % dpsoillabdt )) call nc_err ( nf90_inq_varid ( fid , 'dpsoilsorbdt' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % dpsoilsorbdt )) call nc_err ( nf90_inq_varid ( fid , 'dpsoiloccdt' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % dpsoiloccdt )) call nc_err ( nf90_inq_varid ( fid , 'clitter' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % clitter )) call nc_err ( nf90_inq_varid ( fid , 'nlitter' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % nlitter )) call nc_err ( nf90_inq_varid ( fid , 'plitter' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % plitter )) call nc_err ( nf90_inq_varid ( fid , 'dclitterdt' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % dclitterdt )) call nc_err ( nf90_inq_varid ( fid , 'dnlitterdt' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % dnlitterdt )) call nc_err ( nf90_inq_varid ( fid , 'dplitterdt' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % dplitterdt )) call nc_err ( nf90_inq_varid ( fid , 'rationclitter' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % rationclitter )) call nc_err ( nf90_inq_varid ( fid , 'rationplitter' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % rationplitter )) call nc_err ( nf90_inq_varid ( fid , 'csoil' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % csoil )) call nc_err ( nf90_inq_varid ( fid , 'nsoil' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % nsoil )) call nc_err ( nf90_inq_varid ( fid , 'psoil' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % psoil )) call nc_err ( nf90_inq_varid ( fid , 'dcsoildt' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % dcsoildt )) call nc_err ( nf90_inq_varid ( fid , 'dnsoildt' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % dnsoildt )) call nc_err ( nf90_inq_varid ( fid , 'dpsoildt' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % dpsoildt )) call nc_err ( nf90_inq_varid ( fid , 'rationcsoil' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % rationcsoil )) call nc_err ( nf90_inq_varid ( fid , 'rationcsoilnew' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % rationcsoilnew )) call nc_err ( nf90_inq_varid ( fid , 'rationpsoil' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % rationpsoil )) call nc_err ( nf90_inq_varid ( fid , 'rationcsoilmin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % rationcsoilmin )) call nc_err ( nf90_inq_varid ( fid , 'rationcsoilmax' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % rationcsoilmax )) call nc_err ( nf90_inq_varid ( fid , 'ratiopcsoil' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % ratiopcsoil )) call nc_err ( nf90_inq_varid ( fid , 'ratiopcplant' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % ratiopcplant )) call nc_err ( nf90_inq_varid ( fid , 'ratiopclitter' , vid )) call nc_err ( nf90_get_var ( fid , vid , casapool % ratiopclitter )) ! close NetCDF file call nc_err ( nf90_close ( fid )) end subroutine read_netcdf_casapool subroutine read_netcdf_casaflux ( filename , casaflux ) use netcdf , only : nf90_open , nf90_nowrite , & nf90_inq_varid , nf90_get_var , nf90_close #ifdef __MPI__ use mpi , only : MPI_Abort #endif use cable_def_types_mod , only : nc_err implicit none character ( len =* ), intent ( in ) :: filename type ( casa_flux ), intent ( inout ) :: casaflux logical :: existfile integer :: fid , vid #ifdef __MPI__ integer :: ierr #endif ! open netCDF file inquire ( file = trim ( filename ), exist = existfile ) if (. not . existfile ) then write ( * , * ) filename , ' does not exist!' #ifdef __MPI__ call MPI_Abort ( 0 , 175 , ierr ) #else stop 175 #endif endif ! open netCDF file call nc_err ( nf90_open ( trim ( filename ), nf90_nowrite , fid )) ! read variables call nc_err ( nf90_inq_varid ( fid , 'cgpp' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % cgpp )) call nc_err ( nf90_inq_varid ( fid , 'cnpp' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % cnpp )) call nc_err ( nf90_inq_varid ( fid , 'crp' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % crp )) call nc_err ( nf90_inq_varid ( fid , 'crgplant' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % crgplant )) call nc_err ( nf90_inq_varid ( fid , 'nminfix' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % nminfix )) call nc_err ( nf90_inq_varid ( fid , 'nminuptake' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % nminuptake )) call nc_err ( nf90_inq_varid ( fid , 'plabuptake' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % plabuptake )) call nc_err ( nf90_inq_varid ( fid , 'clabloss' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % clabloss )) call nc_err ( nf90_inq_varid ( fid , 'fracclabile' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fracclabile )) call nc_err ( nf90_inq_varid ( fid , 'stemnpp' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % stemnpp )) call nc_err ( nf90_inq_varid ( fid , 'frac_sapwood' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % frac_sapwood )) call nc_err ( nf90_inq_varid ( fid , 'sapwood_area' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % sapwood_area )) call nc_err ( nf90_inq_varid ( fid , 'charvest' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % charvest )) call nc_err ( nf90_inq_varid ( fid , 'nharvest' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % nharvest )) call nc_err ( nf90_inq_varid ( fid , 'pharvest' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % pharvest )) call nc_err ( nf90_inq_varid ( fid , 'fharvest' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fharvest )) call nc_err ( nf90_inq_varid ( fid , 'fcrop' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fcrop )) call nc_err ( nf90_inq_varid ( fid , 'fraccalloc' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fraccalloc )) call nc_err ( nf90_inq_varid ( fid , 'fracnalloc' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fracnalloc )) call nc_err ( nf90_inq_varid ( fid , 'fracpalloc' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fracpalloc )) call nc_err ( nf90_inq_varid ( fid , 'crmplant' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % crmplant )) call nc_err ( nf90_inq_varid ( fid , 'kplant' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % kplant )) call nc_err ( nf90_inq_varid ( fid , 'cplant_turnover' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % cplant_turnover )) call nc_err ( nf90_inq_varid ( fid , 'fromptol' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fromptol )) call nc_err ( nf90_inq_varid ( fid , 'cnep' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % cnep )) call nc_err ( nf90_inq_varid ( fid , 'crsoil' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % crsoil )) call nc_err ( nf90_inq_varid ( fid , 'nmindep' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % nmindep )) call nc_err ( nf90_inq_varid ( fid , 'nminloss' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % nminloss )) call nc_err ( nf90_inq_varid ( fid , 'nminleach' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % nminleach )) call nc_err ( nf90_inq_varid ( fid , 'nupland' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % nupland )) call nc_err ( nf90_inq_varid ( fid , 'nlittermin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % nlittermin )) call nc_err ( nf90_inq_varid ( fid , 'nsmin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % nsmin )) call nc_err ( nf90_inq_varid ( fid , 'nsimm' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % nsimm )) call nc_err ( nf90_inq_varid ( fid , 'nsnet' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % nsnet )) call nc_err ( nf90_inq_varid ( fid , 'fnminloss' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fnminloss )) call nc_err ( nf90_inq_varid ( fid , 'fnminleach' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fnminleach )) call nc_err ( nf90_inq_varid ( fid , 'pdep' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % pdep )) call nc_err ( nf90_inq_varid ( fid , 'pwea' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % pwea )) call nc_err ( nf90_inq_varid ( fid , 'pleach' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % pleach )) call nc_err ( nf90_inq_varid ( fid , 'ploss' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % ploss )) call nc_err ( nf90_inq_varid ( fid , 'pupland' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % pupland )) call nc_err ( nf90_inq_varid ( fid , 'plittermin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % plittermin )) call nc_err ( nf90_inq_varid ( fid , 'psmin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % psmin )) call nc_err ( nf90_inq_varid ( fid , 'psimm' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % psimm )) call nc_err ( nf90_inq_varid ( fid , 'psnet' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % psnet )) call nc_err ( nf90_inq_varid ( fid , 'fpleach' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fpleach )) call nc_err ( nf90_inq_varid ( fid , 'kplab' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % kplab )) call nc_err ( nf90_inq_varid ( fid , 'kpsorb' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % kpsorb )) call nc_err ( nf90_inq_varid ( fid , 'kpocc' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % kpocc )) call nc_err ( nf90_inq_varid ( fid , 'kmlabp' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % kmlabp )) call nc_err ( nf90_inq_varid ( fid , 'psorbmax' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % psorbmax )) call nc_err ( nf90_inq_varid ( fid , 'cplant_turnover_disturbance' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % cplant_turnover_disturbance )) call nc_err ( nf90_inq_varid ( fid , 'cplant_turnover_crowding' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % cplant_turnover_crowding )) call nc_err ( nf90_inq_varid ( fid , 'cplant_turnover_resource_limitation' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % cplant_turnover_resource_limitation )) call nc_err ( nf90_inq_varid ( fid , 'klitter' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % klitter )) call nc_err ( nf90_inq_varid ( fid , 'ksoil' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % ksoil )) call nc_err ( nf90_inq_varid ( fid , 'fromltos' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fromltos )) call nc_err ( nf90_inq_varid ( fid , 'fromstos' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fromstos )) call nc_err ( nf90_inq_varid ( fid , 'fromltoco2' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fromltoco2 )) call nc_err ( nf90_inq_varid ( fid , 'fromstoco2' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fromstoco2 )) call nc_err ( nf90_inq_varid ( fid , 'fluxctolitter' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxctolitter )) call nc_err ( nf90_inq_varid ( fid , 'fluxntolitter' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxntolitter )) call nc_err ( nf90_inq_varid ( fid , 'fluxptolitter' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxptolitter )) call nc_err ( nf90_inq_varid ( fid , 'fluxctosoil' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxctosoil )) call nc_err ( nf90_inq_varid ( fid , 'fluxntosoil' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxntosoil )) call nc_err ( nf90_inq_varid ( fid , 'fluxptosoil' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxptosoil )) call nc_err ( nf90_inq_varid ( fid , 'fluxctoco2' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxctoco2 )) call nc_err ( nf90_inq_varid ( fid , 'fluxctohwp' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxctohwp )) call nc_err ( nf90_inq_varid ( fid , 'fluxntohwp' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxntohwp )) call nc_err ( nf90_inq_varid ( fid , 'fluxptohwp' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxptohwp )) call nc_err ( nf90_inq_varid ( fid , 'fluxctoclear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxctoclear )) call nc_err ( nf90_inq_varid ( fid , 'fluxntoclear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxntoclear )) call nc_err ( nf90_inq_varid ( fid , 'fluxptoclear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxptoclear )) call nc_err ( nf90_inq_varid ( fid , 'ctransferluc' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % ctransferluc )) call nc_err ( nf90_inq_varid ( fid , 'fromptol_fire' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fromptol_fire )) call nc_err ( nf90_inq_varid ( fid , 'klitter_fire' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % klitter_fire )) call nc_err ( nf90_inq_varid ( fid , 'klitter_tot' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % klitter_tot )) call nc_err ( nf90_inq_varid ( fid , 'kplant_fire' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % kplant_fire )) call nc_err ( nf90_inq_varid ( fid , 'kplant_tot' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % kplant_tot )) call nc_err ( nf90_inq_varid ( fid , 'fluxctoco2_plant_fire' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxctoco2_plant_fire )) call nc_err ( nf90_inq_varid ( fid , 'fluxctoco2_litter_fire' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxctoco2_litter_fire )) call nc_err ( nf90_inq_varid ( fid , 'fluxfromptoco2_fire' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxfromptoco2_fire )) call nc_err ( nf90_inq_varid ( fid , 'fluxfromltoco2_fire' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxfromltoco2_fire )) call nc_err ( nf90_inq_varid ( fid , 'fluxntoatm_fire' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxntoatm_fire )) call nc_err ( nf90_inq_varid ( fid , 'fluxfromptol' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxfromptol )) call nc_err ( nf90_inq_varid ( fid , 'fluxfromltos' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxfromltos )) call nc_err ( nf90_inq_varid ( fid , 'fluxfromstos' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxfromstos )) call nc_err ( nf90_inq_varid ( fid , 'fluxfromptoco2' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxfromptoco2 )) call nc_err ( nf90_inq_varid ( fid , 'fluxfromltoco2' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxfromltoco2 )) call nc_err ( nf90_inq_varid ( fid , 'fluxfromstoco2' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxfromstoco2 )) call nc_err ( nf90_inq_varid ( fid , 'fluxfromptoharvest' , vid )) call nc_err ( nf90_get_var ( fid , vid , casaflux % fluxfromptoharvest )) ! close NetCDF file call nc_err ( nf90_close ( fid )) end subroutine read_netcdf_casaflux subroutine read_netcdf_casamet ( filename , casamet ) use netcdf , only : nf90_open , nf90_nowrite , & nf90_inq_varid , nf90_get_var , nf90_close #ifdef __MPI__ use mpi , only : MPI_Abort #endif use cable_def_types_mod , only : nc_err implicit none character ( len =* ), intent ( in ) :: filename type ( casa_met ), intent ( inout ) :: casamet logical :: existfile integer :: fid , vid #ifdef __MPI__ integer :: ierr #endif ! open netCDF file inquire ( file = trim ( filename ), exist = existfile ) if (. not . existfile ) then write ( * , * ) filename , ' does not exist!' #ifdef __MPI__ call MPI_Abort ( 0 , 176 , ierr ) #else stop 176 #endif endif ! open netCDF file call nc_err ( nf90_open ( trim ( filename ), nf90_nowrite , fid )) ! read variables call nc_err ( nf90_inq_varid ( fid , 'glai' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % glai )) call nc_err ( nf90_inq_varid ( fid , 'tairk' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % tairk )) call nc_err ( nf90_inq_varid ( fid , 'precip' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % precip )) call nc_err ( nf90_inq_varid ( fid , 'tsoilavg' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % tsoilavg )) call nc_err ( nf90_inq_varid ( fid , 'moistavg' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % moistavg )) call nc_err ( nf90_inq_varid ( fid , 'btran' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % btran )) call nc_err ( nf90_inq_varid ( fid , 'lnonwood' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % lnonwood )) call nc_err ( nf90_inq_varid ( fid , 'tsoil' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % tsoil )) call nc_err ( nf90_inq_varid ( fid , 'moist' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % moist )) call nc_err ( nf90_inq_varid ( fid , 'iveg2' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % iveg2 )) call nc_err ( nf90_inq_varid ( fid , 'ijgcm' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % ijgcm )) call nc_err ( nf90_inq_varid ( fid , 'isorder' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % isorder )) call nc_err ( nf90_inq_varid ( fid , 'lat' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % lat )) call nc_err ( nf90_inq_varid ( fid , 'lon' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % lon )) call nc_err ( nf90_inq_varid ( fid , 'areacell' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % areacell )) call nc_err ( nf90_inq_varid ( fid , 'tairkspin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % tairkspin )) call nc_err ( nf90_inq_varid ( fid , 'cgppspin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % cgppspin )) call nc_err ( nf90_inq_varid ( fid , 'crmplantspin_1' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % crmplantspin_1 )) call nc_err ( nf90_inq_varid ( fid , 'crmplantspin_2' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % crmplantspin_2 )) call nc_err ( nf90_inq_varid ( fid , 'crmplantspin_3' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % crmplantspin_3 )) call nc_err ( nf90_inq_varid ( fid , 'tsoilspin_1' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % tsoilspin_1 )) call nc_err ( nf90_inq_varid ( fid , 'tsoilspin_2' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % tsoilspin_2 )) call nc_err ( nf90_inq_varid ( fid , 'tsoilspin_3' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % tsoilspin_3 )) call nc_err ( nf90_inq_varid ( fid , 'tsoilspin_4' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % tsoilspin_4 )) call nc_err ( nf90_inq_varid ( fid , 'tsoilspin_5' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % tsoilspin_5 )) call nc_err ( nf90_inq_varid ( fid , 'tsoilspin_6' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % tsoilspin_6 )) call nc_err ( nf90_inq_varid ( fid , 'moistspin_1' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % moistspin_1 )) call nc_err ( nf90_inq_varid ( fid , 'moistspin_2' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % moistspin_2 )) call nc_err ( nf90_inq_varid ( fid , 'moistspin_3' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % moistspin_3 )) call nc_err ( nf90_inq_varid ( fid , 'moistspin_4' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % moistspin_4 )) call nc_err ( nf90_inq_varid ( fid , 'moistspin_5' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % moistspin_5 )) call nc_err ( nf90_inq_varid ( fid , 'moistspin_6' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % moistspin_6 )) call nc_err ( nf90_inq_varid ( fid , 'mtempspin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % mtempspin )) call nc_err ( nf90_inq_varid ( fid , 'frecspin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % frecspin )) call nc_err ( nf90_inq_varid ( fid , 'can12spin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % can12spin )) call nc_err ( nf90_inq_varid ( fid , 'can13spin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % can13spin )) call nc_err ( nf90_inq_varid ( fid , 'dprecip_spin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % dprecip_spin )) call nc_err ( nf90_inq_varid ( fid , 'aprecip_av20_spin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % aprecip_av20_spin )) call nc_err ( nf90_inq_varid ( fid , 'du10_max_spin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % du10_max_spin )) call nc_err ( nf90_inq_varid ( fid , 'drhum_spin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % drhum_spin )) call nc_err ( nf90_inq_varid ( fid , 'dtemp_max_spin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % dtemp_max_spin )) call nc_err ( nf90_inq_varid ( fid , 'dtemp_min_spin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % dtemp_min_spin )) call nc_err ( nf90_inq_varid ( fid , 'kbdi_spin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % kbdi_spin )) call nc_err ( nf90_inq_varid ( fid , 'd_macarthur_spin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % d_macarthur_spin )) call nc_err ( nf90_inq_varid ( fid , 'ffdi_spin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % ffdi_spin )) call nc_err ( nf90_inq_varid ( fid , 'last_precip_spin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % last_precip_spin )) call nc_err ( nf90_inq_varid ( fid , 'dslr_spin' , vid )) call nc_err ( nf90_get_var ( fid , vid , casamet % dslr_spin )) ! close NetCDF file call nc_err ( nf90_close ( fid )) end subroutine read_netcdf_casamet subroutine read_netcdf_casabal ( filename , casabal ) use netcdf , only : nf90_open , nf90_nowrite , & nf90_inq_varid , nf90_get_var , nf90_close #ifdef __MPI__ use mpi , only : MPI_Abort #endif use cable_def_types_mod , only : nc_err implicit none character ( len =* ), intent ( in ) :: filename type ( casa_balance ), intent ( inout ) :: casabal logical :: existfile integer :: fid , vid #ifdef __MPI__ integer :: ierr #endif ! open netCDF file inquire ( file = trim ( filename ), exist = existfile ) if (. not . existfile ) then write ( * , * ) filename , ' does not exist!' #ifdef __MPI__ call MPI_Abort ( 0 , 177 , ierr ) #else stop 177 #endif endif ! open netCDF file call nc_err ( nf90_open ( trim ( filename ), nf90_nowrite , fid )) ! read variables call nc_err ( nf90_inq_varid ( fid , 'fcgppyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fcgppyear )) call nc_err ( nf90_inq_varid ( fid , 'fcnppyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fcnppyear )) call nc_err ( nf90_inq_varid ( fid , 'fcrmleafyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fcrmleafyear )) call nc_err ( nf90_inq_varid ( fid , 'fcrmwoodyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fcrmwoodyear )) call nc_err ( nf90_inq_varid ( fid , 'fcrmrootyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fcrmrootyear )) call nc_err ( nf90_inq_varid ( fid , 'fcrgrowyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fcrgrowyear )) call nc_err ( nf90_inq_varid ( fid , 'fcrpyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fcrpyear )) call nc_err ( nf90_inq_varid ( fid , 'fcrsyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fcrsyear )) call nc_err ( nf90_inq_varid ( fid , 'fcneeyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fcneeyear )) call nc_err ( nf90_inq_varid ( fid , 'dcdtyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % dcdtyear )) call nc_err ( nf90_inq_varid ( fid , 'laimax' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % laimax )) call nc_err ( nf90_inq_varid ( fid , 'cleafmean' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % cleafmean )) call nc_err ( nf90_inq_varid ( fid , 'crootmean' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % crootmean )) call nc_err ( nf90_inq_varid ( fid , 'fndepyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fndepyear )) call nc_err ( nf90_inq_varid ( fid , 'fnfixyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fnfixyear )) call nc_err ( nf90_inq_varid ( fid , 'fnsnetyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fnsnetyear )) call nc_err ( nf90_inq_varid ( fid , 'fnupyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fnupyear )) call nc_err ( nf90_inq_varid ( fid , 'fnleachyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fnleachyear )) call nc_err ( nf90_inq_varid ( fid , 'fnlossyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fnlossyear )) call nc_err ( nf90_inq_varid ( fid , 'fpweayear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fpweayear )) call nc_err ( nf90_inq_varid ( fid , 'fpdustyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fpdustyear )) call nc_err ( nf90_inq_varid ( fid , 'fpsnetyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fpsnetyear )) call nc_err ( nf90_inq_varid ( fid , 'fpupyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fpupyear )) call nc_err ( nf90_inq_varid ( fid , 'fpleachyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fpleachyear )) call nc_err ( nf90_inq_varid ( fid , 'fplossyear' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % fplossyear )) call nc_err ( nf90_inq_varid ( fid , 'glaimon' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % glaimon )) call nc_err ( nf90_inq_varid ( fid , 'glaimonx' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % glaimonx )) call nc_err ( nf90_inq_varid ( fid , 'cplantlast' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % cplantlast )) call nc_err ( nf90_inq_varid ( fid , 'nplantlast' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % nplantlast )) call nc_err ( nf90_inq_varid ( fid , 'pplantlast' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % pplantlast )) call nc_err ( nf90_inq_varid ( fid , 'clitterlast' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % clitterlast )) call nc_err ( nf90_inq_varid ( fid , 'nlitterlast' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % nlitterlast )) call nc_err ( nf90_inq_varid ( fid , 'plitterlast' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % plitterlast )) call nc_err ( nf90_inq_varid ( fid , 'csoillast' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % csoillast )) call nc_err ( nf90_inq_varid ( fid , 'nsoillast' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % nsoillast )) call nc_err ( nf90_inq_varid ( fid , 'psoillast' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % psoillast )) call nc_err ( nf90_inq_varid ( fid , 'nsoilminlast' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % nsoilminlast )) call nc_err ( nf90_inq_varid ( fid , 'psoillablast' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % psoillablast )) call nc_err ( nf90_inq_varid ( fid , 'psoilsorblast' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % psoilsorblast )) call nc_err ( nf90_inq_varid ( fid , 'psoilocclast' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % psoilocclast )) call nc_err ( nf90_inq_varid ( fid , 'cbalance' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % cbalance )) call nc_err ( nf90_inq_varid ( fid , 'nbalance' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % nbalance )) call nc_err ( nf90_inq_varid ( fid , 'pbalance' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % pbalance )) call nc_err ( nf90_inq_varid ( fid , 'sumcbal' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % sumcbal )) call nc_err ( nf90_inq_varid ( fid , 'sumnbal' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % sumnbal )) call nc_err ( nf90_inq_varid ( fid , 'sumpbal' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % sumpbal )) call nc_err ( nf90_inq_varid ( fid , 'clabilelast' , vid )) call nc_err ( nf90_get_var ( fid , vid , casabal % clabilelast )) ! close NetCDF file call nc_err ( nf90_close ( fid )) end subroutine read_netcdf_casabal ! ------------------------------------------------------------------ subroutine write_netcdf_casabiome ( filename , casabiome ) use netcdf , only : nf90_create , nf90_clobber , nf90_64bit_offset , & nf90_def_dim , nf90_def_var , nf90_int , nf90_double , & nf90_enddef , nf90_put_var , nf90_close use cable_def_types_mod , only : nc_err implicit none character ( len =* ), intent ( in ) :: filename type ( casa_biome ), intent ( in ) :: casabiome integer :: fid integer :: dimid1 , dimid2 , dimid3 , dimid4 integer :: i integer , dimension ( ncasa_biome ) :: vid ! create netCDF file call nc_err ( nf90_create ( trim ( filename ), ior ( nf90_clobber , nf90_64bit_offset ), fid )) ! define dimensions ! vegetation types call nc_err ( nf90_def_dim ( fid , 'dim1' , size ( casabiome % plantrate , 1 ), dimid1 )) ! mplant call nc_err ( nf90_def_dim ( fid , 'dim2' , size ( casabiome % plantrate , 2 ), dimid2 )) ! mlitter call nc_err ( nf90_def_dim ( fid , 'dim3' , size ( casabiome % litterrate , 2 ), dimid3 )) ! msoil call nc_err ( nf90_def_dim ( fid , 'dim4' , size ( casabiome % soilrate , 2 ), dimid4 )) ! define variables i = 1 ! define integer vector variables [dim1] call nc_err ( nf90_def_var ( fid , 'ivt2' , nf90_int , & [ dimid1 ], vid ( i )), i ) ! define double vector variables [dim1] call nc_err ( nf90_def_var ( fid , 'xkleafcoldmax' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'xkleafcoldexp' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'xkleafdrymax' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'xkleafdryexp' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'glaimax' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'glaimin' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'sla' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'ratiofrootleaf' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'kroot' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'krootlen' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'rootdepth' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'kuptake' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'kminn' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'kuplabp' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'kclabrate' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'xnpmax' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'q10soil' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'xkoptlitter' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'xkoptsoil' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'xkplab' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'xkpsorb' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'xkpocc' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'prodptase' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'costnpup' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'maxfinelitter' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'maxcwd' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nintercept' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nslope' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'la_to_sa' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'vcmax_scalar' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'disturbance_interval' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'damm_enzpool' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'damm_kmo2' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'damm_kmcp' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'damm_ea' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'damm_alpha' , nf90_double , & [ dimid1 ], vid ( i )), i ) ! define double array variables [dim1, dim2] call nc_err ( nf90_def_var ( fid , 'plantrate' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'rmplant' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fracnpptop' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fraclignin' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fraclabile' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'rationcplantmin' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'rationcplantmax' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'rationpplantmin' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'rationpplantmax' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fracligninplant' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'ftransnptol' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'ftranspptol' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'ratiopcplantmax' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'ratiopcplantmin' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) ! define double array variables [dim1, dim3] call nc_err ( nf90_def_var ( fid , 'litterrate' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) ! define double array variables [dim1, dim4] call nc_err ( nf90_def_var ( fid , 'soilrate' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) ! end define mode call nc_err ( nf90_enddef ( fid )) ! put variables i = 1 call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % ivt2 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % xkleafcoldmax ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % xkleafcoldexp ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % xkleafdrymax ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % xkleafdryexp ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % glaimax ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % glaimin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % sla ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % ratiofrootleaf ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % kroot ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % krootlen ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % rootdepth ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % kuptake ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % kminN ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % KuplabP ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % kclabrate ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % xnpmax ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % q10soil ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % xkoptlitter ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % xkoptsoil ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % xkplab ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % xkpsorb ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % xkpocc ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % prodptase ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % costnpup ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % maxfinelitter ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % maxcwd ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % nintercept ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % nslope ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % la_to_sa ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % vcmax_scalar ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % disturbance_interval ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % DAMM_EnzPool ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % DAMM_KMO2 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % DAMM_KMcp ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % DAMM_Ea ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % DAMM_alpha ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % plantrate ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % rmplant ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % fracnpptoP ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % fraclignin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % fraclabile ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % ratioNCplantmin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % ratioNCplantmax ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % ratioNPplantmin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % ratioNPplantmax ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % fracLigninplant ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % ftransNPtoL ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % ftransPPtoL ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % ratioPcplantmax ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % ratioPcplantmin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % litterrate ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabiome % soilrate ), i ) ! close NetCDF file call nc_err ( nf90_close ( fid )) end subroutine write_netcdf_casabiome subroutine write_netcdf_casapool ( filename , casapool ) use netcdf , only : nf90_create , nf90_clobber , nf90_64bit_offset , & nf90_def_dim , nf90_def_var , nf90_double , & nf90_enddef , nf90_put_var , nf90_close use cable_def_types_mod , only : nc_err implicit none character ( len =* ), intent ( in ) :: filename type ( casa_pool ), intent ( in ) :: casapool integer :: fid integer :: dimid1 , dimid2 , dimid3 , dimid4 integer :: i integer , dimension ( ncasa_pool ) :: vid ! create netCDF file call nc_err ( nf90_create ( trim ( filename ), ior ( nf90_clobber , nf90_64bit_offset ), fid )) ! define dimensions ! land call nc_err ( nf90_def_dim ( fid , 'dim1' , size ( casapool % Cplant , 1 ), dimid1 )) ! mplant call nc_err ( nf90_def_dim ( fid , 'dim2' , size ( casapool % Cplant , 2 ), dimid2 )) ! mlitter call nc_err ( nf90_def_dim ( fid , 'dim3' , size ( casapool % Clitter , 2 ), dimid3 )) ! msoil call nc_err ( nf90_def_dim ( fid , 'dim4' , size ( casapool % Csoil , 2 ), dimid4 )) ! define variables i = 1 ! define double vector variables [dim1] call nc_err ( nf90_def_var ( fid , 'clabile' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dclabiledt' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nsoilmin' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'psoillab' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'psoilsorb' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'psoilocc' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dnsoilmindt' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dpsoillabdt' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dpsoilsorbdt' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dpsoiloccdt' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'ctot_0' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'ctot' , nf90_double , & [ dimid1 ], vid ( i )), i ) ! define double array variables [dim1, dim2] call nc_err ( nf90_def_var ( fid , 'cplant' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nplant' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'pplant' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dcplantdt' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dnplantdt' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dpplantdt' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'rationcplant' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'rationpplant' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'ratiopcplant' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) ! define double array variables [dim1, dim3] call nc_err ( nf90_def_var ( fid , 'clitter' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nlitter' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'plitter' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dclitterdt' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dnlitterdt' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dplitterdt' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'rationclitter' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'rationplitter' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'ratiopclitter' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) ! define double array variables [dim1, dim4] call nc_err ( nf90_def_var ( fid , 'csoil' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nsoil' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'psoil' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dcsoildt' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dnsoildt' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dpsoildt' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'rationcsoil' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'rationpsoil' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'rationcsoilnew' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'rationcsoilmin' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'rationcsoilmax' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'ratiopcsoil' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) ! end define mode call nc_err ( nf90_enddef ( fid )) ! put variables i = 1 call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Clabile ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % dClabiledt ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Nsoilmin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Psoillab ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Psoilsorb ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Psoilocc ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % dNsoilmindt ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % dPsoillabdt ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % dPsoilsorbdt ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % dPsoiloccdt ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Ctot_0 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Ctot ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Cplant ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Nplant ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Pplant ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % dCplantdt ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % dNplantdt ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % dPplantdt ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % ratioNCplant ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % ratioNPplant ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % ratioPCplant ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Clitter ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Nlitter ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Plitter ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % dClitterdt ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % dNlitterdt ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % dPlitterdt ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % ratioNClitter ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % ratioNPlitter ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % ratioPClitter ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Csoil ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Nsoil ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % Psoil ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % dCsoildt ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % dNsoildt ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % dPsoildt ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % ratioNCsoil ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % ratioNPsoil ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % ratioNCsoilnew ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % ratioNCsoilmin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % ratioNCsoilmax ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casapool % ratioPCsoil ), i ) ! close NetCDF file call nc_err ( nf90_close ( fid )) end subroutine write_netcdf_casapool subroutine write_netcdf_casaflux ( filename , casaflux ) use netcdf , only : nf90_create , nf90_clobber , nf90_64bit_offset , & nf90_def_dim , nf90_def_var , nf90_double , & nf90_enddef , nf90_put_var , nf90_close use cable_def_types_mod , only : nc_err implicit none character ( len =* ), intent ( in ) :: filename type ( casa_flux ), intent ( in ) :: casaflux integer :: fid integer :: dimid1 , dimid2 , dimid3 , dimid4 integer :: i integer , dimension ( ncasa_flux ) :: vid ! create netCDF file call nc_err ( nf90_create ( trim ( filename ), ior ( nf90_clobber , nf90_64bit_offset ), fid )) ! define dimensions ! land call nc_err ( nf90_def_dim ( fid , 'dim1' , size ( casaflux % kplant , 1 ), dimid1 )) ! mplant call nc_err ( nf90_def_dim ( fid , 'dim2' , size ( casaflux % kplant , 2 ), dimid2 )) ! mlitter call nc_err ( nf90_def_dim ( fid , 'dim3' , size ( casaflux % klitter , 2 ), dimid3 )) ! msoil call nc_err ( nf90_def_dim ( fid , 'dim4' , size ( casaflux % ksoil , 2 ), dimid4 )) ! define variables i = 1 ! define double vector variables [dim1] call nc_err ( nf90_def_var ( fid , 'cgpp' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'cnpp' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'crp' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'crgplant' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nminfix' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nminuptake' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'plabuptake' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'clabloss' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fracclabile' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'cnep' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'crsoil' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nmindep' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nminloss' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nminleach' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nupland' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nlittermin' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nsmin' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nsimm' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nsnet' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fnminloss' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fnminleach' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'pdep' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'pwea' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'pleach' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'ploss' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'pupland' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'plittermin' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'psmin' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'psimm' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'psnet' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fpleach' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'kplab' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'kpsorb' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'kpocc' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'kmlabp' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'psorbmax' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'stemnpp' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'frac_sapwood' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'sapwood_area' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fharvest' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'charvest' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nharvest' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'pharvest' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fcrop' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'cplant_turnover_disturbance' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'cplant_turnover_crowding' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'cplant_turnover_resource_limitation' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxctoco2_plant_fire' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxctoco2_litter_fire' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxntoatm_fire' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxctohwp' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxntohwp' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxptohwp' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxctoclear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxntoclear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxptoclear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'ctransferluc' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxctoco2' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxfromptoharvest' , nf90_double , & [ dimid1 ], vid ( i )), i ) ! define double array variables [dim1, dim2] call nc_err ( nf90_def_var ( fid , 'fraccalloc' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fracnalloc' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fracpalloc' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'kplant' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'crmplant' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'cplant_turnover' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'kplant_fire' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'kplant_tot' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxfromptoco2_fire' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxfromptoco2' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) ! define double array variables [dim1, dim3] call nc_err ( nf90_def_var ( fid , 'klitter' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fromltoco2' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'klitter_fire' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'klitter_tot' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxctolitter' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxntolitter' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxptolitter' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxfromltoco2_fire' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxfromltoco2' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) ! define double array variables [dim1, dim4] call nc_err ( nf90_def_var ( fid , 'ksoil' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fromstoco2' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxctosoil' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxntosoil' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxptosoil' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxfromstoco2' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) ! define double array variables [dim1, dim2, dim3] call nc_err ( nf90_def_var ( fid , 'fluxfromptol' , nf90_double , & [ dimid1 , dimid2 , dimid3 ], vid ( i )), i ) ! define double array variables [dim1, dim3, dim2] call nc_err ( nf90_def_var ( fid , 'fromptol' , nf90_double , & [ dimid1 , dimid3 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fromptol_fire' , nf90_double , & [ dimid1 , dimid3 , dimid2 ], vid ( i )), i ) ! define double array variables [dim1, dim3, dim4] call nc_err ( nf90_def_var ( fid , 'fluxfromltos' , nf90_double , & [ dimid1 , dimid3 , dimid4 ], vid ( i )), i ) ! define double array variables [dim1, dim4, dim3] call nc_err ( nf90_def_var ( fid , 'fromltos' , nf90_double , & [ dimid1 , dimid4 , dimid3 ], vid ( i )), i ) ! define double array variables [dim1, dim4, dim4] call nc_err ( nf90_def_var ( fid , 'fromstos' , nf90_double , & [ dimid1 , dimid4 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fluxfromstos' , nf90_double , & [ dimid1 , dimid4 , dimid4 ], vid ( i )), i ) ! end define mode call nc_err ( nf90_enddef ( fid )) ! put variables i = 1 call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Cgpp ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Cnpp ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Crp ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Crgplant ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Nminfix ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Nminuptake ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Plabuptake ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Clabloss ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fracClabile ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Cnep ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Crsoil ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Nmindep ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Nminloss ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Nminleach ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Nupland ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Nlittermin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Nsmin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Nsimm ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Nsnet ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fNminloss ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fNminleach ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Pdep ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Pwea ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Pleach ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Ploss ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Pupland ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Plittermin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Psmin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Psimm ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Psnet ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fPleach ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % kplab ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % kpsorb ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % kpocc ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % kmlabP ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Psorbmax ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % stemnpp ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % frac_sapwood ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % sapwood_area ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fharvest ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Charvest ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Nharvest ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Pharvest ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fcrop ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Cplant_turnover_disturbance ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Cplant_turnover_crowding ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Cplant_turnover_resource_limitation ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxCtoCO2_plant_fire ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxCtoCO2_litter_fire ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxNtoAtm_fire ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxCtohwp ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxNtohwp ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxPtohwp ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxCtoclear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxNtoclear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxPtoclear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % CtransferLUC ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxCtoco2 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxFromPtoHarvest ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fracCalloc ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fracNalloc ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fracPalloc ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % kplant ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Crmplant ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % Cplant_turnover ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % kplant_fire ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % kplant_tot ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fluxfromPtoCO2_fire ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxFromPtoCO2 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % klitter ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fromLtoCO2 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % klitter_fire ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % klitter_tot ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxCtolitter ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxNtolitter ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxPtolitter ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fluxfromLtoCO2_fire ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxFromLtoCO2 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % ksoil ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fromStoCO2 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxCtosoil ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxNtosoil ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxPtosoil ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxFromStoCO2 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxFromPtoL ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fromPtoL ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fromPtoL_fire ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxFromLtoS ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fromLtoS ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % fromStoS ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casaflux % FluxFromStoS ), i ) ! close NetCDF file call nc_err ( nf90_close ( fid )) end subroutine write_netcdf_casaflux subroutine write_netcdf_casamet ( filename , casamet ) use netcdf , only : nf90_create , nf90_clobber , nf90_64bit_offset , & nf90_def_dim , nf90_def_var , nf90_int , nf90_double , & nf90_enddef , nf90_put_var , nf90_close use cable_def_types_mod , only : nc_err implicit none character ( len =* ), intent ( in ) :: filename type ( casa_met ), intent ( in ) :: casamet integer :: fid integer :: dimid1 , dimid2 , dimid3 integer :: i integer , dimension ( ncasa_met ) :: vid ! create netCDF file call nc_err ( nf90_create ( trim ( filename ), ior ( nf90_clobber , nf90_64bit_offset ), fid )) ! define dimensions ! land call nc_err ( nf90_def_dim ( fid , 'dim1' , size ( casamet % Tsoil , 1 ), dimid1 )) ! soil layer call nc_err ( nf90_def_dim ( fid , 'dim2' , size ( casamet % Tsoil , 2 ), dimid2 )) ! days of year = 365 call nc_err ( nf90_def_dim ( fid , 'dim3' , size ( casamet % Tairkspin , 2 ), dimid3 )) ! define variables i = 1 ! define integer vector variables [dim1] call nc_err ( nf90_def_var ( fid , 'lnonwood' , nf90_int , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'iveg2' , nf90_int , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'ijgcm' , nf90_int , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'isorder' , nf90_int , & [ dimid1 ], vid ( i )), i ) ! define double vector variables [dim1] call nc_err ( nf90_def_var ( fid , 'glai' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'tairk' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'precip' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'tsoilavg' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'moistavg' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'btran' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'lat' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'lon' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'areacell' , nf90_double , & [ dimid1 ], vid ( i )), i ) ! define double array variables [dim1, dim2] call nc_err ( nf90_def_var ( fid , 'tsoil' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'moist' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) ! define integer array variables [dim1, dim3] call nc_err ( nf90_def_var ( fid , 'dslr_spin' , nf90_int , & [ dimid1 , dimid3 ], vid ( i )), i ) ! define double array variables [dim1, dim3] call nc_err ( nf90_def_var ( fid , 'tairkspin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'cgppspin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'crmplantspin_1' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'crmplantspin_2' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'crmplantspin_3' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'tsoilspin_1' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'tsoilspin_2' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'tsoilspin_3' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'tsoilspin_4' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'tsoilspin_5' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'tsoilspin_6' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'moistspin_1' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'moistspin_2' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'moistspin_3' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'moistspin_4' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'moistspin_5' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'moistspin_6' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'mtempspin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'frecspin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'can12spin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'can13spin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dprecip_spin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'aprecip_av20_spin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'du10_max_spin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'drhum_spin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dtemp_max_spin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dtemp_min_spin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'kbdi_spin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'd_macarthur_spin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'ffdi_spin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'last_precip_spin' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) ! end define mode call nc_err ( nf90_enddef ( fid )) ! put variables i = 1 call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % lnonwood ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % iveg2 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % ijgcm ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % isorder ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % glai ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % Tairk ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % precip ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % tsoilavg ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % moistavg ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % btran ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % lat ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % lon ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % areacell ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % Tsoil ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % moist ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % DSLR_spin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % Tairkspin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % cgppspin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % crmplantspin_1 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % crmplantspin_2 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % crmplantspin_3 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % Tsoilspin_1 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % Tsoilspin_2 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % Tsoilspin_3 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % Tsoilspin_4 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % Tsoilspin_5 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % Tsoilspin_6 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % moistspin_1 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % moistspin_2 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % moistspin_3 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % moistspin_4 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % moistspin_5 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % moistspin_6 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % mtempspin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % frecspin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % cAn12spin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % cAn13spin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % dprecip_spin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % aprecip_av20_spin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % du10_max_spin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % drhum_spin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % dtemp_max_spin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % dtemp_min_spin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % KBDI_spin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % D_MacArthur_spin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % FFDI_spin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casamet % last_precip_spin ), i ) ! close NetCDF file call nc_err ( nf90_close ( fid )) end subroutine write_netcdf_casamet subroutine write_netcdf_casabal ( filename , casabal ) use netcdf , only : nf90_create , nf90_clobber , nf90_64bit_offset , & nf90_def_dim , nf90_def_var , nf90_float , nf90_double , & nf90_enddef , nf90_put_var , nf90_close use cable_def_types_mod , only : nc_err implicit none character ( len =* ), intent ( in ) :: filename type ( casa_balance ), intent ( in ) :: casabal integer :: fid integer :: dimid1 , dimid2 , dimid3 , dimid4 , dimid5 integer :: i integer , dimension ( ncasa_bal ) :: vid ! create netCDF file call nc_err ( nf90_create ( trim ( filename ), ior ( nf90_clobber , nf90_64bit_offset ), fid )) ! define dimensions ! land call nc_err ( nf90_def_dim ( fid , 'dim1' , size ( casabal % cplantlast , 1 ), dimid1 )) ! mplant call nc_err ( nf90_def_dim ( fid , 'dim2' , size ( casabal % cplantlast , 2 ), dimid2 )) ! mlitter call nc_err ( nf90_def_dim ( fid , 'dim3' , size ( casabal % clitterlast , 2 ), dimid3 )) ! msoil call nc_err ( nf90_def_dim ( fid , 'dim4' , size ( casabal % csoillast , 2 ), dimid4 )) ! number of months = 12 call nc_err ( nf90_def_dim ( fid , 'dim5' , size ( casabal % glaimon , 2 ), dimid5 )) ! define variables i = 1 ! define double vector variables [dim1] call nc_err ( nf90_def_var ( fid , 'fcgppyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fcnppyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fcrpyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fcrmleafyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fcrmwoodyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fcrmrootyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fcrgrowyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fcrsyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fcneeyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fndepyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fnfixyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fnsnetyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fnupyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fnleachyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fnlossyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fpweayear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fpdustyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fpsnetyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fpupyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fpleachyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'fplossyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'dcdtyear' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'laimax' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'cleafmean' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'crootmean' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nsoilminlast' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'psoillablast' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'psoilsorblast' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'psoilocclast' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'cbalance' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nbalance' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'pbalance' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'sumcbal' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'sumnbal' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'sumpbal' , nf90_double , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'clabilelast' , nf90_double , & [ dimid1 ], vid ( i )), i ) ! define double array variables [dim1, dim2] call nc_err ( nf90_def_var ( fid , 'cplantlast' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nplantlast' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'pplantlast' , nf90_double , & [ dimid1 , dimid2 ], vid ( i )), i ) ! define double array variables [dim1, dim3] call nc_err ( nf90_def_var ( fid , 'clitterlast' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nlitterlast' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'plitterlast' , nf90_double , & [ dimid1 , dimid3 ], vid ( i )), i ) ! define double array variables [dim1, dim4] call nc_err ( nf90_def_var ( fid , 'csoillast' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'nsoillast' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'psoillast' , nf90_double , & [ dimid1 , dimid4 ], vid ( i )), i ) ! define double array variables [dim1, dim5] call nc_err ( nf90_def_var ( fid , 'glaimon' , nf90_double , & [ dimid1 , dimid5 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'glaimonx' , nf90_double , & [ dimid1 , dimid5 ], vid ( i )), i ) ! end define mode call nc_err ( nf90_enddef ( fid )) ! put variables i = 1 call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FCgppyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FCnppyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FCrpyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FCrmleafyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FCrmwoodyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FCrmrootyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FCrgrowyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FCrsyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FCneeyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FNdepyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FNfixyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FNsnetyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FNupyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FNleachyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FNlossyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FPweayear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FPdustyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FPsnetyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FPupyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FPleachyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % FPlossyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % dCdtyear ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % LAImax ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % Cleafmean ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % Crootmean ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % nsoilminlast ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % psoillablast ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % psoilsorblast ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % psoilocclast ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % cbalance ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % nbalance ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % pbalance ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % sumcbal ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % sumnbal ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % sumpbal ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % clabilelast ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % cplantlast ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % nplantlast ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % pplantlast ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % clitterlast ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % nlitterlast ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % plitterlast ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % csoillast ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % nsoillast ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % psoillast ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % glaimon ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), casabal % glaimonx ), i ) ! close NetCDF file call nc_err ( nf90_close ( fid )) end subroutine write_netcdf_casabal end module casavariable ! ------------------------------------------------------------------ module phenvariable use cable_def_types_mod , only : mvtype , r_2 use casadimension , only : mdyear , mphase implicit none private ! type public :: phen_variable ! routines on type public :: alloc_phenvariable public :: dealloc_phenvariable public :: print_phenvariable public :: read_netcdf_phen_var public :: write_netcdf_phen_var public :: zero_phenvariable ! number of variables in type definitions ! used in write_netcdf and in MPI code integer , parameter , public :: ncasa_phen = 10 type phen_variable integer , dimension (:), pointer :: phase => null () real ( r_2 ), dimension (:), pointer :: TKshed => null () integer , dimension (:,:), pointer :: doyphase => null () ! fraction of max LAI real , dimension (:), pointer :: phen => null () ! annual leaf on sum real , dimension (:), pointer :: aphen => null () integer , dimension (:,:), pointer :: phasespin => null () integer , dimension (:,:), pointer :: doyphasespin_1 => null () integer , dimension (:,:), pointer :: doyphasespin_2 => null () integer , dimension (:,:), pointer :: doyphasespin_3 => null () integer , dimension (:,:), pointer :: doyphasespin_4 => null () end type phen_variable contains subroutine alloc_phenvariable ( phen , arraysize ) use cable_def_types_mod , only : mvtype use casadimension , only : mdyear , mphase implicit none type ( phen_variable ), intent ( inout ) :: phen integer , intent ( in ) :: arraysize allocate ( phen % Tkshed ( mvtype )) allocate ( & phen % phase ( arraysize ), & phen % doyphase ( arraysize , mphase ), & phen % phen ( arraysize ), & phen % aphen ( arraysize ), & phen % phasespin ( arraysize , mdyear ), & phen % doyphasespin_1 ( arraysize , mdyear ), & phen % doyphasespin_2 ( arraysize , mdyear ), & phen % doyphasespin_3 ( arraysize , mdyear ), & phen % doyphasespin_4 ( arraysize , mdyear )) end subroutine alloc_phenvariable subroutine dealloc_phenvariable ( phen ) implicit none type ( phen_variable ), intent ( inout ) :: phen deallocate ( phen % Tkshed ) deallocate ( phen % phase ) deallocate ( phen % doyphase ) deallocate ( phen % phen ) deallocate ( phen % aphen ) deallocate ( phen % phasespin ) deallocate ( phen % doyphasespin_1 ) deallocate ( phen % doyphasespin_2 ) deallocate ( phen % doyphasespin_3 ) deallocate ( phen % doyphasespin_4 ) end subroutine dealloc_phenvariable subroutine print_phenvariable ( phen ) implicit none type ( phen_variable ), intent ( in ) :: phen write ( * , * ) 'phen%Tkshed ' , phen % Tkshed write ( * , * ) 'phen%phase ' , phen % phase write ( * , * ) 'phen%doyphase ' , phen % doyphase write ( * , * ) 'phen%phen ' , phen % phen write ( * , * ) 'phen%aphen ' , phen % aphen write ( * , * ) 'phen%phasespin ' , phen % phasespin write ( * , * ) 'phen%doyphasespin_1 ' , phen % doyphasespin_1 write ( * , * ) 'phen%doyphasespin_2 ' , phen % doyphasespin_2 write ( * , * ) 'phen%doyphasespin_3 ' , phen % doyphasespin_3 write ( * , * ) 'phen%doyphasespin_4 ' , phen % doyphasespin_4 end subroutine print_phenvariable subroutine zero_phenvariable ( phen ) use cable_def_types_mod , only : r_2 implicit none type ( phen_variable ), intent ( inout ) :: phen phen % phase = 0 phen % Tkshed = 0.0_r_2 phen % doyphase = 0 phen % phen = 0.0 phen % aphen = 0.0 phen % phasespin = 0 phen % doyphasespin_1 = 0 phen % doyphasespin_2 = 0 phen % doyphasespin_3 = 0 phen % doyphasespin_4 = 0 end subroutine zero_phenvariable subroutine read_netcdf_phen_var ( filename , phen ) use netcdf , only : nf90_open , nf90_nowrite , & nf90_inq_varid , nf90_get_var , nf90_close #ifdef __MPI__ use mpi , only : MPI_Abort #endif use cable_def_types_mod , only : nc_err implicit none character ( len =* ), intent ( in ) :: filename type ( phen_variable ), intent ( inout ) :: phen logical :: existfile integer :: fid , vid #ifdef __MPI__ integer :: ierr #endif ! open netCDF file inquire ( file = trim ( filename ), exist = existfile ) if (. not . existfile ) then write ( * , * ) filename , ' does not exist!' #ifdef __MPI__ call MPI_Abort ( 0 , 178 , ierr ) #else stop 178 #endif endif ! open netCDF file call nc_err ( nf90_open ( trim ( filename ), nf90_nowrite , fid )) ! read variables ! integer vectors call nc_err ( nf90_inq_varid ( fid , 'phase' , vid )) call nc_err ( nf90_get_var ( fid , vid , phen % phase )) ! integer arrays call nc_err ( nf90_inq_varid ( fid , 'doyphase' , vid )) call nc_err ( nf90_get_var ( fid , vid , phen % doyphase )) call nc_err ( nf90_inq_varid ( fid , 'phasespin' , vid )) call nc_err ( nf90_get_var ( fid , vid , phen % phasespin )) call nc_err ( nf90_inq_varid ( fid , 'doyphasespin_1' , vid )) call nc_err ( nf90_get_var ( fid , vid , phen % doyphasespin_1 )) call nc_err ( nf90_inq_varid ( fid , 'doyphasespin_2' , vid )) call nc_err ( nf90_get_var ( fid , vid , phen % doyphasespin_2 )) call nc_err ( nf90_inq_varid ( fid , 'doyphasespin_3' , vid )) call nc_err ( nf90_get_var ( fid , vid , phen % doyphasespin_3 )) call nc_err ( nf90_inq_varid ( fid , 'doyphasespin_4' , vid )) call nc_err ( nf90_get_var ( fid , vid , phen % doyphasespin_4 )) ! real vectors call nc_err ( nf90_inq_varid ( fid , 'phen' , vid )) call nc_err ( nf90_get_var ( fid , vid , phen % phen )) call nc_err ( nf90_inq_varid ( fid , 'aphen' , vid )) call nc_err ( nf90_get_var ( fid , vid , phen % aphen )) ! double vectors call nc_err ( nf90_inq_varid ( fid , 'tkshed' , vid )) call nc_err ( nf90_get_var ( fid , vid , phen % tkshed )) ! close NetCDF file call nc_err ( nf90_close ( fid )) end subroutine read_netcdf_phen_var subroutine write_netcdf_phen_var ( filename , phen ) use netcdf , only : nf90_create , nf90_clobber , nf90_64bit_offset , & nf90_def_dim , nf90_def_var , nf90_int , nf90_float , nf90_double , & nf90_enddef , nf90_put_var , nf90_close use cable_def_types_mod , only : nc_err implicit none character ( len =* ), intent ( in ) :: filename type ( phen_variable ), intent ( in ) :: phen integer :: fid integer :: dimid1 , dimid2 , dimid3 , dimid4 integer :: i integer , dimension ( ncasa_phen ) :: vid ! create netCDF file call nc_err ( nf90_create ( trim ( filename ), ior ( nf90_clobber , nf90_64bit_offset ), fid )) ! define dimensions ! land call nc_err ( nf90_def_dim ( fid , 'dim1' , size ( phen % phase , 1 ), dimid1 )) ! phenology phases call nc_err ( nf90_def_dim ( fid , 'dim2' , size ( phen % doyphase , 2 ), dimid2 )) ! days of the year = 365 call nc_err ( nf90_def_dim ( fid , 'dim3' , size ( phen % phasespin , 2 ), dimid3 )) ! vegetation types call nc_err ( nf90_def_dim ( fid , 'dim4' , size ( phen % TKshed , 1 ), dimid4 )) ! define variables i = 1 ! define integer vector variables [dim1] call nc_err ( nf90_def_var ( fid , 'phase' , nf90_int , & [ dimid1 ], vid ( i )), i ) ! define integer array variables [dim1, dim2] call nc_err ( nf90_def_var ( fid , 'doyphase' , nf90_int , & [ dimid1 , dimid2 ], vid ( i )), i ) ! define integer array variables [dim1, dim3] call nc_err ( nf90_def_var ( fid , 'phasespin' , nf90_int , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'doyphasespin_1' , nf90_int , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'doyphasespin_2' , nf90_int , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'doyphasespin_3' , nf90_int , & [ dimid1 , dimid3 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'doyphasespin_4' , nf90_int , & [ dimid1 , dimid3 ], vid ( i )), i ) ! define real vector variables [dim1] call nc_err ( nf90_def_var ( fid , 'phen' , nf90_float , & [ dimid1 ], vid ( i )), i ) call nc_err ( nf90_def_var ( fid , 'aphen' , nf90_float , & [ dimid1 ], vid ( i )), i ) ! define double vector variables [dim4] call nc_err ( nf90_def_var ( fid , 'tkshed' , nf90_double , & [ dimid4 ], vid ( i )), i ) ! end define mode call nc_err ( nf90_enddef ( fid )) ! put variables i = 1 call nc_err ( nf90_put_var ( fid , vid ( i ), phen % phase ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), phen % doyphase ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), phen % phasespin ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), phen % doyphasespin_1 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), phen % doyphasespin_2 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), phen % doyphasespin_3 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), phen % doyphasespin_4 ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), phen % phen ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), phen % aphen ), i ) call nc_err ( nf90_put_var ( fid , vid ( i ), phen % TKshed ), i ) ! close NetCDF file call nc_err ( nf90_close ( fid )) end subroutine write_netcdf_phen_var end module phenvariable","tags":"","loc":"sourcefile/casa_variable.f90.html"},{"title":"POPLUC.F90 – POP","text":"This file depends on sourcefile~~popluc.f90~~EfferentGraph sourcefile~popluc.f90 POPLUC.F90 sourcefile~casa_variable.f90 casa_variable.F90 sourcefile~popluc.f90->sourcefile~casa_variable.f90 sourcefile~pop.f90 POP.F90 sourcefile~popluc.f90->sourcefile~pop.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~popluc.f90~~AfferentGraph sourcefile~popluc.f90 POPLUC.F90 sourcefile~casaonly_luc.f90 CASAONLY_LUC.F90 sourcefile~casaonly_luc.f90->sourcefile~popluc.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules POPLUC_CONSTANTS POPLUC_Types POPLUC_Module Source Code POPLUC.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: module for land-use change which interacts with POP demography ! via secondary forest age-distribution, and updates casa stocks according to land-use transitions ! ! Called from: cable_driver or cable_mpimaster ! ! SUBROUTINES ! Zero_POPLUC(POPLUC) ! execute_luc_event(from_state,to_state,frac_change_grid,g,POPLUC) ! CALCULATE_WEIGHTS(POPLUC, g) ! INCREMENT_AGE(POPLUC,g) ! POPLUCStep(POPLUC,year) ! POPLUC_weights_transfer(POPLUC,POP,LUC_EXPT) ! POP_LUC_CASA_transfer(POPLUC,POP,LUC_EXPT,casapool,casabal,casaflux,ktauday) ! POPLUC_Init(POPLUC,LUC_EXPT, casapool, casaflux, casabiome, veg, POP, np) ! POPLUC_set_patchfrac(POPLUC,LUC_EXPT) ! POPLUC_set_params(POPLUC,LUC_EXPT) ! alloc_POPLUC(POPLUC, arraysize) ! WRITE_LUC_OUTPUT_NC ( POPLUC, ctime, FINAL ) ! WRITE_LUC_RESTART_NC ( POPLUC, ctime ) ! READ_LUC_RESTART_NC (POPLUC) ! WRITE_LUC_OUTPUT_GRID_NC ( POPLUC, ctime, FINAL ) ! History: Vanessa Haverd July 2016 ! ============================================================================== !********************************************************************************* MODULE POPLUC_CONSTANTS USE TYPEdef , ONLY : dp , i4b implicit none INTEGER ( i4b ), PARAMETER :: LENGTH_SECDF_HISTORY = 4000 INTEGER ( i4b ), PARAMETER :: AGE_MAX = 1000 ! N.B. needs to be the same as veg%disturbance_interval INTEGER ( i4b ), PARAMETER :: disturbance_interval = 100 LOGICAL , PARAMETER :: IFHARVEST = . FALSE . INTEGER ( i4b ), PARAMETER :: ROTATION = 70 INTEGER ( i4b ), PARAMETER :: nLU = 3 ! number of land-use tiles (pf, sf, grass) INTEGER ( i4b ), PARAMETER :: nTrans = 4 ! number of possible gross transition types (ptog, ptos, stog, gtos) END MODULE POPLUC_CONSTANTS !******************************************************************************* MODULE POPLUC_Types USE TYPEdef , ONLY : dp , i4b USE POPLUC_Constants , ONLY : LENGTH_SECDF_HISTORY , AGE_MAX implicit none TYPE POPLUC_TYPE INTEGER ( i4b ), POINTER :: it INTEGER ( i4b ), POINTER :: np INTEGER ( i4b ), POINTER :: firstyear INTEGER ( i4b ), POINTER :: thisyear INTEGER ( i4b ), DIMENSION (:), POINTER :: n_event => null () ! number of secondary forest transitions REAL ( dp ), DIMENSION (:), POINTER :: latitude => null (), longitude => null () REAL ( dp ), DIMENSION (:), POINTER :: primf => null (), secdf => null (), grass => null (), & ! land cover types ptos => null (), ptog => null (), stog => null (), gtop => null (), gtos => null (), & ! transitions frac_primf => null (), frac_forest => null () REAL ( dp ), DIMENSION (:), POINTER :: crop => null (), past => null () ! components of managed grass (crop,pasture) ! transitions associated with crop (c) and pasture (q) REAL ( dp ), DIMENSION (:), POINTER :: ptoc => null (), ptoq => null (), stoc => null (), stoq => null (), & qtos => null (), ctos => null () REAL ( dp ), DIMENSION (:,:), POINTER :: freq_age_primary => null (), freq_age_secondary => null (), & biomass_age_primary => null (), biomass_age_secondary => null () REAL ( dp ), DIMENSION (:,:), POINTER :: age_history_secdf => null (), area_history_secdf => null () REAL ( dp ), DIMENSION (:,:), POINTER :: FNEP => null (), Clitt => null (), Csoil => null (), Cbiomass => null () REAL ( dp ), DIMENSION (:,:), POINTER :: FHarvest => null (), FClearance => null (), FTransferNet => null () REAL ( dp ), DIMENSION (:,:), POINTER :: FTransferGross => null () REAL ( dp ), DIMENSION (:), POINTER :: pharv => null (), smharv => null (), syharv => null () ! ag prod pool (grazing + crop harvest) and loss to atm, loss of C from biosphere due to crop/pasture harvest REAL ( dp ), DIMENSION (:), POINTER :: AgProd => null (), AgProdLoss => null (), FAg => null () REAL ( dp ), DIMENSION (:,:), POINTER :: HarvProd => null (), ClearProd => null () ! wood harvest and clearance pools REAL ( dp ), DIMENSION (:,:), POINTER :: fracHarvProd => null (), fracClearProd => null () REAL ( dp ), DIMENSION (:,:), POINTER :: HarvProdLoss => null (), ClearProdLoss => null () REAL ( dp ), DIMENSION (:), POINTER :: fracHarvResid => null (), fracHarvSecResid => null (), fracClearResid => null () REAL ( dp ), DIMENSION (:), POINTER :: kSecHarv => null (), kNatDist => null (), & kExpand1 => null (), kExpand2 => null (), kClear => null () ! carbon denisty in sec forest harvest area, relative to tile average REAL ( dp ), DIMENSION (:), POINTER :: cRelClear => null () ! biomass density loss rates ! For 13C ! Residual flux to litter from harvesting primary forest real ( dp ), dimension (:), pointer :: FluxPHarvResidtoLitter => null () ! Residual flux to litter from harvesting secondary forest real ( dp ), dimension (:), pointer :: FluxSHarvResidtoLitter => null () ! Residual flux to litter from clearing primary forest real ( dp ), dimension (:), pointer :: FluxPClearResidtoLitter => null () ! Residual flux to litter from clearing secondary forest real ( dp ), dimension (:), pointer :: FluxSClearResidtoLitter => null () ! Harvest and Clearance induced change of plant pool of secondary forest real ( dp ), dimension (:), pointer :: dcSHarvClear => null () END TYPE POPLUC_TYPE END MODULE POPLUC_Types !******************************************************************************* MODULE POPLUC_Module !------------------------------------------------------------------------------- ! * This module contains all subroutines for POPLUC calcs at a single time step. !------------------------------------------------------------------------------- USE TYPEdef , ONLY : dp , sp , i4b USE POPLUC_Types USE POPLUC_Constants USE casavariable , ONLY : casa_pool , casa_balance , casa_flux , casa_biome USE POP_Types , ONLY : POP_TYPE USE cable_common_module , ONLY : cable_user USE cable_IO_vars_module , ONLY : landpt , patch , wlogn USE CABLE_LUC_EXPT , ONLY : LUC_EXPT_TYPE USE POPModule , ONLY : pop_init_single implicit none real ( dp ), dimension ( 3 ) :: kHarvProd , kClearProd real ( dp ) :: kAgProd CONTAINS !******************************************************************************* SUBROUTINE zero_popluc ( popluc ) type ( popluc_type ), intent ( inout ) :: popluc popluc % firstyear = 0_i4b popluc % thisyear = 0_i4b popluc % n_event = 0_i4b popluc % latitude = 0.0_dp popluc % longitude = 0.0_dp popluc % primf = 0.0_dp popluc % secdf = 0.0_dp popluc % grass = 0.0_dp popluc % crop = 0.0_dp popluc % past = 0.0_dp popluc % ptos = 0.0_dp popluc % ptog = 0.0_dp popluc % stog = 0.0_dp popluc % gtop = 0.0_dp popluc % gtos = 0.0_dp popluc % ptoc = 0.0_dp popluc % ptoq = 0.0_dp popluc % stoc = 0.0_dp popluc % stoq = 0.0_dp popluc % qtos = 0.0_dp popluc % ctos = 0.0_dp popluc % frac_forest = 0.0_dp popluc % frac_primf = 0.0_dp popluc % area_history_secdf = 0.0_dp popluc % age_history_secdf = 0.0_dp popluc % freq_age_secondary = 0.0_dp popluc % freq_age_primary = 0.0_dp popluc % biomass_age_primary = 0.0_dp popluc % biomass_age_secondary = 0.0_dp popluc % FNEP = 0.0_dp popluc % Clitt = 0.0_dp popluc % Csoil = 0.0_dp popluc % Cbiomass = 0.0_dp popluc % FHarvest = 0.0_dp popluc % FClearance = 0.0_dp popluc % FTransferNet = 0.0_dp popluc % FTransferGross = 0.0_dp popluc % pharv = 0.0_dp popluc % smharv = 0.0_dp popluc % syharv = 0.0_dp popluc % HarvProd = 0.0_dp popluc % HarvProdLoss = 0.0_dp popluc % fracHarvProd = 0.0_dp popluc % fracHarvResid = 0.0_dp popluc % fracHarvSecResid = 0.0_dp popluc % ClearProd = 0.0_dp popluc % ClearProdLoss = 0.0_dp popluc % fracClearProd = 0.0_dp popluc % fracClearResid = 0.0_dp popluc % kSecHarv = 0.0_dp popluc % kNatDist = 0.0_dp popluc % kExpand1 = 0.0_dp popluc % kExpand2 = 0.0_dp popluc % kClear = 0.0_dp popluc % cRelClear = 0.0_dp popluc % AgProd = 0.0_dp popluc % AgProdLoss = 0.0_dp popluc % FAg = 0.0_dp popluc % FluxPHarvResidtoLitter = 0.0_dp popluc % FluxSHarvResidtoLitter = 0.0_dp popluc % FluxPClearResidtoLitter = 0.0_dp popluc % FluxSClearResidtoLitter = 0.0_dp popluc % dcSHarvClear = 0.0_dp END SUBROUTINE zero_popluc !******************************************************************************* SUBROUTINE print_popluc ( popluc ) type ( popluc_type ), intent ( in ) :: popluc write ( * , * ) 'np ' , popluc % np write ( * , * ) 'firstyear ' , popluc % firstyear write ( * , * ) 'thisyear ' , popluc % thisyear write ( * , * ) 'n_event ' , popluc % n_event write ( * , * ) 'latitude ' , popluc % latitude write ( * , * ) 'longitude ' , popluc % longitude write ( * , * ) 'primf ' , popluc % primf write ( * , * ) 'secdf ' , popluc % secdf write ( * , * ) 'grass ' , popluc % grass write ( * , * ) 'crop ' , popluc % crop write ( * , * ) 'past ' , popluc % past write ( * , * ) 'ptos ' , popluc % ptos write ( * , * ) 'ptog ' , popluc % ptog write ( * , * ) 'stog ' , popluc % stog write ( * , * ) 'gtop ' , popluc % gtop write ( * , * ) 'gtos ' , popluc % gtos write ( * , * ) 'ptoc ' , popluc % ptoc write ( * , * ) 'ptoq ' , popluc % ptoq write ( * , * ) 'stoc ' , popluc % stoc write ( * , * ) 'stoq ' , popluc % stoq write ( * , * ) 'qtos ' , popluc % qtos write ( * , * ) 'ctos ' , popluc % ctos write ( * , * ) 'frac_forest ' , popluc % frac_forest write ( * , * ) 'frac_primf ' , popluc % frac_primf write ( * , * ) 'area_history_secdf ' , popluc % area_history_secdf write ( * , * ) 'age_history_secdf ' , popluc % age_history_secdf write ( * , * ) 'freq_age_secondary ' , popluc % freq_age_secondary write ( * , * ) 'freq_age_primary ' , popluc % freq_age_primary write ( * , * ) 'biomass_age_primary ' , popluc % biomass_age_primary write ( * , * ) 'biomass_age_secondary ' , popluc % biomass_age_secondary write ( * , * ) 'FNEP ' , popluc % FNEP write ( * , * ) 'Clitt ' , popluc % Clitt write ( * , * ) 'Csoil ' , popluc % Csoil write ( * , * ) 'Cbiomass ' , popluc % Cbiomass write ( * , * ) 'FHarvest ' , popluc % FHarvest write ( * , * ) 'FClearance ' , popluc % FClearance write ( * , * ) 'FTransferNet ' , popluc % FTransferNet write ( * , * ) 'FTransferGross ' , popluc % FTransferGross write ( * , * ) 'pharv ' , popluc % pharv write ( * , * ) 'smharv ' , popluc % smharv write ( * , * ) 'syharv ' , popluc % syharv write ( * , * ) 'HarvProd ' , popluc % HarvProd write ( * , * ) 'HarvProdLoss ' , popluc % HarvProdLoss write ( * , * ) 'fracHarvProd ' , popluc % fracHarvProd write ( * , * ) 'fracHarvResid ' , popluc % fracHarvResid write ( * , * ) 'fracHarvSecResid ' , popluc % fracHarvSecResid write ( * , * ) 'ClearProd ' , popluc % ClearProd write ( * , * ) 'ClearProdLoss ' , popluc % ClearProdLoss write ( * , * ) 'fracClearProd ' , popluc % fracClearProd write ( * , * ) 'fracClearResid ' , popluc % fracClearResid write ( * , * ) 'kSecHarv ' , popluc % kSecHarv write ( * , * ) 'kNatDist ' , popluc % kNatDist write ( * , * ) 'kExpand1 ' , popluc % kExpand1 write ( * , * ) 'kExpand2 ' , popluc % kExpand2 write ( * , * ) 'kClear ' , popluc % kClear write ( * , * ) 'cRelClear ' , popluc % cRelClear write ( * , * ) 'AgProd ' , popluc % AgProd write ( * , * ) 'AgProdLoss ' , popluc % AgProdLoss write ( * , * ) 'FAg ' , popluc % FAg write ( * , * ) 'FluxPHarvResidtoLitter ' , popluc % FluxPHarvResidtoLitter write ( * , * ) 'FluxSHarvResidtoLitter ' , popluc % FluxSHarvResidtoLitter write ( * , * ) 'FluxPClearResidtoLitter ' , popluc % FluxPClearResidtoLitter write ( * , * ) 'FluxSClearResidtoLitter ' , popluc % FluxSClearResidtoLitter write ( * , * ) 'dcSHarvClear ' , popluc % dcSHarvClear END SUBROUTINE print_POPLUC !******************************************************************************* SUBROUTINE execute_luc_event ( from_state , to_state , frac_change_grid , g , POPLUC ) ! Execute a transition between land use types (states) !  frac_change_grid = fractional change in unit fraction of grid cell this year #ifdef __MPI__ use mpi , only : MPI_Abort #endif IMPLICIT NONE CHARACTER ( 5 ), INTENT ( IN ) :: from_state , to_state REAL ( dp ), INTENT ( INOUT ) :: frac_change_grid INTEGER ( i4b ), INTENT ( IN ) :: g ! grid cell index TYPE ( POPLUC_TYPE ), INTENT ( INOUT ) :: POPLUC REAL ( dp ) :: frac_open_grid , remaining INTEGER ( i4b ) :: n ! position of new element in POPLUC%SecFor array INTEGER ( i4b ) :: i REAL ( dp ) :: tmp , tmp1 , tmp2 #ifdef __MPI__ integer :: ierr #endif ! frac_open_grid = 1.0_dp-POPLUC%frac_forest(g) frac_open_grid = POPLUC % grass ( g ) n = POPLUC % n_event ( g ) IF ( from_state == 'PRIMF' ) THEN IF ( frac_change_grid . GT . POPLUC % primf ( g )) THEN IF ( to_state == 'SECDF' ) POPLUC % ptos ( g ) = POPLUC % primf ( g ) IF ( to_state == 'C3ANN' ) POPLUC % ptog ( g ) = POPLUC % primf ( g ) frac_change_grid = POPLUC % primf ( g ) POPLUC % primf ( g ) = 0.0_dp ELSE POPLUC % primf ( g ) = POPLUC % primf ( g ) - frac_change_grid ENDIF IF ( to_state == 'SECDF' ) THEN ! Transition from primary -> secondary forest(ptos) IF ( sum ( POPLUC % freq_age_secondary ( g ,:)) . gt . 0.0_dp ) THEN tmp = sum ( POPLUC % freq_age_secondary ( g ,:) * POPLUC % biomass_age_secondary ( g ,:)) & / sum ( POPLUC % freq_age_secondary ( g ,:)) ELSE tmp = 0.0_dp ENDIF POPLUC % kExpand1 ( g ) = 0.0_dp POPLUC % n_event ( g ) = POPLUC % n_event ( g ) + 1 n = POPLUC % n_event ( g ) POPLUC % area_history_secdf ( g , n ) = frac_change_grid POPLUC % age_history_secdf ( g , n ) = 0.0_dp POPLUC % freq_age_secondary ( g , 1 ) = POPLUC % freq_age_secondary ( g , 1 ) + frac_change_grid IF ( sum ( POPLUC % freq_age_secondary ( g ,:)) . gt . 0.0_dp ) THEN tmp1 = sum ( POPLUC % freq_age_secondary ( g ,:) * POPLUC % biomass_age_secondary ( g ,:)) & / sum ( POPLUC % freq_age_secondary ( g ,:)) ELSE tmp1 = 0.0_dp ENDIF if ( tmp . gt . 0.0_dp ) then tmp2 = ( tmp1 - tmp ) / tmp POPLUC % kExpand1 ( g ) = - tmp2 else POPLUC % kExpand1 ( g ) = 0.0_dp endif ENDIF ELSEIF ( from_state == 'SECDF' ) THEN IF ( to_state == 'PRIMF' ) THEN write ( * , * ) \"Error: cannot create primary forest from secondary forest\" #ifdef __MPI__ call MPI_Abort ( 0 , 87 , ierr ) ! Do not know comm nor rank here #else stop 87 #endif ELSE ! Transition from secondary -> non forest (stog) ! Assumption: youngest stands cleared first, if stands> 10 years accommodate transition ! Otherwise uniform harvest if ( sum ( POPLUC % freq_age_secondary ( g , 10 : age_max )) . gt . frac_change_grid ) then IF ( sum ( POPLUC % freq_age_secondary ( g ,:)) . gt . 0.0_dp ) THEN tmp = sum ( POPLUC % freq_age_secondary ( g ,:) * POPLUC % biomass_age_secondary ( g ,:)) & / sum ( POPLUC % freq_age_secondary ( g ,:)) ELSE tmp = 0.0_dp ENDIF POPLUC % kClear ( g ) = 0.0_dp POPLUC % CRelClear ( g ) = 0.0_dp remaining = frac_change_grid i = 10 DO WHILE ( remaining > 0.0_dp . and . i <= age_max ) IF ( POPLUC % freq_age_secondary ( g , i ). GE . remaining ) THEN POPLUC % freq_age_secondary ( g , i ) = POPLUC % freq_age_secondary ( g , i ) & - remaining POPLUC % CRelClear ( g ) = POPLUC % biomass_age_secondary ( g , i ) * remaining remaining = 0.0_dp ELSE remaining = remaining - POPLUC % freq_age_secondary ( g , i ) POPLUC % freq_age_secondary ( g , i ) = 0.0_dp POPLUC % CRelClear ( g ) = POPLUC % CRelClear ( g ) & + POPLUC % biomass_age_secondary ( g , i ) * POPLUC % freq_age_secondary ( g , i ) i = i + 1 ENDIF ENDDO if ( tmp . gt . 0.0_dp . and . frac_change_grid . gt . 0.0_dp ) then POPLUC % CRelClear ( g ) = POPLUC % CRelClear ( g ) / frac_change_grid / tmp else POPLUC % CRelClear ( g ) = 0.0_dp endif if ( remaining . gt . 0.0_dp ) POPLUC % stog ( g ) = POPLUC % stog ( g ) - remaining IF ( sum ( POPLUC % freq_age_secondary ( g ,:)) . gt . 0.0_dp ) THEN tmp1 = sum ( POPLUC % freq_age_secondary ( g ,:) * POPLUC % biomass_age_secondary ( g ,:)) & / sum ( POPLUC % freq_age_secondary ( g ,:)) ELSE tmp1 = 0.0_dp ENDIF if ( tmp . gt . 0.0_dp ) then tmp2 = ( tmp1 - tmp ) / tmp POPLUC % kClear ( g ) = - tmp2 else POPLUC % kClear ( g ) = 0.0_dp endif else ! uniform clearance across age classes POPLUC % kClear ( g ) = 0.0_dp ! no change in biomass density frac_change_grid = min ( sum ( POPLUC % freq_age_secondary ( g ,:)), frac_change_grid ) POPLUC % stog ( g ) = frac_change_grid !if (g==3) write(*,*) 'b4 age_sec', frac_change_grid,  sum(POPLUC%freq_age_secondary(g,:)) POPLUC % freq_age_secondary ( g ,:) = POPLUC % freq_age_secondary ( g ,:) * ( 1.0_dp - frac_change_grid ) !if (g==3) write(*,*) 'after age_sec',POPLUC%stog(g),  sum(POPLUC%freq_age_secondary(g,:)) POPLUC % CRelClear ( g ) = 1.0_dp endif ENDIF ELSEIF ( to_state == 'SECDF' ) THEN IF ( sum ( POPLUC % freq_age_secondary ( g ,:)) . gt . 0.0_dp ) THEN tmp = sum ( POPLUC % freq_age_secondary ( g ,:) * POPLUC % biomass_age_secondary ( g ,:)) & / sum ( POPLUC % freq_age_secondary ( g ,:)) ELSE tmp = 0.0_dp ENDIF POPLUC % kExpand2 ( g ) = 0.0_dp POPLUC % n_event ( g ) = POPLUC % n_event ( g ) + 1 n = POPLUC % n_event ( g ) ! Transition from non-forest to secondary forest (gtos) !$if (g==4) then !$write(*,*) 'gtos1', frac_change_grid, frac_open_grid, POPLUC%grass(g) , sum( POPLUC%freq_age_secondary(g,:)) !$endif if ( frac_change_grid . LE . frac_open_grid ) THEN POPLUC % area_history_secdf ( g , n ) = frac_change_grid POPLUC % age_history_secdf ( g , n ) = 0.0_dp POPLUC % freq_age_secondary ( g , 1 ) = POPLUC % freq_age_secondary ( g , 1 ) + frac_change_grid ELSE POPLUC % area_history_secdf ( g , n ) = frac_open_grid POPLUC % age_history_secdf ( g , n ) = 0.0_dp POPLUC % freq_age_secondary ( g , 1 ) = POPLUC % freq_age_secondary ( g , 1 ) + frac_open_grid ! gtos to frac_change_grid here!! POPLUC % gtos ( g ) = frac_open_grid ENDIF IF ( sum ( POPLUC % freq_age_secondary ( g ,:)) . gt . 0.0_dp ) THEN tmp1 = sum ( POPLUC % freq_age_secondary ( g ,:) * POPLUC % biomass_age_secondary ( g ,:)) & / sum ( POPLUC % freq_age_secondary ( g ,:)) ELSE tmp1 = 0.0_dp ENDIF if ( tmp . gt . 0.0_dp ) then tmp2 = ( tmp1 - tmp ) / tmp POPLUC % kExpand2 ( g ) = - tmp2 else POPLUC % kExpand2 ( g ) = 0.0_dp endif ELSEIF ( to_state == 'PRIMF' ) THEN write ( * , * ) \"Error: cannot create primary forest from non-forest\" #ifdef __MPI__ call MPI_Abort ( 0 , 88 , ierr ) ! Do not know comm nor rank here #else stop 88 #endif ENDIF ENDSUBROUTINE execute_luc_event !******************************************************************************* subroutine calculate_weights ( POPLUC , g ) ! Calculates weights (fraction of total forest area on grid cell) !for primary and secondary forest stands up to specified maximum stand age implicit none type ( popluc_type ), intent ( inout ) :: POPLUC integer ( i4b ), intent ( in ) :: g integer ( i4b ) :: age , i , iage real ( dp ) :: fac , disturbance_freq ! First get relative weights for primary forest disturbance_freq = 1.0_dp / real ( disturbance_interval , dp ) !fac = POPLUC%frac_primf/POPLUC%frac_forest fac = 1.0_dp do iage = 1 , age_max POPLUC % freq_age_primary ( g , iage ) = REALExponential ( disturbance_freq , real ( iage - 1 , dp )) POPLUC % freq_age_secondary ( g , iage ) = 0.0_dp end do POPLUC % freq_age_primary ( g ,:) = POPLUC % freq_age_primary ( g ,:) / sum ( POPLUC % freq_age_primary ( g ,:)) * fac !  Loop through secondary forest stands to transfer weights fac = 1.0_dp do i = 1 , POPLUC % n_event ( g ) age = nint ( POPLUC % age_history_secdf ( g , i )) POPLUC % freq_age_secondary ( g , age + 1 ) = POPLUC % area_history_secdf ( g , i ) / fac enddo end subroutine calculate_weights !******************************************************************************* SUBROUTINE INCREMENT_AGE ( POPLUC , g ) IMPLICIT NONE TYPE ( POPLUC_TYPE ), INTENT ( INOUT ) :: POPLUC INTEGER ( i4b ), INTENT ( IN ) :: g INTEGER ( i4b ) :: n_event , i REAL ( dp ) :: remaining REAL ( dp ) :: tmp , tmp1 , tmp2 n_event = POPLUC % n_event ( g ) POPLUC % kSecHarv ( g ) = 0.0_dp POPLUC % kNatDist ( g ) = 0.0_dp POPLUC % freq_age_secondary ( g , 2 : age_max ) = POPLUC % freq_age_secondary ( g , 1 : age_max - 1 ) POPLUC % biomass_age_secondary ( g , 2 : age_max ) = POPLUC % biomass_age_secondary ( g , 1 : age_max - 1 ) POPLUC % freq_age_secondary ( g , 1 ) = 0.0_dp POPLUC % biomass_age_secondary ( g , 1 ) = 0.0_dp ! adjust secondary age distribution for secondary forest harvest area if ( POPLUC % smharv ( g ) + POPLUC % syharv ( g ). gt . 0 ) then ! if (sum(POPLUC%biomass_age_secondary(g,:)).gt.0.5*1000) then ! only harvest if biomass density > 0.5 kg Cm-2 if ( sum ( POPLUC % biomass_age_secondary ( g ,:) * POPLUC % freq_age_secondary ( g ,:)). gt . 0.5_dp ) then ! only harvest if biomass density > 0.5 kg Cm-2 IF ( sum ( POPLUC % freq_age_secondary ( g ,:)) . gt . 0.0_dp ) THEN tmp = sum ( POPLUC % freq_age_secondary ( g ,:) * POPLUC % biomass_age_secondary ( g ,:)) & / sum ( POPLUC % freq_age_secondary ( g ,:)) ELSE tmp = 0.0_dp ENDIF remaining = POPLUC % smharv ( g ) + POPLUC % syharv ( g ) i = age_max do while ( remaining . gt . 1.e-10_dp ) if ( POPLUC % freq_age_secondary ( g , i ) . gt . remaining ) then POPLUC % freq_age_secondary ( g , i ) = POPLUC % freq_age_secondary ( g , i ) - remaining POPLUC % freq_age_secondary ( g , 1 ) = POPLUC % freq_age_secondary ( g , 1 ) + remaining remaining = 0.0_dp else POPLUC % freq_age_secondary ( g , 1 ) = POPLUC % freq_age_secondary ( g , 1 ) + & POPLUC % freq_age_secondary ( g , i ) remaining = remaining - POPLUC % freq_age_secondary ( g , i ) POPLUC % freq_age_secondary ( g , i ) = 0.0_dp i = i - 1 ; end if if ( i . lt . 2 ) then POPLUC % smharv ( g ) = POPLUC % smharv ( g ) + POPLUC % syharv ( g ) - remaining POPLUC % syharv ( g ) = 0.0_dp remaining = 0.0_dp endif enddo IF ( sum ( POPLUC % freq_age_secondary ( g ,:)) . gt . 0.0_dp ) THEN tmp1 = sum ( POPLUC % freq_age_secondary ( g ,:) * POPLUC % biomass_age_secondary ( g ,:)) & / sum ( POPLUC % freq_age_secondary ( g ,:)) ELSE tmp1 = 0.0_dp ENDIF if ( tmp . gt . 0.0_dp ) then tmp2 = ( tmp1 - tmp ) / tmp POPLUC % kSecHarv ( g ) = - tmp2 else POPLUC % kSecHarv ( g ) = 0.0_dp endif endif endif ! remove IFHARVEST ? IF ( IFHARVEST . and . POPLUC % freq_age_secondary ( g , ROTATION + 1 ). gt . 0.0_dp ) THEN POPLUC % freq_age_secondary ( g , 1 ) = POPLUC % freq_age_secondary ( g , 1 ) + & POPLUC % freq_age_secondary ( g , ROTATION + 1 ) POPLUC % freq_age_secondary ( g , ROTATION + 1 ) = 0.0_dp ENDIF IF ( sum ( POPLUC % freq_age_secondary ( g ,:)) . gt . 0.0_dp ) THEN tmp = sum ( POPLUC % freq_age_secondary ( g ,:) * POPLUC % biomass_age_secondary ( g ,:)) & / sum ( POPLUC % freq_age_secondary ( g ,:)) ELSE tmp = 0.0_dp ENDIF ! adjust secondary age distribution for natural disturbance i = age_max DO i = age_max , 2 , - 1 POPLUC % freq_age_secondary ( g , 1 ) = POPLUC % freq_age_secondary ( g , 1 ) + & POPLUC % freq_age_secondary ( g , i ) / disturbance_interval POPLUC % freq_age_secondary ( g , i ) = POPLUC % freq_age_secondary ( g , i ) * & ( 1._dp - 1._dp / disturbance_interval ) ENDDO IF ( sum ( POPLUC % freq_age_secondary ( g ,:)) . gt . 0.0_dp ) THEN tmp1 = sum ( POPLUC % freq_age_secondary ( g ,:) * POPLUC % biomass_age_secondary ( g ,:)) & / sum ( POPLUC % freq_age_secondary ( g ,:)) ELSE tmp1 = 0.0_dp ENDIF if ( tmp . gt . 0.0_dp ) then tmp2 = ( tmp1 - tmp ) / tmp POPLUC % kNatDist ( g ) = - tmp2 else POPLUC % kNatDist ( g ) = 0.0_dp endif END SUBROUTINE INCREMENT_AGE !******************************************************************************* SUBROUTINE POPLUCStep ( POPLUC , year ) IMPLICIT NONE TYPE ( POPLUC_TYPE ), INTENT ( INOUT ) :: POPLUC INTEGER ( i4b ), INTENT ( IN ) :: year INTEGER ( i4b ) :: g POPLUC % it = POPLUC % it + 1 ! vh ! remove code relating to (year.lt.POPLUC%thisyear) ? IF ( year . lt . POPLUC % thisyear ) THEN DO g = 1 , POPLUC % np ! CALL calculate_weights(POPLUC, g) CALL increment_age ( POPLUC , g ) ENDDO ELSE DO g = 1 , POPLUC % np POPLUC % kClear ( g ) = 0.0_dp POPLUC % kExpand1 ( g ) = 0.0_dp POPLUC % kExpand2 ( g ) = 0.0_dp POPLUC % kSecHarv ( g ) = 0.0_dp !CALL increment_age(POPLUC,g) if ( POPLUC % stog ( g ) . gt . 0.0_dp ) & CALL execute_luc_event ( 'SECDF' , 'C3ANN' , POPLUC % stog ( g ), g , POPLUC ) if ( POPLUC % ptos ( g ) . gt . 0.0_dp ) & CALL execute_luc_event ( 'PRIMF' , 'SECDF' , POPLUC % ptos ( g ), g , POPLUC ) if ( POPLUC % ptog ( g ) . gt . 0.0_dp ) & CALL execute_luc_event ( 'PRIMF' , 'C3ANN' , POPLUC % ptog ( g ), g , POPLUC ) ! if (POPLUC%stog(g) .gt.0.0_dp) & !      CALL execute_luc_event('SECDF','C3ANN',POPLUC%stog(g),g,POPLUC) if ( POPLUC % gtop ( g ) . gt . 0.0_dp ) & CALL execute_luc_event ( 'C3ANN' , 'PRIMF' , POPLUC % gtop ( g ), g , POPLUC ) if ( POPLUC % gtos ( g ) . gt . 0.0_dp ) & CALL execute_luc_event ( 'C3ANN' , 'SECDF' , POPLUC % gtos ( g ), g , POPLUC ) POPLUC % frac_forest ( g ) = POPLUC % primf ( g ) + SUM ( POPLUC % freq_age_secondary ( g ,:)) !$if (g==4) write(*,*) 'fracfor: ',  POPLUC%frac_forest(g),  SUM(POPLUC%freq_age_secondary(g,:)) CALL increment_age ( POPLUC , g ) ENDDO ENDIF END SUBROUTINE POPLUCStep !******************************************************************************* SUBROUTINE POPLUC_weights_transfer ( POPLUC , POP , LUC_EXPT ) !------------------------------------------------------------------------------- ! This subroutine transfers LUC-determined age distributions to POP !------------------------------------------------------------------------------- IMPLICIT NONE TYPE ( POPLUC_TYPE ), INTENT ( IN ) :: POPLUC TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP TYPE ( LUC_EXPT_TYPE ), INTENT ( IN ) :: LUC_EXPT integer :: g , j , l REAL ( dp ), DIMENSION (:), ALLOCATABLE :: freq_age DO l = 1 , POP % np pop % pop_grid ( l )% freq_age = 0.0_dp ENDDO ALLOCATE ( freq_age ( age_max )) DO g = 1 , POPLUC % np ! loop over POPLUC gricells (same as CABLE grid-cells) IF (. NOT . LUC_EXPT % prim_only ( g ) . and . sum ( POPLUC % freq_age_secondary ( g ,:)). gt . 1.e-12_dp ) THEN ! check if tile is secondary forest j = landpt ( g )% cstart + 1 ! cable index for secondary forest tile freq_age = POPLUC % freq_age_secondary ( g ,:) / sum ( POPLUC % freq_age_secondary ( g ,:)) DO l = 1 , POP % np ! for each wooded tile if ( POP % Iwood ( l ). eq . j ) then ! check if cable index in pop structure (Iwood) is the target cable index pop % pop_grid ( l )% freq_age = freq_age endif ENDDO ENDIF ENDDO DEALLOCATE ( freq_age ) END SUBROUTINE POPLUC_weights_transfer !******************************************************************************* SUBROUTINE POP_LUC_CASA_transfer ( POPLUC , POP , LUC_EXPT , & casapool , casabal , casaflux , ktauday ) !------------------------------------------------------------------------------- ! This subroutine redestributes carbon (nitrogen and phosphorous) amongst ! pools according to land-use transitions !------------------------------------------------------------------------------- use mo_utils , only : eq IMPLICIT NONE TYPE ( POPLUC_TYPE ), INTENT ( INOUT ) :: POPLUC TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP TYPE ( LUC_EXPT_TYPE ), INTENT ( IN ) :: LUC_EXPT TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux INTEGER , INTENT ( IN ) :: ktauday ! number of cable time-steps in a day (for needed for LUC flux output) integer :: g , k , j , l , idp , irp , idlu , irlu , ilu INTEGER , PARAMETER :: & p = 1 , & s = 2 , & gr = 3 REAL ( dp ) :: dcplant ( nLU , nLU , 3 ), dclitter ( nLU , nLU , 3 ), dcsoil ( nLU , nLU , 3 ) REAL ( dp ) :: dcplant_r ( nLU , 3 ), dclitter_r ( nLU , 3 ), dcsoil_r ( nLU , 3 ) REAL ( dp ) :: dcplant_d ( nLU , 3 ), dclitter_d ( nLU , 3 ), dcsoil_d ( nLU , 3 ) REAL ( dp ) :: dnplant ( nLU , nLU , 3 ), dnlitter ( nLU , nLU , 3 ), dnsoil ( nLU , nLU , 3 ) REAL ( dp ) :: dnplant_r ( nLU , 3 ), dnlitter_r ( nLU , 3 ), dnsoil_r ( nLU , 3 ) REAL ( dp ) :: dnplant_d ( nLU , 3 ), dnlitter_d ( nLU , 3 ), dnsoil_d ( nLU , 3 ) REAL ( dp ) :: dpplant ( nLU , nLU , 3 ), dplitter ( nLU , nLU , 3 ), dpsoil ( nLU , nLU , 3 ) REAL ( dp ) :: dpplant_r ( nLU , 3 ), dplitter_r ( nLU , 3 ), dpsoil_r ( nLU , 3 ) REAL ( dp ) :: dpplant_d ( nLU , 3 ), dplitter_d ( nLU , 3 ), dpsoil_d ( nLU , 3 ) REAL ( dp ) :: dnsoilmin_r ( nLU ), dclabile_r ( nLU ) REAL ( dp ) :: dnsoilmin_d ( nLU ), dclabile_d ( nLU ) REAL ( dp ) :: dclabile ( nLU , nLU ) REAL ( dp ) :: dA_r ( nLU ), dA_d ( nLU ), dA ( nLU ), deltaA , dwood_transfer REAL ( dp ), ALLOCATABLE :: dcHarvCLear (:), dcHarv (:), dcClear (:), dcExpand (:), & dcNat (:), FHarvClear (:), FDist (:), dcExpand1 (:), dcExpand2 (:), & FNatDist (:), FHarv (:), FClear (:) ! 13C REAL(dp) :: kHarvProd(3), kClearProd(3), kAgProd REAL ( dp ) :: NatDist_loss , Clear_Loss , SecHarv_Loss , Dist_Loss , & scalefac , tmp #ifdef __C13DEBUG__ real ( dp ) :: tmp_dplant ( nLU , 3 ), tmp_tplant ( nLU , 3 ), tmp_dlit ( nLU , 3 ), tmp_slit ( nLU , 3 ) real ( dp ) :: tmp_dsoil ( nLU , 3 ) integer :: iwtile , iwpool #endif ! turnover rates for harvest and clearance products (y-1) kHarvProd ( 1 ) = 1.0_dp ! / 1.0_dp kHarvProd ( 2 ) = 1.0_dp / 1 0.0_dp kHarvProd ( 3 ) = 1.0_dp / 10 0.0_dp kClearProd = kHarvProd kAgProd = 1.0_dp ! / 1.0_dp ! zero POPLUC fluxes popluc % FtransferNet = 0.0_dp popluc % FtransferGross = 0.0_dp popluc % FHarvest = 0.0_dp popluc % FClearance = 0.0_dp ! local variable for storing sum of biomass change due to !secondary harvest, clearance and expansion, and secondary forest !  harvest and clearance fluxes Allocate ( FDist ( POPLUC % np )) Allocate ( FClear ( POPLUC % np )) Allocate ( FHarv ( POPLUC % np )) Allocate ( FNatDist ( POPLUC % np )) Allocate ( FHarvClear ( POPLUC % np )) Allocate ( dcHarvClear ( POPLUC % np )) Allocate ( dcHarv ( POPLUC % np )) Allocate ( dcClear ( POPLUC % np )) Allocate ( dcExpand ( POPLUC % np )) Allocate ( dcExpand1 ( POPLUC % np )) Allocate ( dcExpand2 ( POPLUC % np )) Allocate ( dcNat ( POPLUC % np )) FHarvClear = 0.0_dp FDist = 0.0_dp FNatDist = 0.0_dp FHarv = 0.0_dp FClear = 0.0_dp dcHarvClear = 0.0_dp dcHarv = 0.0_dp dcClear = 0.0_dp dcExpand = 0.0_dp dcExpand1 = 0.0_dp ! change in sec for carbon density by p->s dcExpand2 = 0.0_dp ! change in sec for carbon density by g->s dcNat = 0.0_dp POPLUC % FHarvest = 0.0_dp POPLUC % FClearance = 0.0_dp casaflux % FluxCtohwp = 0.0_dp casaflux % FluxCtoclear = 0.0_dp casaflux % CtransferLUC = 0.0_dp popluc % FluxPHarvResidtoLitter = 0.0_dp popluc % FluxSHarvResidtoLitter = 0.0_dp popluc % FluxPClearResidtoLitter = 0.0_dp popluc % FluxSClearResidtoLitter = 0.0_dp popluc % dcSHarvClear = 0.0_dp DO g = 1 , POPLUC % np ! loop over CABLE grid-cells dcHarv ( g ) = 0.0_dp dcClear ( g ) = 0.0_dp POPLUC % FHarvest ( g , 2 ) = 0.0_dp POPLUC % FClearance ( g , 2 ) = 0.0_dp j = landpt ( g )% cstart ! index of primary veg tile in each grid-cell DO l = 1 , POP % np ! loop over all POP tiles (== wooded tiles in CABLE) IF (. NOT . LUC_EXPT % prim_only ( g )) THEN ! land-use change may occur if ( POP % Iwood ( l ). eq . j + 1 . and . & ( patch ( j + 1 )% frac + POPLUC % gtos ( g ) + POPLUC % ptos ( g ) - POPLUC % stog ( g )) . gt . 0.0_dp ) then ! fraction biomass density loss to disturbance ! includes natural disturbance, expansion, harvest, clearing if (( POP % pop_grid ( l )% cmass_sum_old + POP % pop_grid ( l )% growth ). gt . 1.e-6_dp ) then Dist_loss = POP % pop_grid ( l )% cat_mortality & / ( POP % pop_grid ( l )% cmass_sum_old + POP % pop_grid ( l )% growth ) else Dist_loss = 0.0_dp end if POPLUC % biomass_age_secondary ( g ,:) = POP % pop_grid ( l )% biomass_age endif if ( POP % Iwood ( l ). eq . j + 1 . and . & ( patch ( j + 1 )% frac + POPLUC % gtos ( g ) + POPLUC % ptos ( g ) - POPLUC % stog ( g )) . gt . 0.0_dp ) then ! if secondary forest and new secondary forest area > 0 ! set POPLUC diagnostic 2o forest age distribution to POP age distribution ! change in biomass area density due to secondary forest expansion [g C m-2] dcExpand ( g ) = - ( POPLUC % gtos ( g ) + POPLUC % ptos ( g )) * casapool % cplant ( j + 1 , 2 ) / & ( patch ( j + 1 )% frac + POPLUC % gtos ( g ) + POPLUC % ptos ( g ) - POPLUC % stog ( g )) if ( abs (( - POPLUC % kNatDist ( g ) - POPLUC % kSecHarv ( g ) - POPLUC % kClear ( g ))) . gt . 0.0_dp ) then scalefac = ( - Dist_loss - dcExpand ( g ) / casapool % cplant ( j + 1 , 2 )) / & ( - POPLUC % kNatDist ( g ) - POPLUC % kSecHarv ( g ) - POPLUC % kClear ( g )) else scalefac = 0.0_dp endif ! relative  changes in biomass density due to sec forest ! harvest, clearing, natural disturbance if ( scalefac . gt . 0 ) then SecHarv_loss = scalefac * POPLUC % kSecHarv ( g ) NatDist_Loss = scalefac * POPLUC % kNatDist ( g ) Clear_loss = scalefac * POPLUC % kClear ( g ) elseif ( abs ( - POPLUC % kNatDist ( g ) - POPLUC % kSecHarv ( g )). gt . 0.0_dp ) then scalefac = ( - Dist_loss - dcExpand ( g ) / casapool % cplant ( j + 1 , 2 )) / & ( - POPLUC % kNatDist ( g ) - POPLUC % kSecHarv ( g )) Clear_Loss = 0.0_dp SecHarv_loss = scalefac * POPLUC % kSecHarv ( g ) NatDist_Loss = scalefac * POPLUC % kNatDist ( g ) if ( scalefac . lt . 0.0_dp ) then SecHarv_loss = 0.0_dp NatDist_Loss = 0.0_dp endif else Clear_Loss = 0.0_dp SecHarv_loss = 0.0_dp NatDist_Loss = 0.0_dp endif ! absolute  changes in biomass density due to sec forest ! harvest, clearing, natural disturbance dcHarvClear ( g ) = - ( Clear_loss + SecHarv_loss ) & * casapool % cplant ( j + 1 , 2 ) dcHarv ( g ) = - ( SecHarv_loss ) & * casapool % cplant ( j + 1 , 2 ) dcClear ( g ) = - ( Clear_loss ) & * casapool % cplant ( j + 1 , 2 ) dcNat ( g ) = - NatDist_loss & * casapool % cplant ( j + 1 , 2 ) !$               if (g==4) write(*,*) 'b4 fdist', & !$               scalefac, casapool%cplant(j+1,2) + dcExpand(g)+dcClear(g)+dcHarv(g),  & !$               casapool%cplant(j+1,2) , dcExpand(g),dcClear(g),dcHarv(g), dcnat(g) if (( casapool % cplant ( j + 1 , 2 ) + dcExpand ( g ) + dcClear ( g ) + dcHarv ( g )). gt . 0.0_dp . and . & dcnat ( g ). lt . 0.0_dp ) then ! flux + A0C0 = (A + dA) * (C + dC) ! flux = A0 * dC + dA( C0 + dC) ! harvest+ clearance flux (not yet corrected for carbon remaining & ! in landscape as litter) !  [g C m-2] (grid-cell basis) FDist ( g ) = - ( patch ( j + 1 )% frac * ( dcHarvClear ( g ) + dcExpand ( g ) + dcNat ( g )) + & ( POPLUC % ptos ( g ) + POPLUC % gtos ( g ) - POPLUC % stog ( g )) * & ( casapool % cplant ( j + 1 , 2 ) + dcHarvClear ( g ) + dcExpand ( g ) ) ) Fnatdist ( g ) = - patch ( j + 1 )% frac * dcNat ( g ) ! partition disturbance flux between naturl dist, harvest and clearing tmp = - patch ( j + 1 )% frac * ( dcNat ( g ) + dcHarv ( g )) & + POPLUC % stog ( g ) * POPLUC % CRelClear ( g ) * casapool % cplant ( j + 1 , 2 ) Fnatdist ( g ) = - patch ( j + 1 )% frac * dcNat ( g ) / tmp * FDist ( g ) FHarv ( g ) = - patch ( j + 1 )% frac * dcHarv ( g ) / tmp * FDist ( g ) FClear ( g ) = POPLUC % stog ( g ) * POPLUC % CRelClear ( g ) * casapool % cplant ( j + 1 , 2 ) / & tmp * FDist ( g ) FHarvClear ( g ) = FHarv ( g ) + FClear ( g ) !$                   if (g==4 ) write(*,*) 'fdist', & !$                   FDist(g),  Fnatdist(g), tmp, dcharv(g), FHarv(g), FClear(g), & !$                   POPLUC%CRelClear(g) ! adjust biomass density changes to be consistent with FClear & FHarv dcHarvClear ( g ) = - ( FHarvCLear ( g ) + ( - POPLUC % stog ( g ))& * casapool % cplant ( j + 1 , 2 )) / & ( patch ( j + 1 )% frac + POPLUC % gtos ( g ) + POPLUC % ptos ( g ) - POPLUC % stog ( g )) ! POP%pop_grid(l)%cat_mortality = Fnatdist(g)/casapool%cplant(j+1,2)*& !    (POP%pop_grid(l)%cmass_sum_old+POP%pop_grid(l)%growth) ! secondary forest harvest flux (goes to harvest wood products) & ! [g C m-2] (grid-cell basis) !  corrected for carbon remaining in landscape as litter if (( FHarv ( g )). gt . 0.0_dp ) then POPLUC % FHarvest ( g , 2 ) = ( 1.0_dp - POPLUC % fracHarvSecResid ( g )) * FHarv ( g ) endif ! secondary forest clearance flux (goes to clearance pool) & ! [g C m-2] (grid-cell basis) !  corrected for carbon remaining in landscape as litter if (( FClear ( g )). gt . 0.0_dp ) then POPLUC % FClearance ( g , 2 ) = ( 1.0_dp - POPLUC % fracClearResid ( g )) * FClear ( g ) endif else dcHarvClear ( g ) = 0.0_dp POPLUC % stog ( g ) = 0.0_dp endif endif ENDIF if ( POP % Iwood ( l ). eq . j ) then ! set diagnostic POPLUC variables to POP equivalents & !(patch biomass and age distributions) POPLUC % biomass_age_primary ( g ,:) = POP % pop_grid ( l )% biomass_age POPLUC % freq_age_primary ( g ,:) = POP % pop_grid ( l )% freq_age endif ENDDO ENDDO ! Calculate Carbon Pool Transfers DO g = 1 , POPLUC % np ! loop over POPLUC gridcells (== CABLE gridcells) j = landpt ( g )% cstart ! start index of CABLE grid-cell tiles l = landpt ( g )% cend ! end index of CABLE grid-cell tiles ! initialise local variables ! _r refers to receiver tile ! _d refers to donor tile ! dA refers to change in tile area ! dC refers to change in carbon [g m-2] (grid-cell basis) ! dn refers to change in nitrogen [g m-2] (grid-cell basis) ! dp refers to change in phosphorous [g m-2] (grid-cell basis) dA_r = 0.0_dp dA_d = 0.0_dp dA = 0.0_dp dcsoil = 0.0_dp dcplant = 0.0_dp dclitter = 0.0_dp dclabile = 0.0_dp dcsoil_r = 0.0_dp dcplant_r = 0.0_dp dclitter_r = 0.0_dp dcsoil_r = 0.0_dp dcplant_r = 0.0_dp dclitter_r = 0.0_dp dclabile_r = 0.0_dp dcsoil_d = 0.0_dp dcplant_d = 0.0_dp dclitter_d = 0.0_dp dcsoil_d = 0.0_dp dcplant_d = 0.0_dp dclitter_d = 0.0_dp dclabile_d = 0.0_dp dnsoil = 0.0_dp dnplant = 0.0_dp dnlitter = 0.0_dp dnsoil_r = 0.0_dp dnplant_r = 0.0_dp dnlitter_r = 0.0_dp dnsoil_r = 0.0_dp dnplant_r = 0.0_dp dnlitter_r = 0.0_dp dnsoilmin_r = 0.0_dp dnlitter = 0.0_dp dnsoil_d = 0.0_dp dnplant_d = 0.0_dp dnlitter_d = 0.0_dp dnsoil_d = 0.0_dp dnplant_d = 0.0_dp dnlitter_d = 0.0_dp dnsoilmin_d = 0.0_dp dpsoil = 0.0_dp dpplant = 0.0_dp dplitter = 0.0_dp dpsoil_r = 0.0_dp dpplant_r = 0.0_dp dplitter_r = 0.0_dp dpsoil_r = 0.0_dp dpplant_r = 0.0_dp dplitter_r = 0.0_dp dwood_transfer = 0.0_dp dpsoil_d = 0.0_dp dpplant_d = 0.0_dp dplitter_d = 0.0_dp dpsoil_d = 0.0_dp dpplant_d = 0.0_dp dplitter_d = 0.0_dp #ifdef __C13DEBUG__ tmp_dplant = 0.0_dp tmp_tplant = 0.0_dp tmp_dlit = 0.0_dp tmp_slit = 0.0_dp tmp_dsoil = 0.0_dp #endif IF (. NOT . LUC_EXPT % prim_only ( g )) THEN ! only worry about transitions where land-use change is possible DO k = 1 , nTrans ! loop over all possible transition types if ( k == 1 ) then deltaA = POPLUC % ptos ( g ) ! transition area: primary to seondary transition idp = j ! donor patch index irp = j + 1 ! receiver patch index idlu = p ! donor land use index (p = primary) irlu = s ! receiver land use index (s = secondary) elseif ( k == 2 ) then deltaA = POPLUC % ptog ( g ) ! transition area: primary to grass (open) transition idp = j ! donor patch index irp = j + 2 ! receiver patch index idlu = p ! donor land use index (p = primary) irlu = gr ! receiver land use index (gr = grass or open) elseif ( k == 3 ) then deltaA = POPLUC % stog ( g ) ! transition area: secondary to grass (open) transition idp = j + 1 ! donor patch index irp = j + 2 ! receiver patch index idlu = s ! donor land use index irlu = gr ! receiver land use index elseif ( k == 4 ) then deltaA = POPLUC % gtos ( g ) ! transition area: grass (open) to secondary transition idp = j + 2 ! donor patch index irp = j + 1 ! receiver patch index idlu = gr ! donor land use index irlu = s ! receiver land use index (s = secondary) endif dcsoil = 0.0_dp dclitter = 0.0_dp dcplant = 0.0_dp dclabile = 0.0_dp dnsoil = 0.0_dp dnlitter = 0.0_dp dnplant = 0.0_dp dpsoil = 0.0_dp dplitter = 0.0_dp dpplant = 0.0_dp dwood_transfer = 0.0_dp ! transfer fluxes : only consider cases where gross transition area is greater than zero if ( deltaA . gt . 0.0_dp ) then ! all soil pools ! change in carbon associated with gross transition dcsoil ( irlu , idlu ,:) = deltaA * casapool % csoil ( idp ,:) #ifdef __C13DEBUG__ tmp_dsoil ( irlu ,:) = tmp_dsoil ( irlu ,:) + deltaA * casapool % csoil ( idp ,:) #endif ! change in receiver carbon pool (accumulated over all gross transitions) dcsoil_r ( irlu ,:) = dcsoil_r ( irlu ,:) + deltaA * casapool % csoil ( idp ,:) ! change in donor carbon pool (accumulated over all gross transitions) dcsoil_d ( idlu ,:) = dcsoil_d ( idlu ,:) - deltaA * casapool % csoil ( idp ,:) dnsoil ( irlu , idlu ,:) = deltaA * casapool % nsoil ( idp ,:) dnsoil_r ( irlu ,:) = dnsoil_r ( irlu ,:) + deltaA * casapool % nsoil ( idp ,:) dnsoil_d ( idlu ,:) = dnsoil_d ( idlu ,:) - deltaA * casapool % nsoil ( idp ,:) dnsoilmin_r ( irlu ) = dnsoilmin_r ( irlu ) + deltaA * casapool % nsoilmin ( idp ) dnsoilmin_d ( irlu ) = dnsoilmin_d ( idlu ) - deltaA * casapool % nsoilmin ( idp ) dpsoil ( irlu , idlu ,:) = deltaA * casapool % psoil ( idp ,:) dpsoil_r ( irlu ,:) = dpsoil_r ( irlu ,:) + deltaA * casapool % psoil ( idp ,:) dpsoil_d ( idlu ,:) = dpsoil_d ( idlu ,:) - deltaA * casapool % psoil ( idp ,:) ! need to inlcude other P pools here too: occluded P and labile P) ! microbial litter dclitter ( irlu , idlu , 1 ) = deltaA * casapool % clitter ( idp , 1 ) #ifdef __C13DEBUG__ tmp_dlit ( irlu , 1 ) = tmp_dlit ( irlu , 1 ) + deltaA * casapool % clitter ( idp , 1 ) #endif dclitter_r ( irlu , 1 ) = dclitter_r ( irlu , 1 ) + dclitter ( irlu , idlu , 1 ) dclitter_d ( idlu , 1 ) = dclitter_d ( idlu , 1 ) - dclitter ( irlu , idlu , 1 ) dnlitter ( irlu , idlu , 1 ) = deltaA * casapool % nlitter ( idp , 1 ) dnlitter_r ( irlu , 1 ) = dnlitter_r ( irlu , 1 ) + dnlitter ( irlu , idlu , 1 ) dnlitter_d ( idlu , 1 ) = dnlitter_d ( idlu , 1 ) - dnlitter ( irlu , idlu , 1 ) dplitter ( irlu , idlu , 1 ) = deltaA * casapool % plitter ( idp , 1 ) dplitter_r ( irlu , 1 ) = dplitter_r ( irlu , 1 ) + dplitter ( irlu , idlu , 1 ) dplitter_d ( idlu , 1 ) = dplitter_d ( idlu , 1 ) - dplitter ( irlu , idlu , 1 ) ! CWD : donor pool inhreits CWD and residues from harvest/clearance tmp = 0.0_dp if ( idlu == s . and . casapool % cplant ( idp , 2 ). gt . 1.e-5_dp ) then ! secondary forest clearance: use secondary forest clearance flux from above ! 13C tmp = POPLUC % fracClearResid ( g ) * POPLUC % Fclearance ( g , 2 ) / ( 1.0_dp - POPLUC % fracClearResid ( g )) popluc % FluxSClearResidtoLitter ( g ) = tmp dclitter ( irlu , idlu , 3 ) = deltaA * casapool % clitter ( idp , 3 ) + tmp dnlitter ( irlu , idlu , 3 ) = deltaA * casapool % nlitter ( idp , 3 ) + & POPLUC % fracClearResid ( g ) * POPLUC % Fclearance ( g , 2 ) / & ( 1.0_dp - POPLUC % fracClearResid ( g )) & * casapool % nplant ( idp , 2 ) / casapool % cplant ( idp , 2 ) dplitter ( irlu , idlu , 3 ) = deltaA * casapool % plitter ( idp , 3 ) + & POPLUC % fracClearResid ( g ) * POPLUC % Fclearance ( g , 2 ) / & ( 1.0_dp - POPLUC % fracClearResid ( g )) & * casapool % pplant ( idp , 2 ) / casapool % cplant ( idp , 2 ) elseif ( idlu == p . and . irlu == s ) then ! primary forest harvest: assume harvest is uniform across age-classes ! 13C tmp = deltaA * POPLUC % fracHarvResid ( g ) * casapool % cplant ( idp , 2 ) popluc % FluxPHarvResidtoLitter ( g ) = tmp dclitter ( irlu , idlu , 3 ) = deltaA * casapool % clitter ( idp , 3 ) + tmp dnlitter ( irlu , idlu , 3 ) = deltaA * ( casapool % nlitter ( idp , 3 ) + & POPLUC % fracHarvResid ( g ) * casapool % nplant ( idp , 2 ) ) dplitter ( irlu , idlu , 3 ) = deltaA * ( casapool % plitter ( idp , 3 ) + & POPLUC % fracHarvResid ( g ) * casapool % pplant ( idp , 2 ) ) elseif ( idlu == p . and . irlu == gr ) then ! primary forest clearance: assume clearance is uniform across age-classes ! 13C tmp = deltaA * POPLUC % fracClearResid ( g ) * casapool % cplant ( idp , 2 ) popluc % FluxPClearResidtoLitter ( g ) = tmp dclitter ( irlu , idlu , 3 ) = deltaA * casapool % clitter ( idp , 3 ) + tmp dnlitter ( irlu , idlu , 3 ) = deltaA * ( casapool % nlitter ( idp , 3 ) + & POPLUC % fracClearResid ( g ) * casapool % nplant ( idp , 2 ) ) dplitter ( irlu , idlu , 3 ) = deltaA * ( casapool % plitter ( idp , 3 ) + & POPLUC % fracClearResid ( g ) * casapool % pplant ( idp , 2 ) ) else dclitter ( irlu , idlu , 3 ) = deltaA * casapool % clitter ( idp , 3 ) dnlitter ( irlu , idlu , 3 ) = deltaA * casapool % nlitter ( idp , 3 ) dplitter ( irlu , idlu , 3 ) = deltaA * casapool % plitter ( idp , 3 ) endif #ifdef __C13DEBUG__ tmp_dlit ( irlu , 3 ) = tmp_dlit ( irlu , 3 ) + deltaA * casapool % clitter ( idp , 3 ) tmp_slit ( irlu , 3 ) = tmp_slit ( irlu , 3 ) + tmp #endif dclitter_r ( irlu , 3 ) = dclitter_r ( irlu , 3 ) + dclitter ( irlu , idlu , 3 ) dclitter_d ( idlu , 3 ) = dclitter_d ( idlu , 3 ) - dclitter ( irlu , idlu , 3 ) dnlitter_r ( irlu , 3 ) = dnlitter_r ( irlu , 3 ) + dnlitter ( irlu , idlu , 3 ) dnlitter_d ( idlu , 3 ) = dnlitter_d ( idlu , 3 ) - dnlitter ( irlu , idlu , 3 ) dplitter_r ( irlu , 3 ) = dplitter_r ( irlu , 3 ) + dplitter ( irlu , idlu , 3 ) dplitter_d ( idlu , 3 ) = dplitter_d ( idlu , 3 ) - dplitter ( irlu , idlu , 3 ) ! fine structural litter: donor pool inherits leaves and fine roots dclitter ( irlu , idlu , 2 ) = deltaA * ( casapool % clitter ( idp , 2 ) + casapool % cplant ( idp , 1 ) + & casapool % cplant ( idp , 3 )) #ifdef __C13DEBUG__ tmp_dlit ( irlu , 2 ) = tmp_dlit ( irlu , 2 ) + deltaA * casapool % clitter ( idp , 2 ) tmp_slit ( irlu , 2 ) = tmp_slit ( irlu , 2 ) + deltaA * ( casapool % cplant ( idp , 1 ) + casapool % cplant ( idp , 3 )) #endif dclitter_r ( irlu , 2 ) = dclitter_r ( irlu , 2 ) + dclitter ( irlu , idlu , 2 ) dclitter_d ( idlu , 2 ) = dclitter_d ( idlu , 2 ) - dclitter ( irlu , idlu , 2 ) dnlitter ( irlu , idlu , 2 ) = deltaA * ( casapool % nlitter ( idp , 2 ) + casapool % cplant ( idp , 1 ) + & casapool % cplant ( idp , 3 )) dnlitter_r ( irlu , 2 ) = dnlitter_r ( irlu , 2 ) + dnlitter ( irlu , idlu , 2 ) dnlitter_d ( idlu , 2 ) = dnlitter_d ( idlu , 2 ) - dnlitter ( irlu , idlu , 2 ) dplitter ( irlu , idlu , 2 ) = deltaA * ( casapool % plitter ( idp , 2 ) + casapool % cplant ( idp , 1 ) + & casapool % cplant ( idp , 3 )) dplitter_r ( irlu , 2 ) = dplitter_r ( irlu , 2 ) + dplitter ( irlu , idlu , 2 ) dplitter_d ( idlu , 2 ) = dplitter_d ( idlu , 2 ) - dplitter ( irlu , idlu , 2 ) ! labile carbon dclabile ( irlu , idlu ) = deltaA * casapool % clabile ( idp ) dclabile_r ( irlu ) = dclabile_r ( irlu ) + deltaA * casapool % clabile ( idp ) dclabile_d ( irlu ) = dclabile_d ( idlu ) - deltaA * casapool % clabile ( idp ) ! biomass: no biomass inherited dcplant ( irlu , idlu ,:) = 0.0_dp #ifdef __C13DEBUG__ tmp_dplant ( irlu ,:) = tmp_dplant ( irlu ,:) + 0.0_dp #endif dcplant_r ( irlu ,:) = dcplant_r ( irlu ,:) + dcplant ( irlu , idlu ,:) dcplant_d ( idlu ,:) = dcplant_d ( idlu ,:) - dcplant ( irlu , idlu ,:) dnplant ( irlu , idlu ,:) = 0.0_dp dnplant_r ( irlu ,:) = dnplant_r ( irlu ,:) + dnplant ( irlu , idlu ,:) dnplant_d ( idlu ,:) = dnplant_d ( idlu ,:) - dnplant ( irlu , idlu ,:) dpplant ( irlu , idlu ,:) = 0.0_dp dpplant_r ( irlu ,:) = dpplant_r ( irlu ,:) + dpplant ( irlu , idlu ,:) dpplant_d ( idlu ,:) = dpplant_d ( idlu ,:) - dpplant ( irlu , idlu ,:) ! Gross Transfer Flux (total C-tranfer associated with k-th transition) popluc % FtransferGross ( g , k ) = & sum ( dcsoil ( irlu , idlu ,:) + dclitter ( irlu , idlu ,:) + dcplant ( irlu , idlu ,:)) ! Harvest Flux ! primary to secondary forest ! (note secondary harvest and clearance fluxes are already evaluated & !  at the top of this subroutine) if ( idlu == p . and . irlu == s ) then popluc % FHarvest ( g , idlu ) = ( 1.0_dp - POPLUC % fracHarvResid ( g )) & * casapool % cplant ( idp , 2 ) * deltaA endif ! Clearance Flux ! primary forest to grass if (( idlu == p ) . and . irlu == gr ) then popluc % FClearance ( g , idlu ) = ( 1.0_dp - POPLUC % fracClearResid ( g )) & * casapool % cplant ( idp , 2 ) * deltaA endif ! transition area dA_r ( irlu ) = dA_r ( irlu ) + deltaA dA_d ( idlu ) = dA_d ( idlu ) - deltaA endif ENDDO ! ntrans do ilu = 1 , nlu ! update pools irp = ilu + j - 1 #ifdef __C13DEBUG__ iwtile = l - 2 iwpool = 1 #endif !if (g==3 .and. POPLUC%thisyear==1837 .and. ilu==2) & !     write(*,*) 'c00',casapool%cplant(irp,2),casapool%cplant(irp,2)*patch(j)%frac dwood_transfer = 0.0_dp dA ( ilu ) = dA_r ( ilu ) + dA_d ( ilu ) ! Net Transfer Flux POPLUC % FTransferNet ( g , ilu ) = sum ( dcsoil_r ( ilu ,:) + dcsoil_d ( ilu ,:)) + & sum ( dclitter_r ( ilu ,:) + dclitter_d ( ilu ,:)) + & sum ( dcplant_r ( ilu ,:) + dcplant_d ( ilu ,:)) + & dclabile_r ( ilu ) + dclabile_d ( ilu ) if ( ilu == 2 ) then ! augment CWD pools in secondary veg tiles by harvest residues ! 13C tmp = POPLUC % fracHarvSecResid ( g ) * POPLUC % FHarvest ( g , 2 ) / ( 1.0_dp - POPLUC % fracHarvSecResid ( g )) popluc % FluxSHarvResidtoLitter ( g ) = tmp dclitter_r ( ilu , 3 ) = dclitter_r ( irlu , 3 ) + tmp #ifdef __C13DEBUG__ tmp_slit ( irlu , 3 ) = tmp_slit ( irlu , 3 ) + tmp #endif if ( casapool % cplant ( irp , 2 ) . gt . 1.e-5_dp ) then dnlitter_r ( ilu , 3 ) = dnlitter_r ( irlu , 3 ) + & POPLUC % fracHarvSecResid ( g ) * POPLUC % FHarvest ( g , 2 ) / ( 1.0_dp - POPLUC % fracHarvSecResid ( g )) & * casapool % nplant ( irp , 2 ) / casapool % cplant ( irp , 2 ) dplitter_r ( ilu , 3 ) = dplitter_r ( irlu , 3 ) + & POPLUC % fracHarvSecResid ( g ) * POPLUC % FHarvest ( g , 2 ) / ( 1.0_dp - POPLUC % fracHarvSecResid ( g )) & * casapool % pplant ( irp , 2 ) / casapool % cplant ( irp , 2 ) endif endif if (( patch ( irp )% frac + dA ( ilu )). gt . 1.e-5_dp ) then ! avoid fpe's by ensuring finite new tile area casapool % nsoilmin ( irp ) = casapool % nsoilmin ( irp ) + & ( dnsoilmin_r ( ilu ) - casapool % nsoilmin ( irp ) * ( dA ( ilu ) - dA_d ( ilu ))) & / ( patch ( irp )% frac + dA ( ilu )) casaflux % CtransferLUC ( irp ) = casaflux % CtransferLUC ( irp ) + & ( dclabile_r ( ilu ) - casapool % clabile ( irp ) * ( dA ( ilu ) - dA_d ( ilu ))) & / ( patch ( irp )% frac + dA ( ilu )) casapool % clabile ( irp ) = casapool % clabile ( irp ) + & ( dclabile_r ( ilu ) - casapool % clabile ( irp ) * ( dA ( ilu ) - dA_d ( ilu ))) & / ( patch ( irp )% frac + dA ( ilu )) casaflux % CtransferLUC ( irp ) = casaflux % CtransferLUC ( irp ) + & sum ( dcsoil_r ( ilu ,:) - casapool % csoil ( irp ,:) * ( dA ( ilu ) - dA_d ( ilu ))) & / ( patch ( irp )% frac + dA ( ilu )) #ifdef __C13DEBUG__ if ( irp == iwtile ) then print * , 'PA01 ' , patch ( irp )% frac , patch ( irp )% frac + dA ( ilu ), ilu print * , 'PA02 ' , dA ( ilu ) - dA_d ( ilu ) print * , 'PA03 ' , dA ( ilu ), dA_d ( ilu ), dA_r ( ilu ) endif if ( irp == iwtile ) then print * , 'PS01 ' , casapool % csoil ( irp , iwpool ) print * , 'PS02 ' , tmp_dsoil ( ilu , iwpool ) print * , 'PS03 ' , dcsoil_r ( ilu , iwpool ) print * , 'PS04 ' , casapool % csoil ( irp , iwpool ) * ( dA ( ilu ) - dA_d ( ilu )) endif #endif casapool % csoil ( irp ,:) = casapool % csoil ( irp ,:) + & ( dcsoil_r ( ilu ,:) - casapool % csoil ( irp ,:) * ( dA ( ilu ) - dA_d ( ilu ))) & / ( patch ( irp )% frac + dA ( ilu )) #ifdef __C13DEBUG__ if ( irp == iwtile ) then print * , 'PS05 ' , casapool % csoil ( irp , iwpool ) endif #endif casapool % nsoil ( irp ,:) = casapool % nsoil ( irp ,:) + & ( dnsoil_r ( ilu ,:) - casapool % nsoil ( irp ,:) * ( dA ( ilu ) - dA_d ( ilu ))) & / ( patch ( irp )% frac + dA ( ilu )) casapool % psoil ( irp ,:) = casapool % psoil ( irp ,:) + & ( dpsoil_r ( ilu ,:) - casapool % psoil ( irp ,:) * ( dA ( ilu ) - dA_d ( ilu ))) & / ( patch ( irp )% frac + dA ( ilu )) casaflux % CtransferLUC ( irp ) = casaflux % CtransferLUC ( irp ) + & sum ( dclitter_r ( ilu ,:) - casapool % clitter ( irp ,:) * ( dA ( ilu ) - dA_d ( ilu ))) & / ( patch ( irp )% frac + dA ( ilu )) #ifdef __C13DEBUG__ if ( irp == iwtile ) then print * , 'PL01 ' , casapool % clitter ( irp , iwpool ) print * , 'PL02 ' , tmp_dlit ( ilu , iwpool ) print * , 'PL03 ' , tmp_slit ( ilu , iwpool ) print * , 'PL04 ' , dclitter_r ( ilu , iwpool ) print * , 'PL05 ' , casapool % clitter ( irp , iwpool ) * ( dA ( ilu ) - dA_d ( ilu )) endif #endif casapool % clitter ( irp ,:) = casapool % clitter ( irp ,:) + & ( dclitter_r ( ilu ,:) - casapool % clitter ( irp ,:) * ( dA ( ilu ) - dA_d ( ilu ))) & / ( patch ( irp )% frac + dA ( ilu )) #ifdef __C13DEBUG__ if ( irp == iwtile ) then print * , 'PL06 ' , casapool % clitter ( irp , iwpool ) endif #endif casapool % nlitter ( irp ,:) = casapool % nlitter ( irp ,:) + & ( dnlitter_r ( ilu ,:) - casapool % nlitter ( irp ,:) * ( dA ( ilu ) - dA_d ( ilu ))) & / ( patch ( irp )% frac + dA ( ilu )) casapool % plitter ( irp ,:) = casapool % plitter ( irp ,:) + & ( dplitter_r ( ilu ,:) - casapool % plitter ( irp ,:) * ( dA ( ilu ) - dA_d ( ilu ))) & / ( patch ( irp )% frac + dA ( ilu )) casaflux % CtransferLUC ( irp ) = casaflux % CtransferLUC ( irp ) + & sum ( dcplant_r ( ilu ,:) - casapool % cplant ( irp ,:) * ( dA ( ilu ) - dA_d ( ilu ))) & / ( patch ( irp )% frac + dA ( ilu )) #ifdef __C13DEBUG__ if ( irp == iwtile ) then print * , 'PP01 ' , casapool % cplant ( irp , iwpool ) print * , 'PP02 ' , tmp_dplant ( ilu , iwpool ) print * , 'PP03 ' , tmp_tplant ( ilu , iwpool ) print * , 'PP04 ' , dcplant_r ( ilu , iwpool ) print * , 'PP05 ' , casapool % cplant ( irp , iwpool ) * ( dA ( ilu ) - dA_d ( ilu )) endif #endif casapool % cplant ( irp ,:) = casapool % cplant ( irp ,:) + & ( dcplant_r ( ilu ,:) - casapool % cplant ( irp ,:) * ( dA ( ilu ) - dA_d ( ilu ))) & / ( patch ( irp )% frac + dA ( ilu )) #ifdef __C13DEBUG__ if ( irp == iwtile ) then print * , 'PP06 ' , casapool % cplant ( irp , iwpool ) endif #endif casapool % nplant ( irp ,:) = casapool % nplant ( irp ,:) + & ( dnplant_r ( ilu ,:) - casapool % nplant ( irp ,:) * ( dA ( ilu ) - dA_d ( ilu ))) & / ( patch ( irp )% frac + dA ( ilu )) casapool % pplant ( irp ,:) = casapool % pplant ( irp ,:) + & ( dpplant_r ( ilu ,:) - casapool % pplant ( irp ,:) * ( dA ( ilu ) - dA_d ( ilu ))) & / ( patch ( irp )% frac + dA ( ilu )) ! account here for change in secondary forest biomass density due to: !   harvest and clearing, as well as increase in (below ground) CWD !   where secondary forest harvest occurs if ( ilu . eq . s . and . ( casapool % cplant ( irp , 2 ) + dcHarvClear ( g )). gt . 0.0_dp & . and . casapool % cplant ( irp , 2 ). gt . 1.e-10_dp ) then popluc % dcSHarvClear ( g ) = dcHarvClear ( g ) casapool % nplant ( irp , 2 ) = casapool % nplant ( irp , 2 ) + ( dcHarvClear ( g )) & * casapool % nplant ( irp , 2 ) / casapool % cplant ( irp , 2 ) casapool % pplant ( irp , 2 ) = casapool % pplant ( irp , 2 ) + ( dcHarvClear ( g )) & * casapool % pplant ( irp , 2 ) / casapool % cplant ( irp , 2 ) casapool % cplant ( irp , 2 ) = casapool % cplant ( irp , 2 ) + dcHarvClear ( g ) #ifdef __C13DEBUG__ if ( irp == iwtile ) then print * , 'PP07 ' , casapool % cplant ( irp , iwpool ), dcHarvClear ( g ) endif #endif elseif ( ilu . eq . s . and . ( casapool % cplant ( irp , 2 ) + dcHarvClear ( g )). le . 0.0_dp ) then POPLUC % FHarvest ( g , 2 ) = 0.0_dp POPLUC % FClearance ( g , 2 ) = 0.0_dp popluc % FluxSHarvResidtoLitter ( g ) = 0.0_dp popluc % FluxSClearResidtoLitter ( g ) = 0.0_dp endif endif ! (patch(irp)%frac+dA(ilu)).gt.1.e-5_dp if ( patch ( irp )% frac . gt . 1.e-8_dp ) then casaflux % FluxCtohwp ( irp ) = POPLUC % FHarvest ( g , ilu ) / patch ( irp )% frac * real ( ktauday , dp ) casaflux % FluxCtoclear ( irp ) = POPLUC % FClearance ( g , ilu ) / patch ( irp )% frac * real ( ktauday , dp ) endif !if (g==3 .and. POPLUC%thisyear==1837 ) write(*,*) 'c01c',  casapool%cplant(irp,2), ilu,dcharvclear(g) enddo ! ilu=1, nlu ! POPLUC diagnostics ! pools in gC per m2 of gridcell ! NEP in g C y-1 per m2 of gridcell POPLUC % FNEP ( g ,:) = casabal % Fcneeyear ( j : l ) * patch ( j : l )% frac ! note NEE = NEP here !(+ve into surface) DO ilu = 1 , nLU ! update area weights irp = ilu + j - 1 ! Update tile area if ( ilu == p ) then POPLUC % primf ( g ) = max ( patch ( irp )% frac + dA_r ( ilu ) + dA_d ( ilu ), 0.0_dp ) elseif ( ilu == s ) then POPLUC % secdf ( g ) = max ( patch ( irp )% frac + dA_r ( ilu ) + dA_d ( ilu ), 0.0_dp ) if ( eq ( POPLUC % secdf ( g ), 0.0_dp )) then POPLUC % freq_age_secondary ( g ,:) = 0.0_dp endif elseif ( ilu == gr ) then POPLUC % grass ( g ) = max ( patch ( irp )% frac + dA_r ( ilu ) + dA_d ( ilu ), 0.0_dp ) POPLUC % past ( g ) = min ( max ( POPLUC % past ( g ) + POPLUC % ptoq ( g ) + POPLUC % stoq ( g ) & - POPLUC % qtos ( g ), 0.0_dp ), POPLUC % grass ( g )) POPLUC % crop ( g ) = min ( max ( POPLUC % crop ( g ) + POPLUC % ptoc ( g ) + POPLUC % stoc ( g ) & - POPLUC % ctos ( g ), 0.0_dp ), POPLUC % grass ( g ) - POPLUC % past ( g )) endif POPLUC % csoil ( g , ilu ) = sum ( casapool % csoil ( irp ,:)) * & max ( patch ( irp )% frac + dA_r ( ilu ) + dA_d ( ilu ), 0.0_dp ) POPLUC % clitt ( g , ilu ) = sum ( casapool % clitter ( irp ,:)) * & max ( patch ( irp )% frac + dA_r ( ilu ) + dA_d ( ilu ), 0.0_dp ) POPLUC % cbiomass ( g , ilu ) = sum ( casapool % cplant ( irp ,:)) * & max ( patch ( irp )% frac + dA_r ( ilu ) + dA_d ( ilu ), 0.0_dp ) ! if (g==4  .and. ilu==2) write(*,*) 'c02', casapool%cplant(irp,2), & !    casapool%cplant(irp,2)* max(patch(irp)%frac + dA_r(ilu) + dA_d(ilu), 0.0_dp), & !    patch(irp)%frac,  dA_r(ilu) + dA_d(ilu) !  if (g==4  .and. ilu==3) write(*,*) 'c03', casapool%csoil(irp,2), & !     casapool%csoil(irp,2)* max(patch(irp)%frac + dA_r(ilu) + dA_d(ilu), 0.0_dp), & !     patch(irp)%frac,  dA_r(ilu) + dA_d(ilu) ENDDO ELSE POPLUC % csoil ( g ,:) = 0.0_dp POPLUC % clitt ( g ,:) = 0.0_dp POPLUC % cbiomass ( g ,:) = 0.0_dp POPLUC % FNEP ( g ,:) = 0.0_dp POPLUC % csoil ( g , 1 ) = sum ( casapool % csoil ( j ,:)) * patch ( j )% frac POPLUC % clitt ( g , 1 ) = sum ( casapool % clitter ( j ,:)) * patch ( j )% frac POPLUC % cbiomass ( g , 1 ) = sum ( casapool % cplant ( j ,:)) * patch ( j )% frac POPLUC % FNEP ( g , 1 ) = casabal % Fcneeyear ( j ) * patch ( j )% frac POPLUC % primf ( g ) = patch ( j )% frac POPLUC % secdf ( g ) = 0.0_dp if ( POPLUC % grass ( g ). gt . 0.0_dp . and . l . eq . j + 1 ) then POPLUC % csoil ( g , 3 ) = sum ( casapool % csoil ( l ,:)) * patch ( l )% frac POPLUC % clitt ( g , 3 ) = sum ( casapool % clitter ( l ,:)) * patch ( l )% frac POPLUC % cbiomass ( g , 3 ) = sum ( casapool % cplant ( l ,:)) * patch ( l )% frac POPLUC % FNEP ( g , 3 ) = casabal % Fcneeyear ( l ) * patch ( l )% frac POPLUC % grass ( g ) = patch ( l )% frac endif ENDIF POPLUC % HarvProdLoss ( g ,:) = kHarvProd * POPLUC % HarvProd ( g ,:) POPLUC % ClearProdLoss ( g ,:) = kClearProd * POPLUC % ClearProd ( g ,:) POPLUC % AgProdLoss ( g ) = kAgProd * POPLUC % AgProd ( g ) if ( POPLUC % grass ( g ). gt . 0.0_dp . and . l . eq . j + 2 ) then POPLUC % FAg ( g ) = casaflux % Charvest ( l ) * patch ( l )% frac POPLUC % AgProd ( g ) = POPLUC % AgProd ( g ) + casaflux % Charvest ( l ) * patch ( l )% frac - POPLUC % AgProdLoss ( g ) casaflux % charvest ( l ) = 0.0_dp casaflux % nharvest ( l ) = 0.0_dp casaflux % fharvest ( l ) = min ( POPLUC % past ( g ) / POPLUC % grass ( g ), 1.0_dp ) * 0.5_dp + & min ( POPLUC % crop ( g ) / POPLUC % grass ( g ), 1.0_dp ) * 0.9_dp !  fraction grass AGB to be removed next year !write(*,*)'harvest', g,   patch(l)%frac,  casaflux%fharvest(l), POPLUC%crop(g),  POPLUC%past(g) !casaflux%fharvest(l) = 0; ! test vh! casaflux % fcrop ( l ) = min ( POPLUC % crop ( g ) / POPLUC % grass ( g ), 1.0_dp ) endif DO j = 1 , 3 POPLUC % HarvProd ( g , j ) = POPLUC % HarvProd ( g , j ) + & POPLUC % fracHarvProd ( g , j ) * sum ( POPLUC % FHarvest ( g ,:)) - POPLUC % HarvProdLoss ( g , j ) POPLUC % ClearProd ( g , j ) = POPLUC % ClearProd ( g , j ) + & POPLUC % fracClearProd ( g , j ) * sum ( POPLUC % FClearance ( g ,:)) - POPLUC % ClearProdLoss ( g , j ) ENDDO ENDDO ! update total carbon pools and \"last\" pool values for use in carbon balance checks. casapool % ctot = sum ( casapool % cplant , 2 ) + sum ( casapool % clitter , 2 ) + & sum ( casapool % csoil , 2 ) + casapool % clabile casabal % cplantlast = casapool % cplant casabal % clabilelast = casapool % clabile casabal % clitterlast = casapool % clitter casabal % csoillast = casapool % csoil END SUBROUTINE POP_LUC_CASA_transfer !******************************************************************************* SUBROUTINE POPLUC_Init ( POPLUC , LUC_EXPT , casapool , casaflux , casabiome , veg , POP , np ) USE cable_def_types_mod , ONLY : veg_parameter_type USE casaparm , ONLY : LEAF , WOOD , FROOT IMPLICIT NONE TYPE ( POPLUC_TYPE ), INTENT ( INOUT ) :: POPLUC TYPE ( LUC_EXPT_TYPE ), INTENT ( IN ) :: LUC_EXPT TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_biome ), INTENT ( IN ) :: casabiome TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg ! vegetation parameters TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP INTEGER ( i4b ), INTENT ( IN ) :: np INTEGER ( i4b ) :: j , k , l CALL alloc_POPLUC ( POPLUC , np ) POPLUC % it = 0 POPLUC % np = np CALL Zero_POPLUC ( POPLUC ) CALL POPLUC_set_params ( POPLUC , LUC_EXPT ) IF ( cable_user % POPLUC_RunType . eq . 'init' ) THEN POPLUC % frac_primf = real ( LUC_EXPT % primaryf , dp ) POPLUC % primf = real ( LUC_EXPT % primaryf , dp ) POPLUC % grass = real ( LUC_EXPT % grass , dp ) POPLUC % past = real ( LUC_EXPT % past , dp ) POPLUC % crop = real ( LUC_EXPT % crop , dp ) where (( POPLUC % primf + POPLUC % grass ) > 1.0_dp ) POPLUC % grass = 1.0_dp - POPLUC % primf POPLUC % frac_forest = 1.0_dp - POPLUC % grass POPLUC % freq_age_secondary (:, 1 ) = max ( POPLUC % frac_forest - POPLUC % primf , 0.0_dp ) POPLUC % latitude = real ( patch ( landpt (:)% cstart )% latitude , dp ) POPLUC % longitude = real ( patch ( landpt (:)% cstart )% longitude , dp ) ! zero biomass in secondary forest tiles (both CASA and POP variables) where ( veg % iLU == 2 ) casapool % cplant (:, leaf ) = 0.01_dp casapool % nplant (:, leaf ) = casabiome % ratioNCplantmin ( veg % iveg , leaf ) * casapool % cplant (:, leaf ) casapool % pplant (:, leaf ) = casabiome % ratioPCplantmin ( veg % iveg , leaf ) * casapool % cplant (:, leaf ) casapool % cplant (:, froot ) = 0.01_dp casapool % nplant (:, froot ) = casabiome % ratioNCplantmin ( veg % iveg , froot ) * & casapool % cplant (:, froot ) casapool % pplant (:, froot ) = casabiome % ratioPCplantmin ( veg % iveg , froot ) * & casapool % cplant (:, froot ) casapool % cplant (:, wood ) = 0.01_dp casapool % nplant (:, wood ) = casabiome % ratioNCplantmin ( veg % iveg , wood ) * casapool % cplant (:, wood ) casapool % pplant (:, wood ) = casabiome % ratioPCplantmin ( veg % iveg , wood ) * casapool % cplant (:, wood ) casaflux % frac_sapwood = 1.0_dp endwhere DO k = 1 , np IF (. NOT . LUC_EXPT % prim_only ( k )) THEN j = landpt ( k )% cstart + 1 do l = 1 , size ( POP % Iwood ) if ( POP % Iwood ( l ) == j ) then CALL POP_init_single ( POP , veg % disturbance_interval , l ) exit endif enddo ENDIF ENDDO ELSEIF ( cable_user % POPLUC_RunType . eq . 'restart' ) THEN CALL READ_LUC_RESTART_NC ( POPLUC ) POPLUC % frac_primf = POPLUC % primf POPLUC % frac_forest = 1.0_dp - POPLUC % grass POPLUC % latitude = real ( patch ( landpt (:)% cstart )% latitude , dp ) POPLUC % longitude = real ( patch ( landpt (:)% cstart )% longitude , dp ) ENDIF ! set landuse index for secondary forest POP landscapes ! (not for 'static') run type because secondary forest dynamics are only ! simulated with dynamic land-use forcing IF ( TRIM ( cable_user % POPLUC_RunType ) . ne . 'static' ) THEN DO k = 1 , POP % np if ( veg % iLU ( POP % Iwood ( k )). eq . 2 ) then POP % pop_grid ( k )% LU = 2 endif ENDDO ENDIF END SUBROUTINE POPLUC_Init !******************************************************************************* SUBROUTINE POPLUC_set_patchfrac ( POPLUC , LUC_EXPT ) IMPLICIT NONE TYPE ( POPLUC_TYPE ), INTENT ( IN ) :: POPLUC TYPE ( LUC_EXPT_TYPE ), INTENT ( IN ) :: LUC_EXPT INTEGER ( i4b ) :: j , k , l DO k = 1 , POPLUC % np j = landpt ( k )% cstart l = landpt ( k )% cend IF (. NOT . LUC_EXPT % prim_only ( k )) THEN patch ( j )% frac = POPLUC % primf ( k ) patch ( l )% frac = POPLUC % grass ( k ) patch ( j + 1 )% frac = 1.0_dp - patch ( j )% frac - patch ( l )% frac ENDIF ENDDO END SUBROUTINE POPLUC_SET_PATCHFRAC !******************************************************************************* SUBROUTINE POPLUC_set_params ( POPLUC , LUC_EXPT ) IMPLICIT NONE TYPE ( POPLUC_TYPE ), INTENT ( INOUT ) :: POPLUC TYPE ( LUC_EXPT_TYPE ), INTENT ( IN ) :: LUC_EXPT INTEGER ( i4b ) :: g , np np = POPLUC % np DO g = 1 , np POPLUC % fracharvProd ( g , 1 ) = 0.9_dp POPLUC % fracharvProd ( g , 2 ) = 0.04_dp POPLUC % fracharvProd ( g , 3 ) = 0.06_dp POPLUC % fracClearProd ( g , 1 ) = 0.597_dp POPLUC % fracClearProd ( g , 2 ) = 0.403_dp POPLUC % fracClearProd ( g , 3 ) = 0.0_dp POPLUC % fracClearResid ( g ) = 0.33_dp POPLUC % fracHarvResid ( g ) = 0.79_dp POPLUC % fracHarvSecResid ( g ) = 0.81_dp IF ( LUC_EXPT % biome ( g ) == 1 . OR . LUC_EXPT % biome ( g ) == 2 ) THEN ! Tropical Evergreen and Tropical Deciduous POPLUC % fracharvProd ( g , 1 ) = 0.9_dp POPLUC % fracharvProd ( g , 2 ) = 0.04_dp POPLUC % fracharvProd ( g , 3 ) = 0.06_dp POPLUC % fracClearProd ( g , 1 ) = 0.597_dp POPLUC % fracClearProd ( g , 2 ) = 0.403_dp POPLUC % fracClearProd ( g , 3 ) = 0.0_dp IF ( LUC_EXPT % biome ( g ) == 1 ) POPLUC % fracHarvResid ( g ) = 0.79_dp IF ( LUC_EXPT % biome ( g ) == 2 ) POPLUC % fracHarvResid ( g ) = 0.86_dp IF ( LUC_EXPT % biome ( g ) == 1 ) POPLUC % fracHarvSecResid ( g ) = 0.71_dp IF ( LUC_EXPT % biome ( g ) == 2 ) POPLUC % fracHarvSecResid ( g ) = 0.81_dp POPLUC % fracClearResid ( g ) = 0.33_dp ELSEIF ( LUC_EXPT % biome ( g ). GE . 4 . OR . LUC_EXPT % biome ( g ). LE . 10 ) THEN ! Other Forest POPLUC % fracharvProd ( g , 1 ) = 0.4_dp POPLUC % fracharvProd ( g , 2 ) = 0.24_dp POPLUC % fracharvProd ( g , 3 ) = 0.36_dp POPLUC % fracClearProd ( g , 1 ) = 0.597_dp POPLUC % fracClearProd ( g , 2 ) = 0.2985_dp POPLUC % fracClearProd ( g , 3 ) = 0.1045_dp IF ( LUC_EXPT % ivegp ( g ) == 2 ) POPLUC % fracHarvResid ( g ) = 0.83_dp IF ( LUC_EXPT % ivegp ( g ) == 1 . OR . LUC_EXPT % ivegp ( g ) == 3 ) POPLUC % fracHarvResid ( g ) = 0.87_dp IF ( LUC_EXPT % ivegp ( g ) == 4 ) POPLUC % fracHarvResid ( g ) = 0.78_dp IF ( LUC_EXPT % ivegp ( g ) == 2 ) POPLUC % fracHarvSecResid ( g ) = 0.75_dp IF ( LUC_EXPT % ivegp ( g ) == 1 . OR . LUC_EXPT % ivegp ( g ) == 3 ) POPLUC % fracHarvSecResid ( g ) = 0.82_dp IF ( LUC_EXPT % ivegp ( g ) == 4 ) POPLUC % fracHarvSecResid ( g ) = 0.70_dp POPLUC % fracClearResid ( g ) = 0.33_dp ELSEIF ( LUC_EXPT % biome ( g ). EQ . 3 . OR . LUC_EXPT % biome ( g ). GE . 11 ) THEN ! savanna and shrub POPLUC % fracharvProd ( g , 1 ) = 1.0_dp POPLUC % fracharvProd ( g , 2 ) = 0.0_dp POPLUC % fracharvProd ( g , 3 ) = 0.0_dp POPLUC % fracClearProd ( g , 1 ) = 0.8_dp POPLUC % fracClearProd ( g , 2 ) = 0.2_dp POPLUC % fracClearProd ( g , 3 ) = 0.0_dp IF ( LUC_EXPT % biome ( g ). EQ . 13 . OR .( LUC_EXPT % biome ( g ). EQ . 14 ) ) THEN POPLUC % fracHarvResid ( g ) = 0.78_dp POPLUC % fracHarvSecResid ( g ) = 0.70_dp ELSE POPLUC % fracHarvResid ( g ) = 0.86_dp POPLUC % fracHarvSecResid ( g ) = 0.81_dp ENDIF POPLUC % fracClearResid ( g ) = 0.5_dp ENDIF ! no residue test !POPLUC%fracClearResid(g) = 0.0_dp ! POPLUC%fracHarvResid(g) = 0.0_dp ! POPLUC%fracHarvSecResid(g) = 0.0_dp ENDDO END SUBROUTINE POPLUC_SET_PARAMS !******************************************************************************* SUBROUTINE alloc_POPLUC ( POPLUC , arraysize ) IMPLICIT NONE TYPE ( POPLUC_TYPE ), INTENT ( INOUT ) :: POPLUC INTEGER , INTENT ( IN ) :: arraysize ALLOCATE ( POPLUC % it ) ALLOCATE ( POPLUC % np ) ALLOCATE ( POPLUC % firstyear ) ALLOCATE ( POPLUC % thisyear ) ALLOCATE ( POPLUC % latitude ( arraysize )) ALLOCATE ( POPLUC % longitude ( arraysize )) ALLOCATE ( POPLUC % n_event ( arraysize )) ALLOCATE ( POPLUC % primf ( arraysize )) ALLOCATE ( POPLUC % secdf ( arraysize )) ALLOCATE ( POPLUC % grass ( arraysize )) ALLOCATE ( POPLUC % crop ( arraysize )) ALLOCATE ( POPLUC % past ( arraysize )) ALLOCATE ( POPLUC % ptos ( arraysize )) ALLOCATE ( POPLUC % ptog ( arraysize )) ALLOCATE ( POPLUC % stog ( arraysize )) ALLOCATE ( POPLUC % gtop ( arraysize )) ALLOCATE ( POPLUC % gtos ( arraysize )) ALLOCATE ( POPLUC % ptog ( arraysize )) ALLOCATE ( POPLUC % ptoc ( arraysize )) ALLOCATE ( POPLUC % ptoq ( arraysize )) ALLOCATE ( POPLUC % stoc ( arraysize )) ALLOCATE ( POPLUC % stoq ( arraysize )) ALLOCATE ( POPLUC % ctos ( arraysize )) ALLOCATE ( POPLUC % qtos ( arraysize )) ALLOCATE ( POPLUC % pharv ( arraysize )) ALLOCATE ( POPLUC % smharv ( arraysize )) ALLOCATE ( POPLUC % syharv ( arraysize )) ALLOCATE ( POPLUC % frac_primf ( arraysize )) ALLOCATE ( POPLUC % frac_forest ( arraysize )) ALLOCATE ( POPLUC % freq_age_primary ( arraysize , AGE_MAX )) ALLOCATE ( POPLUC % freq_age_secondary ( arraysize , AGE_MAX )) ALLOCATE ( POPLUC % biomass_age_primary ( arraysize , AGE_MAX )) ALLOCATE ( POPLUC % biomass_age_secondary ( arraysize , AGE_MAX )) ALLOCATE ( POPLUC % age_history_secdf ( arraysize , LENGTH_SECDF_HISTORY )) ALLOCATE ( POPLUC % area_history_secdf ( arraysize , LENGTH_SECDF_HISTORY )) ALLOCATE ( POPLUC % FNEP ( arraysize , nLU )) ALLOCATE ( POPLUC % Clitt ( arraysize , nLU )) ALLOCATE ( POPLUC % Csoil ( arraysize , nLU )) ALLOCATE ( POPLUC % Cbiomass ( arraysize , nLU )) ALLOCATE ( POPLUC % FHarvest ( arraysize , nLU )) ALLOCATE ( POPLUC % FClearance ( arraysize , nLU )) ALLOCATE ( POPLUC % FTransferNet ( arraysize , nLU )) ALLOCATE ( POPLUC % FTransferGross ( arraysize , nTrans )) ALLOCATE ( POPLUC % HarvProd ( arraysize , 3 )) ALLOCATE ( POPLUC % AgProd ( arraysize )) ALLOCATE ( POPLUC % ClearProd ( arraysize , 3 )) ALLOCATE ( POPLUC % HarvProdLoss ( arraysize , 3 )) ALLOCATE ( POPLUC % ClearProdLoss ( arraysize , 3 )) ALLOCATE ( POPLUC % AgProdLoss ( arraysize )) ALLOCATE ( POPLUC % FAg ( arraysize )) ALLOCATE ( POPLUC % fracHarvProd ( arraysize , 3 )) ALLOCATE ( POPLUC % fracClearProd ( arraysize , 3 )) ALLOCATE ( POPLUC % fracHarvResid ( arraysize )) ALLOCATE ( POPLUC % fracHarvSecResid ( arraysize )) ALLOCATE ( POPLUC % fracClearResid ( arraysize )) ALLOCATE ( POPLUC % kSecHarv ( arraysize )) ALLOCATE ( POPLUC % kNatDist ( arraysize )) ALLOCATE ( POPLUC % kExpand1 ( arraysize )) ALLOCATE ( POPLUC % kExpand2 ( arraysize )) ALLOCATE ( POPLUC % kClear ( arraysize )) ALLOCATE ( POPLUC % cRelClear ( arraysize )) allocate ( popluc % FluxPHarvResidtoLitter ( arraysize )) allocate ( popluc % FluxSHarvResidtoLitter ( arraysize )) allocate ( popluc % FluxPClearResidtoLitter ( arraysize )) ! Residual flux to litter from clearing primary forest allocate ( popluc % FluxSClearResidtoLitter ( arraysize )) allocate ( popluc % dcSHarvClear ( arraysize )) END SUBROUTINE alloc_POPLUC !******************************************************************************* ! Exponential distribution ! Returns probability of a given time-between-events (x) ! Given a Poisson process with expected frequency (events per unit time) lambda ! Reference: http://en.wikipedia.org/wiki/Exponential_distribution ! Use to determine average age (x, years) of patches with a given random disturbance ! frequency lambda (disturbances per year) REAL ( dp ) FUNCTION REALExponential ( lambda , x ) IMPLICIT NONE REAL ( dp ), INTENT ( IN ) :: lambda REAL ( dp ), INTENT ( IN ) :: x IF ( x . LT . 0.0_dp ) THEN ! Shouldn't happen but ... REALExponential = 0.0_dp ELSE REALExponential = lambda * EXP ( - lambda * x ) ENDIF END FUNCTION REALExponential !******************************************************************************* SUBROUTINE WRITE_LUC_OUTPUT_NC ( POPLUC , ctime , FINAL ) USE CABLE_COMMON_MODULE , ONLY : filename , cable_user , HANDLE_ERR USE netcdf IMPLICIT NONE TYPE ( POPLUC_TYPE ), INTENT ( IN ) :: POPLUC INTEGER , INTENT ( IN ) :: ctime LOGICAL , INTENT ( IN ) :: FINAL INTEGER :: STATUS INTEGER :: land_ID , age_ID , hist_ID , t_ID , nLU_ID , nTrans_ID INTEGER :: i , mp , nprod , nprod_ID CHARACTER :: FNAME * 99 , dum * 50 LOGICAL , SAVE :: CALL1 = . TRUE . ! 1 dim arrays (mp ) CHARACTER ( len = 20 ), DIMENSION ( 2 ) :: A0 ! 2 dim real arrays (mp,t) CHARACTER ( len = 20 ), DIMENSION ( 24 ) :: A1 ! 2 dim integer arrays (mp,t) CHARACTER ( len = 20 ), DIMENSION ( 1 ) :: AI1 ! 3 dim real arrays (mp,age_max,t) CHARACTER ( len = 25 ), DIMENSION ( 4 ) :: A2 ! 3 dim real arrays (mp,LENGTH_SECDF_HISTORY,t) CHARACTER ( len = 20 ), DIMENSION ( 1 ) :: A3 ! 3 dim integer arrays (mp,LENGTH_SECDF_HISTORY,t) CHARACTER ( len = 20 ), DIMENSION ( 1 ) :: AI3 ! 3 dim real arrays (mp,nLU,t) CHARACTER ( len = 20 ), DIMENSION ( 7 ) :: A4 ! 3 dim real arrays (mp,nTrans,t) CHARACTER ( len = 20 ), DIMENSION ( 1 ) :: A5 ! 3 dim real arrays (mp,nprod,t) CHARACTER ( len = 20 ), DIMENSION ( 4 ) :: A6 INTEGER , SAVE :: VIDtime , VID0 ( SIZE ( A0 )), VID1 ( SIZE ( A1 )), VIDI1 ( SIZE ( AI1 )) INTEGER , SAVE :: VID2 ( SIZE ( A2 )) INTEGER , SAVE :: VID4 ( SIZE ( A4 )), VID5 ( SIZE ( A5 )), VID6 ( size ( A6 )) INTEGER , SAVE :: FILE_ID , CNT = 0 REAL ( dp ), ALLOCATABLE :: freq_age_secondary (:,:) INTEGER :: g LOGICAL :: put_age_vars mp = POPLUC % np nprod = 3 put_age_vars = . TRUE . allocate ( freq_age_secondary ( mp , age_max )) A0 ( 1 ) = 'latitude' A0 ( 2 ) = 'longitude' A1 ( 1 ) = 'primf' A1 ( 2 ) = 'secdf' A1 ( 3 ) = 'grass' A1 ( 4 ) = 'ptos' A1 ( 5 ) = 'ptog' A1 ( 6 ) = 'stog' A1 ( 7 ) = 'gtop' A1 ( 8 ) = 'gtos' A1 ( 9 ) = 'frac_primf' A1 ( 10 ) = 'frac_forest' A1 ( 11 ) = 'pharv' A1 ( 12 ) = 'smharv' A1 ( 13 ) = 'syharv' A1 ( 14 ) = 'crop' A1 ( 15 ) = 'past' A1 ( 16 ) = 'ptoc' A1 ( 17 ) = 'ptoq' A1 ( 18 ) = 'stoc' A1 ( 19 ) = 'stoq' A1 ( 20 ) = 'qtos' A1 ( 21 ) = 'ctos' A1 ( 22 ) = 'AgProd' A1 ( 23 ) = 'AgProdLoss' A1 ( 24 ) = 'FAg' AI1 ( 1 ) = 'n_event' A2 ( 1 ) = 'freq_age_primary' A2 ( 2 ) = 'freq_age_secondary' A2 ( 3 ) = 'biomass_age_primary' A2 ( 4 ) = 'biomass_age_secondary' A3 ( 1 ) = 'area_history_secdf' AI3 ( 1 ) = 'age_history_secdf' A4 ( 1 ) = 'FHarvest' A4 ( 2 ) = 'FClearance' A4 ( 3 ) = 'FNEP' A4 ( 4 ) = 'CLitt' A4 ( 5 ) = 'CSoil' A4 ( 6 ) = 'CBiomass' A4 ( 7 ) = 'FTransferNet' A5 ( 1 ) = 'FTransferGross' A6 ( 1 ) = 'HarvProd' A6 ( 2 ) = 'ClearProd' A6 ( 3 ) = 'HarvProdLoss' A6 ( 4 ) = 'ClearProdLoss' DO g = 1 , mp if ( sum ( POPLUC % freq_age_secondary ( g ,:)). gt . 1.e-12_dp ) then freq_age_secondary ( g ,:) = POPLUC % freq_age_secondary ( g ,:) / sum ( POPLUC % freq_age_secondary ( g ,:)) else freq_age_secondary ( g ,:) = 0.0_dp endif ENDDO CNT = CNT + 1 ! Get File-Name if ( cable_user % yearstart < 1000 ) then write ( dum , fmt = \"(i3)\" ) cable_user % yearstart else write ( dum , fmt = \"(i4)\" ) cable_user % yearstart endif if ( cable_user % yearend < 1000 ) then write ( dum , fmt = \"(a,a,i3)\" ) trim ( dum ), '_' , cable_user % yearend else write ( dum , fmt = \"(a,a,i4)\" ) trim ( dum ), '_' , cable_user % yearend endif if ( len_trim ( cable_user % LUC_outfile ) . gt . 0 ) then fname = trim ( cable_user % LUC_outfile ) else fname = trim ( filename % path ) // '/' // trim ( cable_user % RunIden ) // '_' // trim ( dum ) // '_LUC_out.nc' endif IF ( CALL1 ) THEN ! Create NetCDF file: #ifdef __NETCDF3__ STATUS = NF90_create ( trim ( fname ), ior ( nf90_clobber , nf90_64bit_offset ), FILE_ID ) #else STATUS = NF90_create ( trim ( fname ), ior ( nf90_clobber , ior ( nf90_netcdf4 , nf90_classic_model )), FILE_ID ) #endif IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_ATT ( FILE_ID , NF90_GLOBAL , \"StartYear\" , CABLE_USER % YEARSTART ) STATUS = NF90_PUT_ATT ( FILE_ID , NF90_GLOBAL , \"EndYear\" , CABLE_USER % YEAREND ) STATUS = NF90_PUT_ATT ( FILE_ID , NF90_GLOBAL , \"RunIden\" , CABLE_USER % RunIden ) ! Define dimensions: ! Land (number of points) STATUS = NF90_def_dim ( FILE_ID , 'land' , mp , land_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'mage' , age_max , age_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'mhist' , LENGTH_SECDF_HISTORY , hist_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'mLU' , nLU , nLU_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'mTrans' , nTrans , nTrans_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'nprod' , nprod , nprod_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'time' , NF90_UNLIMITED , t_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! Define variables STATUS = NF90_def_var ( FILE_ID , 'time' , NF90_INT ,( / t_ID / ), VIDtime ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO i = 1 , SIZE ( A0 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A0 ( i )) , NF90_FLOAT ,( / land_ID / ), VID0 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( A1 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A1 ( i )) , NF90_FLOAT ,( / land_ID , t_ID / ), VID1 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI1 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AI1 ( i )) , NF90_INT ,( / land_ID , t_ID / ), VIDI1 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO if ( put_age_vars ) then DO i = 1 , SIZE ( A2 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A2 ( i )) , NF90_FLOAT ,( / land_ID , age_ID , t_ID / ), VID2 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO endif !$ !$       DO i = 1, SIZE(A3) !$          STATUS = NF90_def_var(FILE_ID,TRIM(A3(i)) ,NF90_FLOAT,(/land_ID,hist_ID,t_ID/),VID3(i)) !$          IF (STATUS /= NF90_noerr) CALL handle_err(STATUS) !$       END DO !$ !$       DO i = 1, SIZE(A3) !$          STATUS = NF90_def_var(FILE_ID,TRIM(AI3(i)) ,NF90_INT,(/land_ID,hist_ID,t_ID/),VIDI3(i)) !$          IF (STATUS /= NF90_noerr) CALL handle_err(STATUS) !$       END DO DO i = 1 , SIZE ( A4 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A4 ( i )) , NF90_FLOAT ,( / land_ID , nLU_ID , t_ID / ), VID4 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( A5 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A5 ( i )) , NF90_FLOAT ,( / land_ID , ntrans_ID , t_ID / ), VID5 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( A6 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A6 ( i )) , NF90_FLOAT ,( / land_ID , nprod_ID , t_ID / ), VID6 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO ! End define mode: STATUS = NF90_enddef ( FILE_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! PUT LAT / LON ( mp ) STATUS = NF90_PUT_VAR ( FILE_ID , VID0 ( 1 ), real ( POPLUC % latitude , sp )) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID0 ( 2 ), real ( POPLUC % longitude , sp )) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) CALL1 = . FALSE . ENDIF ! CALL1 ! TIME  ( t ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDtime , ctime , start = ( / CNT / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! PUT 2D VARS ( mp, t ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 1 ), real ( POPLUC % primf , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 2 ), real ( POPLUC % secdf , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 3 ), real ( POPLUC % grass , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 4 ), real ( POPLUC % ptos , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 5 ), real ( POPLUC % ptog , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 6 ), real ( POPLUC % stog , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 7 ), real ( POPLUC % gtop , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 8 ), real ( POPLUC % gtos , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 9 ), real ( POPLUC % frac_primf , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 10 ), real ( POPLUC % frac_forest , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 11 ), real ( POPLUC % pharv , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 12 ), real ( POPLUC % smharv , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 13 ), real ( POPLUC % syharv , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 14 ), real ( POPLUC % crop , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 15 ), real ( POPLUC % past , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 16 ), real ( POPLUC % ptoc , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 17 ), real ( POPLUC % ptoq , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 18 ), real ( POPLUC % stoc , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 19 ), real ( POPLUC % stoq , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 20 ), real ( POPLUC % qtos , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 21 ), real ( POPLUC % ctos , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 22 ), real ( POPLUC % AgProd , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 23 ), real ( POPLUC % AgProdLoss , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 24 ), real ( POPLUC % FAg , sp ), start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDI1 ( 1 ), POPLUC % n_event , start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) if ( put_age_vars ) then ! PUT 3D VARS ( mp, mage, t ) STATUS = NF90_PUT_VAR ( FILE_ID , VID2 ( 1 ), real ( POPLUC % freq_age_primary , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , age_max , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID2 ( 2 ), real ( freq_age_secondary , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , age_max , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID2 ( 3 ), real ( POPLUC % biomass_age_primary , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , age_max , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID2 ( 4 ), real ( POPLUC % biomass_age_secondary , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , age_max , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) endif ! PUT 3D VARS ( mp, nLU, t ) STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 1 ), real ( POPLUC % FHarvest , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , nLU , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 2 ), real ( POPLUC % FClearance , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , nLU , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 3 ), real ( POPLUC % FNEP , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , nLU , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 4 ), real ( POPLUC % Clitt , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , nLU , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 5 ), real ( POPLUC % CSoil , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , nLU , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 6 ), real ( POPLUC % CBiomass , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , nLU , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 7 ), real ( POPLUC % FTransferNet , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , nLU , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! PUT 3D VARS ( mp, nTrans, t ) STATUS = NF90_PUT_VAR ( FILE_ID , VID5 ( 1 ), real ( POPLUC % FTransferGross , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , nTrans , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! PUT 3D VARS ( mp, nprod, t ) STATUS = NF90_PUT_VAR ( FILE_ID , VID6 ( 1 ), real ( POPLUC % HarvProd , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , nprod , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID6 ( 2 ), real ( POPLUC % ClearProd , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , nprod , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID6 ( 3 ), real ( POPLUC % HarvProdLoss , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , nprod , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID6 ( 4 ), real ( POPLUC % ClearProdLoss , sp ), & start = ( / 1 , 1 , CNT / ), count = ( / mp , nprod , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) IF ( FINAL ) THEN ! Close NetCDF file: STATUS = NF90_close ( FILE_ID ) file_id = - 1 IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) WRITE ( * , * ) \" POPLUC Output written to \" , trim ( fname ) ENDIF END SUBROUTINE WRITE_LUC_OUTPUT_NC !********************************************************************************************************************* SUBROUTINE WRITE_LUC_RESTART_NC ( POPLUC ) use cable_common_module , only : filename , cable_user , HANDLE_ERR use netcdf implicit none type ( popluc_type ), intent ( in ) :: POPLUC INTEGER :: STATUS INTEGER :: land_ID , age_ID , i , mp , nprod_ID CHARACTER :: FNAME * 99 , dum * 50 ! 1 dim arrays (mp ) CHARACTER ( len = 20 ), DIMENSION ( 2 ) :: A0 ! 2 dim real arrays (mp) CHARACTER ( len = 20 ), DIMENSION ( 6 ) :: A1 ! 2 dim real arrays (mp,age_max) CHARACTER ( len = 25 ), DIMENSION ( 2 ) :: A2 ! 2 dim real arrays (mp,nprod) CHARACTER ( len = 25 ), DIMENSION ( 2 ) :: A3 INTEGER , SAVE :: VID0 ( SIZE ( A0 )), VID1 ( SIZE ( A1 )) INTEGER , SAVE :: VID2 ( SIZE ( A2 )), VID3 ( SIZE ( A3 )) INTEGER , SAVE :: FILE_ID INTEGER :: nprod mp = POPLUC % np nprod = 3 ! number of product pools A0 ( 1 ) = 'latitude' A0 ( 2 ) = 'longitude' A1 ( 1 ) = 'primf' A1 ( 2 ) = 'secdf' A1 ( 3 ) = 'grass' A1 ( 4 ) = 'crop' A1 ( 5 ) = 'past' A1 ( 6 ) = 'AgProd' A2 ( 1 ) = 'biomass_age_secondary' A2 ( 2 ) = 'freq_age_secondary' A3 ( 1 ) = 'HarvProd' A3 ( 2 ) = 'ClearProd' ! Get File-Name write ( dum , fmt = \"(i4,'_',i4)\" ) cable_user % yearstart , cable_user % yearend if ( cable_user % yearstart . lt . 1000 . and . cable_user % yearend . lt . 1000 ) then write ( dum , fmt = \"(i3,'_',i3)\" ) cable_user % yearstart , cable_user % yearend elseif ( cable_user % yearstart . lt . 1000 ) then write ( dum , fmt = \"(i3,'_',i4)\" ) cable_user % yearstart , cable_user % yearend endif if ( len_trim ( cable_user % luc_restart_out ) . gt . 0 ) then fname = trim ( cable_user % luc_restart_out ) else fname = trim ( filename % path ) // '/' // trim ( cable_user % RunIden ) // '_' // 'LUC_rst.nc' endif ! Create NetCDF file: STATUS = NF90_create ( trim ( fname ), ior ( nf90_clobber , nf90_64bit_offset ), FILE_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! Put the file in define mode: STATUS = NF90_redef ( FILE_ID ) STATUS = NF90_PUT_ATT ( FILE_ID , NF90_GLOBAL , \"StartYear\" , CABLE_USER % YEARSTART ) STATUS = NF90_PUT_ATT ( FILE_ID , NF90_GLOBAL , \"EndYear\" , CABLE_USER % YEAREND ) STATUS = NF90_PUT_ATT ( FILE_ID , NF90_GLOBAL , \"RunIden\" , CABLE_USER % RunIden ) ! Define dimensions: ! Land (number of points) status = nf90_def_dim ( file_id , 'land' , mp , land_id ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_def_dim ( file_id , 'mage' , age_max , age_id ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_def_dim ( file_id , 'nprod' , nprod , nprod_id ) ! Define variables DO i = 1 , SIZE ( A0 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A0 ( i )), NF90_DOUBLE , ( / land_ID / ), VID0 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( A1 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A1 ( i )), NF90_DOUBLE , ( / land_ID / ), VID1 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( A2 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A2 ( i )), NF90_DOUBLE , ( / land_ID , age_ID / ), VID2 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( A3 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A3 ( i )), NF90_DOUBLE , ( / land_ID , nprod_ID / ), VID3 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO ! End define mode: STATUS = NF90_enddef ( FILE_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! PUT LAT / LON ( mp ) STATUS = NF90_PUT_VAR ( FILE_ID , VID0 ( 1 ), POPLUC % latitude ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID0 ( 2 ), POPLUC % longitude ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! PUT 2D VARS ( mp, t ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 1 ), POPLUC % primf ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 2 ), POPLUC % secdf ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 3 ), POPLUC % grass ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 4 ), POPLUC % crop ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 5 ), POPLUC % past ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 6 ), POPLUC % AgProd ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! PUT 3D VARS ( mp, mage, t ) STATUS = NF90_PUT_VAR ( FILE_ID , VID2 ( 1 ), POPLUC % biomass_age_secondary ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID2 ( 2 ), POPLUC % freq_age_secondary ) ! PUT 3D VARS ( mp, nprod, t ) STATUS = NF90_PUT_VAR ( FILE_ID , VID3 ( 1 ), POPLUC % HarvProd ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID3 ( 2 ), POPLUC % ClearProd ) ! Close NetCDF file: STATUS = NF90_close ( FILE_ID ) file_id = - 1 IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) WRITE ( * , * ) \" POPLUC Restart written to \" , trim ( fname ) END SUBROUTINE WRITE_LUC_RESTART_NC !******************************************************************************* SUBROUTINE READ_LUC_RESTART_NC ( POPLUC ) USE CABLE_COMMON_MODULE , ONLY : filename , cable_user , HANDLE_ERR USE netcdf IMPLICIT NONE TYPE ( POPLUC_TYPE ), INTENT ( INOUT ) :: POPLUC INTEGER :: STATUS , land_dim , mage_dim , nprod_dim INTEGER :: i , mp , FILE_ID , dID , nprod CHARACTER :: FNAME * 99 REAL ( dp ), ALLOCATABLE :: TMP (:), TMP2 (:,:), TMP3 (:,:) ! 1 dim arrays (mp ) CHARACTER ( len = 20 ), DIMENSION ( 2 ) :: A0 ! 2 dim real arrays (mp) CHARACTER ( len = 20 ), DIMENSION ( 6 ) :: A1 ! 2 dim real arrays (mp,age_max) CHARACTER ( len = 25 ), DIMENSION ( 2 ) :: A2 ! 2 dim real arrays (mp,nprod) CHARACTER ( len = 25 ), DIMENSION ( 2 ) :: A3 mp = POPLUC % np nprod = 3 ALLOCATE ( tmp ( mp )) ALLOCATE ( tmp2 ( mp , age_max )) ALLOCATE ( tmp3 ( mp , nprod )) A0 ( 1 ) = 'latitude' A0 ( 2 ) = 'longitude' A1 ( 1 ) = 'primf' A1 ( 2 ) = 'secdf' A1 ( 3 ) = 'grass' A1 ( 4 ) = 'crop' A1 ( 5 ) = 'past' A1 ( 6 ) = 'AgProd' A2 ( 1 ) = 'biomass_age_secondary' A2 ( 2 ) = 'freq_age_secondary' A3 ( 1 ) = 'HarvProd' A3 ( 2 ) = 'ClearProd' IF ( LEN_TRIM ( cable_user % LUC_restart_in ) . gt . 0 ) THEN fname = TRIM ( cable_user % LUC_restart_in ) ELSE fname = TRIM ( filename % path ) // '/' // TRIM ( cable_user % RunIden ) // '_' // 'LUC_rst.nc' ENDIF STATUS = NF90_OPEN ( TRIM ( fname ), NF90_NOWRITE , FILE_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! DIMS STATUS = NF90_INQ_DIMID ( FILE_ID , 'land' , dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQUIRE_DIMENSION ( FILE_ID , dID , LEN = land_dim ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQ_DIMID ( FILE_ID , 'mage' , dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQUIRE_DIMENSION ( FILE_ID , dID , LEN = mage_dim ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQ_DIMID ( FILE_ID , 'nprod' , dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQUIRE_DIMENSION ( FILE_ID , dID , LEN = nprod_dim ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! READ 1-dimensional fields DO i = 1 , SIZE ( A1 ) STATUS = NF90_INQ_VARID ( FILE_ID , A1 ( i ), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , TMP ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) SELECT CASE ( TRIM ( A1 ( i ))) CASE ( 'primf' ) POPLUC % primf = TMP CASE ( 'secdf' ) POPLUC % secdf = TMP CASE ( 'grass' ) POPLUC % grass = TMP CASE ( 'crop' ) POPLUC % crop = TMP CASE ( 'past' ) POPLUC % past = TMP CASE ( 'AgProd' ) POPLUC % AgProd = TMP END SELECT END DO ! READ 2-dimensional fields (mage) DO i = 1 , SIZE ( A2 ) STATUS = NF90_INQ_VARID ( FILE_ID , A2 ( i ), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , TMP2 ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) SELECT CASE ( TRIM ( A2 ( i ))) CASE ( 'biomass_age_secondary' ) POPLUC % biomass_age_secondary = TMP2 CASE ( 'freq_age_secondary' ) POPLUC % freq_age_secondary = TMP2 END SELECT END DO ! READ 3-dimensional fields (nprod) DO i = 1 , SIZE ( A3 ) STATUS = NF90_INQ_VARID ( FILE_ID , A3 ( i ), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , TMP3 ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) SELECT CASE ( TRIM ( A3 ( i ))) CASE ( 'HarvProd' ) POPLUC % HarvProd = TMP3 CASE ( 'ClearProd' ) POPLUC % ClearProd = TMP3 END SELECT END DO STATUS = NF90_CLOSE ( FILE_ID ) file_id = - 1 END SUBROUTINE READ_LUC_RESTART_NC !******************************************************************************* SUBROUTINE WRITE_LUC_OUTPUT_GRID_NC ( POPLUC , ctime , FINAL ) USE cable_IO_vars_module , ONLY : mask , xdimsize , ydimsize , lat_all , lon_all USE CABLE_COMMON_MODULE , ONLY : filename , cable_user , HANDLE_ERR USE netcdf IMPLICIT NONE TYPE ( POPLUC_TYPE ), INTENT ( IN ) :: POPLUC LOGICAL , INTENT ( IN ) :: FINAL INTEGER , INTENT ( IN ) :: ctime INTEGER :: STATUS INTEGER :: age_ID , hist_ID , t_ID , nLU_ID , nTrans_ID , xID , yID INTEGER :: xvID , yvID INTEGER :: i , mp , nprod , nprod_ID CHARACTER :: FNAME * 99 , dum * 50 LOGICAL , SAVE :: CALL1 = . TRUE . ! 1 dim arrays (mp ) CHARACTER ( len = 20 ), DIMENSION ( 2 ) :: A0 ! 2 dim real arrays (mp,t) CHARACTER ( len = 20 ), DIMENSION ( 24 ) :: A1 ! 2 dim integer arrays (mp,t) CHARACTER ( len = 20 ), DIMENSION ( 1 ) :: AI1 ! 3 dim real arrays (mp,age_max,t) CHARACTER ( len = 25 ), DIMENSION ( 4 ) :: A2 ! 3 dim real arrays (mp,LENGTH_SECDF_HISTORY,t) CHARACTER ( len = 20 ), DIMENSION ( 1 ) :: A3 ! 3 dim integer arrays (mp,LENGTH_SECDF_HISTORY,t) CHARACTER ( len = 20 ), DIMENSION ( 1 ) :: AI3 ! 3 dim real arrays (mp,nLU,t) CHARACTER ( len = 20 ), DIMENSION ( 7 ) :: A4 ! 3 dim real arrays (mp,nTrans,t) CHARACTER ( len = 20 ), DIMENSION ( 1 ) :: A5 ! 3 dim real arrays (mp,nprod,t) CHARACTER ( len = 20 ), DIMENSION ( 4 ) :: A6 INTEGER , SAVE :: VIDtime , VID0 ( SIZE ( A0 )), VID1 ( SIZE ( A1 )), VIDI1 ( SIZE ( AI1 )) INTEGER , SAVE :: VID2 ( SIZE ( A2 )) INTEGER , SAVE :: VID4 ( SIZE ( A4 )), VID5 ( SIZE ( A5 )), VID6 ( size ( A6 )) INTEGER , SAVE :: FILE_ID , CNT = 0 , latID , lonID REAL ( dp ), ALLOCATABLE :: freq_age_secondary (:,:) INTEGER :: g , k LOGICAL :: put_age_vars REAL ( dp ) :: ncmissingr = - 1.e+33_dp INTEGER :: ncmissingi = - 9999999 ! REAL :: missing_value = -999999.0 ! for netcdf output INTEGER :: nx , ny LOGICAL , DIMENSION (:,:), ALLOCATABLE :: LandMask ! Logical landmask, true for land, false for non-land REAL ( dp ), DIMENSION (:,:), ALLOCATABLE :: fieldr INTEGER , DIMENSION (:,:), ALLOCATABLE :: fieldi REAL ( dp ), DIMENSION (:,:,:), ALLOCATABLE :: tmparr1 REAL ( dp ), DIMENSION (:,:,:), ALLOCATABLE :: tmparr2 REAL ( dp ), DIMENSION (:,:,:), ALLOCATABLE :: tmparr3 mp = POPLUC % np nx = xdimsize ny = ydimsize nprod = 3 put_age_vars = . FALSE . allocate ( freq_age_secondary ( mp , age_max )) ALLOCATE ( landmask ( xdimsize , ydimsize )) ! Local use in this routine (integer) ALLOCATE ( fieldr ( xdimsize , ydimsize )) ! field for UNPACK command (reals) ALLOCATE ( fieldi ( xdimsize , ydimsize )) ! field for UNPACK command (integers) ALLOCATE ( tmparr1 ( xdimsize , ydimsize , nLU )) ALLOCATE ( tmparr2 ( xdimsize , ydimsize , nTrans )) ALLOCATE ( tmparr3 ( xdimsize , ydimsize , nprod )) ! Convert the integer 'mask' into the logical 'landmask' WHERE ( mask . EQ . 1 ) landmask = . TRUE . ELSEWHERE landmask = . FALSE . END WHERE fieldr = ncmissingr fieldi = ncmissingi A0 ( 1 ) = 'local_latitude' A0 ( 2 ) = 'local_longitude' A1 ( 1 ) = 'primf' A1 ( 2 ) = 'secdf' A1 ( 3 ) = 'grass' A1 ( 4 ) = 'ptos' A1 ( 5 ) = 'ptog' A1 ( 6 ) = 'stog' A1 ( 7 ) = 'gtop' A1 ( 8 ) = 'gtos' A1 ( 9 ) = 'frac_primf' A1 ( 10 ) = 'frac_forest' A1 ( 11 ) = 'pharv' A1 ( 12 ) = 'smharv' A1 ( 13 ) = 'syharv' A1 ( 14 ) = 'crop' A1 ( 15 ) = 'past' A1 ( 16 ) = 'ptoc' A1 ( 17 ) = 'ptoq' A1 ( 18 ) = 'stoc' A1 ( 19 ) = 'stoq' A1 ( 20 ) = 'qtos' A1 ( 21 ) = 'ctos' A1 ( 22 ) = 'AgProd' A1 ( 23 ) = 'AgProdLoss' A1 ( 24 ) = 'FAg' AI1 ( 1 ) = 'n_event' A2 ( 1 ) = 'freq_age_primary' A2 ( 2 ) = 'freq_age_secondary' A2 ( 3 ) = 'biomass_age_primary' A2 ( 4 ) = 'biomass_age_secondary' A3 ( 1 ) = 'area_history_secdf' AI3 ( 1 ) = 'age_history_secdf' A4 ( 1 ) = 'FHarvest' A4 ( 2 ) = 'FClearance' A4 ( 3 ) = 'FNEP' A4 ( 4 ) = 'CLitt' A4 ( 5 ) = 'CSoil' A4 ( 6 ) = 'CBiomass' A4 ( 7 ) = 'FTransferNet' A5 ( 1 ) = 'FTransferGross' A6 ( 1 ) = 'HarvProd' A6 ( 2 ) = 'ClearProd' A6 ( 3 ) = 'HarvProdLoss' A6 ( 4 ) = 'ClearProdLoss' DO g = 1 , mp if ( sum ( POPLUC % freq_age_secondary ( g ,:)) . gt . 1.e-12_dp ) then freq_age_secondary ( g ,:) = POPLUC % freq_age_secondary ( g ,:) / sum ( POPLUC % freq_age_secondary ( g ,:)) else freq_age_secondary ( g ,:) = 0.0_dp endif ENDDO CNT = CNT + 1 IF ( CALL1 ) THEN ! Get File-Name WRITE ( dum , FMT = \"(I4,'_',I4)\" ) CABLE_USER % YEARSTART , CABLE_USER % YEAREND IF ( CABLE_USER % YEARSTART . lt . 100 0. and . CABLE_USER % YEAREND . lt . 1000 ) THEN WRITE ( dum , FMT = \"(I3,'_',I3)\" ) CABLE_USER % YEARSTART , CABLE_USER % YEAREND ELSEIF ( CABLE_USER % YEARSTART . lt . 1000 ) THEN WRITE ( dum , FMT = \"(I3,'_',I4)\" ) CABLE_USER % YEARSTART , CABLE_USER % YEAREND ENDIF if ( len_trim ( cable_user % LUC_outfile ) > 0 ) then fname = trim ( cable_user % LUC_outfile ) else fname = trim ( filename % path ) // '/' // trim ( cable_user % RunIden ) // '_' // trim ( dum ) // '_LUC_out.nc' endif ! Create NetCDF file: #ifdef __NETCDF3__ STATUS = NF90_create ( trim ( fname ), ior ( nf90_clobber , nf90_64bit_offset ), FILE_ID ) #else STATUS = NF90_create ( trim ( fname ), ior ( nf90_clobber , ior ( nf90_netcdf4 , nf90_classic_model )), FILE_ID ) #endif IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! Put the file in define mode: STATUS = NF90_redef ( FILE_ID ) STATUS = NF90_PUT_ATT ( FILE_ID , NF90_GLOBAL , \"StartYear\" , CABLE_USER % YEARSTART ) STATUS = NF90_PUT_ATT ( FILE_ID , NF90_GLOBAL , \"EndYear\" , CABLE_USER % YEAREND ) STATUS = NF90_PUT_ATT ( FILE_ID , NF90_GLOBAL , \"RunIden\" , CABLE_USER % RunIden ) ! Define dimensions: STATUS = NF90_DEF_DIM ( FILE_ID , 'x' , xdimsize , xID ) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining x dimension in output file. ' // & '(SUBROUTINE open_output_file)' ) STATUS = NF90_DEF_DIM ( FILE_ID , 'y' , ydimsize , yID ) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining y dimension in output file. ' // & '(SUBROUTINE open_output_file)' ) STATUS = NF90_def_dim ( FILE_ID , 'mage' , age_max , age_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'mhist' , LENGTH_SECDF_HISTORY , hist_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'mLU' , nLU , nLU_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'mTrans' , nTrans , nTrans_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'nprod' , nprod , nprod_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'time' , NF90_UNLIMITED , t_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! Define variables STATUS = NF90_def_var ( FILE_ID , 'time' , NF90_INT ,( / t_ID / ), VIDtime ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_DEF_VAR ( FILE_ID , 'latitude' , NF90_FLOAT , ( / xID , yID / ), latID ) STATUS = NF90_DEF_VAR ( FILE_ID , 'longitude' , NF90_FLOAT , ( / xID , yID / ), lonID ) STATUS = NF90_PUT_ATT ( FILE_ID , latID , 'units' , 'degrees_north' ) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining latitude variable attributes in output file. ' // & '(SUBROUTINE open_output_file)' ) STATUS = NF90_PUT_ATT ( FILE_ID , lonID , 'units' , 'degrees_east' ) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining longitude variable attributes in output file. ' // & '(SUBROUTINE open_output_file)' ) ! Write \"cordinate variables\" to enable reading by GrADS: STATUS = NF90_DEF_VAR ( FILE_ID , 'x' , NF90_FLOAT , ( / xID / ), xvID ) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining \"x\" variable (for GrADS) in output file. ' // & '(SUBROUTINE open_output_file)' ) STATUS = NF90_PUT_ATT ( FILE_ID , xvID , 'units' , 'degrees_east' ) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error writing x coordinate variable (GrADS) units in output ' // & 'file. (SUBROUTINE open_output_file)' ) STATUS = NF90_PUT_ATT ( FILE_ID , xvID , 'comment' , & 'x coordinate variable for GrADS compatibility' ) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error writing x variables comment in output file. ' // & '(SUBROUTINE open_output_file)' ) STATUS = NF90_DEF_VAR ( FILE_ID , 'y' , NF90_FLOAT , ( / yID / ), yvID ) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining \"y\" variable (for GrADS) in output file. ' // & '(SUBROUTINE open_output_file)' ) STATUS = NF90_PUT_ATT ( FILE_ID , yvID , 'units' , 'degrees_north' ) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error writing y coordinate variable (GrADS) units in output ' // & 'file. (SUBROUTINE open_output_file)' ) STATUS = NF90_PUT_ATT ( FILE_ID , yvID , 'comment' , & 'y coordinate variable for GrADS compatibility' ) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error writing y variables comment in output file. ' // & '(SUBROUTINE open_output_file)' ) DO i = 1 , SIZE ( A0 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A0 ( i )), NF90_FLOAT , ( / xID , yID / ), VID0 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! Define missing/fill values: STATUS = NF90_PUT_ATT ( FILE_ID , VID0 ( i ), '_FillValue' , REAL ( ncmissingr , 4 )) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining ' // A0 ( i ) // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) ! Define missing/fill values: STATUS = NF90_PUT_ATT ( FILE_ID , VID0 ( i ), 'missing_value' , REAL ( ncmissingr , 4 )) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining ' // A0 ( i ) // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) END DO DO i = 1 , SIZE ( A1 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A1 ( i )), NF90_FLOAT , ( / xID , yID , t_ID / ), VID1 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! Define missing/fill values: STATUS = NF90_PUT_ATT ( FILE_ID , VID1 ( i ), '_FillValue' , REAL ( ncmissingr , 4 )) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining ' // A1 ( i ) // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) ! Define missing/fill values: STATUS = NF90_PUT_ATT ( FILE_ID , VID1 ( i ), 'missing_value' , REAL ( ncmissingr , 4 )) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining ' // A1 ( i ) // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) END DO DO i = 1 , SIZE ( AI1 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AI1 ( i )), NF90_INT , ( / xID , yID , t_ID / ), VIDI1 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! Define missing/fill values: STATUS = NF90_PUT_ATT ( FILE_ID , VIDI1 ( i ), '_FillValue' , ncmissingi ) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining ' // AI1 ( i ) // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) ! Define missing/fill values: STATUS = NF90_PUT_ATT ( FILE_ID , VIDI1 ( i ), 'missing_value' , ncmissingi ) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining ' // AI1 ( i ) // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) END DO if ( put_age_vars ) then DO i = 1 , SIZE ( A2 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A2 ( i )), NF90_FLOAT , ( / xID , yID , age_ID , t_ID / ), VID2 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO endif DO i = 1 , SIZE ( A4 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A4 ( i )), NF90_FLOAT , ( / xID , yID , nLU_ID , t_ID / ), VID4 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! Define missing/fill values: STATUS = NF90_PUT_ATT ( FILE_ID , VID4 ( i ), '_FillValue' , REAL ( ncmissingr , sp )) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining ' // A4 ( i ) // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) ! Define missing/fill values: STATUS = NF90_PUT_ATT ( FILE_ID , VID4 ( i ), 'missing_value' , REAL ( ncmissingr , sp )) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining ' // A4 ( i ) // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) END DO DO i = 1 , SIZE ( A5 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A5 ( i )), NF90_FLOAT , ( / xID , yID , ntrans_ID , t_ID / ), VID5 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! Define missing/fill values: STATUS = NF90_PUT_ATT ( FILE_ID , VID5 ( i ), '_FillValue' , REAL ( ncmissingr , sp )) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining ' // A5 ( i ) // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) ! Define missing/fill values: STATUS = NF90_PUT_ATT ( FILE_ID , VID5 ( i ), 'missing_value' , REAL ( ncmissingr , sp )) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining ' // A5 ( i ) // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) END DO DO i = 1 , SIZE ( A6 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A6 ( i )), NF90_FLOAT , ( / xID , yID , nprod_ID , t_ID / ), VID6 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! Define missing/fill values: STATUS = NF90_PUT_ATT ( FILE_ID , VID6 ( i ), '_FillValue' , REAL ( ncmissingr , sp )) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining ' // A6 ( i ) // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) ! Define missing/fill values: STATUS = NF90_PUT_ATT ( FILE_ID , VID6 ( i ), 'missing_value' , REAL ( ncmissingr , sp )) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error defining ' // A6 ( i ) // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) END DO ! End define mode: STATUS = NF90_enddef ( FILE_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! Write GrADS coordinate variables STATUS = NF90_PUT_VAR ( FILE_ID , xvID , REAL ( lon_all (:, 1 ), sp )) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error writing GrADS x coordinate variable to ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) STATUS = NF90_PUT_VAR ( FILE_ID , yvID , REAL ( lat_all ( 1 , :), sp )) IF ( STATUS /= NF90_NOERR ) CALL handle_err & ( STATUS , 'Error writing GrADS y coordinate variable to ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) ! PUT LAT / LON ( mp ) STATUS = NF90_PUT_VAR ( FILE_ID , VID0 ( 1 ), real ( UNPACK ( POPLUC % latitude , landmask , fieldr ), sp )) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID0 ( 2 ), real ( UNPACK ( POPLUC % longitude , landmask , fieldr ), sp )) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! PUT LAT / LON ( mp ) STATUS = NF90_PUT_VAR ( FILE_ID , latID , real ( lat_all , sp )) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , lonID , real ( lon_all , sp )) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) CALL1 = . FALSE . ENDIF ! CALL1 ! TIME  ( t ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDtime , ctime , start = ( / CNT / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! PUT 2D VARS ( mp, t ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 1 ), real ( UNPACK ( POPLUC % primf , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 2 ), real ( UNPACK ( POPLUC % secdf , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 3 ), real ( UNPACK ( POPLUC % grass , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 4 ), real ( UNPACK ( POPLUC % ptos , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 5 ), real ( UNPACK ( POPLUC % ptog , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 6 ), real ( UNPACK ( POPLUC % stog , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 7 ), real ( UNPACK ( POPLUC % gtop , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 8 ), real ( UNPACK ( POPLUC % gtos , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 9 ), real ( UNPACK ( POPLUC % frac_primf , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 10 ), real ( UNPACK ( POPLUC % frac_forest , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 11 ), real ( UNPACK ( POPLUC % pharv , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 12 ), real ( UNPACK ( POPLUC % smharv , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 13 ), real ( UNPACK ( POPLUC % syharv , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 14 ), real ( UNPACK ( POPLUC % crop , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 15 ), real ( UNPACK ( POPLUC % past , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 16 ), real ( UNPACK ( POPLUC % ptoc , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 17 ), real ( UNPACK ( POPLUC % ptoq , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 18 ), real ( UNPACK ( POPLUC % stoc , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 19 ), real ( UNPACK ( POPLUC % stoq , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 20 ), real ( UNPACK ( POPLUC % qtos , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 21 ), real ( UNPACK ( POPLUC % ctos , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 22 ), real ( UNPACK ( POPLUC % AgProd , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 23 ), real ( UNPACK ( POPLUC % AgProdLoss , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 24 ), real ( UNPACK ( POPLUC % FAg , landmask , fieldr ), sp ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDI1 ( 1 ), UNPACK ( POPLUC % n_event , landmask , fieldi ), & start = ( / 1 , 1 , CNT / ), count = ( / nx , ny , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! PUT 3D VARS ( mp, nLU, t ) DO k = 1 , nLU tmparr1 (:,:, k ) = UNPACK ( POPLUC % FHarvest (:, k ), landmask , fieldr ) ENDDO STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 1 ), real ( tmparr1 , sp ), & start = ( / 1 , 1 , 1 , CNT / ), count = ( / nx , ny , nLU , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) DO k = 1 , nLU tmparr1 (:,:, k ) = UNPACK ( POPLUC % FClearance (:, k ), landmask , fieldr ) ENDDO STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 2 ), real ( tmparr1 , sp ), & start = ( / 1 , 1 , 1 , CNT / ), count = ( / nx , ny , nLU , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) DO k = 1 , nLU tmparr1 (:,:, k ) = UNPACK ( POPLUC % FNEP (:, k ), landmask , fieldr ) ENDDO STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 3 ), real ( tmparr1 , sp ), & start = ( / 1 , 1 , 1 , CNT / ), count = ( / nx , ny , nLU , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) DO k = 1 , nLU tmparr1 (:,:, k ) = UNPACK ( POPLUC % Clitt (:, k ), landmask , fieldr ) ENDDO STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 4 ), real ( tmparr1 , sp ), & start = ( / 1 , 1 , 1 , CNT / ), count = ( / nx , ny , nLU , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) DO k = 1 , nLU tmparr1 (:,:, k ) = UNPACK ( POPLUC % Csoil (:, k ), landmask , fieldr ) ENDDO STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 5 ), real ( tmparr1 , sp ), & start = ( / 1 , 1 , 1 , CNT / ), count = ( / nx , ny , nLU , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) DO k = 1 , nLU tmparr1 (:,:, k ) = UNPACK ( POPLUC % CBiomass (:, k ), landmask , fieldr ) ENDDO STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 6 ), real ( tmparr1 , sp ), & start = ( / 1 , 1 , 1 , CNT / ), count = ( / nx , ny , nLU , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) DO k = 1 , nLU tmparr1 (:,:, k ) = UNPACK ( POPLUC % FTransferNet (:, k ), landmask , fieldr ) ENDDO STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 7 ), real ( tmparr1 , sp ), & start = ( / 1 , 1 , 1 , CNT / ), count = ( / nx , ny , nLU , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! PUT 3D VARS ( nx,ny, nTrans, t ) DO k = 1 , nTrans tmparr2 (:,:, k ) = UNPACK ( POPLUC % FTransferGross (:, k ), landmask , fieldr ) ENDDO STATUS = NF90_PUT_VAR ( FILE_ID , VID5 ( 1 ), real ( tmparr2 , sp ), & start = ( / 1 , 1 , 1 , CNT / ), count = ( / nx , ny , nTrans , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! PUT 3D VARS ( nx,ny, nprod, t ) DO k = 1 , nprod tmparr3 (:,:, k ) = UNPACK ( POPLUC % HarvProd (:, k ), landmask , fieldr ) ENDDO STATUS = NF90_PUT_VAR ( FILE_ID , VID6 ( 1 ), real ( tmparr3 , sp ), & start = ( / 1 , 1 , 1 , CNT / ), count = ( / nx , ny , nprod , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) DO k = 1 , nprod tmparr3 (:,:, k ) = UNPACK ( POPLUC % ClearProd (:, k ), landmask , fieldr ) ENDDO STATUS = NF90_PUT_VAR ( FILE_ID , VID6 ( 2 ), real ( tmparr3 , sp ), & start = ( / 1 , 1 , 1 , CNT / ), count = ( / nx , ny , nprod , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) DO k = 1 , nprod tmparr3 (:,:, k ) = UNPACK ( POPLUC % HarvProdLoss (:, k ), landmask , fieldr ) ENDDO STATUS = NF90_PUT_VAR ( FILE_ID , VID6 ( 3 ), real ( tmparr3 , sp ), & start = ( / 1 , 1 , 1 , CNT / ), count = ( / nx , ny , nprod , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) DO k = 1 , nprod tmparr3 (:,:, k ) = UNPACK ( POPLUC % ClearProdLoss (:, k ), landmask , fieldr ) ENDDO STATUS = NF90_PUT_VAR ( FILE_ID , VID6 ( 4 ), real ( tmparr3 , sp ), & start = ( / 1 , 1 , 1 , CNT / ), count = ( / nx , ny , nprod , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) IF ( FINAL ) THEN ! Close NetCDF file: STATUS = NF90_close ( FILE_ID ) file_id = - 1 IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) WRITE ( * , * ) \" POPLUC Output written to \" , trim ( fname ) ENDIF END SUBROUTINE WRITE_LUC_OUTPUT_GRID_NC !******************************************************************************************************************** END MODULE POPLUC_MODULE","tags":"","loc":"sourcefile/popluc.f90.html"},{"title":"pop_io.F90 – POP","text":"This file depends on sourcefile~~pop_io.f90~~EfferentGraph sourcefile~pop_io.f90 pop_io.F90 sourcefile~casa_variable.f90 casa_variable.F90 sourcefile~pop_io.f90->sourcefile~casa_variable.f90 sourcefile~pop.f90 POP.F90 sourcefile~pop_io.f90->sourcefile~pop.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules cable_pop_io Source Code pop_io.F90 Source Code module cable_pop_io implicit none contains SUBROUTINE POP_IO ( POP , casamet , YEAR , ACTION , CF ) ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! POP        : POP structure containing all specific parameter ! casamet    : structure containing met and grid specific parameters from CASA ! YEAR       : Current year <YYYY> ! ACTION     : What do you want? !              \"READ_RST\"  : Read a restart file (will be looking for a file !                            either with given name or from YEAR-1 !              \"WRITE_RST\" : Write a restart file for YEAR+1 !              \"WRITE_EPI\" : Write data at the end of each year ! CLOSE_FILE : Flag to close file at the end of Episode (Episode only) ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! USE netcdf USE TypeDef , only : dp USE POP_constants USE POP_types USE CASADIMENSION , only : icycle USE CASAVARIABLE , only : casa_met USE CABLE_COMMON_MODULE use mo_utils , only : ne #ifdef __MPI__ use mpi , only : MPI_Abort #endif IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP TYPE ( casa_met ), INTENT ( IN ) :: casamet INTEGER , INTENT ( IN ) :: YEAR CHARACTER ( LEN =* ), INTENT ( IN ) :: ACTION LOGICAL , INTENT ( IN ) :: CF INTEGER :: STATUS , i , m , p , l , land_ID , patch_ID , ndis_ID !CRM  INTEGER    :: ndis1_ID,nlay_ID,hgtb_ID,ncoh_ID,t_ID INTEGER :: nlay_ID , hgtb_ID , ncoh_ID , t_ID INTEGER :: nlayer_dim , ndisturb_dim , land_dim INTEGER :: HEIGHT_BINS_dim , npatch2d_dim , NCOHORT_MAX_dim INTEGER :: dID , t_dim , tx =- 1 , ntile , mp , CNT CHARACTER ( len = 3 ) :: typ CHARACTER :: dum * 9 , fname * 120 LOGICAL :: CLOSE_FILE , EXISTFILE !   ! 1 dim arrays (np) !   CHARACTER(len=40),DIMENSION( 2), PARAMETER :: AR0 = (/'latitude','longitude'/) !   ! LANDSCAPE STRUCTURE !   ! 2 dim arrays (np,t) !   CHARACTER(len=40),DIMENSION( 1), PARAMETER :: AI1 = (/ 'npatch_active' /) !   CHARACTER(len=40),DIMENSION(11), PARAMETER :: AR1 = (/ 'cmass_sum',           & !        'densindiv','height_mean','height_max','basal_area','stress_mortality',  & !        'fire_mortality','growth','crown_cover','crown_area','crown_volume' /) !   ! 3 dim arrays (np,nlayer,t) !   CHARACTER(len=40),DIMENSION( 4), PARAMETER :: AR2 = (/ 'biomass','density',   & !        'hmean','hmax' /) !   ! 3 dim arrays (np,height_bins,t) !   CHARACTER(len=40),DIMENSION( 4), PARAMETER :: AR3 = (/ 'cmass_stem_bin',      & !        'densindiv_bin','height_bin','diameter_bin' /) !   ! 3 dim arrays (np,ndisturb,t) !   CHARACTER(len=40),DIMENSION( 1), PARAMETER :: AI4 = (/ 'n_age' /) !   ! PATCH STRUCTURE !   ! 3 dim arrays (np,npatch2d,t) !   CHARACTER(len=40),DIMENSION( 1), PARAMETER :: AI5 = (/ 'patch_id' /) !   CHARACTER(len=40),DIMENSION(10), PARAMETER :: AR5 = (/ 'patch_freq',          & !        'patch_freq_old','patch_freq_old2','patch_factor_recruit',               & !        'patch_biomass','patch_biomass_old','patch_biomass_old2',                & !        'patch_stress_mortality','patch_fire_mortality','patch_growth' /) !   ! 4 dim arrays (np,npatch2d,ndisturb+1,t) ! !CRM  CHARACTER(len=40),DIMENSION( 1), PARAMETER :: AI6 =                           & ! !CRM       (/ 'patch_ranked_age_unique' /) ! !CRM  CHARACTER(len=40),DIMENSION( 1), PARAMETER :: AR6 =                           & ! !CRM       (/ 'patch_freq_ranked_age_unique' /) !   ! 4 dim arrays (np,npatch2d,ndisturb,t) !   CHARACTER(len=40),DIMENSION( 5), PARAMETER :: AI7 =                           & !        (/ 'patch_disturbance_interval','patch_first_disturbance_year',          & !        'patch_age','patch_age_old','patch_ranked_age_unique' /) !   CHARACTER(len=40),DIMENSION( 1), PARAMETER :: AR7 =                           & !        (/ 'patch_freq_ranked_age_unique' /) !   ! LAYER STRUCTURE !   ! 4 dim arrays (np,npatch2d,nlayer,t) !   CHARACTER(len=40),DIMENSION( 4), PARAMETER :: AR8 = (/ 'layer_biomass',       & !        'layer_density','layer_hmean','layer_hmax' /) !   CHARACTER(len=40),DIMENSION( 1), PARAMETER :: AI8 = (/ 'layer_ncohort' /) !   ! COHORT STRUCTURE !   ! 5 dim arrays (np,npatch2d,nlayer,ncohort_max,t) !   CHARACTER(len=40),DIMENSION( 5), PARAMETER :: AR9 = (/ 'cohort_biomass',      & !        'cohort_density','cohort_frac_resource_uptake','cohort_height',          & !        'cohort_diameter' /) !   CHARACTER(len=40),DIMENSION( 2), PARAMETER :: AI9 = (/'cohort_age','cohort_id'/) ! 1 dim arrays (np) CHARACTER ( len = 40 ), DIMENSION ( 2 ) :: AR0 CHARACTER ( len = 40 ), DIMENSION ( 2 ) :: AI0 ! LANDSCAPE STRUCTURE ! 2 dim arrays (np,t) CHARACTER ( len = 40 ), DIMENSION ( 1 ) :: AI1 CHARACTER ( len = 40 ), DIMENSION ( 24 ) :: AR1 ! 3 dim arrays (np,nlayer,t) CHARACTER ( len = 40 ), DIMENSION ( 4 ) :: AR2 ! 3 dim arrays (np,height_bins,t) CHARACTER ( len = 40 ), DIMENSION ( 4 ) :: AR3 ! 3 dim arrays (np,ndisturb,t) CHARACTER ( len = 40 ), DIMENSION ( 1 ) :: AI4 ! PATCH STRUCTURE ! 3 dim arrays (np,npatch2d,t) CHARACTER ( len = 40 ), DIMENSION ( 1 ) :: AI5 CHARACTER ( len = 40 ), DIMENSION ( 24 ) :: AR5 ! 4 dim arrays (np,npatch2d,ndisturb,t) CHARACTER ( len = 40 ), DIMENSION ( 4 ) :: AI7 CHARACTER ( len = 40 ), DIMENSION ( 1 ) :: AR7 ! LAYER STRUCTURE ! 4 dim arrays (np,npatch2d,nlayer,t) CHARACTER ( len = 40 ), DIMENSION ( 4 ) :: AR8 CHARACTER ( len = 40 ), DIMENSION ( 1 ) :: AI8 ! COHORT STRUCTURE ! 5 dim arrays (np,npatch2d,nlayer,ncohort_max,t) CHARACTER ( len = 40 ), DIMENSION ( 19 ) :: AR9 CHARACTER ( len = 40 ), DIMENSION ( 2 ) :: AI9 INTEGER , SAVE :: VIDtime , & VIDR0 ( SIZE ( AR0 )), VIDI0 ( SIZE ( AI0 )), VIDR1 ( SIZE ( AR1 )), VIDI1 ( SIZE ( AI1 )), & VIDR2 ( SIZE ( AR2 )), VIDR3 ( SIZE ( AR3 )), VIDI4 ( SIZE ( AI4 )), VIDR5 ( SIZE ( AR5 )), & VIDI5 ( SIZE ( AI5 )), VIDI7 ( SIZE ( AI7 )), VIDR7 ( SIZE ( AR7 )), VIDR8 ( SIZE ( AR8 )), & VIDI8 ( SIZE ( AI8 )), VIDR9 ( SIZE ( AR9 )), VIDI9 ( SIZE ( AI9 )) INTEGER , SAVE :: FILE_ID , EPI_CNT = 0 ! TEMPORARY ARRAYS INTEGER , ALLOCATABLE :: I1 (:), I2 (:,:), I3 (:,:,:), I4 (:,:,:,:) REAL ( dp ), ALLOCATABLE :: R1 (:), R2 (:,:), R3 (:,:,:), R4 (:,:,:,:) #ifdef __MPI__ integer :: ierr #endif mp = POP % np AR0 ( 1 ) = 'latitude' AR0 ( 2 ) = 'longitude' AI0 ( 1 ) = 'Iwood' AI0 ( 2 ) = 'it_pop' ! Scalar value !!! AI1 ( 1 ) = 'npatch_active' AR1 ( 1 ) = 'cmass_sum' AR1 ( 2 ) = 'cmass_sum_old' AR1 ( 3 ) = 'cheartwood_sum' AR1 ( 4 ) = 'csapwood_sum' AR1 ( 5 ) = 'csapwood_sum_old' AR1 ( 6 ) = 'densindiv' AR1 ( 7 ) = 'height_mean' AR1 ( 8 ) = 'height_max' AR1 ( 9 ) = 'basal_area' AR1 ( 10 ) = 'sapwood_loss' AR1 ( 11 ) = 'sapwood_area_loss' AR1 ( 12 ) = 'stress_mortality' AR1 ( 13 ) = 'crowding_mortality' AR1 ( 14 ) = 'fire_mortality' AR1 ( 15 ) = 'cat_mortality' AR1 ( 16 ) = 'res_mortality' AR1 ( 17 ) = 'growth' AR1 ( 18 ) = 'area_growth' AR1 ( 19 ) = 'crown_cover' AR1 ( 20 ) = 'crown_area' AR1 ( 21 ) = 'crown_volume' AR1 ( 22 ) = 'sapwood_area' AR1 ( 23 ) = 'sapwood_area_old' AR1 ( 24 ) = 'Kclump' AR2 ( 1 ) = 'biomass' AR2 ( 2 ) = 'density' AR2 ( 3 ) = 'hmean' AR2 ( 4 ) = 'hmax' AR3 ( 1 ) = 'cmass_stem_bin' AR3 ( 2 ) = 'densindiv_bin' AR3 ( 3 ) = 'height_bin' AR3 ( 4 ) = 'diameter_bin' AI4 ( 1 ) = 'n_age' AI5 ( 1 ) = 'patch_id' AR5 ( 1 ) = 'patch_freq' AR5 ( 2 ) = 'patch_freq_old' AR5 ( 3 ) = 'patch_factor_recruit' AR5 ( 4 ) = 'patch_pgap' AR5 ( 5 ) = 'patch_lai' AR5 ( 6 ) = 'patch_biomass' AR5 ( 7 ) = 'patch_biomass_old' AR5 ( 8 ) = 'patch_sapwood' AR5 ( 9 ) = 'patch_heartwood' AR5 ( 10 ) = 'patch_sapwood_old' AR5 ( 11 ) = 'patch_sapwood_area' AR5 ( 12 ) = 'patch_sapwood_area_old' AR5 ( 13 ) = 'patch_stress_mortality' AR5 ( 14 ) = 'patch_fire_mortality' AR5 ( 15 ) = 'patch_cat_mortality' AR5 ( 16 ) = 'patch_crowding_mortality' AR5 ( 17 ) = 'patch_cpc' AR5 ( 18 ) = 'patch_sapwood_loss' AR5 ( 19 ) = 'patch_sapwood_area_loss' AR5 ( 20 ) = 'patch_growth' AR5 ( 21 ) = 'patch_area_growth' AR5 ( 22 ) = 'patch_frac_NPP' AR5 ( 23 ) = 'patch_frac_respiration' AR5 ( 24 ) = 'patch_frac_GPP' AI7 ( 1 ) = 'patch_disturbance_interval' AI7 ( 2 ) = 'patch_first_disturbance_year' AI7 ( 3 ) = 'patch_age' AI7 ( 4 ) = 'patch_ranked_age_unique' AR7 ( 1 ) = 'patch_freq_ranked_age_unique' AR8 ( 1 ) = 'layer_biomass' AR8 ( 2 ) = 'layer_density' AR8 ( 3 ) = 'layer_hmean' AR8 ( 4 ) = 'layer_hmax' AI8 ( 1 ) = 'layer_ncohort' AR9 ( 1 ) = 'cohort_biomass' AR9 ( 2 ) = 'cohort_density' AR9 ( 3 ) = 'cohort_frac_resource_uptake' AR9 ( 4 ) = 'cohort_frac_light_uptake' AR9 ( 5 ) = 'cohort_frac_interception' AR9 ( 6 ) = 'cohort_frac_respiration' AR9 ( 7 ) = 'cohort_frac_NPP' AR9 ( 8 ) = 'cohort_respiration_scalar' AR9 ( 9 ) = 'cohort_crown_area' AR9 ( 10 ) = 'cohort_Pgap' AR9 ( 11 ) = 'cohort_height' AR9 ( 12 ) = 'cohort_diameter' AR9 ( 13 ) = 'cohort_sapwood' AR9 ( 14 ) = 'cohort_heartwood' AR9 ( 15 ) = 'cohort_sapwood_area' AR9 ( 16 ) = 'cohort_basal_area' AR9 ( 17 ) = 'cohort_LAI' AR9 ( 18 ) = 'cohort_Cleaf' AR9 ( 19 ) = 'cohort_Croot' AI9 ( 1 ) = 'cohort_age' AI9 ( 2 ) = 'cohort_id' ntile = mp ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! IF ( PRESENT( CF ) ) THEN CLOSE_FILE = CF ! ELSE !    CLOSE_FILE = .FALSE. ! END IF ! Check for valid ACTION typ = 'rst' IF ( INDEX ( ACTION , \"WRITE_EPI\" ) . GT . 0 ) THEN typ = 'out' ELSE IF ( INDEX ( ACTION , \"WRITE_RST\" ) . GT . 0 ) THEN typ = 'rst' ELSE IF ( INDEX ( ACTION , \"WRITE_INI\" ) . GT . 0 ) THEN typ = 'ini' ELSE IF ( INDEX ( ACTION , \"READ_RST\" ) . GT . 0 ) THEN typ = 'rst' ELSE WRITE ( * , * ) \"WRONG ACTION:'\" , TRIM ( ACTION ), \"' in call to pop_io!\" #ifdef __MPI__ call MPI_Abort ( 0 , 94 , ierr ) ! Do not know comm nor rank here #else stop 94 #endif ENDIF ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! WRITE POP VALUES TO OUTPUT FILE ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Get File-Name IF ( typ . EQ . 'out' ) THEN WRITE ( dum , FMT = \"(I4,'_',I4)\" ) CABLE_USER % YEARSTART , CABLE_USER % YEAREND IF ( CABLE_USER % YEARSTART . lt . 100 0. and . CABLE_USER % YEAREND . lt . 1000 ) THEN WRITE ( dum , FMT = \"(I3,'_',I3)\" ) CABLE_USER % YEARSTART , CABLE_USER % YEAREND ELSEIF ( CABLE_USER % YEARSTART . lt . 1000 ) THEN WRITE ( dum , FMT = \"(I3,'_',I4)\" ) CABLE_USER % YEARSTART , CABLE_USER % YEAREND ENDIF ELSE WRITE ( dum , FMT = \"(I4)\" ) YEAR ENDIF ! IF (typ.eq.'ini') THEN !    fname = TRIM(cable_user%POP_rst)//'/'//'pop_'//TRIM(cable_user%RunIDEN)& !         //'_'//typ//'.nc' ! ELSE !    fname = TRIM(filename%path)//'/'//TRIM(cable_user%RunIden)//'_'//& !         TRIM(dum)//'_pop_'//typ//'.nc' ! ENDIF IF (( typ . eq . 'ini' ) . OR . ( typ . eq . 'rst' )) THEN IF ( LEN_TRIM ( TRIM ( cable_user % POP_restart_out ) ) . gt . 0 ) THEN fname = TRIM ( cable_user % POP_restart_out ) ELSE fname = TRIM ( filename % path ) // '/' // 'pop_' // TRIM ( cable_user % RunIDEN ) // '_' // typ // '.nc' ENDIF ELSE IF ( LEN_TRIM ( TRIM ( cable_user % POP_outfile ) ) . gt . 0 ) THEN fname = TRIM ( cable_user % POP_outfile ) ELSE fname = TRIM ( filename % path ) // '/' // TRIM ( cable_user % RunIden ) // '_' // TRIM ( dum ) // '_pop_' // typ // '.nc' ENDIF ENDIF IF ( INDEX ( ACTION , \"WRITE\" ) . GT . 0 ) THEN IF ( typ . EQ . 'out' ) THEN EPI_CNT = EPI_CNT + 1 CNT = EPI_CNT ELSE CNT = 1 ENDIF IF ( CNT . EQ . 1 ) THEN INQUIRE ( FILE = TRIM ( fname ), EXIST = EXISTFILE ) EXISTFILE = . FALSE . IF ( EXISTFILE . and . ( typ . ne . 'ini' ) . and . ( typ . ne . 'rst' ) ) THEN ! file exists STATUS = NF90_open ( trim ( fname ), mode = nf90_write , ncid = FILE_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = nf90_inq_dimid ( FILE_ID , 'time' , t_id ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) !CLN status = nf90_inquire_dimension(FILE_ID, t_id,name = RecordDimName, len = CNT) !CLN if (status /= nf90_noerr) call handle_err(status) !CLN CNT = CNT+1 ! Enquire variable IDs STATUS = nf90_inq_varid ( FILE_ID , 'Time' , VIDTime ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO i = 1 , SIZE ( AR0 ) STATUS = nf90_inq_varid ( FILE_ID , TRIM ( AR0 ( i )), VIDR0 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI0 ) STATUS = nf90_inq_varid ( FILE_ID , TRIM ( AI0 ( i )), VIDI0 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI1 ) STATUS = nf90_inq_varid ( FILE_ID , TRIM ( AI1 ( i )), VIDI1 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AR1 ) STATUS = nf90_inq_varid ( FILE_ID , TRIM ( AR1 ( i )), VIDR1 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AR2 ) STATUS = nf90_inq_varid ( FILE_ID , TRIM ( AR2 ( i )), VIDR2 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AR3 ) STATUS = nf90_inq_varid ( FILE_ID , TRIM ( AR3 ( i )), VIDR3 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI4 ) STATUS = nf90_inq_varid ( FILE_ID , TRIM ( AI4 ( i )), VIDI4 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI5 ) STATUS = nf90_inq_varid ( FILE_ID , TRIM ( AI5 ( i )), VIDI5 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AR5 ) STATUS = nf90_inq_varid ( FILE_ID , TRIM ( AR5 ( i )), VIDR5 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI7 ) STATUS = nf90_inq_varid ( FILE_ID , TRIM ( AI7 ( i )), VIDI7 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AR7 ) STATUS = nf90_inq_varid ( FILE_ID , TRIM ( AR7 ( i )), VIDR7 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI8 ) STATUS = nf90_inq_varid ( FILE_ID , TRIM ( AI8 ( i )), VIDI8 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AR8 ) STATUS = nf90_inq_varid ( FILE_ID , TRIM ( AR8 ( i )), VIDR8 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI9 ) STATUS = nf90_inq_varid ( FILE_ID , TRIM ( AI9 ( i )), VIDI9 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AR9 ) STATUS = nf90_inq_varid ( FILE_ID , TRIM ( AR9 ( i )), VIDR9 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO ELSE ! file doesn't already exist, or is RST or INI ! Create NetCDF file: #ifdef __NETCDF3__ STATUS = NF90_create ( trim ( fname ), cmode = ior ( nf90_clobber , nf90_64bit_offset ), ncid = FILE_ID ) #else STATUS = NF90_create ( trim ( fname ), cmode = ior ( nf90_clobber , ior ( nf90_netcdf4 , nf90_classic_model )), ncid = FILE_ID ) #endif IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! GLOBAL ATTRIBUTES STATUS = NF90_PUT_ATT ( FILE_ID , NF90_GLOBAL , \"Icycle\" , icycle ) STATUS = NF90_PUT_ATT ( FILE_ID , NF90_GLOBAL , \"Year\" , YEAR ) STATUS = NF90_PUT_ATT ( FILE_ID , NF90_GLOBAL , \"RunIden\" , CABLE_USER % RunIden ) ! Define dimensions: STATUS = NF90_def_dim ( FILE_ID , 'land' , mp , land_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'NPATCH2D' , NPATCH2D , patch_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'NDISTURB' , NDISTURB , ndis_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) !CRM     STATUS = NF90_def_dim(FILE_ID, 'NDISTURB+1' , NDISTURB+1 , ndis1_ID) !CRM     IF (STATUS /= NF90_noerr) CALL handle_err(STATUS) STATUS = NF90_def_dim ( FILE_ID , 'NLAYER' , NLAYER , nlay_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'HEIGHT_BINS' , HEIGHT_BINS , hgtb_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'NCOHORT_MAX' , NCOHORT_MAX , ncoh_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) IF ( typ . EQ . 'out' ) THEN STATUS = NF90_def_dim ( FILE_ID , 'time' , NF90_UNLIMITED , t_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ELSE STATUS = NF90_def_dim ( FILE_ID , 'time' , 1 , t_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ENDIF ! Define variables STATUS = NF90_def_var ( FILE_ID , 'Time' , NF90_INT , ( / t_ID / ), VIDtime ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO i = 1 , SIZE ( AR0 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AR0 ( i )), NF90_DOUBLE , ( / land_ID / ), VIDR0 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI0 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AI0 ( i )), NF90_INT , ( / land_ID / ), VIDI0 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI1 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AI1 ( i )), NF90_INT , ( / land_ID , t_ID / ), VIDI1 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AR1 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AR1 ( i )), NF90_DOUBLE , ( / land_ID , t_ID / ), VIDR1 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AR2 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AR2 ( i )), NF90_DOUBLE , ( / land_ID , nlay_ID , t_ID / ), VIDR2 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AR3 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AR3 ( i )), NF90_DOUBLE , ( / land_ID , hgtb_ID , t_ID / ), VIDR3 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI4 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AI4 ( i )), NF90_INT , ( / land_ID , ndis_ID , t_ID / ), VIDI4 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI5 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AI5 ( i )), NF90_INT , ( / land_ID , patch_ID , t_ID / ), VIDI5 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AR5 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AR5 ( i )), NF90_DOUBLE , ( / land_ID , patch_ID , t_ID / ), VIDR5 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI7 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AI7 ( i )), NF90_INT , & ( / land_ID , patch_ID , ndis_ID , t_ID / ), VIDI7 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AR7 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AR7 ( i )), NF90_DOUBLE , & ( / land_ID , patch_ID , ndis_ID , t_ID / ), VIDR7 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI8 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AI8 ( i )), NF90_INT , & ( / land_ID , patch_ID , nlay_ID , t_ID / ), VIDI8 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AR8 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AR8 ( i )), NF90_DOUBLE , & ( / land_ID , patch_ID , nlay_ID , t_ID / ), VIDR8 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI9 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AI9 ( i )), NF90_INT , & ( / land_ID , patch_ID , nlay_ID , ncoh_ID , t_ID / ), VIDI9 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AR9 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AR9 ( i )), NF90_DOUBLE , & ( / land_ID , patch_ID , nlay_ID , ncoh_ID , t_ID / ), VIDR9 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO ! End define mode: STATUS = NF90_enddef ( FILE_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! PUT LAT / LON ( np ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR0 ( 1 ), casamet % lat ( POP % Iwood ), & start = ( / 1 / ), count = ( / mp / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR0 ( 2 ), casamet % lon ( POP % Iwood ), & start = ( / 1 / ), count = ( / mp / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! PUT Iwood STATUS = NF90_PUT_VAR ( FILE_ID , VIDI0 ( 1 ), POP % Iwood , & start = ( / 1 / ), count = ( / mp / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! PUT it_pop STATUS = NF90_PUT_VAR ( FILE_ID , VIDI0 ( 2 ), POP % it_pop , & start = ( / 1 / ), count = ( / mp / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) END IF ! file exists, or is rst or ini END IF ! CNT == 1 ! WRITE CURRENT STATE ! TIME  ( t ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDtime , YEAR , start = ( / CNT / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! PUT 2D VARS ( mp, t ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDI1 ( 1 ), POP % pop_grid (:)% npatch_active , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 1 ), POP % pop_grid (:)% cmass_sum , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 2 ), POP % pop_grid (:)% cmass_sum_old , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 3 ), POP % pop_grid (:)% cheartwood_sum , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 4 ), POP % pop_grid (:)% csapwood_sum , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 5 ), POP % pop_grid (:)% csapwood_sum_old , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 6 ), POP % pop_grid (:)% densindiv , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 7 ), POP % pop_grid (:)% height_mean , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 8 ), POP % pop_grid (:)% height_max , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 9 ), POP % pop_grid (:)% basal_area , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 10 ), POP % pop_grid (:)% sapwood_loss , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 11 ), POP % pop_grid (:)% sapwood_area_loss , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 12 ), POP % pop_grid (:)% stress_mortality , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 13 ), POP % pop_grid (:)% crowding_mortality , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 14 ), POP % pop_grid (:)% fire_mortality , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 15 ), POP % pop_grid (:)% cat_mortality , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 16 ), POP % pop_grid (:)% res_mortality , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 17 ), POP % pop_grid (:)% growth , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 18 ), POP % pop_grid (:)% area_growth , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 19 ), POP % pop_grid (:)% crown_cover , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 20 ), POP % pop_grid (:)% crown_area , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 21 ), POP % pop_grid (:)% crown_volume , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 22 ), POP % pop_grid (:)% sapwood_area , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 23 ), POP % pop_grid (:)% sapwood_area_old , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDR1 ( 24 ), POP % pop_grid (:)% KClump , & start = ( / 1 , CNT / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! PUT 3D VARS ( mp,nlayer, t ) ALLOCATE ( R2 ( mp , nlayer ) ) !  DO i = 1, SIZE(AR2) DO i = 1 , SIZE ( VIDR2 ) DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) R2 ( m ,:) = POP % pop_grid ( m )% biomass CASE ( 2 ) R2 ( m ,:) = POP % pop_grid ( m )% density CASE ( 3 ) R2 ( m ,:) = POP % pop_grid ( m )% hmean CASE ( 4 ) R2 ( m ,:) = POP % pop_grid ( m )% hmax CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 95 , ierr ) ! Do not know comm nor rank here #else stop 95 #endif END SELECT END DO STATUS = NF90_PUT_VAR ( FILE_ID , VIDR2 ( i ), R2 , & start = ( / 1 , 1 , CNT / ), count = ( / mp , nlayer , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) END DO DEALLOCATE ( R2 ) ! PUT 3D VARS ( mp,height_bins, t ) ALLOCATE ( R2 ( mp , height_bins ) ) DO i = 1 , SIZE ( VIDR3 ) DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) R2 ( m ,:) = POP % pop_grid ( m )% cmass_stem_bin CASE ( 2 ) R2 ( m ,:) = POP % pop_grid ( m )% densindiv_bin CASE ( 3 ) R2 ( m ,:) = POP % pop_grid ( m )% height_bin CASE ( 4 ) R2 ( m ,:) = POP % pop_grid ( m )% diameter_bin CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 96 , ierr ) ! Do not know comm nor rank here #else stop 96 #endif END SELECT END DO STATUS = NF90_PUT_VAR ( FILE_ID , VIDR3 ( i ), R2 , & start = ( / 1 , 1 , CNT / ), count = ( / mp , height_bins , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) END DO DEALLOCATE ( R2 ) ! PUT 3D VARS ( mp,ndisturb, t ) ALLOCATE ( I2 ( mp , ndisturb ) ) DO i = 1 , SIZE ( VIDI4 ) DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) I2 ( m ,: ) = POP % pop_grid ( m )% n_age CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 97 , ierr ) ! Do not know comm nor rank here #else stop 97 #endif END SELECT END DO STATUS = NF90_PUT_VAR ( FILE_ID , VIDI4 ( i ), I2 , & start = ( / 1 , 1 , CNT / ), count = ( / mp , ndisturb , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) END DO DEALLOCATE ( I2 ) ! PUT 3D VARS ( mp,npatch2d, t ) ALLOCATE ( I2 ( mp , npatch2d ) ) DO i = 1 , SIZE ( VIDI5 ) DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) I2 ( m ,: ) = POP % pop_grid ( m )% patch (:)% id CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 98 , ierr ) ! Do not know comm nor rank here #else stop 98 #endif END SELECT END DO STATUS = NF90_PUT_VAR ( FILE_ID , VIDI5 ( i ), I2 , & start = ( / 1 , 1 , CNT / ), count = ( / mp , npatch2d , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) END DO DEALLOCATE ( I2 ) ALLOCATE ( R2 ( mp , npatch2d ) ) DO i = 1 , SIZE ( VIDR5 ) DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) R2 ( m ,:) = POP % pop_grid ( m )% freq CASE ( 2 ) R2 ( m ,:) = POP % pop_grid ( m )% freq_old CASE ( 3 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% factor_recruit CASE ( 4 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% pgap CASE ( 5 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% lai CASE ( 6 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% biomass CASE ( 7 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% biomass_old CASE ( 8 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% sapwood CASE ( 9 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% heartwood CASE ( 10 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% sapwood_old CASE ( 11 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% sapwood_area CASE ( 12 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% sapwood_area_old CASE ( 13 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% stress_mortality CASE ( 14 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% fire_mortality CASE ( 15 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% cat_mortality CASE ( 16 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% crowding_mortality CASE ( 17 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% cpc CASE ( 18 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% sapwood_loss CASE ( 19 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% sapwood_area_loss CASE ( 20 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% growth CASE ( 21 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% area_growth CASE ( 22 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% frac_NPP CASE ( 23 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% frac_respiration CASE ( 24 ) R2 ( m ,:) = POP % pop_grid ( m )% patch (:)% frac_light_uptake CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 99 , ierr ) ! Do not know comm nor rank here #else stop 99 #endif END SELECT END DO STATUS = NF90_PUT_VAR ( FILE_ID , VIDR5 ( i ), R2 , & start = ( / 1 , 1 , CNT / ), count = ( / mp , npatch2d , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) END DO DEALLOCATE ( R2 ) ! PUT 4D VARS ( mp,npatch2d, ndisturb,t ) ALLOCATE ( I3 ( mp , npatch2d , ndisturb ) ) DO i = 1 , SIZE ( VIDI7 ) DO p = 1 , npatch2d DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) I3 ( m , p ,:) = POP % pop_grid ( m )% patch ( p )% disturbance_interval CASE ( 2 ) I3 ( m , p ,:) = POP % pop_grid ( m )% patch ( p )% first_disturbance_year CASE ( 3 ) I3 ( m , p ,:) = POP % pop_grid ( m )% patch ( p )% age CASE ( 4 ) I3 ( m , p ,:) = POP % pop_grid ( m )% ranked_age_unique ( p ,:) CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 100 , ierr ) ! Do not know comm nor rank here #else stop 100 #endif END SELECT END DO END DO STATUS = NF90_PUT_VAR ( FILE_ID , VIDI7 ( i ), I3 , & start = ( / 1 , 1 , 1 , CNT / ), count = ( / mp , npatch2d , ndisturb , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) END DO DEALLOCATE ( I3 ) ALLOCATE ( R3 ( mp , npatch2d , ndisturb ) ) DO i = 1 , SIZE ( VIDR7 ) DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) R3 ( m ,:,:) = POP % pop_grid ( m )% freq_ranked_age_unique CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 101 , ierr ) ! Do not know comm nor rank here #else stop 101 #endif END SELECT END DO STATUS = NF90_PUT_VAR ( FILE_ID , VIDR7 ( i ), R3 , & start = ( / 1 , 1 , 1 , CNT / ), count = ( / mp , npatch2d , ndisturb , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) END DO DEALLOCATE ( R3 ) !PUT 4D VARS ( mp,npatch2d, nlayer,t ) ALLOCATE ( I3 ( mp , npatch2d , nlayer ) ) DO i = 1 , SIZE ( VIDI8 ) DO p = 1 , npatch2d DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) I3 ( m , p ,:) = POP % pop_grid ( m )% patch ( p )% layer (:)% ncohort CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 102 , ierr ) ! Do not know comm nor rank here #else stop 102 #endif END SELECT END DO END DO STATUS = NF90_PUT_VAR ( FILE_ID , VIDI8 ( i ), I3 , & start = ( / 1 , 1 , 1 , CNT / ), count = ( / mp , npatch2d , nlayer , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) END DO DEALLOCATE ( I3 ) ALLOCATE ( R3 ( mp , npatch2d , nlayer ) ) DO i = 1 , SIZE ( VIDR8 ) DO p = 1 , npatch2d DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) R3 ( m , p ,:) = POP % pop_grid ( m )% patch ( p )% layer (:)% biomass CASE ( 2 ) R3 ( m , p ,:) = POP % pop_grid ( m )% patch ( p )% layer (:)% density CASE ( 3 ) R3 ( m , p ,:) = POP % pop_grid ( m )% patch ( p )% layer (:)% hmean CASE ( 4 ) R3 ( m , p ,:) = POP % pop_grid ( m )% patch ( p )% layer (:)% hmax CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 103 , ierr ) ! Do not know comm nor rank here #else stop 103 #endif END SELECT END DO END DO STATUS = NF90_PUT_VAR ( FILE_ID , VIDR8 ( i ), R3 , & start = ( / 1 , 1 , 1 , CNT / ), count = ( / mp , npatch2d , nlayer , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) END DO DEALLOCATE ( R3 ) ! PUT 5D VARS ( mp,npatch2d, nlayer,ncohort_max,t ) ALLOCATE ( I4 ( mp , npatch2d , nlayer , ncohort_max ) ) DO i = 1 , SIZE ( VIDI9 ) DO l = 1 , nlayer DO p = 1 , npatch2d DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) I4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% age CASE ( 2 ) I4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% id CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 104 , ierr ) ! Do not know comm nor rank here #else stop 104 #endif END SELECT END DO END DO END DO STATUS = NF90_PUT_VAR ( FILE_ID , VIDI9 ( i ), I4 , & start = ( / 1 , 1 , 1 , 1 , CNT / ), count = ( / mp , npatch2d , nlayer , ncohort_max , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ENDDO DEALLOCATE ( I4 ) ALLOCATE ( R4 ( mp , npatch2d , nlayer , ncohort_max ) ) DO i = 1 , SIZE ( VIDR9 ) DO l = 1 , nlayer DO p = 1 , npatch2d DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) R4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% biomass CASE ( 2 ) R4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% density CASE ( 3 ) R4 ( m , p , l ,:) = & POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% frac_resource_uptake CASE ( 4 ) R4 ( m , p , l ,:) = & POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% frac_light_uptake CASE ( 5 ) R4 ( m , p , l ,:) = & POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% frac_interception CASE ( 6 ) R4 ( m , p , l ,:) = & POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% frac_respiration CASE ( 7 ) R4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% frac_NPP CASE ( 8 ) R4 ( m , p , l ,:) = & POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% respiration_scalar CASE ( 9 ) R4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% crown_area CASE ( 10 ) R4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% Pgap CASE ( 11 ) R4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% height CASE ( 12 ) R4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% diameter CASE ( 13 ) R4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% sapwood CASE ( 14 ) R4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% heartwood CASE ( 15 ) R4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% sapwood_area CASE ( 16 ) R4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% basal_area CASE ( 17 ) R4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% LAI CASE ( 18 ) R4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% Cleaf CASE ( 19 ) R4 ( m , p , l ,:) = POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% Croot CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 105 , ierr ) ! Do not know comm nor rank here #else stop 105 #endif END SELECT END DO END DO END DO STATUS = NF90_PUT_VAR ( FILE_ID , VIDR9 ( i ), R4 , & start = ( / 1 , 1 , 1 , 1 , CNT / ), count = ( / mp , npatch2d , nlayer , ncohort_max , 1 / ) ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ENDDO DEALLOCATE ( R4 ) ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! READ POP VALUES AS RESTART VALUES ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ELSE IF ( INDEX ( ACTION , 'READ' ) . GT . 0 ) THEN IF ( LEN_TRIM ( TRIM ( cable_user % POP_restart_in )). gt . 0 ) THEN fname = TRIM ( cable_user % POP_restart_in ) ELSE WRITE ( dum , FMT = \"(I4)\" ) YEAR - 1 fname = TRIM ( cable_user % POP_rst ) // '/' // TRIM ( dum ) // '_pop_' // TRIM ( cable_user % RunIDEN ) // '_' // typ // '.nc' ENDIF INQUIRE ( FILE = TRIM ( fname ), EXIST = EXISTFILE ) ! If suitable restart-file, try ini-restart IF ( . NOT . EXISTFILE ) THEN WRITE ( * , * ) \"Restart file not found: \" , TRIM ( fname ) WRITE ( * , * ) \"Looking for initialization file...\" fname = TRIM ( cable_user % POP_rst ) // '/' // 'pop_' // TRIM ( cable_user % RunIDEN ) // '_ini.nc' ENDIF INQUIRE ( FILE = TRIM ( fname ), EXIST = EXISTFILE ) IF (. NOT . EXISTFILE ) THEN WRITE ( * , * ) \" No ini-restart file found either! \" , TRIM ( fname ) #ifdef __MPI__ call MPI_Abort ( 0 , 106 , ierr ) ! Do not know comm nor rank here #else stop 106 #endif ELSE typ = \"ini\" ENDIF WRITE ( * , * ) \"Reading POP-rst file: \" , TRIM ( fname ) STATUS = NF90_OPEN ( TRIM ( fname ), NF90_NOWRITE , FILE_ID ) IF ( STATUS /= NF90_noerr ) THEN WRITE ( * , * ) \"Error opening file (pop_io.F90) \" , TRIM ( fname ) CALL handle_err ( STATUS ) ENDIF ! DIMS STATUS = NF90_INQ_DIMID ( FILE_ID , 'land' , dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQUIRE_DIMENSION ( FILE_ID , dID , LEN = land_dim ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQ_DIMID ( FILE_ID , 'NPATCH2D' , dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQUIRE_DIMENSION ( FILE_ID , dID , LEN = npatch2d_dim ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQ_DIMID ( FILE_ID , 'NDISTURB' , dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQUIRE_DIMENSION ( FILE_ID , dID , LEN = NDISTURB_dim ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) !CRM   STATUS = NF90_INQ_DIMID( FILE_ID, 'NDISTURB+1', dID ) !CRM   IF (STATUS /= NF90_noerr) CALL handle_err(STATUS) !CRM   STATUS = NF90_INQUIRE_DIMENSION( FILE_ID, dID, LEN=NDISTURB1_dim ) !CRM   IF (STATUS /= NF90_noerr) CALL handle_err(STATUS) STATUS = NF90_INQ_DIMID ( FILE_ID , 'NLAYER' , dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQUIRE_DIMENSION ( FILE_ID , dID , LEN = NLAYER_dim ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQ_DIMID ( FILE_ID , 'HEIGHT_BINS' , dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQUIRE_DIMENSION ( FILE_ID , dID , LEN = HEIGHT_BINS_dim ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQ_DIMID ( FILE_ID , 'NCOHORT_MAX' , dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQUIRE_DIMENSION ( FILE_ID , dID , LEN = NCOHORT_MAX_dim ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) IF ( land_dim . NE . mp . OR . npatch2d_dim . NE . NPATCH2D . OR . & HEIGHT_BINS_dim . NE . HEIGHT_BINS . OR . NCOHORT_MAX_dim . NE . NCOHORT_MAX & . OR . NLAYER_dim . NE . NLAYER . OR . NDISTURB_dim . NE . NDISTURB ) THEN WRITE ( * , * ) \"Dimension misfit in pop_io.F90!\" WRITE ( * , * ) \"Restart file  | Current Run\" WRITE ( * , * ) \"# points   \" , land_dim , \"     \" , mp WRITE ( * , * ) \"# patches  \" , NPATCH2D_dim , \"     \" , NPATCH2D WRITE ( * , * ) \"# HGT_BINS \" , HEIGHT_BINS_dim , \"     \" , HEIGHT_BINS WRITE ( * , * ) \"NCOHORT_MAX\" , NCOHORT_MAX_dim , \"     \" , NCOHORT_MAX WRITE ( * , * ) \"# NLAYER   \" , NLAYER_dim , \"     \" , NLAYER WRITE ( * , * ) \"# NDISTURB \" , NDISTURB_dim , \"     \" , NDISTURB #ifdef __MPI__ call MPI_Abort ( 0 , 107 , ierr ) ! Do not know comm nor rank here #else stop 107 #endif ENDIF ! TIME STATUS = NF90_INQ_DIMID ( FILE_ID , 'time' , dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQUIRE_DIMENSION ( FILE_ID , dID , LEN = t_dim ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQ_VARID ( FILE_ID , 'Time' , t_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ALLOCATE ( I1 ( t_dim ) ) STATUS = NF90_GET_VAR ( FILE_ID , t_ID , I1 ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO i = 1 , t_dim IF ( YEAR . EQ . I1 ( i ) + 1 ) THEN ! DATA FROM PRECEDING YEAR ! tx = i EXIT END IF END DO DEALLOCATE ( I1 ) IF ( tx . LE . 0 ) THEN WRITE ( * , * ) 'FILE ' // TRIM ( fname ) // \" doesn't contain specific data for \" , YEAR WRITE ( * , * ) 'Resetting  tx to 1!' tx = 1 IF ( typ . NE . \"ini\" ) THEN WRITE ( * , * ) \"Wrong date in input pop restart-file! \" , TRIM ( fname ) #ifdef __MPI__ call MPI_Abort ( 0 , 108 , ierr ) ! Do not know comm nor rank here #else stop 108 #endif ENDIF ENDIF ! CHECK LAT 'N LON ALLOCATE ( R1 ( mp ) ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AR0 ( 1 )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , R1 ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) IF ( ANY ( ne ( casamet % lat ( POP % Iwood ), R1 ) ) ) THEN WRITE ( * , * ) \"INPUT LATs don't match casamet! pop_io.F90\" & , TRIM ( fname ) ! STOP ENDIF STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AR0 ( 2 )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , R1 ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) IF ( ANY ( ne ( casamet % lon ( POP % Iwood ), R1 ) ) ) THEN WRITE ( * , * ) \"INPUT LONs don't match casamet! pop_io.F90\" & , TRIM ( fname ) !STOP ENDIF DEALLOCATE ( R1 ) ! GET 0D VARS ( np ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AI0 ( 1 )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , POP % Iwood , & start = ( / 1 , tx / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AI0 ( 2 )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , POP % it_pop , & start = ( / 1 , tx / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! GET 1D VARS ( np ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AI1 ( 1 )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , POP % pop_grid (:)% npatch_active , & start = ( / 1 , tx / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ALLOCATE ( R1 ( mp ) ) DO i = 1 , SIZE ( AR1 ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AR1 ( i )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , R1 , start = ( / 1 , tx / ), count = ( / mp , 1 / ) ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) SELECT CASE ( i ) CASE ( 1 ) POP % pop_grid (:)% cmass_sum = R1 CASE ( 2 ) POP % pop_grid (:)% cmass_sum_old = R1 CASE ( 3 ) POP % pop_grid (:)% cheartwood_sum = R1 CASE ( 4 ) POP % pop_grid (:)% csapwood_sum = R1 CASE ( 5 ) POP % pop_grid (:)% csapwood_sum_old = R1 CASE ( 6 ) POP % pop_grid (:)% densindiv = R1 CASE ( 7 ) POP % pop_grid (:)% height_mean = R1 CASE ( 8 ) POP % pop_grid (:)% height_max = R1 CASE ( 9 ) POP % pop_grid (:)% basal_area = R1 CASE ( 10 ) POP % pop_grid (:)% sapwood_loss = R1 CASE ( 11 ) POP % pop_grid (:)% sapwood_area_loss = R1 CASE ( 12 ) POP % pop_grid (:)% stress_mortality = R1 CASE ( 13 ) POP % pop_grid (:)% crowding_mortality = R1 CASE ( 14 ) POP % pop_grid (:)% fire_mortality = R1 CASE ( 15 ) POP % pop_grid (:)% cat_mortality = R1 CASE ( 16 ) POP % pop_grid (:)% res_mortality = R1 CASE ( 17 ) POP % pop_grid (:)% growth = R1 CASE ( 18 ) POP % pop_grid (:)% area_growth = R1 CASE ( 19 ) POP % pop_grid (:)% crown_cover = R1 CASE ( 20 ) POP % pop_grid (:)% crown_area = R1 CASE ( 21 ) POP % pop_grid (:)% crown_volume = R1 CASE ( 22 ) POP % pop_grid (:)% sapwood_area = R1 CASE ( 23 ) POP % pop_grid (:)% sapwood_area_old = R1 CASE ( 24 ) POP % pop_grid (:)% KClump = R1 CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 109 , ierr ) ! Do not know comm nor rank here #else stop 109 #endif END SELECT END DO DEALLOCATE ( R1 ) ! GET 2D VARS ( mp,nlayer ) ALLOCATE ( R2 ( mp , nlayer ) ) DO i = 1 , SIZE ( AR2 ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AR2 ( i )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , R2 , & start = ( / 1 , 1 , tx / ), count = ( / mp , nlayer , 1 / ) ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) POP % pop_grid ( m )% biomass = R2 ( m ,:) CASE ( 2 ) POP % pop_grid ( m )% density = R2 ( m ,:) CASE ( 3 ) POP % pop_grid ( m )% hmean = R2 ( m ,:) CASE ( 4 ) POP % pop_grid ( m )% hmax = R2 ( m ,:) CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 110 , ierr ) ! Do not know comm nor rank here #else stop 110 #endif END SELECT END DO END DO DEALLOCATE ( R2 ) ! GET 2D VARS ( mp,height_bins ) ALLOCATE ( R2 ( mp , height_bins ) ) DO i = 1 , SIZE ( AR3 ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AR3 ( i )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , R2 , & start = ( / 1 , 1 , tx / ), count = ( / mp , height_bins , 1 / ) ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) POP % pop_grid ( m )% cmass_stem_bin = R2 ( m ,:) CASE ( 2 ) POP % pop_grid ( m )% densindiv_bin = R2 ( m ,:) CASE ( 3 ) POP % pop_grid ( m )% height_bin = R2 ( m ,:) CASE ( 4 ) POP % pop_grid ( m )% diameter_bin = R2 ( m ,:) CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 111 , ierr ) ! Do not know comm nor rank here #else stop 111 #endif END SELECT END DO END DO DEALLOCATE ( R2 ) ! GET 2D VARS ( mp,ndisturb) ALLOCATE ( I2 ( mp , ndisturb ) ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AI4 ( 1 )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , I2 , & start = ( / 1 , 1 , tx / ), count = ( / mp , ndisturb , 1 / ) ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO m = 1 , mp POP % pop_grid ( m )% n_age = I2 ( m ,: ) END DO DEALLOCATE ( I2 ) ! GET 2D VARS ( mp,npatch2d) ALLOCATE ( I2 ( mp , npatch2d ) ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AI5 ( 1 )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , I2 , & start = ( / 1 , 1 , tx / ), count = ( / mp , npatch2d , 1 / ) ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO m = 1 , mp POP % pop_grid ( m )% patch (:)% id = I2 ( m ,: ) END DO DEALLOCATE ( I2 ) ! PATCH STRUCTURE ! GET 2D VARS ( mp,npatch2d ) ALLOCATE ( R2 ( mp , npatch2d ) ) DO i = 1 , SIZE ( AR5 ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AR5 ( i )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , R2 , & start = ( / 1 , 1 , tx / ), count = ( / mp , npatch2d , 1 / ) ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) POP % pop_grid ( m )% freq = R2 ( m ,:) CASE ( 2 ) POP % pop_grid ( m )% freq_old = R2 ( m ,:) CASE ( 3 ) POP % pop_grid ( m )% patch (:)% factor_recruit = R2 ( m ,:) CASE ( 4 ) POP % pop_grid ( m )% patch (:)% pgap = R2 ( m ,:) CASE ( 5 ) POP % pop_grid ( m )% patch (:)% lai = R2 ( m ,:) CASE ( 6 ) POP % pop_grid ( m )% patch (:)% biomass = R2 ( m ,:) CASE ( 7 ) POP % pop_grid ( m )% patch (:)% biomass_old = R2 ( m ,:) CASE ( 8 ) POP % pop_grid ( m )% patch (:)% sapwood = R2 ( m ,:) CASE ( 9 ) POP % pop_grid ( m )% patch (:)% heartwood = R2 ( m ,:) CASE ( 10 ) POP % pop_grid ( m )% patch (:)% sapwood_old = R2 ( m ,:) CASE ( 11 ) POP % pop_grid ( m )% patch (:)% sapwood_area = R2 ( m ,:) CASE ( 12 ) POP % pop_grid ( m )% patch (:)% sapwood_area_old = R2 ( m ,:) CASE ( 13 ) POP % pop_grid ( m )% patch (:)% stress_mortality = R2 ( m ,:) CASE ( 14 ) POP % pop_grid ( m )% patch (:)% fire_mortality = R2 ( m ,:) CASE ( 15 ) POP % pop_grid ( m )% patch (:)% cat_mortality = R2 ( m ,:) CASE ( 16 ) POP % pop_grid ( m )% patch (:)% crowding_mortality = R2 ( m ,:) CASE ( 17 ) POP % pop_grid ( m )% patch (:)% cpc = R2 ( m ,:) CASE ( 18 ) POP % pop_grid ( m )% patch (:)% sapwood_loss = R2 ( m ,:) CASE ( 19 ) POP % pop_grid ( m )% patch (:)% sapwood_area_loss = R2 ( m ,:) CASE ( 20 ) POP % pop_grid ( m )% patch (:)% growth = R2 ( m ,:) CASE ( 21 ) POP % pop_grid ( m )% patch (:)% area_growth = R2 ( m ,:) CASE ( 22 ) POP % pop_grid ( m )% patch (:)% frac_NPP = R2 ( m ,:) CASE ( 23 ) POP % pop_grid ( m )% patch (:)% frac_respiration = R2 ( m ,:) CASE ( 24 ) POP % pop_grid ( m )% patch (:)% frac_light_uptake = R2 ( m ,:) CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 112 , ierr ) ! Do not know comm nor rank here #else stop 112 #endif END SELECT END DO END DO DEALLOCATE ( R2 ) ! GET 3D VARS ( mp,npatch2d,ndisturb ) ALLOCATE ( I3 ( mp , npatch2d , ndisturb ) ) DO i = 1 , SIZE ( AI7 ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AI7 ( i )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , I3 , & start = ( / 1 , 1 , 1 , tx / ), count = ( / mp , npatch2d , ndisturb , 1 / ) ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO p = 1 , npatch2d DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) POP % pop_grid ( m )% patch ( p )% disturbance_interval = I3 ( m , p ,:) CASE ( 2 ) POP % pop_grid ( m )% patch ( p )% first_disturbance_year = I3 ( m , p ,:) CASE ( 3 ) POP % pop_grid ( m )% patch ( p )% age = I3 ( m , p ,:) CASE ( 4 ) POP % pop_grid ( m )% ranked_age_unique ( p ,:) = I3 ( m , p ,:) CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 113 , ierr ) ! Do not know comm nor rank here #else stop 113 #endif END SELECT END DO END DO END DO DEALLOCATE ( I3 ) ALLOCATE ( R3 ( mp , npatch2d , ndisturb ) ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AR7 ( 1 )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , R3 , & start = ( / 1 , 1 , 1 , tx / ), count = ( / mp , npatch2d , ndisturb , 1 / ) ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO m = 1 , mp POP % pop_grid ( m )% freq_ranked_age_unique = R3 ( m ,:,:) END DO DEALLOCATE ( R3 ) ! LAYER STRUCTURE ! GET 3D VARS ( mp,npatch2d,nlayer ) ALLOCATE ( I3 ( mp , npatch2d , nlayer ) ) DO i = 1 , SIZE ( AI8 ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AI8 ( i )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , I3 , & start = ( / 1 , 1 , 1 , tx / ), count = ( / mp , npatch2d , nlayer , 1 / ) ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO p = 1 , npatch2d DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) POP % pop_grid ( m )% patch ( p )% layer (:)% ncohort = I3 ( m , p ,:) CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 114 , ierr ) ! Do not know comm nor rank here #else stop 114 #endif END SELECT END DO END DO END DO DEALLOCATE ( I3 ) ALLOCATE ( R3 ( mp , npatch2d , nlayer ) ) DO i = 1 , SIZE ( AR8 ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AR8 ( i )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , R3 , & start = ( / 1 , 1 , 1 , tx / ), count = ( / mp , npatch2d , nlayer , 1 / ) ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO p = 1 , npatch2d DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) POP % pop_grid ( m )% patch ( p )% layer (:)% biomass = R3 ( m , p ,:) CASE ( 2 ) POP % pop_grid ( m )% patch ( p )% layer (:)% density = R3 ( m , p ,:) CASE ( 3 ) POP % pop_grid ( m )% patch ( p )% layer (:)% hmean = R3 ( m , p ,:) CASE ( 4 ) POP % pop_grid ( m )% patch ( p )% layer (:)% hmax = R3 ( m , p ,:) CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 115 , ierr ) ! Do not know comm nor rank here #else stop 115 #endif END SELECT END DO END DO END DO DEALLOCATE ( R3 ) ! COHORT STRUCTURE ! GET 4D VARS ( mp,npatch2d,nlayer,ncohort_max ) ALLOCATE ( I4 ( mp , npatch2d , nlayer , ncohort_max ) ) DO i = 1 , SIZE ( AI9 ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AI9 ( i )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , I4 , start = ( / 1 , 1 , 1 , 1 , tx / ), & count = ( / mp , npatch2d , nlayer , ncohort_max , 1 / ) ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO l = 1 , nlayer DO p = 1 , npatch2d DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% age = I4 ( m , p , l ,:) CASE ( 2 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% id = I4 ( m , p , l ,:) CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 116 , ierr ) ! Do not know comm nor rank here #else stop 116 #endif END SELECT END DO END DO END DO END DO DEALLOCATE ( I4 ) ALLOCATE ( R4 ( mp , npatch2d , nlayer , ncohort_max ) ) DO i = 1 , SIZE ( AR9 ) STATUS = NF90_INQ_VARID ( FILE_ID , TRIM ( AR9 ( i )), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , R4 , start = ( / 1 , 1 , 1 , 1 , tx / ), & count = ( / mp , npatch2d , nlayer , ncohort_max , 1 / ) ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO l = 1 , nlayer DO p = 1 , npatch2d DO m = 1 , mp SELECT CASE ( i ) CASE ( 1 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% biomass = R4 ( m , p , l ,:) CASE ( 2 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% density = R4 ( m , p , l ,:) CASE ( 3 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% frac_resource_uptake = R4 ( m , p , l ,:) CASE ( 4 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% frac_light_uptake = R4 ( m , p , l ,:) CASE ( 5 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% frac_interception = R4 ( m , p , l ,:) CASE ( 6 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% frac_respiration = R4 ( m , p , l ,:) CASE ( 7 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% frac_NPP = R4 ( m , p , l ,:) CASE ( 8 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% respiration_scalar = R4 ( m , p , l ,:) CASE ( 9 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% crown_area = R4 ( m , p , l ,:) CASE ( 10 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% Pgap = R4 ( m , p , l ,:) CASE ( 11 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% height = R4 ( m , p , l ,:) CASE ( 12 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% diameter = R4 ( m , p , l ,:) CASE ( 13 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% sapwood = R4 ( m , p , l ,:) CASE ( 14 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% heartwood = R4 ( m , p , l ,:) CASE ( 15 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% sapwood_area = R4 ( m , p , l ,:) CASE ( 16 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% basal_area = R4 ( m , p , l ,:) CASE ( 17 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% LAI = R4 ( m , p , l ,:) CASE ( 18 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% Cleaf = R4 ( m , p , l ,:) CASE ( 19 ) POP % pop_grid ( m )% patch ( p )% layer ( l )% cohort (:)% Croot = R4 ( m , p , l ,:) CASE default write ( * , * ) \"Parameter not assigned in pop_io.F90!\" #ifdef __MPI__ call MPI_Abort ( 0 , 117 , ierr ) ! Do not know comm nor rank here #else stop 117 #endif END SELECT END DO END DO END DO END DO DEALLOCATE ( R4 ) ELSE WRITE ( * , * ) 'ACTION = ' , TRIM ( ACTION ) write ( * , * ) 'Please, enter either \"READ\" or \"WRITE\" when calling pop_io.F90!' #ifdef __MPI__ call MPI_Abort ( 0 , 118 , ierr ) ! Do not know comm nor rank here #else stop 118 #endif END IF IF ( CLOSE_FILE . OR . ( typ . EQ . 'rst' ) . OR . ( typ . EQ . 'ini' ) ) THEN ! Close NetCDF file: STATUS = NF90_close ( FILE_ID ) file_id = - 1 IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) WRITE ( * , * ) \"Closed POP-file \" , TRIM ( fname ) ENDIF END SUBROUTINE POP_IO end module cable_pop_io","tags":"","loc":"sourcefile/pop_io.f90.html"},{"title":"cable_optimiseJVratio.F90 – POP","text":"This file depends on sourcefile~~cable_optimisejvratio.f90~~EfferentGraph sourcefile~cable_optimisejvratio.f90 cable_optimiseJVratio.F90 sourcefile~pop.f90 POP.F90 sourcefile~cable_optimisejvratio.f90->sourcefile~pop.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~cable_optimisejvratio.f90~~AfferentGraph sourcefile~cable_optimisejvratio.f90 cable_optimiseJVratio.F90 sourcefile~casa_cable.f90 casa_cable.F90 sourcefile~casa_cable.f90->sourcefile~cable_optimisejvratio.f90 sourcefile~casaonly_luc.f90 CASAONLY_LUC.F90 sourcefile~casaonly_luc.f90->sourcefile~casa_cable.f90 sourcefile~spincasacnp.f90 spincasacnp.F90 sourcefile~spincasacnp.f90->sourcefile~casa_cable.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules cable_optimise_JV_module Source Code cable_optimiseJVratio.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: acclimation of ratio of Jmax to Vcmax, with corresponding optimisation ! of contributions of electron-tranport and carboxylation rates to rate of net photosynthesis ! ! Called from: SUBROUTINE bgcdriver in casa_cable.F90 ! ! History: Vanessa Haverd Aug 2017 ! ============================================================================== MODULE cable_optimise_JV_module Use cable_def_types_mod , ONLY : met_type , climate_type , canopy_type , veg_parameter_type , & mp , r_2 USE cable_data_module , ONLY : icanopy_type , point2constants USE TypeDef , ONLY : i4b , dp USE cable_common_module , ONLY : cable_user TYPE ( icanopy_type ) :: C ! variables local to module REAL , ALLOCATABLE :: APAR (:), Dleaf (:), Tleaf (:), cs (:), scalex (:), fwsoil (:), g0 (:) REAL :: Anet , vcmax00 , bjv , g1 , kc0 , ko0 , ekc , eko , gam0 , egam , alpha , gm0 , a1 , D0 , qs , qm , qb REAL :: convex , Neff , relcost_J , Rd0 , Tgrowth , Thome INTEGER :: nt , kk !REAL, PARAMETER :: relcost_J = 1.6 ! Chen et al. Oecologia, 1993, 93: 63-69 ! (use this value for forced co-ordination) ! now moved to icanopy_type and (if Cc-based) recalculated in the ! adjust_JV_gm Subroutine !REAL, PARAMETER :: relcost_J = 2.3  ! use this value for optimisation algorithm LOGICAL , PARAMETER :: coord = . FALSE . ! adjust ratioJV to force co-oridnation. ! otherwise maximise photosynthesis CONTAINS ! ============================================================================== SUBROUTINE optimise_JV ( veg , climate , ktauday , bjv , relcostJ ) IMPLICIT NONE TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( climate_type ), INTENT ( IN ) :: climate ! climate variables INTEGER , INTENT ( IN ) :: ktauday REAL , DIMENSION ( mp ), INTENT ( IN ) :: bjv REAL , DIMENSION ( mp ), INTENT ( IN ) :: relcostJ INTEGER :: k REAL , DIMENSION ( mp ) :: bjv_new REAL :: Anet_cost REAL , PARAMETER :: l_bound = 0.5 REAL , PARAMETER :: u_bound = 5.0 ! assign local ptrs to constants defined in cable_data_module CALL point2constants ( C ) nt = ktauday * C % ndays_optim ALLOCATE ( APAR ( nt )) ALLOCATE ( Dleaf ( nt )) ALLOCATE ( Tleaf ( nt )) ALLOCATE ( cs ( nt )) ALLOCATE ( scalex ( nt )) ALLOCATE ( g0 ( nt )) ALLOCATE ( fwsoil ( nt )) DO k = 1 , mp if ( veg % frac4 ( k ) < 0.001 ) then ! not C4 if ( cable_user % explicit_gm ) then if ( trim ( cable_user % Rubisco_parameters ) == 'Bernacchi_2002' ) then gam0 = C % gam0cc Kc0 = C % conkc0cc Ko0 = C % conko0cc egam = C % egamcc ekc = C % ekccc eko = C % ekocc else if ( trim ( cable_user % Rubisco_parameters ) == 'Walker_2013' ) then gam0 = C % gam0ccw Kc0 = C % conkc0ccw Ko0 = C % conko0ccw egam = C % egamccw ekc = C % ekcccw eko = C % ekoccw endif gm0 = veg % gm ( k ) vcmax00 = veg % vcmaxcc ( k ) ! vcmax at standard temperature (25degC) qs = C % qs qm = C % qm qb = C % qb else Kc0 = C % conkc0 Ko0 = C % conko0 ekc = C % ekc eko = C % eko gam0 = C % gam0 egam = C % egam gm0 = veg % gm ( k ) ! used in code but not in solution if explicit_gm = false vcmax00 = veg % vcmax ( k ) ! vcmax at standard temperature (25degC) qs = 0.5 qm = 0.0 qb = 1.0 endif g1 = veg % g1 ( k ) Rd0 = veg % cfrd ( k ) * veg % vcmax ( k ) ! soil-moisture modifier to stomatal conductance fwsoil = climate % fwsoil ( k ,:) alpha = veg % alpha ( k ) ! quantum efficiency for electron transport convex = veg % convex ( k ) a1 = veg % a1gs ( k ) D0 = veg % d0gs ( k ) relcost_J = relcostJ ( k ) Neff = vcmax00 + relcost_J * bjv ( k ) * vcmax00 / 4. ! effective nitrogen amount !for distribution between e-limited and c-limited processes ! optimisation for shade leaves APAR = climate % APAR_leaf_shade ( k ,:) * 1e-6 ; Dleaf = max ( climate % Dleaf_shade ( k ,:), 5 0.0 ) * 1e-3 ! Pa -> kPa Tleaf = climate % Tleaf_shade ( k ,:) cs = climate % cs_shade ( k ,:) * 1e-6 scalex = climate % scalex_shade ( k ,:) g0 = veg % g0 ( k ) * scalex / C % RGSWC if ( cable_user % acclimate_photosyn ) then Tgrowth = climate % mtemp ( k ) Thome = climate % mtemp_max20 ( k ) endif if ( coord ) then if ( diff_Ac_Aj ( l_bound ) * diff_Ac_Aj ( u_bound ) < 0.0 ) then bjv_new ( k ) = rtbis ( diff_Ac_Aj , l_bound , u_bound , 0.001 ) else bjv_new ( k ) = bjv ( k ) endif veg % vcmax_shade ( k ) = Neff / ( 1. + relcost_J * bjv_new ( k ) / 4.0 ) veg % ejmax_shade ( k ) = veg % vcmax_shade ( k ) * bjv_new ( k ) else if ( total_photosynthesis_cost ( bjv ( k )). lt . total_photosynthesis_cost ( l_bound ) . and . & total_photosynthesis_cost ( bjv ( k )). lt . total_photosynthesis_cost ( u_bound )) then Anet_cost = golden ( l_bound , bjv ( k ), u_bound , total_photosynthesis_cost , 0.01 , bjv_new ( k )) veg % vcmax_shade ( k ) = Neff / ( 1. + relcost_J * bjv_new ( k ) / 4.0 ) veg % ejmax_shade ( k ) = veg % vcmax_shade ( k ) * bjv_new ( k ) else bjv_new ( k ) = bjv ( k ) veg % vcmax_shade ( k ) = veg % vcmax ( k ) veg % ejmax_shade ( k ) = veg % ejmax ( k ) endif endif ! optimisation for sun leaves APAR = climate % APAR_leaf_sun ( k ,:) * 1e-6 ; Dleaf = max ( climate % Dleaf_sun ( k ,:), 5 0.0 ) * 1e-3 ! Pa -> kPa Tleaf = climate % Tleaf_sun ( k ,:) cs = climate % cs_sun ( k ,:) * 1e-6 scalex = climate % scalex_sun ( k ,:) if ( coord ) then if ( diff_Ac_Aj ( l_bound ) * diff_Ac_Aj ( u_bound ) < 0 ) then bjv_new ( k ) = rtbis ( diff_Ac_Aj , l_bound , u_bound , 0.001 ) !call total_An_Ac_Aj(bjv_new(k),An,Ac,Aj) else bjv_new ( k ) = bjv ( k ) endif veg % vcmax_sun ( k ) = Neff / ( 1. + relcost_J * bjv_new ( k ) / 4.0 ) veg % ejmax_sun ( k ) = veg % vcmax_sun ( k ) * bjv_new ( k ) !call total_An_Ac_Aj(bjv_new(k),An,Ac,Aj) else if ( total_photosynthesis_cost ( bjv ( k )). lt . total_photosynthesis_cost ( l_bound ). and . & total_photosynthesis_cost ( bjv ( k )). lt . total_photosynthesis_cost ( u_bound )) then Anet_cost = golden ( l_bound , bjv ( k ), u_bound , total_photosynthesis_cost , 0.01 , bjv_new ( k )) veg % vcmax_sun ( k ) = Neff / ( 1. + relcost_J * bjv_new ( k ) / 4.0 ) veg % ejmax_sun ( k ) = veg % vcmax_sun ( k ) * bjv_new ( k ) else bjv_new ( k ) = bjv ( k ) veg % vcmax_sun ( k ) = veg % vcmax ( k ) veg % ejmax_sun ( k ) = veg % ejmax ( k ) endif !call total_An_Ac_Aj(bjv_new(k),An,Ac,Aj) endif else !C4 bjv_new ( k ) = bjv ( k ) veg % vcmax_shade ( k ) = veg % vcmax ( k ) veg % ejmax_shade ( k ) = veg % ejmax ( k ) veg % vcmax_sun ( k ) = veg % vcmax ( k ) veg % ejmax_sun ( k ) = veg % ejmax ( k ) endif ENDDO DEALLOCATE ( APAR ) DEALLOCATE ( Dleaf ) DEALLOCATE ( Tleaf ) DEALLOCATE ( cs ) DEALLOCATE ( g0 ) DEALLOCATE ( scalex ) DEALLOCATE ( fwsoil ) END SUBROUTINE optimise_JV ! Copied from cable_canopy.f90 (is there a better way??) ! ------------------------------------------------------------------------------ FUNCTION light_inhibition ( APAR ) RESULT ( xrd ) !Mercado, L. M., Huntingford, C., Gash, J. H. C., Cox, P. M., ! and Jogireddy, V.: ! Improving the representation of radiation !interception and photosynthesis for climate model applications, !Tellus B, 59, 553-565, 2007. ! Equation 3 ! (Brooks and Farquhar, 1985, as implemented by Lloyd et al., 1995). ! Rc = Rd 0 < Io < 10 umol quanta m-2 s-1 ! Rc = [0.5 * 0.05 ln(Io)] Rd Io > 10 umol quanta m-2 s-1 ! JK: note that APAR is incoming radation in the original formulations !     However, APAR considered a good proxy here implicit none real , intent ( in ) :: APAR ! absorbed PAR in umol m-2 s-1 real :: xrd ! light inhibition of Rd (0-1) if ( APAR > 1 0.0 ) then xrd = 0.5 - 0.05 * log ( APAR ) else xrd = 1.0 endif END FUNCTION light_inhibition ! ------------------------------------------------------------------------------ subroutine fAn_c3 ( a , b , c , A2 ) use cable_def_types_mod , only : r_2 implicit none real ( r_2 ), intent ( in ) :: a , b , c real ( r_2 ), intent ( OUT ) :: A2 real ( r_2 ) :: s2 s2 = b ** 2 - 4.0_r_2 * a * c A2 = ( - b - sqrt ( s2 )) / ( 2.0_r_2 * a ) end subroutine fAn_c3 ! ------------------------------------------------------------------------------ subroutine fabc ( Cs , g0 , x , gamm , beta , Gammastar , Rd , a , b , c ) use cable_def_types_mod , only : r_2 implicit none real , intent ( in ) :: Cs , g0 , x , gamm , beta , Gammastar , Rd real ( r_2 ), intent ( out ) :: a , b , c a = real (( 1.0 - x ) * Cs - x * beta , r_2 ) b = real ( - g0 * Cs ** 2 + (( 1.0 - x ) * ( Rd - gamm ) - g0 * beta ) * Cs - x * ( gamm * Gammastar + Rd * beta ), r_2 ) c = real ( - g0 * ( Rd - gamm ) * Cs ** 2 - g0 * ( gamm * Gammastar + Rd * beta ) * Cs , r_2 ) end subroutine fabc ! ------------------------------------------------------------------------------ subroutine fabcd ( Cs , g0 , x , gamm , beta , Gammastar , Rd , gm , a , b , c1 , d ) use cable_def_types_mod , only : r_2 implicit none real , intent ( in ) :: Cs , g0 , x , gamm , beta , Gammastar , Rd , gm real ( r_2 ), intent ( out ) :: a , b , c1 , d a = real ( x , r_2 ) b = real (( gm + g0 - gm * x ) * Cs + x * ( Rd - gamm ) - gm * x * beta , r_2 ) c1 = real ( - gm * g0 * Cs ** 2 + (( gm + g0 - gm * x ) * ( Rd - gamm ) - gm * g0 * beta ) * Cs - & gm * x * ( gamm * Gammastar + Rd * beta ), r_2 ) d = real ( - gm * g0 * ( Rd - gamm ) * Cs ** 2 - gm * g0 * ( gamm * Gammastar + Rd * beta ) * Cs , r_2 ) end subroutine fabcd ! ------------------------------------------------------------------------------ subroutine fpq ( a , b , c , d , p , q ) use cable_def_types_mod , only : r_2 implicit none real ( r_2 ), intent ( in ) :: a , b , c , d real ( r_2 ), intent ( out ) :: p , q p = ( 3.0_r_2 * a * c - b ** 2 ) / ( 3.0_r_2 * a ** 2 ) q = ( 2.0_r_2 * b ** 3 - 9.0_r_2 * a * b * c + 2 7.0_r_2 * a ** 2 * d ) / ( 2 7.0_r_2 * a ** 3 ) end subroutine fpq ! ------------------------------------------------------------------------------ subroutine fAm_c3 ( a , b , c1 , d , p , q , Am ) use cable_def_types_mod , only : r_2 use mo_constants , only : pi => pi_dp implicit none real ( r_2 ), intent ( in ) :: a , b , c1 , d , p , q real ( r_2 ), intent ( out ) :: Am real ( r_2 ) :: p3 , pq , k p3 = - p / 3.0_r_2 pq = max ( min ( 3.0_r_2 * q / ( 2.0_r_2 * p ) * sqrt ( 1.0_r_2 / p3 ), & 0.999999999999_r_2 ), - 0.999999999999_r_2 ) k = 1.0_r_2 Am = 2.0_r_2 * sqrt ( p3 ) * cos ( acos ( pq ) / 3.0_r_2 - 2.0_r_2 * pi * k / 3.0_r_2 ) - b / ( 3.0_r_2 * a ) end subroutine fAm_c3 ! ------------------------------------------------------------------------------ REAL FUNCTION total_photosynthesis_cost ( bjv ) use cable_canopy_module , only : xvcmxt3 , xejmxt3 , ej3x , xrdt , & xgmesT , xvcmxt3_acclim , xejmxt3_acclim use cable_def_types_mod , only : r_2 implicit none real , intent ( in ) :: bjv INTEGER :: k , j REAL :: kct , kot ! , tdiff REAL :: x , gamm , beta , gammastar , Rd , gm , jmaxt , trf , vcmax0 REAL ( r_2 ) :: a , b , c1 , d REAL ( r_2 ) :: p , q ! if cable_user%explicit_gm REAL ( r_2 ) :: Anc , Ane REAL :: An ( nt ), Ac ( nt ), Aj ( nt ) CALL point2constants ( C ) An = 0.0 Ac = 0.0 Aj = 0.0 j = 1 vcmax0 = Neff / ( 1. + relcost_J * bjv / 4.0 ) DO k = 1 , nt if ( APAR ( k ) . gt . C % tAPAR_optim ) then if ( cable_user % GS_SWITCH == 'medlyn' ) THEN x = 1.0 + ( g1 * fwsoil ( k ) ** qs ) / SQRT ( Dleaf ( k )) elseif ( cable_user % GS_SWITCH == 'leuning' ) THEN x = 1.0 / ( 1.0 / a1 + ( Dleaf ( k ) * 1.0e-3 / D0 )) endif if ( cable_user % acclimate_photosyn ) then CALL xvcmxt3_acclim ( Tleaf ( k ), Tgrowth , trf ) gamm = Vcmax0 * scalex ( k ) * trf * fwsoil ( k ) ** qb else gamm = Vcmax0 * scalex ( k ) * xvcmxt3 ( Tleaf ( k )) * fwsoil ( k ) ** qb endif gm = gm0 * scalex ( k ) * max ( 0.15 , fwsoil ( k ) ** qm ) * xgmesT ( Tleaf ( k )) ! tdiff = Tleaf(k) - C%Trefk ! gammastar = C%gam0 * ( 1.0 + C%gam1 * tdiff & !     + C%gam2 * tdiff * tdiff ) gammastar = gam0 * EXP ( ( egam / ( C % rgas * C % trefk ) ) & * ( 1.0 - C % trefk / Tleaf ( k ) ) ) Rd = Rd0 * scalex ( k ) * xrdt ( Tleaf ( k )) * fwsoil ( k ) ** qb * light_inhibition ( APAR ( k ) * 1.0e6 ) kct = kc0 * EXP ( ( ekc / ( C % rgas * C % trefk ) ) & * ( 1.0 - C % trefk / Tleaf ( k ) ) ) kot = ko0 * EXP ( ( eko / ( C % rgas * C % trefk ) ) & * ( 1.0 - C % trefk / Tleaf ( k ) ) ) beta = kct * ( 1.0 + 0.21 / kot ) ! Rubisco-limited if ( cable_user % explicit_gm ) then if ( TRIM ( cable_user % g0_switch ) == 'default' ) then CALL fabcd ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , x , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Anc ) elseif ( TRIM ( cable_user % g0_switch ) == 'maximum' ) then CALL fabcd ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Anc ) if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Anc * x / cs ( k )) then CALL fabcd ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Anc ) endif endif else ! infinite (implicit) gm if ( TRIM ( cable_user % g0_switch ) == 'default' ) then CALL fabc ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , x , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Anc ) ! rubisco-limited elseif ( TRIM ( cable_user % g0_switch ) == 'maximum' ) then CALL fabc ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Anc ) ! rubisco-limited if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Anc * x / cs ( k )) then CALL fabc ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Anc ) ! rubisco-limited endif endif endif if ( cable_user % acclimate_photosyn ) then call xejmxt3_acclim ( Tleaf ( k ), Tgrowth , Thome , trf ) jmaxt = bjv * Vcmax0 * scalex ( k ) * trf * fwsoil ( k ) ** qb else jmaxt = bjv * Vcmax0 * scalex ( k ) * xejmxt3 ( Tleaf ( k )) * fwsoil ( k ) ** qb endif gamm = ej3x ( APAR ( k ), alpha , convex , jmaxt ) beta = 2.0 * gammastar ! RuBP regeneration-limited if ( cable_user % explicit_gm ) then if ( TRIM ( cable_user % g0_switch ) == 'default' ) then CALL fabcd ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , x , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Ane ) elseif ( TRIM ( cable_user % g0_switch ) == 'maximum' ) then CALL fabcd ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Ane ) if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Ane * x / cs ( k )) then CALL fabcd ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Ane ) endif endif else ! infinite (implicit) gm if ( TRIM ( cable_user % g0_switch ) == 'default' ) then CALL fabc ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , x , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Ane ) ! e-transport limited elseif ( TRIM ( cable_user % g0_switch ) == 'maximum' ) then CALL fabc ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Ane ) ! e-transport limited if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Ane * x / cs ( k )) then CALL fabc ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Ane ) ! e-transport limited endif endif endif An ( j ) = real ( min ( Anc , Ane )) else An ( j ) = 0.0 endif j = j + 1 ENDDO if ( sum ( An ) > 0.0 ) then total_photosynthesis_cost = Neff / sum ( An ) !total_photosynthesis_cost = (relcost_J*Vcmax0*bjv/4.0 + Vcmax0)/sum(An) else total_photosynthesis_cost = 0.0 endif END FUNCTION total_photosynthesis_cost ! ------------------------------------------------------------------------------ REAL FUNCTION total_photosynthesis ( bjv ) use cable_canopy_module , only : xvcmxt3 , xejmxt3 , ej3x , xrdt , & xgmesT , xvcmxt3_acclim , xejmxt3_acclim use cable_def_types_mod , only : r_2 implicit none !TYPE( icanopy_type ) :: C real , intent ( in ) :: bjv INTEGER :: k , j REAL :: kct , kot , tdiff REAL :: x , gamm , beta , gammastar , Rd , jmaxt , gm , trf , vcmax0 REAL ( r_2 ) :: a , b , c1 , d , p , q REAL ( r_2 ) :: Anc , Ane REAL :: An ( nt ) CALL point2constants ( C ) An = 0.0 j = 1 vcmax0 = Neff / ( 1. + relcost_J * bjv / 4.0 ) DO k = 1 , nt if ( APAR ( k ) . gt . C % tAPAR_optim ) then if ( cable_user % GS_SWITCH == 'medlyn' ) THEN x = 1.0 + ( g1 * fwsoil ( k ) ** qs ) / SQRT ( Dleaf ( k )) elseif ( cable_user % GS_SWITCH == 'leuning' ) THEN x = 1.0 / ( 1.0 / a1 + ( Dleaf ( k ) * 1.0e-3 / D0 )) endif if ( cable_user % acclimate_photosyn ) then cALL xvcmxt3_acclim ( Tleaf ( k ), Tgrowth , trf ) gamm = Vcmax0 * scalex ( k ) * trf * fwsoil ( k ) ** qb else gamm = Vcmax0 * scalex ( k ) * xvcmxt3 ( Tleaf ( k )) * fwsoil ( k ) ** qb endif gm = gm0 * scalex ( k ) * max ( 0.15 , fwsoil ( k ) ** qm ) * xgmesT ( Tleaf ( k )) tdiff = Tleaf ( k ) - C % Trefk !gammastar = C%gam0 * ( 1.0 + C%gam1 * tdiff                  & !     + C%gam2 * tdiff * tdiff ) gammastar = gam0 * EXP ( ( egam / ( C % rgas * C % trefk ) ) & * ( 1.0 - C % trefk / Tleaf ( k ) ) ) Rd = Rd0 * scalex ( k ) * xrdt ( Tleaf ( k )) * fwsoil ( k ) ** qb * light_inhibition ( APAR ( k ) * 1.0e6 ) kct = kc0 * EXP ( ( ekc / ( C % rgas * C % trefk ) ) & * ( 1.0 - C % trefk / Tleaf ( k ) ) ) kot = ko0 * EXP ( ( eko / ( C % rgas * C % trefk ) ) & * ( 1.0 - C % trefk / Tleaf ( k ) ) ) beta = kct * ( 1.0 + 0.21 / kot ) ! Rubisco-limited if ( cable_user % explicit_gm ) then if ( TRIM ( cable_user % g0_switch ) == 'default' ) then CALL fabcd ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , x , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Anc ) elseif ( TRIM ( cable_user % g0_switch ) == 'maximum' ) then CALL fabcd ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Anc ) if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Anc * x / cs ( k )) then CALL fabcd ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Anc ) endif endif else ! infinite (implicit) gm if ( TRIM ( cable_user % g0_switch ) == 'default' ) then CALL fabc ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , x , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Anc ) ! rubisco-limited elseif ( TRIM ( cable_user % g0_switch ) == 'maximum' ) then CALL fabc ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Anc ) ! rubisco-limited if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Anc * x / cs ( k )) then CALL fabc ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Anc ) ! rubisco-limited endif endif endif if ( cable_user % acclimate_photosyn ) then call xejmxt3_acclim ( Tleaf ( k ), Tgrowth , Thome , trf ) jmaxt = bjv * Vcmax0 * scalex ( k ) * trf * fwsoil ( k ) ** qb else jmaxt = bjv * Vcmax0 * scalex ( k ) * xejmxt3 ( Tleaf ( k )) * fwsoil ( k ) ** qb endif gamm = ej3x ( APAR ( k ), alpha , convex , jmaxt ) beta = 2.0 * gammastar ! RuBP regeneration-limited if ( cable_user % explicit_gm ) then if ( TRIM ( cable_user % g0_switch ) == 'default' ) then CALL fabcd ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , x , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Ane ) elseif ( TRIM ( cable_user % g0_switch ) == 'maximum' ) then CALL fabcd ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Ane ) if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Ane * x / cs ( k )) then CALL fabcd ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Ane ) endif endif else ! infinite (implicit) gm if ( TRIM ( cable_user % g0_switch ) == 'default' ) then CALL fabc ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , x , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Anc ) ! rubisco-limited elseif ( TRIM ( cable_user % g0_switch ) == 'maximum' ) then CALL fabc ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Ane ) ! e-transport limited if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Ane * x / cs ( k )) then CALL fabc ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Ane ) ! e-transport limited endif endif endif An ( j ) = real ( min ( Anc , Ane )) else An ( j ) = 0.0 endif j = j + 1 ENDDO total_photosynthesis = sum ( An ) END FUNCTION total_photosynthesis ! ------------------------------------------------------------------------------ REAL FUNCTION diff_Ac_Aj ( bjv ) use cable_canopy_module , only : xvcmxt3 , xejmxt3 , ej3x , xrdt , & xgmesT , xvcmxt3_acclim , xejmxt3_acclim use cable_def_types_mod , only : r_2 implicit none !TYPE( icanopy_type ) :: C real , intent ( in ) :: bjv INTEGER :: k , j ! k is timestep! REAL :: kct , kot , tdiff REAL :: x , gamm , beta , gammastar , Rd , jmaxt , gm , trf , vcmax0 ! c1 because C already taken REAL ( r_2 ) :: a , b , c1 , d , p , q ! if cable_user%explicit_gm REAL ( r_2 ) :: Anc , Ane REAL :: An ( nt ), Ac ( nt ), Aj ( nt ) REAL :: total_An , total_Ac , total_Aj CALL point2constants ( C ) An = 0.0 Ac = 0.0 Aj = 0.0 j = 1 vcmax0 = Neff / ( 1. + relcost_J * bjv / 4.0 ) !bjv = (vcmax0/Neff -1.)*4.0/relcost_J DO k = 1 , nt if ( APAR ( k ) . gt . C % tAPAR_optim ) then Ac ( j ) = 0.0 Aj ( j ) = 0.0 if ( cable_user % GS_SWITCH == 'medlyn' ) THEN x = 1.0 + ( g1 * fwsoil ( k ) ** qs ) / SQRT ( Dleaf ( k )) elseif ( cable_user % GS_SWITCH == 'leuning' ) THEN x = 1.0 / ( 1.0 / a1 + ( Dleaf ( k ) * 1.0e-3 / D0 )) endif if ( cable_user % acclimate_photosyn ) then CALL xvcmxt3_acclim ( Tleaf ( k ), Tgrowth , trf ) gamm = Vcmax0 * scalex ( k ) * trf * fwsoil ( k ) ** qb else gamm = Vcmax0 * scalex ( k ) * xvcmxt3 ( Tleaf ( k )) * fwsoil ( k ) ** qb endif gm = gm0 * scalex ( k ) * max ( 0.15 , fwsoil ( k ) ** qm ) * xgmesT ( Tleaf ( k )) tdiff = Tleaf ( k ) - C % Trefk !gammastar = C%gam0 * ( 1.0 + C%gam1 * tdiff                  & !     + C%gam2 * tdiff * tdiff ) gammastar = gam0 * EXP ( ( egam / ( C % rgas * C % trefk ) ) & * ( 1.0 - C % trefk / Tleaf ( k ) ) ) Rd = Rd0 * scalex ( k ) * xrdt ( Tleaf ( k )) * fwsoil ( k ) ** qb * light_inhibition ( APAR ( k ) * 1.0e6 ) kct = kc0 * EXP ( ( ekc / ( C % rgas * C % trefk ) ) & * ( 1.0 - C % trefk / Tleaf ( k ) ) ) kot = ko0 * EXP ( ( eko / ( C % rgas * C % trefk ) ) & * ( 1.0 - C % trefk / Tleaf ( k ) ) ) beta = kct * ( 1.0 + 0.21 / kot ) ! Rubisco-limited if ( cable_user % explicit_gm ) then if ( TRIM ( cable_user % g0_switch ) == 'default' ) then CALL fabcd ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , x , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Anc ) elseif ( TRIM ( cable_user % g0_switch ) == 'maximum' ) then CALL fabcd ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Anc ) if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Anc * x / cs ( k )) then CALL fabcd ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Anc ) endif endif else ! infinite (implicit) gm if ( TRIM ( cable_user % g0_switch ) == 'default' ) then CALL fabc ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , x , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Anc ) ! rubisco-limited elseif ( TRIM ( cable_user % g0_switch ) == 'maximum' ) then CALL fabc ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Anc ) ! rubisco-limited if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Anc * x / cs ( k )) then CALL fabc ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Anc ) ! rubisco-limited endif endif endif if ( cable_user % acclimate_photosyn ) then call xejmxt3_acclim ( Tleaf ( k ), Tgrowth , Thome , trf ) jmaxt = bjv * Vcmax0 * scalex ( k ) * trf * fwsoil ( k ) ** qb else jmaxt = bjv * Vcmax0 * scalex ( k ) * xejmxt3 ( Tleaf ( k )) * fwsoil ( k ) ** qb endif gamm = ej3x ( APAR ( k ), alpha , convex , jmaxt ) beta = 2.0 * gammastar ! RuBP regeneration-limited if ( cable_user % explicit_gm ) then if ( TRIM ( cable_user % g0_switch ) == 'default' ) then CALL fabcd ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , x , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Ane ) elseif ( TRIM ( cable_user % g0_switch ) == 'maximum' ) then CALL fabcd ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Ane ) if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Ane * x / cs ( k )) then CALL fabcd ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Ane ) endif endif else ! infinite (implicit) gm if ( TRIM ( cable_user % g0_switch ) == 'default' ) then CALL fabc ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , x , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Ane ) ! e-transport limited elseif ( TRIM ( cable_user % g0_switch ) == 'maximum' ) then CALL fabc ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Ane ) ! e-transport limited if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Ane * x / cs ( k )) then CALL fabc ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Ane ) ! e-transport limited endif endif endif An ( j ) = real ( min ( Anc , Ane )) if ( Anc < Ane ) Ac ( j ) = real ( Anc ) if ( Ane < Anc ) Aj ( j ) = real ( Ane ) else An ( j ) = 0.0 endif j = j + 1 ENDDO total_An = sum ( An ) total_Ac = sum ( Ac ) total_Aj = sum ( Aj ) diff_Ac_Aj = total_Ac - total_Aj END FUNCTION diff_Ac_Aj ! ------------------------------------------------------------------------------ FUNCTION golden ( ax , bx , cx , func , tol , xmin ) IMPLICIT NONE REAL , INTENT ( IN ) :: ax , bx , cx INTERFACE FUNCTION func ( x ) IMPLICIT NONE REAL , INTENT ( IN ) :: x REAL :: func END FUNCTION func END INTERFACE REAL , INTENT ( IN ) :: tol REAL , INTENT ( OUT ) :: xmin REAL :: golden REAL , PARAMETER :: R = 0.61803399 REAL , PARAMETER :: C = 1.0 - R REAL :: f1 , f2 , x0 , x1 , x2 , x3 x0 = ax x3 = cx if ( abs ( cx - bx ) > abs ( bx - ax )) then x1 = bx x2 = bx + C * ( cx - bx ) else x2 = bx x1 = bx - C * ( bx - ax ) end if f1 = func ( x1 ) f2 = func ( x2 ) do if ( abs ( x3 - x0 ) <= tol * ( abs ( x1 ) + abs ( x2 ))) exit if ( f2 < f1 ) then call shft3 ( x0 , x1 , x2 , R * x2 + C * x3 ) call shft2 ( f1 , f2 , func ( x2 )) else call shft3 ( x3 , x2 , x1 , R * x1 + C * x0 ) call shft2 ( f2 , f1 , func ( x1 )) end if end do if ( f1 < f2 ) then golden = f1 xmin = x1 else golden = f2 xmin = x2 end if CONTAINS SUBROUTINE shft2 ( a , b , c ) REAL , INTENT ( OUT ) :: a REAL , INTENT ( INOUT ) :: b REAL , INTENT ( IN ) :: c a = b b = c END SUBROUTINE shft2 SUBROUTINE shft3 ( a , b , c , d ) REAL , INTENT ( OUT ) :: a REAL , INTENT ( INOUT ) :: b , c REAL , INTENT ( IN ) :: d a = b b = c c = d END SUBROUTINE shft3 END FUNCTION golden ! ------------------------------------------------------------------------------ SUBROUTINE total_An_Ac_Aj ( bjv , total_An , total_Ac , total_Aj ) use cable_canopy_module , only : xvcmxt3 , xejmxt3 , ej3x , xrdt , & xgmesT , xvcmxt3_acclim , xejmxt3_acclim use cable_def_types_mod , only : r_2 implicit none !TYPE( icanopy_type ) :: C real , intent ( in ) :: bjv real , intent ( out ) :: total_An , total_Ac , total_Aj INTEGER :: k , j REAL :: kct , kot , tdiff REAL :: x , gamm , beta , gammastar , Rd , jmaxt , gm , trf , vcmax0 REAL ( r_2 ) :: a , b , c1 , d , p , q ! if cable_user%explicit_gm REAL ( r_2 ) :: Anc , Ane REAL :: An ( nt ), Ac ( nt ), Aj ( nt ) CALL point2constants ( C ) An = 0.0 Ac = 0 Aj = 0 j = 1 vcmax0 = Neff / ( 1. + relcost_J * bjv / 4.0 ) DO k = 1 , nt if ( APAR ( k ) . gt . C % tAPAR_optim ) then Ac ( j ) = 0.0 Aj ( j ) = 0.0 if ( cable_user % GS_SWITCH == 'medlyn' ) THEN x = 1.0 + ( g1 * fwsoil ( k ) ** qs ) / SQRT ( Dleaf ( k )) elseif ( cable_user % GS_SWITCH == 'leuning' ) THEN x = 1.0 / ( 1.0 / a1 + ( Dleaf ( k ) * 1.0e-3 / D0 )) endif if ( cable_user % acclimate_photosyn ) then CALL xvcmxt3_acclim ( Tleaf ( k ), Tgrowth , trf ) gamm = Vcmax0 * scalex ( k ) * trf * fwsoil ( k ) ** qb else gamm = Vcmax0 * scalex ( k ) * xvcmxt3 ( Tleaf ( k )) * fwsoil ( k ) ** qb endif gm = gm0 * scalex ( k ) * max ( 0.15 , fwsoil ( k ) ** qm ) * xgmesT ( Tleaf ( k )) tdiff = Tleaf ( k ) - C % Trefk !gammastar = C%gam0 * ( 1.0 + C%gam1 * tdiff                  & !                                 + C%gam2 * tdiff * tdiff ) gammastar = gam0 * EXP ( ( egam / ( C % rgas * C % trefk ) ) & * ( 1.0 - C % trefk / Tleaf ( k ) ) ) Rd = Rd0 * scalex ( k ) * xrdt ( Tleaf ( k )) * fwsoil ( k ) ** qb * light_inhibition ( APAR ( k ) * 1.0e6 ) kct = kc0 * EXP ( ( ekc / ( C % rgas * C % trefk ) ) & * ( 1.0 - C % trefk / Tleaf ( k ) ) ) kot = ko0 * EXP ( ( eko / ( C % rgas * C % trefk ) ) & * ( 1.0 - C % trefk / Tleaf ( k ) ) ) beta = kct * ( 1.0 + 0.21 / kot ) ! Rubisco-limited if ( cable_user % explicit_gm ) then CALL fabcd ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Anc ) if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Anc * x / cs ( k )) then CALL fabcd ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Anc ) endif else ! infinite (implicit) gm CALL fabc ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Anc ) if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Anc * x / cs ( k )) then CALL fabc ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Anc ) ! rubisco-limited endif endif if ( cable_user % acclimate_photosyn ) then call xejmxt3_acclim ( Tleaf ( k ), Tgrowth , Thome , trf ) jmaxt = bjv * Vcmax0 * scalex ( k ) * trf * fwsoil ( k ) ** qb else jmaxt = bjv * Vcmax0 * scalex ( k ) * xejmxt3 ( Tleaf ( k )) * fwsoil ( k ) ** qb endif gamm = ej3x ( APAR ( k ), alpha , convex , jmaxt ) beta = 2.0 * gammastar ! RuBP regeneration-limited if ( cable_user % explicit_gm ) then CALL fabcd ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Ane ) if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Ane * x / cs ( k )) then CALL fabcd ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , gm , a , b , c1 , d ) CALL fpq ( a , b , c1 , d , p , q ) CALL fAm_c3 ( a , b , c1 , d , p , q , Ane ) endif else ! infinite (implicit) gm CALL fabc ( cs ( k ), 0.0 , x , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Ane ) if ( g0 ( k ) * fwsoil ( k ) ** qs . gt . Ane * x / cs ( k )) then CALL fabc ( cs ( k ), g0 ( k ) * fwsoil ( k ) ** qs , 0.1e-4 , gamm , beta , gammastar , Rd , a , b , c1 ) CALL fAn_c3 ( a , b , c1 , Ane ) ! e-transport limited endif endif An ( j ) = real ( min ( Anc , Ane )) if ( Anc < Ane ) Ac ( j ) = real ( Anc ) if ( Ane < Anc ) Aj ( j ) = real ( Ane ) else An ( j ) = 0.0 endif j = j + 1 ENDDO total_An = sum ( An ) total_Ac = sum ( Ac ) total_Aj = sum ( Aj ) END SUBROUTINE total_An_Ac_Aj ! ------------------------------------------------------------------------------ FUNCTION rtbis ( func , x1 , x2 , xacc ) !USE nrtype; USE nrutil, ONLY : nrerror use mo_utils , only : eq , le , ge #ifdef __MPI__ use mpi , only : MPI_Abort #endif IMPLICIT NONE INTERFACE FUNCTION func ( x ) IMPLICIT NONE REAL , INTENT ( IN ) :: x REAL :: func END FUNCTION func END INTERFACE REAL , INTENT ( IN ) :: x1 , x2 , xacc REAL :: rtbis INTEGER , PARAMETER :: MAXIT = 40 INTEGER :: j REAL :: dx , f , fmid , xmid #ifdef __MPI__ integer :: ierr #endif fmid = func ( x2 ) f = func ( x1 ) if ( ge ( f * fmid , 0.0 )) then write ( * , * ) 'rtbis: root must be bracketed' #ifdef __MPI__ call MPI_Abort ( 0 , 89 , ierr ) ! Do not know comm nor rank here #else stop 89 #endif endif if ( f < 0.0 ) then rtbis = x1 dx = x2 - x1 else rtbis = x2 dx = x1 - x2 end if do j = 1 , MAXIT dx = dx * 0.5 xmid = rtbis + dx fmid = func ( xmid ) if ( le ( fmid , 0.0 )) rtbis = xmid if ( abs ( dx ) < xacc . or . eq ( fmid , 0.0 )) RETURN end do write ( * , * ) 'rtbis: too many bisections' #ifdef __MPI__ call MPI_Abort ( 0 , 90 , ierr ) ! Do not know comm nor rank here #else stop 90 #endif END FUNCTION rtbis ! ============================================================================== END MODULE cable_optimise_JV_module","tags":"","loc":"sourcefile/cable_optimisejvratio.f90.html"},{"title":"cable_phenology.F90 – POP","text":"This file depends on sourcefile~~cable_phenology.f90~~EfferentGraph sourcefile~cable_phenology.f90 cable_phenology.F90 sourcefile~casa_variable.f90 casa_variable.F90 sourcefile~cable_phenology.f90->sourcefile~casa_variable.f90 sourcefile~pop.f90 POP.F90 sourcefile~cable_phenology.f90->sourcefile~pop.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~cable_phenology.f90~~AfferentGraph sourcefile~cable_phenology.f90 cable_phenology.F90 sourcefile~casa_cable.f90 casa_cable.F90 sourcefile~casa_cable.f90->sourcefile~cable_phenology.f90 sourcefile~casaonly_luc.f90 CASAONLY_LUC.F90 sourcefile~casaonly_luc.f90->sourcefile~casa_cable.f90 sourcefile~spincasacnp.f90 spincasacnp.F90 sourcefile~spincasacnp.f90->sourcefile~casa_cable.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules cable_phenology_module Source Code cable_phenology.F90 Source Code ! ============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: climate-dependent phenology ! ! Called from: SUBROUTINE bgcdriver in casa_cable.F90 ! ! History: Vanessa Haverd Jan 2015 ! ============================================================================== MODULE cable_phenology_module Use cable_def_types_mod , ONLY : met_type , climate_type , canopy_type , & veg_parameter_type , mp , r_2 USE TypeDef , ONLY : i4b , dp USE cable_IO_vars_module , ONLY : patch USE CABLE_COMMON_MODULE , ONLY : CurYear , filename , cable_user , HANDLE_ERR CONTAINS ! ============================================================================== SUBROUTINE cable_phenology_clim ( veg , climate , phen ) ! sets the following days of year for use in allocation and leaf senescence ! algorithm depends on pft and climate !phen%doyphase(np,1) ! DOY for greenup !phen%doyphase(np,2) ! DOY for steady LAI ! phen%doyphase(np,3) ! DOY for leaf senescence !phen%doyphase(np,4) ! DOY for minimal LAI season USE casadimension USE casaparm USE casavariable USE phenvariable use mo_utils , only : eq , ge IMPLICIT NONE TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg ! vegetation parameters TYPE ( phen_variable ), INTENT ( INOUT ) :: phen TYPE ( climate_type ), INTENT ( IN ) :: climate ! climate variables INTEGER :: np , days REAL :: gdd0 REAL ( r_2 ) :: phen_tmp REAL , PARAMETER :: k_chilla = 0 , k_chillb = 100 , k_chillk = 0.05 REAL , PARAMETER :: APHEN_MAX = 20 0.0 , ndays_raingreenup = 60 INTEGER , PARAMETER :: COLDEST_DAY_NHEMISPHERE = 355 INTEGER , PARAMETER :: COLDEST_DAY_SHEMISPHERE = 172 REAL :: phengdd5ramp DO np = 1 , mp phen_tmp = 1.0_r_2 ! evergreen pfts if ( veg % iveg ( np ) == 1 . or . veg % iveg ( np ) == 2 . or . veg % iveg ( np ) == 5 ) then phen % doyphase ( np , 1 ) = - 50 phen % doyphase ( np , 2 ) = phen % doyphase ( np , 1 ) + 14 phen % doyphase ( np , 3 ) = 367 phen % doyphase ( np , 4 ) = phen % doyphase ( np , 3 ) + 14 phen % phase ( np ) = 2 endif ! summergreen woody pfts if ( veg % iveg ( np ) == 3 . or . veg % iveg ( np ) == 4 ) then ! deciduous needleleaf(3) and broadleaf(4) ! Calculate GDD0  base value (=gdd to bud burst) for this PFT given !  current length of chilling period (Sykes et al 1996, Eqn 1) gdd0 = k_chilla + k_chillb * exp ( - k_chillk * real ( climate % chilldays ( np ))) phengdd5ramp = 200 if ( climate % gdd5 ( np ). gt . gdd0 . and . phen % aphen ( np ). lt . APHEN_MAX ) then phen_tmp = min ( 1.0_r_2 , real (( climate % gdd5 ( np ) - gdd0 ) / phengdd5ramp , dp )) else phen_tmp = 0.0_r_2 endif endif ! summergreen grass or crops if ( veg % iveg ( np ). ge . 6. and . veg % iveg ( np ). le . 10 ) then ! grass or crops if ( climate % gdd5 ( np ). gt . 0.1 ) THEN phengdd5ramp = 200 phen_tmp = min ( 1.0_r_2 , real ( climate % gdd5 ( np ) / phengdd5ramp , r_2 )) ELSE phen_tmp = 0.0_r_2 ENDIF !if (np==3) write(61,*) 'chk1',np, climate%doy,climate%gdd5(np), phen_tmp endif if ( 1. eq . 1 ) then ! raingreen pfts if ( veg % iveg ( np ). ge . 6. and . veg % iveg ( np ). le . 10 ) then ! (grass or crops) need to include raingreen savanna trees here too ! if (climate%dmoist(np).lt. mmoisture_min) phen_tmp = 0.0 if ( climate % GMD ( np ) . GE . 1 . and . climate % GMD ( np ) . LT . ndays_raingreenup ) THEN phen_tmp = min ( phen_tmp , 0.99_r_2 ) elseif ( climate % GMD ( np ) . EQ . 0 ) THEN phen_tmp = 0.0_r_2 elseif ( climate % GMD ( np ) . GE . ndays_raingreenup ) THEN phen_tmp = min ( phen_tmp , 1.0_r_2 ) endif !if (np==3) write(61,*) 'chk2',np, climate%doy,climate%GMD(np), phen_tmp endif endif if (( veg % iveg ( np ) == 3 . or . veg % iveg ( np ) == 4 ) . or . & ( veg % iveg ( np ). ge . 6. and . veg % iveg ( np ). le . 10 )) then !    if (phen_tmp.gt.0.0 .and.( phen%phase(np).eq.3 .or. phen%phase(np).eq.0 )) then !       phen%phase(np) = 1 ! greenup !       phen%doyphase(np,1) = climate%doy !    elseif (phen_tmp.ge.1.0_r_2 .and. phen%phase(np).eq.1) then !       phen%phase(np) = 2 ! steady LAI !       phen%doyphase(np,2) = climate%doy !    elseif (phen_tmp.lt.1.0_r_2 .and. phen%phase(np).eq.2) then !       phen%phase(np) = 3 ! senescence !       phen%doyphase(np,3) = climate%doy !    endif if (( phen_tmp . gt . 0.0_r_2 ) . and . ( phen_tmp . lt . 1.0_r_2 )) then phen % phase ( np ) = 1 ! greenup phen % doyphase ( np , 1 ) = climate % doy elseif ( ge ( phen_tmp , 1.0_r_2 )) then phen % phase ( np ) = 2 ! steady LAI phen % doyphase ( np , 2 ) = climate % doy elseif ( eq ( phen_tmp , 0.0_r_2 )) then phen % phase ( np ) = 3 ! senescence phen % doyphase ( np , 3 ) = climate % doy endif if ( phen % phase ( np ) == 3 ) then days = min ( climate % doy , 365 ) - phen % doyphase ( np , 3 ) if ( days < 0 ) days = days + 365 if ( days > 14 ) phen % phase ( np ) = 0 ! mimimum LAI endif ! Update annual leaf-on sum IF (( patch ( np )% latitude >= 0.0 . and . climate % doy == COLDEST_DAY_NHEMISPHERE ). OR . & ( patch ( np )% latitude < 0.0 . and . climate % doy == COLDEST_DAY_SHEMISPHERE ) ) & phen % aphen ( np ) = 0.0 phen % phen ( np ) = real ( phen_tmp ) phen % aphen ( np ) = phen % aphen ( np ) + phen % phen ( np ) endif !if (np==6) write(59,*) veg%iveg(np), phen%phase(np) !if (np==19) write(60,*) veg%iveg(np), phen%phase(np) ENDDO ! end loop over patches END SUBROUTINE cable_phenology_clim ! ============================================================================== END MODULE cable_phenology_module","tags":"","loc":"sourcefile/cable_phenology.f90.html"},{"title":"casa_inout.F90 – POP","text":"This file depends on sourcefile~~casa_inout.f90~~EfferentGraph sourcefile~casa_inout.f90 casa_inout.F90 sourcefile~casa_cnp.f90 casa_cnp.F90 sourcefile~casa_inout.f90->sourcefile~casa_cnp.f90 sourcefile~casa_variable.f90 casa_variable.F90 sourcefile~casa_inout.f90->sourcefile~casa_variable.f90 sourcefile~pop.f90 POP.F90 sourcefile~casa_inout.f90->sourcefile~pop.f90 sourcefile~casa_cnp.f90->sourcefile~casa_variable.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~casa_inout.f90~~AfferentGraph sourcefile~casa_inout.f90 casa_inout.F90 sourcefile~casa_cable.f90 casa_cable.F90 sourcefile~casa_cable.f90->sourcefile~casa_inout.f90 sourcefile~casaonly_luc.f90 CASAONLY_LUC.F90 sourcefile~casaonly_luc.f90->sourcefile~casa_inout.f90 sourcefile~casaonly_luc.f90->sourcefile~casa_cable.f90 sourcefile~spincasacnp.f90 spincasacnp.F90 sourcefile~spincasacnp.f90->sourcefile~casa_inout.f90 sourcefile~spincasacnp.f90->sourcefile~casa_cable.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules casa_inout Source Code casa_inout.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: Input and output code for CASA-CNP when run offline !          ACCESS version may use some of this code but split into different files? ! ! Contact: Yingping.Wang@csiro.au and Bernard.Pak@csiro.au ! ! History: Developed for offline code.  Expect to re-write for MPI and ACCESS !          versions ! ! Matthias Cuntz, 24/2/2020: Make all new netCDF files 64bit_offset. Do also not reopen ! the define mode because they are already in define mode once they are created. Read ! and write N/P variables from and to dump files only if icycle>1 or icycle>2. Also pass ! the variables in MPI code only if icycle>1,2. Rewrote write_casa_output_nc so that N/P ! variables are only written in case of icycle>1,2. Initialised more variables in Cable and Casa, ! which might otherwise be undefined during write_output. Also some more consistencies of variable ! kinds during calculations, mostly casa. Reinstated ESM-SnowMIP output variables that were present ! in an earlier branch trunk4252_wales. Only pass bal to close_output_file, not all ! other unnecessary variables. Use a generic conversion routine toreal4() for output to catch ! floating point underflow in conversions (real(variable,4)). ! ============================================================================== ! casa_inout.f90 ! ! the following routines are used when \"casacnp\" is coupled to \"cable\" !   zero_casa_dump !   casa_readbiome !   casa_readphen !   casa_readpoint   (removed, now done in parameter_module) !   casa_init !   casa_poolout !   casa_cnpflux  (zeros casabal quantites on doy 1 and updates casabal at end of biogeochem) !   biogeochem module casa_inout implicit none contains subroutine zero_casa_dump ( casamet , phen ) ! Zero variables that will be read from dump files. ! This is done to have zero in MPI and non MPI code ! if .not. cable_user%casa_dump_read. use cable_def_types_mod , only : r_2 use casavariable , only : casa_met use phenvariable , only : phen_variable use cable_common_module , only : cable_user implicit none type ( casa_met ), intent ( inout ) :: casamet type ( phen_variable ), intent ( inout ) :: phen casamet % Tairkspin = 0.0_r_2 casamet % Tsoilspin_1 = 0.0_r_2 casamet % Tsoilspin_2 = 0.0_r_2 casamet % Tsoilspin_3 = 0.0_r_2 casamet % Tsoilspin_4 = 0.0_r_2 casamet % Tsoilspin_5 = 0.0_r_2 casamet % Tsoilspin_6 = 0.0_r_2 casamet % moistspin_1 = 0.0_r_2 casamet % moistspin_2 = 0.0_r_2 casamet % moistspin_3 = 0.0_r_2 casamet % moistspin_4 = 0.0_r_2 casamet % moistspin_5 = 0.0_r_2 casamet % moistspin_6 = 0.0_r_2 casamet % cgppspin = 0.0_r_2 casamet % crmplantspin_1 = 0.0_r_2 casamet % crmplantspin_2 = 0.0_r_2 casamet % crmplantspin_3 = 0.0_r_2 phen % phasespin = 0 phen % doyphasespin_1 = 0 phen % doyphasespin_2 = 0 phen % doyphasespin_3 = 0 phen % doyphasespin_4 = 0 casamet % mtempspin = 0.0_r_2 casamet % frecspin = 0.0_r_2 if ( cable_user % c13o2 ) then casamet % cAn12spin = 0.0_r_2 casamet % cAn13spin = 0.0_r_2 end if if ( cable_user % call_blaze ) then casamet % dprecip_spin = 0.0_r_2 casamet % aprecip_av20_spin = 0.0_r_2 casamet % du10_max_spin = 0.0_r_2 casamet % drhum_spin = 0.0_r_2 casamet % dtemp_max_spin = 0.0_r_2 casamet % dtemp_max_spin = 0.0_r_2 casamet % KBDI_spin = 0.0_r_2 casamet % D_MacArthur_spin = 0.0_r_2 casamet % FFDI_spin = 0.0_r_2 casamet % DSLR_spin = 0 casamet % last_precip_spin = 0.0_r_2 end if end subroutine zero_casa_dump ! #define UM_BUILD YES SUBROUTINE casa_readbiome ( veg , soil , casabiome , casapool , casaflux , casamet , phen ) ! mst actually not used in this routine (BP sep2010) !SUBROUTINE casa_readbiome(mvt,mst,veg,soil, & !                          casabiome,casapool,casaflux,casamet,phen) USE cable_def_types_mod USE casadimension USE casaparm USE casavariable USE phenvariable !! vh_js !! USE cable_common_module , only : cable_user IMPLICIT NONE !  INTEGER,               INTENT(IN)    :: mvt,mst TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil ! soil parameters TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( phen_variable ), INTENT ( INOUT ) :: phen ! local variables REAL ( r_2 ), DIMENSION ( mvtype ) :: leafage , frootage , woodage REAL ( r_2 ), DIMENSION ( mvtype ) :: cwdage , metage , strage REAL ( r_2 ), DIMENSION ( mvtype ) :: micage , slowage , passage , clabileage , slax REAL ( r_2 ), DIMENSION ( mvtype , mplant ) :: ratioCNplant REAL ( r_2 ), DIMENSION ( mvtype , msoil ) :: ratioCNsoil , ratioCNsoilmin , ratioCNsoilmax REAL ( r_2 ), DIMENSION ( ms ) :: depthsoila , depthsoilb REAL ( r_2 ), DIMENSION ( mvtype ) :: xfNminloss , xfNminleach , xnfixrate REAL ( r_2 ), DIMENSION ( mvtype ) :: cleaf , cwood , cfroot , & cmet , cstr , ccwd , & cmic , cslow , cpass REAL ( r_2 ), DIMENSION ( mvtype ) :: nleaf , nwood , nfroot , & nmet , nstr , ncwd , & nmic , nslow , npass , xnsoilmin REAL ( r_2 ), DIMENSION ( mvtype ) :: xpleaf , xpwood , xpfroot , & xpmet , xpstr , xpcwd , & xpmic , xpslow , xppass , xplab , xpsorb , xpocc REAL ( r_2 ), DIMENSION ( mso ) :: xkmlabp , xpsorbmax , xfPleach REAL ( r_2 ), DIMENSION ( mso , msoil ) :: ratioNPsoil REAL ( r_2 ), DIMENSION ( mvtype ) :: xfherbivore , xxkleafcoldmax , xxkleafdrymax REAL ( r_2 ), DIMENSION ( mvtype , ms ) :: fracroot REAL ( r_2 ) :: xratioNPleafmin , xratioNPleafmax , & xratioNPwoodmin , xratioNPwoodmax , & xratioNPfrootmin , xratioNPfrootmax INTEGER :: i , iv1 , nv , ns , npt , iso INTEGER :: nv0 , nv1 , nv2 , nv3 , nv4 , nv6 , nv7 , nv8 , nv9 , nv10 , nv11 , nv12 , nv13 REAL ( r_2 ), DIMENSION ( mvtype ) :: xxnpmax , xq10soil , xxkoptlitter , xxkoptsoil , xprodptase , & xcostnpup , xmaxfinelitter , xmaxcwd , xnintercept , xnslope REAL ( r_2 ), DIMENSION ( mvtype ) :: la_to_sa , vcmax_scalar , disturbance_interval REAL ( r_2 ), DIMENSION ( mvtype ) :: DAMM_EnzPool , DAMM_KMO2 , DAMM_KMcp , DAMM_Ea , DAMM_alpha REAL ( r_2 ), DIMENSION ( mso ) :: xxkplab , xxkpsorb , xxkpocc OPEN ( 101 , file = casafile % cnpbiome ) DO i = 1 , 3 READ ( 101 , * ) ENDDO DO nv = 1 , mvtype READ ( 101 , * ) nv0 , casabiome % ivt2 ( nv ) ENDDO READ ( 101 , * ) READ ( 101 , * ) DO nv = 1 , mvtype READ ( 101 , * ) nv1 , casabiome % kroot ( nv ), casabiome % rootdepth ( nv ), & casabiome % kuptake ( nv ), casabiome % krootlen ( nv ), & casabiome % kminN ( nv ), casabiome % kuplabP ( nv ), & xfherbivore ( nv ), leafage ( nv ), woodage ( nv ), frootage ( nv ), & metage ( nv ), strage ( nv ), cwdage ( nv ), & micage ( nv ), slowage ( nv ), passage ( nv ), clabileage ( nv ), slax ( nv ) ! write(59,*) nv, leafage(nv),woodage(nv),frootage(nv), & !             metage(nv),strage(nv),cwdage(nv),  & !             micage(nv),slowage(nv),passage(nv) ENDDO READ ( 101 , * ) READ ( 101 , * ) DO nv = 1 , mvtype READ ( 101 , * ) nv2 , & casabiome % fracnpptoP ( nv , leaf ), casabiome % fracnpptoP ( nv , wood ), & casabiome % fracnpptoP ( nv , froot ), casabiome % rmplant ( nv , leaf ), & casabiome % rmplant ( nv , wood ), casabiome % rmplant ( nv , froot ) ENDDO READ ( 101 , * ) READ ( 101 , * ) DO nv = 1 , mvtype READ ( 101 , * ) nv2 , ratioCNplant ( nv , leaf ), ratioCNplant ( nv , wood ), & ratioCNplant ( nv , froot ), & casabiome % ftransNPtoL ( nv , leaf ), casabiome % ftransNPtoL ( nv , wood ), & casabiome % ftransNPtoL ( nv , froot ), & casabiome % fracligninplant ( nv , leaf ), & casabiome % fracligninplant ( nv , wood ), & casabiome % fracligninplant ( nv , froot ), & ratioCNsoil ( nv , mic ), ratioCNsoil ( nv , slow ), ratioCNsoil ( nv , pass ), & ratioCNsoilmin ( nv , mic ), ratioCNsoilmin ( nv , slow ), ratioCNsoilmin ( nv , pass ), & ratioCNsoilmax ( nv , mic ), ratioCNsoilmax ( nv , slow ), ratioCNsoilmax ( nv , pass ), & ! xfherbivore(nv),casabiome%ratiofrootleaf(nv),                  & casabiome % glaimax ( nv ), casabiome % glaimin ( nv ) ENDDO READ ( 101 , * ) READ ( 101 , * ) DO nv = 1 , mvtype READ ( 101 , * ) nv3 , cleaf ( nv ), cwood ( nv ), cfroot ( nv ), cmet ( nv ), & cstr ( nv ), ccwd ( nv ), cmic ( nv ), cslow ( nv ), cpass ( nv ) ENDDO READ ( 101 , * ) READ ( 101 , * ) DO nv = 1 , mvtype READ ( 101 , * ) nv4 , & phen % TKshed ( nv ), xxkleafcoldmax ( nv ), casabiome % xkleafcoldexp ( nv ), & xxkleafdrymax ( nv ), casabiome % xkleafdryexp ( nv ) ENDDO !  READ(101,*) !  READ(101,*) !  DO nv=1,mvtype !    READ(101,*) nv5, & !         xxkleafcoldmax(nv),casabiome%xkleafcoldexp(nv),   & !         xxkleafdrymax(nv),casabiome%xkleafdryexp(nv) !  ENDDO READ ( 101 , * ) READ ( 101 , * ) DO nv = 1 , mvtype READ ( 101 , * ) nv6 , & casabiome % ratioNCplantmin ( nv , leaf ), casabiome % ratioNCplantmax ( nv , leaf ), & casabiome % ratioNCplantmin ( nv , wood ), casabiome % ratioNCplantmax ( nv , wood ), & casabiome % ratioNCplantmin ( nv , froot ), casabiome % ratioNCplantmax ( nv , froot ), & xfNminloss ( nv ), xfNminleach ( nv ), xnfixrate ( nv ) ENDDO READ ( 101 , * ) READ ( 101 , * ) DO nv = 1 , mvtype READ ( 101 , * ) nv7 , nleaf ( nv ), nwood ( nv ), nfroot ( nv ), & nmet ( nv ), nstr ( nv ), ncwd ( nv ), & nmic ( nv ), nslow ( nv ), npass ( nv ), xnsoilmin ( nv ) ENDDO READ ( 101 , * ) READ ( 101 , * ) DO nv = 1 , mvtype READ ( 101 , * ) nv8 , xratioNPleafmin , xratioNPleafmax , & xratioNPwoodmin , xratioNPwoodmax , & xratioNPfrootmin , xratioNPfrootmax , & casabiome % ftransPPtoL ( nv , leaf ), casabiome % ftransPPtoL ( nv , wood ), & casabiome % ftransPPtoL ( nv , froot ) casabiome % ratioPcplantmin ( nv , leaf ) = 1.0 / ( xratioNPleafmax * ratioCNplant ( nv , leaf )) casabiome % ratioPcplantmax ( nv , leaf ) = 1.0 / ( xratioNPleafmin * ratioCNplant ( nv , leaf )) casabiome % ratioPcplantmin ( nv , wood ) = 1.0 / ( xratioNPwoodmax * ratioCNplant ( nv , wood )) casabiome % ratioPcplantmax ( nv , wood ) = 1.0 / ( xratioNPwoodmin * ratioCNplant ( nv , wood )) casabiome % ratioPcplantmin ( nv , froot ) = 1.0 / ( xratioNPfrootmax * ratioCNplant ( nv , froot )) casabiome % ratioPcplantmax ( nv , froot ) = 1.0 / ( xratioNPfrootmin * ratioCNplant ( nv , froot )) casabiome % ratioNPplantmin ( nv , leaf ) = xratioNPleafmin casabiome % ratioNPplantmax ( nv , leaf ) = xratioNPleafmax casabiome % ratioNPplantmin ( nv , wood ) = xratioNPwoodmin casabiome % ratioNPplantmax ( nv , wood ) = xratioNPwoodmax casabiome % ratioNPplantmin ( nv , froot ) = xratioNPfrootmin casabiome % ratioNPplantmax ( nv , froot ) = xratioNPfrootmax ENDDO READ ( 101 , * ) READ ( 101 , * ) DO iso = 1 , mso READ ( 101 , * ) nv9 , xkmlabp ( iso ), xpsorbmax ( iso ), xfPleach ( iso ), & ratioNPsoil ( iso , mic ), ratioNPsoil ( iso , slow ), ratioNPsoil ( iso , pass ), & xxkplab ( iso ), xxkpsorb ( iso ), xxkpocc ( iso ) ENDDO READ ( 101 , * ) READ ( 101 , * ) DO nv = 1 , mvtype READ ( 101 , * ) nv10 , & xpleaf ( nv ), xpwood ( nv ), xpfroot ( nv ), xpmet ( nv ), xpstr ( nv ), xpcwd ( nv ), & xpmic ( nv ), xpslow ( nv ), xppass ( nv ), xplab ( nv ), xpsorb ( nv ), xpocc ( nv ) ENDDO READ ( 101 , * ) READ ( 101 , * ) DO nv = 1 , mvtype READ ( 101 , * ) nv11 , & xxnpmax ( nv ), xq10soil ( nv ), xxkoptlitter ( nv ), xxkoptsoil ( nv ), xprodptase ( nv ), & xcostnpup ( nv ), xmaxfinelitter ( nv ), xmaxcwd ( nv ), xnintercept ( nv ), xnslope ( nv ) ENDDO READ ( 101 , * ) READ ( 101 , * ) DO nv = 1 , mvtype READ ( 101 , * ) nv12 , & la_to_sa ( nv ), disturbance_interval ( nv ), vcmax_scalar ( nv ) ENDDO READ ( 101 , * ) READ ( 101 , * ) DO nv = 1 , mvtype READ ( 101 , * ) nv13 , & DAMM_EnzPool ( nv ), DAMM_KMO2 ( nv ), DAMM_KMcp ( nv ), DAMM_Ea ( nv ), DAMM_alpha ( nv ) ENDDO CLOSE ( 101 ) fracroot = 0.0_r_2 depthsoila = 0.0_r_2 depthsoilb = 0.0_r_2 DO ns = 1 , ms depthsoilb ( ns ) = depthsoilb ( ns ) + soil % zse ( ns ) IF ( ns == 1 ) THEN depthsoila ( ns ) = 0.0_r_2 ELSE depthsoila ( ns ) = depthsoilb ( ns - 1 ) ENDIF ENDDO DO nv = 1 , mvtype casabiome % sla ( nv ) = slax ( nv ) casabiome % fraclabile ( nv , leaf ) = deltcasa * 0.6_r_2 !1/day casabiome % fraclabile ( nv , froot ) = deltcasa * 0.4_r_2 !1/day casabiome % fraclabile ( nv , wood ) = deltcasa * 0.0_r_2 casabiome % plantrate ( nv , leaf ) = deltcasa / ( leafage ( nv ) * ( 1.0_r_2 - xfherbivore ( nv ))) casabiome % plantrate ( nv , froot ) = deltcasa / frootage ( nv ) casabiome % plantrate ( nv , wood ) = deltcasa / woodage ( nv ) casabiome % litterrate ( nv , metb ) = deltcasa / metage ( nv ) casabiome % litterrate ( nv , str ) = deltcasa / strage ( nv ) casabiome % litterrate ( nv , cwd ) = deltcasa / cwdage ( nv ) casabiome % soilrate ( nv , mic ) = deltcasa / micage ( nv ) casabiome % soilrate ( nv , slow ) = deltcasa / slowage ( nv ) casabiome % soilrate ( nv , pass ) = deltcasa / passage ( nv ) casabiome % xkleafcoldmax ( nv ) = deltcasa * xxkleafcoldmax ( nv ) casabiome % xkleafdrymax ( nv ) = deltcasa * xxkleafdrymax ( nv ) ! casabiome%kuplabp(nv)         = xkuplabp(nv) casabiome % rmplant ( nv ,:) = casabiome % rmplant ( nv ,:) * deltcasa casabiome % kclabrate ( nv ) = deltcasa / clabileage ( nv ) casabiome % xnpmax ( nv ) = xxnpmax ( nv ) casabiome % q10soil ( nv ) = xq10soil ( nv ) casabiome % xkoptlitter ( nv ) = xxkoptlitter ( nv ) casabiome % xkoptsoil ( nv ) = xxkoptsoil ( nv ) casabiome % prodptase ( nv ) = xprodptase ( nv ) / 36 5.0_r_2 ! convert from yearly to daily casabiome % costnpup ( nv ) = xcostnpup ( nv ) casabiome % maxfinelitter ( nv ) = xmaxfinelitter ( nv ) casabiome % maxcwd ( nv ) = xmaxcwd ( nv ) casabiome % nintercept ( nv ) = xnintercept ( nv ) casabiome % nslope ( nv ) = xnslope ( nv ) casabiome % la_to_sa ( nv ) = la_to_sa ( nv ) casabiome % vcmax_scalar ( nv ) = vcmax_scalar ( nv ) casabiome % disturbance_interval ( nv ) = disturbance_interval ( nv ) casabiome % DAMM_EnzPool ( nv ) = DAMM_EnzPool ( nv ) casabiome % DAMM_KMO2 ( nv ) = DAMM_KMO2 ( nv ) casabiome % DAMM_KMcp ( nv ) = DAMM_KMcp ( nv ) casabiome % DAMM_Ea ( nv ) = DAMM_Ea ( nv ) casabiome % DAMM_alpha ( nv ) = DAMM_alpha ( nv ) ENDDO DO ns = 1 , mso casabiome % xkplab ( ns ) = xxkplab ( ns ) casabiome % xkpsorb ( ns ) = xxkpsorb ( ns ) casabiome % xkpocc ( ns ) = xxkpocc ( ns ) ENDDO DO npt = 1 , mp iv1 = veg % iveg ( npt ) iso = casamet % isorder ( npt ) ! The following to be commented out when coupled to CABLE !    veg%froot(npt,:) = fracroot(iv1,:) casamet % iveg2 ( npt ) = casabiome % ivt2 ( iv1 ) casamet % lnonwood ( npt ) = 1 casapool % cplant ( npt , wood ) = 0.0_r_2 casapool % clitter ( npt , cwd ) = 0.0_r_2 casapool % nplant ( npt , wood ) = 0.0_r_2 casapool % nlitter ( npt , cwd ) = 0.0_r_2 casapool % pplant ( npt , wood ) = 0.0_r_2 casapool % plitter ( npt , cwd ) = 0.0_r_2 IF ( casamet % iveg2 ( npt ) == forest . or . casamet % iveg2 ( npt ) == shrub ) THEN casamet % lnonwood ( npt ) = 0 casapool % cplant ( npt , wood ) = Cwood ( iv1 ) casapool % clitter ( npt , cwd ) = ccwd ( iv1 ) casapool % nplant ( npt , wood ) = nwood ( iv1 ) casapool % nlitter ( npt , cwd ) = ncwd ( iv1 ) casapool % pplant ( npt , wood ) = xpwood ( iv1 ) casapool % plitter ( npt , cwd ) = xpcwd ( iv1 ) !! vh_js !! IF ( cable_user % CALL_POP ) THEN ! initialise very small wood pool, so POP can start from zero. casapool % cplant ( npt , wood ) = 0.01_r_2 casapool % nplant ( npt , wood ) = casabiome % ratioNCplantmin ( iv1 , wood ) * casapool % cplant ( npt , wood ) casapool % pplant ( npt , wood ) = casabiome % ratioPCplantmin ( iv1 , wood ) * casapool % cplant ( npt , wood ) ENDIF !! vh_js ENDIF casapool % cplant ( npt , leaf ) = cleaf ( iv1 ) casapool % cplant ( npt , froot ) = cfroot ( iv1 ) casapool % clabile ( npt ) = 0.0_r_2 casapool % clitter ( npt , metb ) = cmet ( iv1 ) casapool % clitter ( npt , str ) = cstr ( iv1 ) casapool % csoil ( npt , mic ) = cmic ( iv1 ) casapool % csoil ( npt , slow ) = cslow ( iv1 ) casapool % csoil ( npt , pass ) = cpass ( iv1 ) IF ( icycle == 1 ) THEN casapool % ratioNCplant ( npt ,:) = 1.0_r_2 / ratioCNplant ( iv1 ,:) ENDIF ! initializing glai in case not reading pool file (eg. during spin) casamet % glai ( npt ) = MAX ( casabiome % glaimin ( iv1 ), & casabiome % sla ( iv1 ) * casapool % cplant ( npt , leaf )) casaflux % fNminloss ( npt ) = xfNminloss ( iv1 ) ! comment out by ypw 12/07/2009 casaflux % fNminleach ( npt ) = 1 0.0_r_2 * xfNminleach ( iv1 ) * deltcasa ! casaflux%fNminleach(npt)  = xfNminleach(iv1) casapool % nplant ( npt , leaf ) = nleaf ( iv1 ) casapool % nplant ( npt , froot ) = nfroot ( iv1 ) casapool % nlitter ( npt , metb ) = nmet ( iv1 ) ! casapool%nlitter(npt,str) = nstr(iv1) casapool % nlitter ( npt , str ) = cstr ( iv1 ) * ratioNCstrfix casapool % nsoil ( npt , mic ) = nmic ( iv1 ) casapool % nsoil ( npt , slow ) = nslow ( iv1 ) casapool % nsoil ( npt , pass ) = npass ( iv1 ) casapool % nsoilmin ( npt ) = xnsoilmin ( iv1 ) casapool % pplant ( npt , leaf ) = xpleaf ( iv1 ) casapool % pplant ( npt , froot ) = xpfroot ( iv1 ) casapool % plitter ( npt , metb ) = xpmet ( iv1 ) ! casapool%plitter(npt,str) = xpstr(iv1) casapool % plitter ( npt , str ) = casapool % nlitter ( npt , str ) / ratioNPstrfix casapool % psoil ( npt , mic ) = xpmic ( iv1 ) casapool % psoil ( npt , slow ) = xpslow ( iv1 ) casapool % psoil ( npt , pass ) = xppass ( iv1 ) casapool % psoillab ( npt ) = xplab ( iv1 ) casapool % psoilsorb ( npt ) = xpsorb ( iv1 ) casapool % psoilocc ( npt ) = xpocc ( iv1 ) casapool % Psoillab ( npt ) = 0.0_r_2 casaflux % kmlabp ( npt ) = xkmlabp ( iso ) casaflux % psorbmax ( npt ) = xpsorbmax ( iso ) casaflux % fpleach ( npt ) = xfPleach ( iso ) / ( 36 5.0_r_2 ) ! convert from 1/year to 1/day ! we used the spatially explicit estimate N fixation by Wang and Houlton (GRL) ! casaflux%Nminfix(npt)     = xnfixrate(iv1)/365.0_r_2 casapool % ratioNCplant ( npt ,:) = 1.0_r_2 / ratioCNplant ( iv1 ,:) casapool % ratioNPplant ( npt ,:) = casabiome % ratioNPplantmin ( iv1 ,:) casapool % ratioNClitter ( npt ,:) = casapool % nlitter ( npt ,:) / ( casapool % clitter ( npt ,:) + 1.0e-10_r_2 ) casapool % ratioNPlitter ( npt ,:) = casapool % nlitter ( npt ,:) / ( casapool % plitter ( npt ,:) + 1.0e-10_r_2 ) casapool % ratioNCsoil ( npt ,:) = 1.0_r_2 / ratioCNsoil ( iv1 ,:) casapool % ratioNPsoil ( npt ,:) = ratioNPsoil ( iso ,:) casapool % ratioNCsoilmin ( npt ,:) = 1.0_r_2 / ratioCNsoilmax ( iv1 ,:) casapool % ratioNCsoilmax ( npt ,:) = 1.0_r_2 / ratioCNsoilmin ( iv1 ,:) casapool % ratioNCsoilnew ( npt ,:) = casapool % ratioNCsoilmax ( npt ,:) ENDDO if ( icycle < 2 ) then casapool % Nplant (:,:) = casapool % Cplant (:,:) * casapool % ratioNCplant (:,:) casapool % Nsoil (:,:) = casapool % ratioNCsoil (:,:) * casapool % Csoil (:,:) endif if ( icycle < 3 ) then casapool % Psoil (:,:) = casapool % Nsoil (:,:) / casapool % ratioNPsoil (:,:) casapool % Psoilsorb (:) = casaflux % psorbmax (:) * casapool % psoillab (:) & / ( casaflux % kmlabp (:) + casapool % psoillab (:)) endif END SUBROUTINE casa_readbiome SUBROUTINE casa_readphen ( veg , casamet , phen ) !SUBROUTINE casa_readphen(mvt,veg,casamet,phen) ! read in the tabulated modis-derived leaf phenology data ! for latitude bands of 79.75 to -55.25 USE cable_def_types_mod USE casadimension USE casaparm USE casavariable USE phenvariable IMPLICIT NONE !  INTEGER,              INTENT(IN)    :: mvt TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg ! vegetation parameters TYPE ( casa_met ), INTENT ( IN ) :: casamet TYPE ( phen_variable ), INTENT ( INOUT ) :: phen ! local variables INTEGER , PARAMETER :: npheno = 8 ! was 10(IGBP). changed by Q.Zhang @01/12/2011 INTEGER :: np , nx , ilat INTEGER , DIMENSION ( 271 , mvtype ) :: greenup , fall , phendoy1 INTEGER , DIMENSION ( npheno ) :: greenupx , fallx , xphendoy1 INTEGER , DIMENSION ( npheno ) :: ivtx REAL ( r_2 ), DIMENSION ( 271 ) :: xlat ! initilize for evergreen PFTs greenup (:,:) = - 50 fall (:,:) = 367 phendoy1 (:,:) = 2 OPEN ( 101 , file = casafile % phen ) READ ( 101 , * ) READ ( 101 , * ) ( ivtx ( nx ), nx = 1 , npheno ) ! fixed at 10, as only 10 of 17 IGBP PFT ! have seasonal leaf phenology DO ilat = 271 , 1 , - 1 READ ( 101 , * ) xlat ( ilat ), ( greenupx ( nx ), nx = 1 , npheno ), & ( fallx ( nx ), nx = 1 , npheno ), ( xphendoy1 ( nx ), nx = 1 , npheno ) DO nx = 1 , npheno greenup ( ilat , ivtx ( nx )) = greenupx ( nx ) fall ( ilat , ivtx ( nx )) = fallx ( nx ) phendoy1 ( ilat , ivtx ( nx )) = xphendoy1 ( nx ) ENDDO ENDDO CLOSE ( 101 ) DO np = 1 , mp ilat = nint (( casamet % lat ( np ) + 5 5.25 ) / 0.5 ) + 1 ilat = MIN ( 271 , MAX ( 1 , ilat )) phen % phase ( np ) = phendoy1 ( ilat , veg % iveg ( np )) phen % doyphase ( np , 1 ) = greenup ( ilat , veg % iveg ( np )) ! DOY for greenup phen % doyphase ( np , 2 ) = phen % doyphase ( np , 1 ) + 14 ! DOY for steady LAI phen % doyphase ( np , 3 ) = fall ( ilat , veg % iveg ( np )) ! DOY for leaf senescence phen % doyphase ( np , 4 ) = phen % doyphase ( np , 3 ) + 14 ! DOY for minimal LAI season IF ( phen % doyphase ( np , 2 ) > 365 ) phen % doyphase ( np , 2 ) = phen % doyphase ( np , 2 ) - 365 IF ( phen % doyphase ( np , 4 ) > 365 ) phen % doyphase ( np , 4 ) = phen % doyphase ( np , 4 ) - 365 ENDDO END SUBROUTINE casa_readphen SUBROUTINE casa_init ( casabiome , casamet , casaflux , casapool , casabal , phen ) ! mst not used (BP sep2010) !! for first time reading file *_1220.csv  (BP may2010) !SUBROUTINE casa_init(mst,casapool,casabal,veg) !!SUBROUTINE casa_init(mst,casapool,casabal) !! end addition (BP may2010) !  initialize some values in phenology parameters and leaf growth phase USE casadimension USE casaparm USE casavariable USE phenvariable ! for first time reading file *_1220.csv  (BP may2010) USE cable_def_types_mod USE cable_io_vars_module , ONLY : patch USE cable_common_module , only : cable_user ! end addition (BP may2010) IMPLICIT NONE TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal ! for first time reading file *_1220.csv  (BP may2010) TYPE ( phen_variable ), INTENT ( INOUT ) :: phen ! end addition (BP may2010) ! local variables INTEGER :: npt if (. not . cable_user % casa_fromzero ) then write ( * , * ) 'initial pool from restart file' endif write ( * , * ) 'icycle, initcasa, mp ' , icycle , initcasa , mp !phen%phase = 2 !MC - remove zeroing because done in load_parameters before ! !CLN initialise all !!!!! THIS NEEDS FIXING because of e.g. ICE-WATER ! casaflux%Cgpp         = 0.0_r_2 ! casaflux%Cnpp         = 0.0_r_2 ! casaflux%Crp          = 0.0_r_2 ! casaflux%Crgplant     = 0.0_r_2 ! ! casaflux%Nminfix      = 0.0_r_2 ! casaflux%Nminuptake   = 0.0_r_2 ! casaflux%Plabuptake   = 0.0_r_2 ! casaflux%Clabloss     = 0.0_r_2 ! casaflux%fracClabile  = 0.0_r_2 ! casaflux%stemnpp      = 0.0_r_2 ! casaflux%frac_sapwood = 0.0_r_2 ! casaflux%sapwood_area = 0.0_r_2 ! casaflux%FluxCtohwp   = 0.0_r_2 ! casaflux%FluxCtoClear = 0.0_r_2 ! casaflux%fracCalloc   = 0.0_r_2 ! casaflux%fracNalloc   = 0.0_r_2 ! casaflux%fracPalloc   = 0.0_r_2 ! casaflux%Crmplant     = 0.0_r_2 ! casaflux%kplant       = 0.0_r_2 ! casaflux%kplant_fire  = 0.0_r_2 ! casaflux%kplant_tot   = 0.0_r_2 ! casaflux%fromPtoL      = 0.0_r_2 ! casaflux%fromPtoL_fire = 0.0_r_2 ! casaflux%Cnep         = 0.0_r_2 ! casaflux%Crsoil       = 0.0_r_2 ! casapool%dClabiledt   = 0.0_r_2 ! ! casaflux%Nmindep      =  casaflux%Nmindep /2.0_r_2 ! ! casaflux%Nmindep      = 0.0_r_2 ! casaflux%Nminloss     = 0.0_r_2 ! casaflux%Nminleach    = 0.0_r_2 ! casaflux%Nupland      = 0.0_r_2 ! casaflux%Nlittermin   = 0.0_r_2 ! casaflux%Nsmin        = 0.0_r_2 ! casaflux%Nsimm        = 0.0_r_2 ! casaflux%Nsnet        = 0.0_r_2 ! ! casaflux%fNminloss    = 0.0_r_2 ! ! casaflux%fNminleach   = 0.0_r_2 ! ! casaflux%Pdep         = 0.0_r_2 ! ! casaflux%Pwea         = 0.0_r_2 ! casaflux%Pleach       = 0.0_r_2 ! casaflux%Ploss        = 0.0_r_2 ! casaflux%Pupland      = 0.0_r_2 ! casaflux%Plittermin   = 0.0_r_2 ! casaflux%Psmin        = 0.0_r_2 ! casaflux%Psimm        = 0.0_r_2 ! casaflux%Psnet        = 0.0_r_2 ! ! casaflux%fPleach      = 0.0_r_2 !vh ! this should be a parameter, not a flux variable ! casaflux%kplab        = 0.0_r_2 ! casaflux%kpsorb       = 0.0_r_2 ! casaflux%kpocc        = 0.0_r_2 ! ! casaflux%kmlabp       = 0.0_r_2  !vh ! this should be a paramter, not a flux variable ! ! casaflux%Psorbmax     = 0.0_r_2 !vh ! this should be a paramter, not a flux variable ! casaflux%klitter       = 0.0_r_2 ! casaflux%klitter_fire  = 0.0_r_2 ! casaflux%ksoil         = 0.0_r_2 ! casaflux%fromLtoS      = 0.0_r_2 ! casaflux%fromStoS      = 0.0_r_2 ! casaflux%fromLtoCO2    = 0.0_r_2 ! casaflux%fromStoCO2    = 0.0_r_2 ! casaflux%FluxCtolitter = 0.0_r_2 ! casaflux%FluxNtolitter = 0.0_r_2 ! casaflux%FluxPtolitter = 0.0_r_2 ! casaflux%FluxCtosoil   = 0.0_r_2 ! casaflux%FluxNtosoil   = 0.0_r_2 ! casaflux%FluxPtosoil   = 0.0_r_2 ! casaflux%FluxCtoCO2    = 0.0_r_2 ! casaflux%FluxCtoCO2_plant_fire  = 0.0_r_2 ! casaflux%FluxCtoCO2_litter_fire = 0.0_r_2 ! casaflux%FluxFromPtoL       = 0.0_r_2 ! casaflux%FluxFromLtoS       = 0.0_r_2 ! casaflux%FluxFromStoS       = 0.0_r_2 ! casaflux%FluxFromPtoCO2     = 0.0_r_2 ! casaflux%FluxFromLtoCO2     = 0.0_r_2 ! casaflux%FluxFromStoCO2     = 0.0_r_2 ! casaflux%FluxFromPtoHarvest = 0.0_r_2 ! casaflux%Cplant_turnover                     = 0.0_r_2 ! casaflux%Cplant_turnover_disturbance         = 0.0_r_2 ! casaflux%Cplant_turnover_crowding            = 0.0_r_2 ! casaflux%Cplant_turnover_resource_limitation = 0.0_r_2 ! casaflux%fHarvest = 0.0_r_2 ! casaflux%Charvest = 0.0_r_2 ! casaflux%Nharvest = 0.0_r_2 ! casaflux%fcrop    = 0.0_r_2 phen % doyphase (:, 1 ) = - 50 phen % doyphase (:, 2 ) = phen % doyphase (:, 1 ) + 14 phen % doyphase (:, 3 ) = 367 phen % doyphase (:, 4 ) = phen % doyphase (:, 3 ) + 14 phen % phase (:) = 2 phen % phen (:) = 1 phen % aphen (:) = 0 ! casapool%dCplantdt     = 0.0_r_2 ! casapool%dNplantdt     = 0.0_r_2 ! casapool%dPplantdt     = 0.0_r_2 ! casapool%dNsoilmindt   = 0.0_r_2 ! casapool%dPsoillabdt   = 0.0_r_2 ! casapool%dPsoilsorbdt  = 0.0_r_2 ! casapool%dPsoiloccdt   = 0.0_r_2 ! casapool%dClitterdt    = 0.0_r_2 ! casapool%dNlitterdt    = 0.0_r_2 ! casapool%dPlitterdt    = 0.0_r_2 ! casapool%dCsoildt      = 0.0_r_2 ! casapool%dNsoildt      = 0.0_r_2 ! casapool%dPsoildt      = 0.0_r_2 ! casapool%ratioNClitter = 0.0_r_2 ! casapool%ratioNCsoil   = 0.0_r_2 ! casapool%ratioPClitter = 0.0_r_2 ! casapool%ratioPCsoil   = 0.0_r_2 ! !CLN add more if necessary casapool % Nsoilmin (:) = 2.5_r_2 !MC - Check if next commented 2 if-blocks are necessary ! if (icycle > 1) then !    casapool%nplant     = MAX(1.e-6_r_2, casapool%nplant) !    casapool%nlitter    = MAX(1.e-6_r_2, casapool%nlitter) !    casapool%nsoil      = MAX(1.e-6_r_2, casapool%nsoil) !    casapool%nsoilmin   = MAX(1.e-6_r_2, casapool%nsoilmin) !    casabal%cplantlast  = casapool%cplant !    casabal%clitterlast = casapool%clitter !    casabal%csoillast   = casapool%csoil !    casabal%clabilelast = casapool%clabile ! endif ! if (icycle > 2) then !    casapool%pplant       = MAX(1.e-7_r_2, casapool%pplant) !    casapool%plitter      = MAX(1.e-7_r_2, casapool%plitter) !    casapool%psoil        = MAX(1.e-7_r_2, casapool%psoil) !    casapool%Psoillab     = MAX(1.e-7_r_2, casapool%psoillab) !    casapool%psoilsorb    = MAX(1.e-7_r_2, casapool%psoilsorb) !    casapool%psoilocc     = MAX(1.e-7_r_2, casapool%psoilocc) !    casabal%pplantlast    = casapool%pplant !    casabal%plitterlast   = casapool%plitter !    casabal%psoillast     = casapool%psoil !    casabal%psoillablast  = casapool%psoillab !    casabal%psoilsorblast = casapool%psoilsorb !    casabal%psoilocclast  = casapool%psoilocc ! endif if (( initcasa == 1 ) . and . cable_user % casa_fromzero ) then write ( * , * ) 'casa_init: not using restart file!' write ( * , * ) 'Using input from readbiome.!!!' write ( * , * ) 'initialising frac_sapwood=1 and sapwood_area = 0)' casaflux % frac_sapwood (:) = 1.0_r_2 casaflux % sapwood_area (:) = 0.0_r_2 #ifndef UM_BUILD else if (( initcasa == 1 ) . and . (. not . cable_user % casa_fromzero )) then call read_casa_restart_nc ( casabiome , casamet , casapool , casaflux , & casabal , phen ) call zero_casa_dump ( casamet , phen ) #endif else do npt = 1 , mp casamet % lon ( npt ) = real ( patch ( npt )% longitude , r_2 ) casamet % lat ( npt ) = real ( patch ( npt )% latitude , r_2 ) enddo endif !MC - remove zeroing because done in load_parameters before ! where(casamet%lnonwood==1) casapool%cplant(:,WOOD) = 0.0_r_2 ! where(casamet%lnonwood==1) casapool%nplant(:,WOOD) = 0.0_r_2 ! where(casamet%lnonwood==1) casapool%pplant(:,WOOD) = 0.0_r_2 ! ! reset labile C pool, comment out by Q.Zhang 10/09/2011: casapool%clabile = 0.0 ! ! check pool sizes ! casapool%Ctot_0     = 0.0_r_2 ! casapool%Ctot       = 0.0_r_2 ! casapool%cplant     = MAX(0.0_r_2, casapool%cplant) ! casapool%clitter    = MAX(0.0_r_2, casapool%clitter) ! casapool%csoil      = MAX(0.0_r_2, casapool%csoil) ! casabal%cplantlast  = casapool%cplant ! casabal%clitterlast = casapool%clitter ! casabal%csoillast   = casapool%csoil ! casabal%clabilelast = casapool%clabile ! casabal%sumcbal     = 0.0_r_2 ! casabal%FCgppyear   = 0.0_r_2 ! casabal%FCrpyear    = 0.0_r_2 ! casabal%FCnppyear   = 0.0_r_2 ! casabal%FCrsyear    = 0.0_r_2 ! casabal%FCneeyear   = 0.0_r_2 ! ! vh ! ! WHERE (casamet%lnonwood==1) casapool%cplant(:,WOOD) = 0.0_r_2 ! IF (icycle == 1) THEN !    casapool%Nplant(:,:) = casapool%cplant(:,:) * casapool%ratioNCplant(:,:) !    casapool%Nsoil(:,:)  = casapool%ratioNCsoil(:,:) * casapool%Csoil(:,:) !    casapool%Psoil(:,:)  = casapool%Nsoil(:,:) / casapool%ratioNPsoil(:,:) !    casapool%Nsoilmin(:) = 2.5_r_2 ! ENDIF ! IF (icycle >= 1) THEN !    casapool%nplant     = MAX(1.0e-6_r_2, casapool%nplant) !    casapool%nlitter    = MAX(1.0e-6_r_2, casapool%nlitter) !    casapool%nsoil      = MAX(1.0e-6_r_2, casapool%nsoil) !    casapool%nsoilmin   = MAX(1.0e-6_r_2, casapool%nsoilmin) !    casabal%nplantlast  = casapool%nplant !    casabal%nlitterlast = casapool%nlitter !    casabal%nsoillast   = casapool%nsoil !    casabal%nsoilminlast= casapool%nsoilmin !    casabal%sumnbal     = 0.0_r_2 !    casabal%FNdepyear   = 0.0_r_2 !    casabal%FNfixyear   = 0.0_r_2 !    casabal%FNsnetyear  = 0.0_r_2 !    casabal%FNupyear    = 0.0_r_2 !    casabal%FNleachyear = 0.0_r_2 !    casabal%FNlossyear  = 0.0_r_2 !    ! vh ! !    WHERE(casamet%lnonwood==1) casapool%nplant(:,WOOD) = 0.0_r_2 ! ENDIF ! IF (icycle >=1 ) THEN !    casapool%pplant       = MAX(1.0e-7_r_2, casapool%pplant) !    casapool%plitter      = MAX(1.0e-7_r_2, casapool%plitter) !    casapool%psoil        = MAX(1.0e-7_r_2, casapool%psoil) !    casapool%Psoillab     = MAX(1.0e-7_r_2, casapool%psoillab)  ! was 2.0, changed according to  YP !    casapool%psoilsorb    = MAX(1.0e-7_r_2, casapool%psoilsorb) ! was 10.0, - !    casapool%psoilocc     = MAX(1.0e-7_r_2, casapool%psoilocc)  ! was 50.0, - !    casabal%pplantlast    = casapool%pplant !    casabal%plitterlast   = casapool%plitter !    casabal%psoillast     = casapool%psoil !    casabal%psoillablast  = casapool%psoillab !    casabal%psoilsorblast = casapool%psoilsorb !    casabal%psoilocclast  = casapool%psoilocc !    casabal%sumpbal       = 0.0_r_2 !    casabal%FPweayear     = 0.0_r_2 !    casabal%FPdustyear    = 0.0_r_2 !    casabal%FPsnetyear    = 0.0_r_2 !    casabal%FPupyear      = 0.0_r_2 !    casabal%FPleachyear   = 0.0_r_2 !    casabal%FPlossyear    = 0.0_r_2 !    ! vh ! !    WHERE(casamet%lnonwood==1) casapool%pplant(:,WOOD) = 0.0_r_2 ! ENDIF END SUBROUTINE casa_init SUBROUTINE casa_poolout ( ktau , veg , soil , casabiome , casapool , casaflux , casamet , & casabal , phen ) USE cable_def_types_mod USE casadimension USE casaparm USE casavariable USE phenvariable USE cable_common_module , only : cable_user IMPLICIT NONE INTEGER , INTENT ( IN ) :: ktau TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil ! soil parameters TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal TYPE ( phen_variable ), INTENT ( INOUT ) :: phen ! local variables REAL ( r_2 ), DIMENSION ( mso ) :: Psorder , xPsoil50 ! , Pweasoil REAL ( r_2 ), DIMENSION ( mso ) :: fracPlab , fracPocc ! , fracPsorb, fracPorg REAL ( r_2 ), DIMENSION ( mp ) :: totPsoil INTEGER :: npt , nout , nso ! Soiltype     soilnumber soil P(g P/m2) ! Alfisol     1       61.3 ! Andisol     2       103.9 ! Aridisol    3       92.8 ! Entisol     4       136.9 ! Gellisol    5       98.2 ! Histosol    6       107.6 ! Inceptisol  7       84.1 ! Mollisol    8       110.1 ! Oxisol      9       35.4 ! Spodosol    10      41.0 ! Ultisol     11      51.5 ! Vertisol    12      190.6 DATA Psorder / 6 1.3_r_2 , 10 3.9_r_2 , 9 2.8_r_2 , 13 6.9_r_2 , 9 8.2_r_2 , 10 7.6_r_2 , 8 4.1_r_2 , & 11 0.1_r_2 , 3 5.4_r_2 , 4 1.0_r_2 , 5 1.5_r_2 , 19 0.6_r_2 / ! DATA Pweasoil/0.05_r_2, 0.04_r_2, 0.03_r_2, 0.02_r_2, 0.01_r_2, 0.009_r_2, 0.008_r_2, & !      0.007_r_2, 0.006_r_2, 0.005_r_2, 0.004_r_2, 0.003_r_2/ DATA fracPlab / 0.08_r_2 , 0.08_r_2 , 0.10_r_2 , 0.02_r_2 , 0.08_r_2 , 0.08_r_2 , 0.08_r_2 , & 0.06_r_2 , 0.02_r_2 , 0.05_r_2 , 0.09_r_2 , 0.05_r_2 / ! DATA fracPsorb/0.32_r_2, 0.37_r_2, 0.57_r_2, 0.67_r_2, 0.37_r_2, 0.37_r_2, 0.37_r_2, & !      0.32_r_2, 0.24_r_2, 0.22_r_2, 0.21_r_2, 0.38_r_2/ DATA fracPocc / 0.36_r_2 , 0.38_r_2 , 0.25_r_2 , 0.26_r_2 , 0.38_r_2 , 0.38_r_2 , 0.38_r_2 , & 0.44_r_2 , 0.38_r_2 , 0.38_r_2 , 0.37_r_2 , 0.45_r_2 / ! DATA fracPorg/0.25_r_2, 0.17_r_2, 0.08_r_2, 0.05_r_2, 0.17_r_2, 0.17_r_2, 0.17_r_2, & !      0.18_r_2, 0.36_r_2, 0.35_r_2, 0.34_r_2, 0.12_r_2/ DATA xPsoil50 / 7.6_r_2 , 4.1_r_2 , 4.2_r_2 , 3.4_r_2 , 4.1_r_2 , 4.1_r_2 , 4.8_r_2 , 4.1_r_2 , & 6.9_r_2 , 6.9_r_2 , 6.9_r_2 , 1.7_r_2 / ! ! estimated based on Yang, Post and Jain (2013) !   Soiltype     soilnumber soil P(g P/m2  top 50 cm) !   Alfisol     1       400 !   Andisol     2       426 !   Aridisol    3       352 !   Entisol     4       490 !   Gellisol    5       403 !   Histosol    6       441 !   Inceptisol  7       501 !   Mollisol    8       358 !   Oxisol      9       96 !   Spodosol    10      364 !   Ultisol     11      272 !   Vertisol    12      430 !  DATA psorder/400.0,426.0,352.0,490.0,403.0,441.0,501.0,358.0,96.0,364.0,272.0,430.0/ !  DATA pweasoil/0.05,0.04,0.03,0.02,0.01,0.009,0.008,0.007,0.006,0.005,0.004,0.003/ !  DATA fracpLab/0.07,0.04,0.08,0.10,0.08,0.10,0.12,0.05,0.05,0.06,0.06,0.05/ !  DATA fracPsorb/0.30,0.44,0.69,0.53,0.37,0.14,0.24,0.32,0.15,0.21,0.17,0.35/ !  DATA fracPocc/0.38,0.22,0.18,0.22,0.38,0.42,0.23,0.44,0.60,0.30,0.51,0.48/ !  DATA fracPorg/0.25,0.30,0.05,0.15,0.17,0.34,0.41,0.19,0.20,0.43,0.26,0.12/ !  DATA xpsoil50/1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0/ write ( * , * ) 'Within casa_poolout, mp = ' , mp nout = 103 OPEN ( nout , file = casafile % cnpepool ) write ( * , * ) 'Opened file ' , casafile % cnpepool casabal % sumcbal = MIN ( 999 9.0_r_2 , MAX ( - 999 9.0_r_2 , casabal % sumcbal )) casabal % sumnbal = MIN ( 999 9.0_r_2 , MAX ( - 999 9.0_r_2 , casabal % sumnbal )) casabal % sumpbal = MIN ( 999 9.0_r_2 , MAX ( - 999 9.0_r_2 , casabal % sumpbal )) DO npt = 1 , mp nso = casamet % isorder ( npt ) totpsoil ( npt ) = psorder ( nso ) * xpsoil50 ( nso ) if ( casamet % iveg2 ( npt ) > 0 ) then IF ( icycle < 2 ) THEN casapool % Nplant ( npt ,:) = casapool % ratioNCplant ( npt ,:) & * casapool % cplant ( npt ,:) casapool % Nlitter ( npt ,:) = casapool % ratioNClitter ( npt ,:) & * casapool % clitter ( npt ,:) casapool % Nsoil ( npt ,:) = casapool % ratioNCsoil ( npt ,:) & * casapool % Csoil ( npt ,:) casapool % nsoilmin ( npt ) = 2.0_r_2 casabal % sumnbal ( npt ) = 0.0_r_2 if ( casamet % iveg2 ( npt ) == grass ) then casapool % nplant ( npt , wood ) = 0.0_r_2 casapool % nlitter ( npt , cwd ) = 0.0_r_2 endif ENDIF IF ( icycle < 3 ) THEN casabal % sumpbal ( npt ) = 0.0_r_2 casapool % pplant ( npt ,:) = casapool % Nplant ( npt ,:) / casapool % ratioNPplant ( npt ,:) casapool % plitter ( npt ,:) = casapool % Nlitter ( npt ,:) / ( casapool % ratioNPlitter ( npt ,:) + 1.e-10_r_2 ) casapool % psoil ( npt ,:) = casapool % Nsoil ( npt ,:) / casapool % ratioNPsoil ( npt ,:) casapool % psoillab ( npt ) = totpsoil ( npt ) * fracpLab ( nso ) casapool % psoilsorb ( npt ) = casaflux % psorbmax ( npt ) * casapool % psoillab ( npt ) & / ( casaflux % kmlabp ( npt ) + casapool % psoillab ( npt )) casapool % psoilocc ( npt ) = totpsoil ( npt ) * fracPocc ( nso ) if ( casamet % iveg2 ( npt ) == grass ) then casapool % pplant ( npt , wood ) = 0.0_r_2 casapool % plitter ( npt , cwd ) = 0.0_r_2 endif ENDIF else casapool % cplant ( npt ,:) = 0.0_r_2 casapool % clitter ( npt ,:) = 0.0_r_2 casapool % csoil ( npt ,:) = 0.0_r_2 casapool % clabile ( npt ) = 0.0_r_2 casapool % nplant ( npt ,:) = 0.0_r_2 casapool % nlitter ( npt ,:) = 0.0_r_2 casapool % nsoil ( npt ,:) = 0.0_r_2 casapool % nsoilmin ( npt ) = 0.0_r_2 casapool % pplant ( npt ,:) = 0.0_r_2 casapool % plitter ( npt ,:) = 0.0_r_2 casapool % psoil ( npt ,:) = 0.0_r_2 casapool % psoillab ( npt ) = 0.0_r_2 casapool % psoilsorb ( npt ) = 0.0_r_2 casapool % psoilocc ( npt ) = 0.0_r_2 casabal % sumcbal ( npt ) = 0.0_r_2 casabal % sumnbal ( npt ) = 0.0_r_2 casabal % sumpbal ( npt ) = 0.0_r_2 endif !! vh_js  !! IF ( cable_user % CALL_POP ) THEN WRITE ( nout , 92 ) ktau , npt , veg % iveg ( npt ), soil % isoilm ( npt ) , & casamet % isorder ( npt ), casamet % lat ( npt ), casamet % lon ( npt ), & casamet % areacell ( npt ) * ( 1.0e-9_r_2 ), casamet % glai ( npt ), & casabiome % sla ( veg % iveg ( npt )), phen % phase ( npt ), & phen % doyphase ( npt , 3 ), phen % phen ( npt ), phen % aphen ( npt ), & casapool % clabile ( npt ), & casapool % cplant ( npt ,:), casapool % clitter ( npt ,:), casapool % csoil ( npt ,:), & casaflux % frac_sapwood ( npt ), casaflux % sapwood_area ( npt ), & casapool % nplant ( npt ,:), casapool % nlitter ( npt ,:), casapool % nsoil ( npt ,:), & casapool % nsoilmin ( npt ), casapool % pplant ( npt ,:), & casapool % plitter ( npt ,:), casapool % psoil ( npt ,:), & casapool % psoillab ( npt ), casapool % psoilsorb ( npt ), casapool % psoilocc ( npt ), & casabal % sumcbal ( npt ), casabal % sumnbal ( npt ), casabal % sumpbal ( npt ) ELSE WRITE ( nout , 92 ) ktau , npt , veg % iveg ( npt ), soil % isoilm ( npt ), & casamet % isorder ( npt ), casamet % lat ( npt ), casamet % lon ( npt ), & casamet % areacell ( npt ) * ( 1.0e-9_r_2 ), casamet % glai ( npt ), & casabiome % sla ( veg % iveg ( npt )), phen % phase ( npt ), & phen % doyphase ( npt , 3 ), phen % phen ( npt ), phen % aphen ( npt ), & casapool % clabile ( npt ), & casapool % cplant ( npt ,:), casapool % clitter ( npt ,:), casapool % csoil ( npt ,:), & casapool % nplant ( npt ,:), casapool % nlitter ( npt ,:), casapool % nsoil ( npt ,:), & casapool % nsoilmin ( npt ), casapool % pplant ( npt ,:), & casapool % plitter ( npt ,:), casapool % psoil ( npt ,:), & casapool % psoillab ( npt ), casapool % psoilsorb ( npt ), casapool % psoilocc ( npt ), & casabal % sumcbal ( npt ), casabal % sumnbal ( npt ), casabal % sumpbal ( npt ) ENDIF ENDDO CLOSE ( nout ) 92 format ( 5 ( i6 , ',' , 2 x ), 5 ( f18 . 6 , ',' , 2 x ), 2 ( i6 , ',' , 2 x ), 100 ( f18 . 6 , ',' , 2 x )) END SUBROUTINE casa_poolout ! casa_fluxout output data for Julie Tang; comment out (BP apr2010) SUBROUTINE casa_fluxout ( myear , veg , soil , casabal , casamet ) !SUBROUTINE casa_fluxout(myear,clitterinput,csoilinput) USE cable_def_types_mod ! USE cableDeclare, ONLY: veg, soil USE casadimension USE casaparm USE casavariable USE phenvariable !  USE casaDeclare IMPLICIT NONE INTEGER , INTENT ( IN ) :: myear TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil ! soil parameters TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal !  REAL(r_2),    INTENT(IN) :: clitterinput(mp,3),csoilinput(mp,3) ! local variables INTEGER :: npt , nout REAL ( r_2 ) :: xyear , totGPP , totNPP totGPP = 0.0_r_2 totNPP = 0.0_r_2 nout = 104 xyear = 1.0_r_2 / real ( myear , r_2 ) casabal % FCgppyear = casabal % FCgppyear * xyear casabal % FCnppyear = casabal % FCnppyear * xyear casabal % FCrmleafyear = casabal % FCrmleafyear * xyear casabal % FCrmwoodyear = casabal % FCrmwoodyear * xyear casabal % FCrmrootyear = casabal % FCrmrootyear * xyear casabal % FCrgrowyear = casabal % FCrgrowyear * xyear casabal % FCrsyear = casabal % FCrsyear * xyear casabal % FCneeyear = casabal % FCneeyear * xyear casabal % FNdepyear = casabal % FNdepyear * xyear casabal % FNfixyear = casabal % FNfixyear * xyear casabal % FNsnetyear = casabal % FNsnetyear * xyear casabal % FNupyear = casabal % FNupyear * xyear casabal % FNleachyear = casabal % FNleachyear * xyear casabal % FNlossyear = casabal % FNlossyear * xyear casabal % FPweayear = casabal % FPweayear * xyear casabal % FPdustyear = casabal % FPdustyear * xyear casabal % FPsnetyear = casabal % FPsnetyear * xyear casabal % FPupyear = casabal % FPupyear * xyear casabal % FPleachyear = casabal % FPleachyear * xyear casabal % FPlossyear = casabal % FPlossyear * xyear !  clitterinput = clitterinput * xyear !  csoilinput   = csoilinput   * xyear write ( * , * ) 'writing CNP fluxes out to file ' , casafile % cnpflux OPEN ( nout , file = casafile % cnpflux ) DO npt = 1 , mp SELECT CASE ( icycle ) CASE ( 1 ) WRITE ( nout , * ) myear , npt , veg % iveg ( npt ), soil % isoilm ( npt ), & casamet % isorder ( npt ), casamet % lat ( npt ), casamet % lon ( npt ), & casamet % areacell ( npt ) * ( 1.0e-9_r_2 ), casabal % Fcgppyear ( npt ), & casabal % Fcnppyear ( npt ), & casabal % Fcrmleafyear ( npt ), casabal % Fcrmwoodyear ( npt ), & casabal % Fcrmrootyear ( npt ), casabal % Fcrgrowyear ( npt ), & casabal % Fcrsyear ( npt ), casabal % Fcneeyear ( npt ) ! , & ! clitterinput(npt,:),csoilinput(npt,:) CASE ( 2 ) WRITE ( nout , * ) myear , npt , veg % iveg ( npt ), soil % isoilm ( npt ), & casamet % isorder ( npt ), casamet % lat ( npt ), casamet % lon ( npt ), & !MC - casamet%areacell is different between MPI and serial casamet % areacell ( npt ) * ( 1.0e-9_r_2 ), casabal % Fcgppyear ( npt ), & casabal % FCnppyear ( npt ), & casabal % Fcrmleafyear ( npt ), casabal % Fcrmwoodyear ( npt ), & casabal % Fcrmrootyear ( npt ), casabal % Fcrgrowyear ( npt ), & casabal % FCrsyear ( npt ), casabal % FCneeyear ( npt ), & ! clitterinput(npt,:),csoilinput(npt,:), & casabal % FNdepyear ( npt ), casabal % FNfixyear ( npt ), casabal % FNsnetyear ( npt ), & casabal % FNupyear ( npt ), casabal % FNleachyear ( npt ), casabal % FNlossyear ( npt ) CASE ( 3 ) WRITE ( nout , * ) myear , npt , veg % iveg ( npt ), soil % isoilm ( npt ), & casamet % isorder ( npt ), casamet % lat ( npt ), casamet % lon ( npt ), & casamet % areacell ( npt ) * ( 1.0e-9_r_2 ), casabal % Fcgppyear ( npt ), & casabal % FCnppyear ( npt ), & casabal % Fcrmleafyear ( npt ), casabal % Fcrmwoodyear ( npt ), & casabal % Fcrmrootyear ( npt ), casabal % Fcrgrowyear ( npt ), & casabal % FCrsyear ( npt ), casabal % FCneeyear ( npt ), & !        clitterinput(npt,:),csoilinput(npt,:), & casabal % FNdepyear ( npt ), casabal % FNfixyear ( npt ), casabal % FNsnetyear ( npt ),& casabal % FNupyear ( npt ), casabal % FNleachyear ( npt ), casabal % FNlossyear ( npt ),& casabal % FPweayear ( npt ), casabal % FPdustyear ( npt ), casabal % FPsnetyear ( npt ),& casabal % FPupyear ( npt ), casabal % FPleachyear ( npt ), casabal % FPlossyear ( npt ) END SELECT totGPP = totGPP + casabal % Fcgppyear ( npt ) * casamet % areacell ( npt ) totNPP = totNPP + casabal % Fcnppyear ( npt ) * casamet % areacell ( npt ) ENDDO write ( * , * ) 'totGPP global = ' , totGPP * ( 1.0e-15_r_2 ) write ( * , * ) 'totNPP global = ' , totNPP * ( 1.0e-15_r_2 ) CLOSE ( nout ) END SUBROUTINE casa_fluxout ! clitterinput and csoilinput are for Julie Tang; comment out (BP apr2010) !SUBROUTINE casa_cnpflux(clitterinput,csoilinput) SUBROUTINE casa_cnpflux ( casaflux , casapool , casabal , zeroflux ) USE cable_def_types_mod USE casadimension USE casaparm USE casavariable IMPLICIT NONE TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_pool ), INTENT ( IN ) :: casapool TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal LOGICAL , intent ( in ) :: zeroflux IF ( zeroflux ) THEN casabal % FCgppyear = 0.0_r_2 casabal % FCrpyear = 0.0_r_2 casabal % FCrmleafyear = 0.0_r_2 casabal % FCrmwoodyear = 0.0_r_2 casabal % FCrmrootyear = 0.0_r_2 casabal % FCrgrowyear = 0.0_r_2 casabal % FCnppyear = 0.0_r_2 casabal % FCrsyear = 0.0_r_2 casabal % FCneeyear = 0.0_r_2 casabal % dCdtyear = 0.0_r_2 casabal % FNdepyear = 0.0_r_2 casabal % FNfixyear = 0.0_r_2 casabal % FNsnetyear = 0.0_r_2 casabal % FNupyear = 0.0_r_2 casabal % FNleachyear = 0.0_r_2 casabal % FNlossyear = 0.0_r_2 casabal % FPweayear = 0.0_r_2 casabal % FPdustyear = 0.0_r_2 casabal % FPsnetyear = 0.0_r_2 casabal % FPupyear = 0.0_r_2 casabal % FPleachyear = 0.0_r_2 casabal % FPlossyear = 0.0_r_2 casaflux % FluxCtohwp = 0.0_r_2 casaflux % FluxNtohwp = 0.0_r_2 casaflux % FluxPtohwp = 0.0_r_2 casaflux % FluxCtoclear = 0.0_r_2 casaflux % FluxNtoclear = 0.0_r_2 casaflux % FluxPtoclear = 0.0_r_2 casaflux % CtransferLUC = 0.0_r_2 !MC - commented because otherwise serial and MPI versions different ! casaflux%Cplant_turnover_disturbance         = 0.0_r_2 ! casaflux%Cplant_turnover_crowding            = 0.0_r_2 ! casaflux%Cplant_turnover_resource_limitation = 0.0_r_2 ELSE casabal % FCgppyear = casabal % FCgppyear + casaflux % Cgpp * deltpool casabal % FCrpyear = casabal % FCrpyear + casaflux % Crp * deltpool casabal % FCrmleafyear (:) = casabal % FCrmleafyear (:) + casaflux % Crmplant (:, leaf ) * deltpool casabal % FCrmwoodyear (:) = casabal % FCrmwoodyear (:) + casaflux % Crmplant (:, wood ) * deltpool casabal % FCrmrootyear (:) = casabal % FCrmrootyear (:) + casaflux % Crmplant (:, froot ) * deltpool casabal % FCrgrowyear = casabal % FCrgrowyear + casaflux % Crgplant * deltpool ! change made ypwang 17-nov-2013 to accoutn for change in labile carbon pool  size casabal % FCnppyear = casabal % FCnppyear + ( casaflux % Cnpp + casapool % dClabiledt ) * deltpool casabal % FCrsyear = casabal % FCrsyear + casaflux % Crsoil * deltpool !casabal%FCneeyear = casabal%FCneeyear & !     + (casaflux%Cnpp+casapool%dClabiledt-casaflux%Crsoil) * deltpool casabal % FCneeyear = casabal % FCneeyear + ( casaflux % Cnpp - casaflux % Crsoil ) * deltpool casabal % dCdtyear = casabal % dCdtyear + ( casapool % Ctot - casapool % Ctot_0 ) * deltpool !  DO n=1,3 !    clitterinput(:,n)= clitterinput(:,n) + casaflux%kplant(:,n) * casapool%cplant(:,n) * deltpool !    csoilinput(:,n) = csoilinput(:,n) + casaflux%fluxCtosoil(:,n) * deltpool !    !csoilinput(:,n) = csoilinput(:,n)+casaflux%fluxCtolitter(:,n)*deltpool !  ENDDO IF ( icycle > 1 ) THEN casabal % FNdepyear = casabal % FNdepyear + casaflux % Nmindep * deltpool casabal % FNfixyear = casabal % FNfixyear + casaflux % Nminfix * deltpool casabal % FNsnetyear = casabal % FNsnetyear + casaflux % Nsnet * deltpool casabal % FNupyear = casabal % FNupyear + casaflux % Nminuptake * deltpool casabal % FNleachyear = casabal % FNleachyear + casaflux % Nminleach * deltpool casabal % FNlossyear = casabal % FNlossyear + casaflux % Nminloss * deltpool ENDIF IF ( icycle > 2 ) THEN casabal % FPweayear = casabal % FPweayear + casaflux % Pwea * deltpool casabal % FPdustyear = casabal % FPdustyear + casaflux % Pdep * deltpool casabal % FPsnetyear = casabal % FPsnetyear + casaflux % Psnet * deltpool casabal % FPupyear = casabal % FPupyear + casaflux % Plabuptake * deltpool casabal % FPleachyear = casabal % FPleachyear + casaflux % Pleach * deltpool casabal % FPlossyear = casabal % FPlossyear + casaflux % Ploss * deltpool ENDIF ENDIF END SUBROUTINE casa_cnpflux ! changed by yp wang following Chris Lu 5/nov/2012 SUBROUTINE biogeochem ( idoY , LALLOC , veg , soil , casabiome , casapool , casaflux , & casamet , casabal , phen , POP , climate , xnplimit , xkNlimiting , xklitter , xksoil , xkleaf , xkleafcold , xkleafdry , & cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd , & nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd , & pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd ) USE cable_def_types_mod USE casadimension USE casa_cnp_module USE POP_TYPES , ONLY : POP_TYPE IMPLICIT NONE INTEGER , INTENT ( IN ) :: idoy INTEGER , INTENT ( IN ) :: LALLOC TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil ! soil parameters TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal TYPE ( phen_variable ), INTENT ( INOUT ) :: phen TYPE ( POP_TYPE ), INTENT ( IN ) :: POP TYPE ( climate_TYPE ), INTENT ( IN ) :: climate real ( r_2 ), dimension ( mp ), intent ( out ) :: xnplimit real ( r_2 ), dimension ( mp ), intent ( out ) :: xkNlimiting real ( r_2 ), dimension ( mp ), intent ( out ) :: xklitter , xksoil real ( r_2 ), dimension ( mp ), intent ( out ) :: xkleafcold , xkleafdry , xkleaf ! added by ypwang following Chris Lu 5/nov/2012 real ( r_2 ), dimension ( mp ), intent ( out ) :: & cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd , & nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd , & pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd ! local variables REAL ( r_2 ), DIMENSION ( mp ) :: xNPuptake INTEGER :: j REAL ( r_2 ), ALLOCATABLE :: tmp (:) xKNlimiting = 1.0_r_2 ! zero annual sums if ( idoy == 1 ) CALL casa_cnpflux ( casaflux , casapool , casabal , . true .) IF ( cable_user % PHENOLOGY_SWITCH . eq . 'MODIS' ) THEN call phenology ( idoy , veg , phen ) ENDIF call avgsoil ( veg , soil , casamet ) call casa_rplant ( veg , casabiome , casapool , casaflux , casamet , climate ) IF (. NOT . cable_user % CALL_POP ) THEN call casa_allocation ( veg , soil , casabiome , casaflux , casapool , casamet , phen , LALLOC ) ENDIF call casa_xrateplant ( xkleafcold , xkleafdry , xkleaf , veg , casabiome , & casamet , phen ) call casa_coeffplant ( xkleafcold , xkleafdry , xkleaf , veg , casabiome , casapool , & casaflux , casamet ) call casa_xnp ( xnplimit , xNPuptake , veg , casabiome , casapool , casaflux , casamet ) IF ( cable_user % CALL_POP ) THEN call casa_allocation ( veg , soil , casabiome , casaflux , casapool , casamet , phen , LALLOC ) WHERE ( pop % pop_grid (:)% cmass_sum_old . gt . 0.001_r_2 . and . pop % pop_grid (:)% cmass_sum . gt . 0.001_r_2 ) casaflux % frac_sapwood ( POP % Iwood ) = POP % pop_grid (:)% csapwood_sum / POP % pop_grid (:)% cmass_sum casaflux % sapwood_area ( POP % Iwood ) = max ( POP % pop_grid (:)% sapwood_area / 1000 0._r_2 , 1.0e-6_r_2 ) veg % hc ( POP % Iwood ) = real ( POP % pop_grid (:)% height_max ) WHERE ( pop % pop_grid (:)% LU == 2 ) casaflux % kplant ( POP % Iwood , 2 ) = 1.0_r_2 - & ( 1.0_r_2 - max ( min (( POP % pop_grid (:)% stress_mortality + & POP % pop_grid (:)% crowding_mortality ) & / ( POP % pop_grid (:)% cmass_sum + POP % pop_grid (:)% growth ) + & 1.0_r_2 / veg % disturbance_interval ( POP % Iwood , 1 ), 0.99_r_2 ), & 0.0_r_2 )) ** ( 1.0_r_2 / 36 5.0_r_2 ) ELSEWHERE casaflux % kplant ( POP % Iwood , 2 ) = 1.0_r_2 - & ( 1.0_r_2 - max ( min (( POP % pop_grid (:)% stress_mortality + & POP % pop_grid (:)% crowding_mortality + & POP % pop_grid (:)% cat_mortality ) & / ( POP % pop_grid (:)% cmass_sum + POP % pop_grid (:)% growth ), 0.99_r_2 ), & 0.0_r_2 )) ** ( 1.0_r_2 / 36 5.0_r_2 ) ENDWHERE veg % hc ( POP % Iwood ) = real ( POP % pop_grid (:)% height_max ) ELSEWHERE casaflux % frac_sapwood ( POP % Iwood ) = 1.0_r_2 casaflux % sapwood_area ( POP % Iwood ) = max ( POP % pop_grid (:)% sapwood_area / 1000 0._r_2 , 1e-6_r_2 ) casaflux % kplant ( POP % Iwood , 2 ) = 0.0_r_2 veg % hc ( POP % Iwood ) = real ( POP % pop_grid (:)% height_max ) ENDWHERE if ( any ( casaflux % kplant (:, leaf ) < 0.0_r_2 )) then do j = 1 , mp if ( casaflux % kplant ( j , leaf ) < 0.0_r_2 ) then print * , 'ERR KK20 ' , j , casaflux % kplant ( j , leaf ) endif enddo endif casaflux % kplant_tot ( POP % Iwood , 2 ) = casaflux % kplant ( POP % Iwood , 2 ) + & ( 1.0_r_2 - casaflux % kplant ( POP % Iwood , 2 )) * casaflux % kplant_fire ( POP % Iwood , 2 ) ENDIF call casa_xratesoil ( xklitter , xksoil , veg , soil , casamet , casabiome ) call casa_coeffsoil ( xklitter , xksoil , veg , soil , casabiome , casaflux , casamet ) IF ( icycle > 1 ) THEN call casa_xkN ( xkNlimiting , casapool , casaflux , casamet , casabiome , veg ) ! vh ! why is this here and not in casa_cnp.F90? DO j = 1 , mlitter casaflux % klitter (:, j ) = casaflux % klitter (:, j ) * xkNlimiting (:) ! MC - have to update klitter_tot as well, otherwise no C balance casaflux % klitter_tot (:, j ) = casaflux % klitter (:, j ) + & ( 1.0_r_2 - casaflux % klitter (:, j )) * casaflux % klitter_fire (:, j ) ENDDO call casa_nuptake ( veg , xkNlimiting , casabiome , casapool , casaflux , casamet ) IF ( icycle > 2 ) call casa_puptake ( veg , xkNlimiting , casabiome , & casapool , casaflux , casamet ) ENDIF ! changed by ypwang following Chris Lu on 5/nov/2012 call casa_delplant ( veg , casabiome , casapool , casaflux , casamet , & cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd , & nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd , & pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd ) casaflux % Cplant_turnover_disturbance = 0.0_r_2 casaflux % Cplant_turnover_crowding = 0.0_r_2 casaflux % Cplant_turnover_resource_limitation = 0.0_r_2 if ( cable_user % CALL_POP ) THEN if (. not . allocated ( tmp )) allocate ( tmp ( size ( POP % pop_grid ))) tmp = POP % pop_grid (:)% stress_mortality & + POP % pop_grid (:)% crowding_mortality & + POP % pop_grid (:)% cat_mortality & + POP % pop_grid (:)% fire_mortality ! where (tmp .gt. 1.e-12_r_2) where ( tmp > real ( epsilon ( 1.0 ), r_2 )) casaflux % Cplant_turnover_disturbance ( POP % Iwood (:)) = & casaflux % Cplant_turnover ( POP % Iwood (:), 2 ) * & ( POP % pop_grid (:)% cat_mortality + POP % pop_grid (:)% fire_mortality ) / tmp (:) casaflux % Cplant_turnover_crowding ( POP % Iwood (:)) = & casaflux % Cplant_turnover ( POP % Iwood (:), 2 ) * POP % pop_grid (:)% crowding_mortality / tmp (:) casaflux % Cplant_turnover_resource_limitation ( POP % Iwood ) = & casaflux % Cplant_turnover ( POP % Iwood (:), 2 ) * POP % pop_grid (:)% stress_mortality / tmp (:) endwhere deallocate ( tmp ) endif call casa_delsoil ( veg , casapool , casaflux , casamet , casabiome ) call casa_cnpcycle ( veg , casabiome , casapool , casaflux , casamet ) !! vh_js !! !CLN ndummy must be before pdummy!!!! IF ( icycle < 3 ) then IF ( icycle < 2 ) call casa_ndummy ( casapool ) call casa_pdummy ( casapool ) ENDIF call casa_cnpbal ( casapool , casaflux , casabal , idoy ) call casa_cnpflux ( casaflux , casapool , casabal ,. false .) ! for spinning up only IF ( cable_user % limit_labile ) THEN casapool % Nsoilmin = max ( casapool % Nsoilmin , 5.0_r_2 ) casapool % Psoillab = max ( casapool % Psoillab , 1.0_r_2 ) ENDIF END SUBROUTINE biogeochem #ifndef UM_BUILD subroutine write_casa_restart_nc ( casabiome , casamet , casapool , casaflux , & casabal , phen ) use cable_common_module , only : cable_user , filename use casavariable , only : casa_biome , casa_met , casa_pool , casa_flux , & casa_balance , write_netcdf_casa_var , casafile use phenvariable , only : phen_variable , write_netcdf_phen_var implicit none type ( casa_biome ), intent ( in ) :: casabiome type ( casa_met ), intent ( in ) :: casamet type ( casa_pool ), intent ( in ) :: casapool type ( casa_flux ), intent ( in ) :: casaflux type ( casa_balance ), intent ( in ) :: casabal type ( phen_variable ), intent ( in ) :: phen character ( len = 99 ) :: basename , fname if ( len_trim ( casafile % cnpepool ) > 0 ) then basename = trim ( casafile % cnpepool ) else basename = trim ( filename % path ) // '/' // & trim ( cable_user % runiden ) // '_casa' end if ! casabiome fname = trim ( basename ) // '_biome_rst.nc' write ( * , * ) 'Writing casa_biome restart: ' , trim ( fname ) call write_netcdf_casa_var ( trim ( fname ), casabiome ) ! casamet fname = trim ( basename ) // '_met_rst.nc' write ( * , * ) 'Writing casa_met restart: ' , trim ( fname ) call write_netcdf_casa_var ( trim ( fname ), casamet ) ! casapool fname = trim ( basename ) // '_pool_rst.nc' write ( * , * ) 'Writing casa_pool restart: ' , trim ( fname ) call write_netcdf_casa_var ( trim ( fname ), casapool ) ! casaflux fname = trim ( basename ) // '_flux_rst.nc' write ( * , * ) 'Writing casa_flux restart: ' , trim ( fname ) call write_netcdf_casa_var ( trim ( fname ), casaflux ) ! casabal fname = trim ( basename ) // '_bal_rst.nc' write ( * , * ) 'Writing casa_bal restart: ' , trim ( fname ) call write_netcdf_casa_var ( trim ( fname ), casabal ) ! phen fname = trim ( basename ) // '_phen_rst.nc' write ( * , * ) 'Writing casa_phen restart: ' , trim ( fname ) call write_netcdf_phen_var ( trim ( fname ), phen ) ! write(*,*) 'Done writing casa restart files' end subroutine write_casa_restart_nc #endif #ifndef UM_BUILD subroutine read_casa_restart_nc ( casabiome , casamet , casapool , casaflux , & casabal , phen ) use cable_common_module , only : cable_user , filename use casavariable , only : casa_biome , casa_met , casa_pool , casa_flux , & casa_balance , read_netcdf_casa_var , casafile use phenvariable , only : phen_variable , read_netcdf_phen_var implicit none type ( casa_biome ), intent ( inout ) :: casabiome type ( casa_met ), intent ( inout ) :: casamet type ( casa_pool ), intent ( inout ) :: casapool type ( casa_flux ), intent ( inout ) :: casaflux type ( casa_balance ), intent ( inout ) :: casabal type ( phen_variable ), intent ( inout ) :: phen character ( len = 99 ) :: basename , fname if ( len_trim ( casafile % cnpipool ) > 0 ) then basename = trim ( casafile % cnpipool ) else basename = trim ( filename % path ) // '/' // & trim ( cable_user % runiden ) // '_casa' end if ! casabiome fname = trim ( basename ) // '_biome_rst.nc' write ( * , * ) 'Reading casa_biome restart: ' , trim ( fname ) call read_netcdf_casa_var ( trim ( fname ), casabiome ) ! casamet fname = trim ( basename ) // '_met_rst.nc' write ( * , * ) 'Reading casa_met restart: ' , trim ( fname ) call read_netcdf_casa_var ( trim ( fname ), casamet ) ! casapool fname = trim ( basename ) // '_pool_rst.nc' write ( * , * ) 'Reading casa_pool restart: ' , trim ( fname ) call read_netcdf_casa_var ( trim ( fname ), casapool ) ! casaflux fname = trim ( basename ) // '_flux_rst.nc' write ( * , * ) 'Reading casa_flux restart: ' , trim ( fname ) call read_netcdf_casa_var ( trim ( fname ), casaflux ) ! casabal fname = trim ( basename ) // '_bal_rst.nc' write ( * , * ) 'Reading casa_bal restart: ' , trim ( fname ) call read_netcdf_casa_var ( trim ( fname ), casabal ) ! phen fname = trim ( basename ) // '_phen_rst.nc' write ( * , * ) 'Reading casa_phen restart: ' , trim ( fname ) call read_netcdf_phen_var ( trim ( fname ), phen ) end subroutine read_casa_restart_nc #endif #ifndef UM_BUILD subroutine write_casa_output_nc ( veg , casamet , casapool , casabal , casaflux , casaonly , ctime , lfinal ) use casadimension , only : mplant , mlitter , msoil , icycle use casavariable , only : casa_met , casa_pool , casa_balance , casa_flux , & casafile , casa_timeunits use cable_common_module , only : cable_user , filename , handle_err use cable_IO_vars_module , only : patch use cable_def_types_mod , only : veg_parameter_type , mp ! use cable_def_types_mod,  only: sp => r_2 use netcdf , only : nf90_noerr , & nf90_put_var , nf90_clobber , nf90_create , nf90_global , nf90_put_att , & #ifdef __NETCDF3__ nf90_64bit_offset , & #else nf90_netcdf4 , nf90_classic_model , & #endif nf90_def_dim , nf90_unlimited , nf90_int , nf90_def_var , nf90_float , nf90_enddef , nf90_put_var , nf90_close ! , nf90_double implicit none type ( veg_parameter_type ), intent ( in ) :: veg ! vegetation parameters type ( casa_met ) , intent ( in ) :: casamet type ( casa_pool ), intent ( in ) :: casapool type ( casa_balance ), intent ( in ) :: casabal type ( casa_flux ), intent ( in ) :: casaflux logical , intent ( in ) :: casaonly integer , intent ( in ) :: ctime logical , intent ( in ) :: lfinal integer :: status integer :: land_id , plant_id , litter_id , soil_id , t_id , i character ( len = 99 ) :: fname character ( len = 50 ) :: dum logical , save :: call1 = . true . integer , parameter :: sp = kind ( 1.0 ) ! 1 dim arrays (mp) character ( len = 20 ), dimension ( 2 ) :: a0 ! 2 dim arrays (mp,t) character ( len = 20 ), dimension ( 53 ) :: a1 ! 3 dim arrays (mp,mplant,t) character ( len = 20 ), dimension ( 9 ) :: a2 ! 3 dim arrays (mp,mlitter,t) character ( len = 20 ), dimension ( 9 ) :: a3 ! 3 dim arrays (mp,msoil,t) character ( len = 20 ), dimension ( 8 ) :: a4 ! 4 dim arrays (mp,mlitter,mplant,t) character ( len = 20 ), dimension ( 1 ) :: a5 ! 4 dim arrays (mp,msoil,mlitter,t) character ( len = 20 ), dimension ( 1 ) :: a6 ! 4 dim arrays (mp,msoil,msoil,t) character ( len = 20 ), dimension ( 1 ) :: a7 integer , dimension ( size ( a0 )), save :: vid0 integer , dimension ( size ( a1 )), save :: vid1 integer , dimension ( size ( a2 )), save :: vid2 integer , dimension ( size ( a3 )), save :: vid3 integer , dimension ( size ( a4 )), save :: vid4 integer , dimension ( size ( a5 )), save :: vid5 integer , dimension ( size ( a6 )), save :: vid6 integer , dimension ( size ( a7 )), save :: vid7 integer , save :: vidtime , file_id , cnt integer :: na0 , na1 , na2 , na3 , na4 , na5 , na6 , na7 ! actual size to write depending on icycle if ( icycle < 1 ) return a0 ( 1 ) = 'latitude' a0 ( 2 ) = 'longitude' na0 = 2 ! patch fraction and area a1 ( 1 ) = 'patchfrac' a1 ( 2 ) = 'patcharea' ! C a1 ( 3 ) = 'glai' a1 ( 4 ) = 'clabile' a1 ( 5 ) = 'sumcbal' a1 ( 6 ) = 'Cgpp' a1 ( 7 ) = 'Cnpp' a1 ( 8 ) = 'stemnpp' a1 ( 9 ) = 'Crp' a1 ( 10 ) = 'Crgplant' a1 ( 11 ) = 'Clabloss' a1 ( 12 ) = 'fraclabile' a1 ( 13 ) = 'Cnep' a1 ( 14 ) = 'Crsoil' a1 ( 15 ) = 'FluxCtoco2' a1 ( 16 ) = 'FCgppyear' a1 ( 17 ) = 'FCrpyear' a1 ( 18 ) = 'FCnppyear' a1 ( 19 ) = 'FCrsyear' a1 ( 20 ) = 'FCNeeyear' a1 ( 21 ) = 'vcmax' na1 = 21 ! N a1 ( 22 ) = 'sumnbal' a1 ( 23 ) = 'Nminfix' a1 ( 24 ) = 'Nmindep' a1 ( 25 ) = 'Nminloss' a1 ( 26 ) = 'Nminleach' a1 ( 27 ) = 'Nupland' a1 ( 28 ) = 'Nlittermin' a1 ( 29 ) = 'Nsmin' a1 ( 30 ) = 'Nsimm' a1 ( 31 ) = 'Nsnet' a1 ( 32 ) = 'fNMinloss' a1 ( 33 ) = 'Nsoilmin' if ( icycle == 2 ) na1 = 33 ! P a1 ( 34 ) = 'psoillab' a1 ( 35 ) = 'psoilsorb' a1 ( 36 ) = 'psoilocc' a1 ( 37 ) = 'sumpbal' a1 ( 38 ) = 'Plabuptake' a1 ( 39 ) = 'Pdep' a1 ( 40 ) = 'pwea' a1 ( 41 ) = 'Pleach' a1 ( 42 ) = 'Ploss' a1 ( 43 ) = 'Pupland' a1 ( 44 ) = 'Plittermin' a1 ( 45 ) = 'Psmin' a1 ( 46 ) = 'Psimm' a1 ( 47 ) = 'Psnet' a1 ( 48 ) = 'fPleach' a1 ( 49 ) = 'kPlab' a1 ( 50 ) = 'kPsorb' a1 ( 51 ) = 'kpocc' a1 ( 52 ) = 'kmlabP' a1 ( 53 ) = 'Psorbmax' if ( icycle == 3 ) na1 = 53 ! C a2 ( 1 ) = 'cplant' a2 ( 2 ) = 'fracCalloc' a2 ( 3 ) = 'kplant' a2 ( 4 ) = 'Crmplant' a2 ( 5 ) = 'kplant_fire' na2 = 5 ! N a2 ( 6 ) = 'nplant' a2 ( 7 ) = 'fracNalloc' if ( icycle == 2 ) na2 = 7 ! P a2 ( 8 ) = 'pplant' a2 ( 9 ) = 'fracPalloc' if ( icycle == 3 ) na2 = 9 ! C a3 ( 1 ) = 'clitter' a3 ( 2 ) = 'klitter' a3 ( 3 ) = 'fromLtoCO2' a3 ( 4 ) = 'FluxCtolitter' a3 ( 5 ) = 'klitter_fire' na3 = 5 ! N a3 ( 6 ) = 'nlitter' a3 ( 7 ) = 'FluxNtolitter' if ( icycle == 2 ) na3 = 7 ! P a3 ( 8 ) = 'plitter' a3 ( 9 ) = 'FluxPtolitter' if ( icycle == 3 ) na3 = 9 ! C a4 ( 1 ) = 'csoil' a4 ( 2 ) = 'ksoil' a4 ( 3 ) = 'fromStoCO2' a4 ( 4 ) = 'FluxCtosoil' na4 = 4 ! N a4 ( 5 ) = 'nsoil' a4 ( 6 ) = 'FluxNtosoil' if ( icycle == 2 ) na4 = 6 ! P a4 ( 7 ) = 'psoil' a4 ( 8 ) = 'FluxPxtosoil' if ( icycle == 3 ) na4 = 8 ! C a5 ( 1 ) = 'fromPtoL' na5 = 1 ! C a6 ( 1 ) = 'fromLtoS' na6 = 1 ! C a7 ( 1 ) = 'fromStoS' na7 = 1 ! Get File-Name if ( len_trim ( casafile % out ) > 0 ) then fname = trim ( casafile % out ) else if ( len_trim ( cable_user % mettype ) > 0 ) then if ( cable_user % yearstart < 1000 ) then write ( dum , fmt = \"(i3)\" ) cable_user % yearstart else write ( dum , fmt = \"(i4)\" ) cable_user % yearstart endif if ( cable_user % yearend < 1000 ) then write ( dum , fmt = \"(a,a,i3)\" ) trim ( dum ), '_' , cable_user % yearend else write ( dum , fmt = \"(a,a,i4)\" ) trim ( dum ), '_' , cable_user % yearend endif fname = trim ( filename % path ) // '/' // trim ( cable_user % RunIden ) // '_' // trim ( dum ) // '_casa_out.nc' else ! site data fname = trim ( filename % path ) // '/' // trim ( cable_user % RunIden ) // '_casa_out.nc' endif endif if ( call1 ) then cnt = 0 ! create netcdf file: #ifdef __NETCDF3__ status = nf90_create ( trim ( fname ), ior ( nf90_clobber , nf90_64bit_offset ), file_id ) #else status = nf90_create ( trim ( fname ), ior ( nf90_clobber , ior ( nf90_netcdf4 , nf90_classic_model )), file_id ) #endif if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_att ( file_id , nf90_global , \"icycle\" , icycle ) status = nf90_put_att ( file_id , nf90_global , \"startyear\" , cable_user % yearstart ) status = nf90_put_att ( file_id , nf90_global , \"endyear\" , cable_user % yearend ) status = nf90_put_att ( file_id , nf90_global , \"runiden\" , cable_user % runiden ) if ( casaonly ) then dum = 'casa-only run' else dum = 'cable-casa coupled run' endif status = nf90_put_att ( file_id , nf90_global , \"run-type\" , trim ( dum )) ! define dimensions: ! land (number of points) status = nf90_def_dim ( file_id , 'land' , mp , land_id ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_def_dim ( file_id , 'mplant' , mplant , plant_id ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_def_dim ( file_id , 'mlitter' , mlitter , litter_id ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_def_dim ( file_id , 'msoil' , msoil , soil_id ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_def_dim ( file_id , 'time' , nf90_unlimited , t_id ) if ( status /= nf90_noerr ) call handle_err ( status ) ! define variables status = nf90_def_var ( file_id , 'time' , nf90_int , ( / t_id / ), vidtime ) if ( status /= nf90_noerr ) call handle_err ( status ) STATUS = NF90_PUT_ATT ( FILE_ID , VIDtime , 'units' , TRIM ( casa_timeunits )) IF ( STATUS /= NF90_NOERR ) CALL handle_err ( STATUS ) ! STATUS = NF90_PUT_ATT(FILE_ID, VIDtime, 'calendar', trim(casa_calendar)) ! IF (STATUS /= NF90_NOERR)  CALL handle_err(STATUS) do i = 1 , na0 status = nf90_def_var ( file_id , trim ( a0 ( i )), nf90_float , ( / land_id / ), vid0 ( i )) if ( status /= nf90_noerr ) call handle_err ( status ) end do do i = 1 , na1 status = nf90_def_var ( file_id , trim ( a1 ( i )), nf90_float , ( / land_id , t_id / ), vid1 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) if ( status /= nf90_noerr ) call handle_err ( status ) end do do i = 1 , na2 status = nf90_def_var ( file_id , trim ( a2 ( i )), nf90_float , ( / land_id , plant_id , t_id / ), vid2 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) if ( status /= nf90_noerr ) call handle_err ( status ) end do do i = 1 , na3 status = nf90_def_var ( file_id , trim ( a3 ( i )), nf90_float , ( / land_id , litter_id , t_id / ), vid3 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) if ( status /= nf90_noerr ) call handle_err ( status ) end do do i = 1 , na4 status = nf90_def_var ( file_id , trim ( a4 ( i )), nf90_float , ( / land_id , soil_id , t_id / ), vid4 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) if ( status /= nf90_noerr ) call handle_err ( status ) end do do i = 1 , na5 status = nf90_def_var ( file_id , trim ( a5 ( i )), nf90_float , ( / land_id , litter_id , plant_id , t_id / ), vid5 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) if ( status /= nf90_noerr ) call handle_err ( status ) end do do i = 1 , na6 status = nf90_def_var ( file_id , trim ( a6 ( i )), nf90_float , ( / land_id , soil_id , litter_id , t_id / ), vid6 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) if ( status /= nf90_noerr ) call handle_err ( status ) end do do i = 1 , na7 status = nf90_def_var ( file_id , trim ( a7 ( i )), nf90_float , ( / land_id , soil_id , soil_id , t_id / ), vid7 ( i ) & #ifndef __NETCDF3__ , deflate_level = 4 & #endif ) if ( status /= nf90_noerr ) call handle_err ( status ) end do ! end define mode: status = nf90_enddef ( file_id ) if ( status /= nf90_noerr ) call handle_err ( status ) ! put lat / lon ( mp ) status = nf90_put_var ( file_id , vid0 ( 1 ), real ( casamet % lat , sp )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid0 ( 2 ), real ( casamet % lon , sp )) if ( status /= nf90_noerr ) call handle_err ( status ) call1 = . false . endif ! call1 cnt = cnt + 1 ! time  ( t ) status = nf90_put_var ( file_id , vidtime , ctime , start = ( / cnt / )) if ( status /= nf90_noerr ) call handle_err ( status ) ! patchfrac and area status = nf90_put_var ( file_id , vid1 ( 1 ), real ( patch (:)% frac , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) !status = nf90_put_att(file_id, vid1(52), 'units', '-') !if(status /= nf90_noerr) call handle_err(status) status = nf90_put_var ( file_id , vid1 ( 2 ), real ( casamet % areacell , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) ! C status = nf90_put_var ( file_id , vid1 ( 3 ), real ( casamet % glai , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 4 ), real ( casapool % clabile , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 5 ), real ( casabal % sumcbal , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 6 ), real ( casaflux % cgpp , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 7 ), real ( casaflux % cnpp , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 8 ), real ( casaflux % stemnpp , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 9 ), real ( casaflux % crp , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 10 ), real ( casaflux % crgplant , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 11 ), real ( casaflux % clabloss , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 12 ), real ( casaflux % fracclabile , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 13 ), real ( casaflux % cnep , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 14 ), real ( casaflux % crsoil , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 15 ), real ( casaflux % fluxctoco2 , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 16 ), real ( casabal % fcgppyear , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 17 ), real ( casabal % fcrpyear , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 18 ), real ( casabal % fcnppyear , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 19 ), real ( casabal % fcrsyear , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 20 ), real ( casabal % fcneeyear , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 21 ), real ( veg % vcmax , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) ! N if ( icycle > 1 ) then status = nf90_put_var ( file_id , vid1 ( 22 ), real ( casabal % sumnbal , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 23 ), real ( casaflux % nminfix , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 24 ), real ( casaflux % nmindep , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 25 ), real ( casaflux % nminloss , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 26 ), real ( casaflux % nminleach , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 27 ), real ( casaflux % nupland , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 28 ), real ( casaflux % nlittermin , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 29 ), real ( casaflux % nsmin , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 30 ), real ( casaflux % nsimm , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 31 ), real ( casaflux % nsnet , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 32 ), real ( casaflux % fnminloss , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 33 ), real ( casapool % nsoilmin , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) endif ! P if ( icycle > 2 ) then status = nf90_put_var ( file_id , vid1 ( 34 ), real ( casapool % psoillab , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 35 ), real ( casapool % psoilsorb , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 36 ), real ( casapool % psoilocc , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 37 ), real ( casabal % sumpbal , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 38 ), real ( casaflux % plabuptake , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 39 ), real ( casaflux % pdep , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 40 ), real ( casaflux % pwea , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 41 ), real ( casaflux % pleach , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 42 ), real ( casaflux % ploss , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 43 ), real ( casaflux % pupland , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 44 ), real ( casaflux % plittermin , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 45 ), real ( casaflux % psmin , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 46 ), real ( casaflux % psimm , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 47 ), real ( casaflux % psnet , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 48 ), real ( casaflux % fpleach , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 49 ), real ( casaflux % kplab , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 50 ), real ( casaflux % kpsorb , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 51 ), real ( casaflux % kpocc , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 52 ), real ( casaflux % kmlabp , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid1 ( 53 ), real ( casaflux % psorbmax , sp ), start = ( / 1 , cnt / ), count = ( / mp , 1 / ) ) if ( status /= nf90_noerr ) call handle_err ( status ) endif ! put 3d vars ( mp, mplant, t ) ! C status = nf90_put_var ( file_id , vid2 ( 1 ), real ( casapool % cplant , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mplant , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid2 ( 2 ), real ( casaflux % fracCalloc , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mplant , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid2 ( 3 ), real ( casaflux % kplant , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mplant , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid2 ( 4 ), real ( casaflux % crmplant , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mplant , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid2 ( 5 ), real ( casaflux % kplant_fire , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mplant , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) ! N if ( icycle > 1 ) then status = nf90_put_var ( file_id , vid2 ( 6 ), real ( casapool % nplant , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mplant , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid2 ( 7 ), real ( casaflux % fracnalloc , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mplant , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) endif ! P if ( icycle > 2 ) then status = nf90_put_var ( file_id , vid2 ( 8 ), real ( casapool % pplant , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mplant , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid2 ( 9 ), real ( casaflux % fracpalloc , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mplant , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) endif ! put 3d vars ( mp, mlitter, t ) ! C status = nf90_put_var ( file_id , vid3 ( 1 ), real ( casapool % clitter , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mlitter , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid3 ( 2 ), real ( casaflux % klitter , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mlitter , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid3 ( 3 ), real ( casaflux % fromltoco2 , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mlitter , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid3 ( 4 ), real ( casaflux % fluxctolitter , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mlitter , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid3 ( 5 ), real ( casaflux % klitter_fire , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mlitter , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) ! N if ( icycle > 1 ) then status = nf90_put_var ( file_id , vid3 ( 6 ), real ( casapool % nlitter , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mlitter , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid3 ( 7 ), real ( casaflux % fluxntolitter , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mlitter , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) endif ! P if ( icycle > 2 ) then status = nf90_put_var ( file_id , vid3 ( 8 ), real ( casapool % plitter , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mlitter , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid3 ( 9 ), real ( casaflux % fluxptolitter , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , mlitter , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) endif ! put 3d vars ( mp, msoil, t ) ! C status = nf90_put_var ( file_id , vid4 ( 1 ), real ( casapool % csoil , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , msoil , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid4 ( 2 ), real ( casaflux % ksoil , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , msoil , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid4 ( 3 ), real ( casaflux % fromstoco2 , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , msoil , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid4 ( 4 ), real ( casaflux % fluxctosoil , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , msoil , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) ! N if ( icycle > 1 ) then status = nf90_put_var ( file_id , vid4 ( 5 ), real ( casapool % nsoil , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , msoil , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid4 ( 6 ), real ( casaflux % fluxntosoil , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , msoil , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) endif ! P if ( icycle > 2 ) then status = nf90_put_var ( file_id , vid4 ( 7 ), real ( casapool % psoil , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , msoil , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) status = nf90_put_var ( file_id , vid4 ( 8 ), real ( casaflux % fluxptosoil , sp ), start = ( / 1 , 1 , cnt / ), count = ( / mp , msoil , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) endif ! put 4d vars ( mp, mlitter,mplant, t ) ! C status = nf90_put_var ( file_id , vid5 ( 1 ), real ( casaflux % fromptol , sp ), start = ( / 1 , 1 , 1 , cnt / ), count = ( / mp , mlitter , mplant , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) ! put 4d vars ( mp, msoil, mlitter, t ) ! C status = nf90_put_var ( file_id , vid6 ( 1 ), real ( casaflux % fromltos , sp ), start = ( / 1 , 1 , 1 , cnt / ), count = ( / mp , msoil , mlitter , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) ! put 4d vars ( mp, msoil, msoil, t ) ! C status = nf90_put_var ( file_id , vid7 ( 1 ), real ( casaflux % fromstos , sp ), start = ( / 1 , 1 , 1 , cnt / ), count = ( / mp , msoil , msoil , 1 / )) if ( status /= nf90_noerr ) call handle_err ( status ) if ( lfinal ) then ! close netcdf file: status = nf90_close ( file_id ) file_id = - 1 if ( status /= nf90_noerr ) call handle_err ( status ) write ( * , * ) \" casa output written to \" , trim ( fname ) endif end subroutine write_casa_output_nc #endif end module casa_inout","tags":"","loc":"sourcefile/casa_inout.f90.html"},{"title":"POP.F90 – POP","text":"Files dependent on this one sourcefile~~pop.f90~~AfferentGraph sourcefile~pop.f90 POP.F90 sourcefile~cable_optimisejvratio.f90 cable_optimiseJVratio.F90 sourcefile~cable_optimisejvratio.f90->sourcefile~pop.f90 sourcefile~cable_phenology.f90 cable_phenology.F90 sourcefile~cable_phenology.f90->sourcefile~pop.f90 sourcefile~casa_cable.f90 casa_cable.F90 sourcefile~casa_cable.f90->sourcefile~pop.f90 sourcefile~casa_cable.f90->sourcefile~cable_optimisejvratio.f90 sourcefile~casa_cable.f90->sourcefile~cable_phenology.f90 sourcefile~casa_inout.f90 casa_inout.F90 sourcefile~casa_cable.f90->sourcefile~casa_inout.f90 sourcefile~casa_inout.f90->sourcefile~pop.f90 sourcefile~casaonly_luc.f90 CASAONLY_LUC.F90 sourcefile~casaonly_luc.f90->sourcefile~pop.f90 sourcefile~casaonly_luc.f90->sourcefile~casa_cable.f90 sourcefile~casaonly_luc.f90->sourcefile~casa_inout.f90 sourcefile~popluc.f90 POPLUC.F90 sourcefile~casaonly_luc.f90->sourcefile~popluc.f90 sourcefile~pop_io.f90 pop_io.F90 sourcefile~pop_io.f90->sourcefile~pop.f90 sourcefile~pop_mpi.f90 pop_mpi.F90 sourcefile~pop_mpi.f90->sourcefile~pop.f90 sourcefile~popluc.f90->sourcefile~pop.f90 sourcefile~spincasacnp.f90 spincasacnp.F90 sourcefile~spincasacnp.f90->sourcefile~pop.f90 sourcefile~spincasacnp.f90->sourcefile~casa_cable.f90 sourcefile~spincasacnp.f90->sourcefile~casa_inout.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules TypeDef POP_Constants POP_Types POPModule Source Code POP.F90 Source Code ! This file contains Fortran90 code for the POP model, ! a stand-alone tree demography and landscape structure module for Earth system models ! 17-01-2014 ! Written by Vanessa Haverd, Ben Smith and Lars Nieradzik ! Report Bugs to Vanessa.Haverd@csiro.au !CITATION !-------------------------------------------------------- !When referring to this code in publications, please cite: ! Haverd, V., Smith, B., Cook, G., Briggs, P.R., Nieradzik, L., Roxburgh, S.R., Liedloff, A., ! Meyer, C.P. and Canadell, J.G., 2013. ! A stand-alone tree demography and landscape structure module for Earth system models. ! Geophysical Research Letters, 40: 1-6. !DISCLAIMER, COPYRIGHT AND LICENCE !-------------------------------------------------------- ! Use of this code is subject to the Legal Notice and Disclaimer at ! http://www.csiro.au/org/LegalNoticeAndDisclaimer.html ! This code is Copyright, CSIRO, 2014. ! This code is made available under the conditions of the Creative Commons ! Attribution-Share Alike 3.0 License: ! http://creativecommons.org/licenses/by-sa/3.0/ !******************************************************************************* MODULE TypeDef !------------------------------------------------------------------------------- ! This module explicitly defines the sizes of variable types !------------------------------------------------------------------------------- IMPLICIT NONE SAVE ! Define integer kind parameters to accommodate the range of numbers usually ! associated with 4, 2, and 1 byte integers. INTEGER , PARAMETER :: i4b = SELECTED_INT_KIND ( 9 ) INTEGER , PARAMETER :: i2b = SELECTED_INT_KIND ( 4 ) INTEGER , PARAMETER :: i1b = SELECTED_INT_KIND ( 2 ) ! Define single and double precision real kind parameters: ! * Kind(1.0)   defines sp as the machine's default size for single precision ! * Kind(1.0d0) defines dp as the machine's default size for double precision INTEGER , PARAMETER :: sp = KIND ( 1.0 ) INTEGER , PARAMETER :: dp = KIND ( 1.0d0 ) ! lgt is set to the default kind required for representing logical values. INTEGER , PARAMETER :: lgt = KIND (. TRUE .) END MODULE TypeDef !******************************************************************************* MODULE POP_Constants USE TYPEdef , ONLY : dp , i4b IMPLICIT NONE ! REAL(dp),PARAMETER:: FULTON_ALPHA= 5.6 ! recruitment scalar alpha in Fulton (1991) ! REAL(dp),PARAMETER:: DENSINDIV_MAX=2  ! 0.5 !  Maximum density of individuals within a cohort indiv/m2 ! REAL(dp),PARAMETER:: DENSINDIV_MIN=1e-9 ! ! REAL(dp),PARAMETER:: Kbiometric=50.0 ! Constant in height-diameter relationship ! REAL(dp),PARAMETER:: WD= 300.0 ! Wood density kgC/m3 ! ! threshold growth efficiency for enhanced mortality (higher value gives higher biomass turnover) ! REAL(dp),PARAMETER:: GROWTH_EFFICIENCY_MIN=0.008 ! 0.008 ! REAL(dp),PARAMETER:: Pmort=5.0 ! exponent in mortality formula ! REAL(dp),PARAMETER:: MORT_MAX=0.3 ! upper asymptote for enhanced mortality ! REAL(dp),PARAMETER:: THETA_recruit=0.95 ! shape parameter in recruitment equation ! REAL(dp),PARAMETER:: CMASS_STEM_INIT= 1e-4 ! initial biomass kgC/m2 ! REAL(dp),PARAMETER:: POWERbiomass=0.75 ! exponent for biomass in proportion to which cohorts preempt resources ! REAL(dp),PARAMETER:: POWERGrowthEfficiency = 0.75 ! REAL(dp),PARAMETER:: CrowdingFactor = 0.0128 ! REAL(dp),PARAMETER:: ALPHA_CPC = 3.0 REAL ( dp ), PARAMETER :: FULTON_ALPHA = 3.5_dp ! recruitment scalar alpha in Fulton (1991) REAL ( dp ), PARAMETER :: DENSINDIV_MAX = 0.2_dp ! 0.5 !  Maximum density of individuals within a cohort indiv/m2 REAL ( dp ), PARAMETER :: DENSINDIV_MIN = 1.0e-9_dp ! REAL ( dp ), PARAMETER :: Kbiometric = 5 0.0_dp ! Constant in height-diameter relationship REAL ( dp ), PARAMETER :: WD = 30 0.0_dp ! Wood density kgC/m3 ! threshold growth efficiency for enhanced mortality (higher value gives higher biomass turnover) REAL ( dp ), PARAMETER :: GROWTH_EFFICIENCY_MIN = 0.009_dp ! 0.0095 ! 0.0089 ! 0.0084 REAL ( dp ), PARAMETER :: Pmort = 5.0_dp ! exponent in mortality formula REAL ( dp ), PARAMETER :: MORT_MAX = 0.3_dp ! upper asymptote for enhanced mortality REAL ( dp ), PARAMETER :: THETA_recruit = 0.95_dp ! shape parameter in recruitment equation REAL ( dp ), PARAMETER :: CMASS_STEM_INIT = 1.0e-4_dp ! initial biomass kgC/m2 REAL ( dp ), PARAMETER :: POWERbiomass = 0.67_dp ! exponent for biomass in proportion to which cohorts preempt resources REAL ( dp ), PARAMETER :: POWERGrowthEfficiency = 0.67_dp REAL ( dp ), PARAMETER :: CrowdingFactor = 0.043_dp ! 0.043 ! 0.039  !0.029 ! 0.033 REAL ( dp ), PARAMETER :: ALPHA_CPC = 3.5_dp REAL ( dp ), PARAMETER :: k_allom1 = 20 0.0_dp ! crown area =  k_allom1 * diam ** k_rp REAL ( dp ), PARAMETER :: k_rp = 1.67_dp ! constant in crown area relation to tree diameter REAL ( dp ), PARAMETER :: ksapwood = 0.05_dp ! rate constant for conversion of sapwood to heartwood (y-1) REAL ( dp ), PARAMETER :: Q = 7.0_dp ! governs rate of increase of mortality with age (2=exponential) REAL , PARAMETER :: rshootfrac = 0.63 REAL ( dp ), PARAMETER :: shootfrac = real ( rshootfrac , dp ) REAL ( dp ), PARAMETER :: CtoNw = 40 0.0_dp REAL ( dp ), PARAMETER :: CtoNl = 6 0.0_dp REAL ( dp ), PARAMETER :: CtoNr = 7 0.0_dp REAL ( dp ), PARAMETER :: N_EXTENT = 2.0_dp ! multiple of crown diameters within which tree competes with other cohorts REAL ( dp ), PARAMETER :: EPS = 1.0e-12_dp INTEGER ( i4b ), PARAMETER :: NLAYER = 1 ! number of vertical veg layers (1 is currently the only option) INTEGER ( i4b ), PARAMETER :: NCOHORT_MAX = 20 ! maximum number of cohorts INTEGER ( i4b ), PARAMETER :: NDISTURB = 1 ! number of disturbance regimes (1 (total only)  or 2 (partial and total)) INTEGER ( i4b ), PARAMETER :: PATCH_REPS = 10 ! higher number reduces 'noise' INTEGER ( i4b ), PARAMETER :: NAGE_MAX = 1 ! number of maxium ages INTEGER ( i4b ), PARAMETER :: PATCH_REPS1 = 60 ! number of first dist years INTEGER ( i4b ), PARAMETER :: PATCH_REPS2 = 1 ! number of second dist years INTEGER ( i4b ), PARAMETER :: NPATCH = PATCH_REPS1 * PATCH_REPS2 INTEGER ( i4b ), PARAMETER :: NPATCH1D = NPATCH INTEGER ( i4b ), PARAMETER :: NPATCH2D = NPATCH INTEGER ( i4b ), PARAMETER :: HEIGHT_BINS = 12 ! number of height categories to keep track of for diagnostics REAL ( dp ), PARAMETER :: BIN_POWER = 1.4_dp ! bins have muscles ! Time base factor (to be multiplied by mean dist interval to give TIMEBASE) ! for sampling disturbance probabilities from Poisson distribution INTEGER ( i4b ), PARAMETER :: TIMEBASE_FACTOR = 50 REAL ( dp ), PARAMETER :: PI = 3.14159265358979323846264_dp ! 0 == default; 1 = top-end allometry (requires precip as input to POPSTEP); 2 = Allometry following Williams 2005, Model 5b INTEGER ( i4b ), PARAMETER :: ALLOM_SWITCH = 2 ! 0 == binnned max height variable; 1 = continuous (needs lots of memory); 2 = binned by integer heights INTEGER ( i4b ), PARAMETER :: MAX_HEIGHT_SWITCH = 2 INTEGER ( i4b ), PARAMETER :: RESOURCE_SWITCH = 1 ! 0 = default; 1  fraction net resource uptake INTEGER ( i4b ), PARAMETER :: RECRUIT_SWITCH = 1 ! 0 = default, 1 = Pgap-dependence INTEGER ( i4b ), PARAMETER :: INTERP_SWITCH = 1 ! 0 = sum over weighted patches, 1 = sum over interpolated patches INTEGER ( i4b ), PARAMETER :: SMOOTH_SWITCH = 0 ! smooth disturbance flux INTEGER ( i4b ), PARAMETER :: NYEAR_WINDOW = 5 ! one-side of smoothing window (y) INTEGER ( i4b ), PARAMETER :: NYEAR_SMOOTH = 2 * NYEAR_WINDOW + 1 ! smoothing window (y) INTEGER ( i4b ), PARAMETER :: NYEAR_HISTORY = NYEAR_SMOOTH - NYEAR_WINDOW INTEGER ( i4b ), PARAMETER :: AGEMAX = 1000 END MODULE POP_Constants !******************************************************************************* MODULE POP_Types USE TYPEdef , ONLY : dp , i4b USE POP_Constants , ONLY : NCOHORT_MAX , NLAYER , HEIGHT_BINS , NDISTURB , NPATCH , NPATCH2D , & NYEAR_HISTORY , AGEMAX IMPLICIT NONE TYPE Cohort INTEGER ( i4b ) :: id INTEGER ( i4b ) :: age ! cohort age REAL ( dp ) :: biomass ! cohort biomass REAL ( dp ) :: density ! landscape tree density (weighted mean over patches) REAL ( dp ) :: frac_resource_uptake REAL ( dp ) :: frac_light_uptake REAL ( dp ) :: frac_interception REAL ( dp ) :: frac_respiration REAL ( dp ) :: frac_NPP REAL ( dp ) :: respiration_scalar REAL ( dp ) :: crown_area REAL ( dp ) :: Pgap REAL ( dp ) :: height REAL ( dp ) :: diameter REAL ( dp ) :: sapwood REAL ( dp ) :: heartwood REAL ( dp ) :: sapwood_area REAL ( dp ) :: basal_area REAL ( dp ) :: LAI REAL ( dp ) :: Cleaf REAL ( dp ) :: Croot END TYPE Cohort TYPE Layer TYPE ( Cohort ), DIMENSION ( NCOHORT_MAX ) :: Cohort INTEGER ( i4b ) :: ncohort ! number of cohorts with density >0 REAL ( dp ) :: biomass ! layer biomass REAL ( dp ) :: density ! layer tree density REAL ( dp ) :: hmean ! layer mean tree height (weighted mean over patches) REAL ( dp ) :: hmax ! layer max tree height END TYPE Layer TYPE Patch TYPE ( Layer ), DIMENSION ( NLAYER ) :: Layer REAL ( dp ) :: factor_recruit REAL ( dp ) :: pgap REAL ( dp ) :: lai REAL ( dp ) :: biomass ! total biomass in patch REAL ( dp ) :: biomass_old ! total biomass in patch REAL ( dp ) :: sapwood ! total sapwood biomass in patch REAL ( dp ) :: heartwood ! total heartwood biomass in patch REAL ( dp ) :: sapwood_old ! total sapwood biomass in patch REAL ( dp ) :: sapwood_area ! total sapwood area in patch REAL ( dp ) :: sapwood_area_old ! total sapwood area in patch REAL ( dp ) :: stress_mortality ! biomass lost in each patch due to stress REAL ( dp ) :: fire_mortality ! biomass lost in each patch due partial fire disturbance REAL ( dp ) :: cat_mortality ! biomass lost in each patch due partial fire disturbance REAL ( dp ) :: crowding_mortality ! biomass lost to crowding mortality REAL ( dp ) :: cpc REAL ( dp ) :: mortality ! REAL ( dp ) :: sapwood_loss REAL ( dp ) :: sapwood_area_loss REAL ( dp ) :: growth ! biomass growth in each patch due to stem increment REAL ( dp ) :: area_growth ! basal area growth in each patch due to stem increment INTEGER ( i4b ) :: disturbance_interval ( NDISTURB ) ! prescribed disturbance(s) interval for this patch INTEGER ( i4b ) :: first_disturbance_year ( NDISTURB ) INTEGER ( i4b ) :: age ( NDISTURB ) ! number of years since last disturbance(s) INTEGER ( i4b ) :: id REAL ( dp ) :: frac_NPP REAL ( dp ) :: frac_respiration REAL ( dp ) :: frac_light_uptake REAL ( dp ) :: fire_top_kill_density END TYPE Patch TYPE Landscape TYPE ( Patch ), DIMENSION ( NPATCH2D ) :: patch REAL ( dp ), DIMENSION ( NPATCH2D ) :: freq ! patch weighting REAL ( dp ), DIMENSION ( NPATCH2D ) :: freq_old ! patch weighting (previous time-step) REAL ( dp ), DIMENSION ( NPATCH2D ) :: fire_freq ! REAL ( dp ), DIMENSION ( NPATCH2D ) :: fire_freq_old ! REAL ( dp ), DIMENSION ( NPATCH2D ) :: cat_freq ! REAL ( dp ), DIMENSION ( NPATCH2D ) :: cat_freq_old ! REAL ( dp ), DIMENSION ( NPATCH2D , NDISTURB ) :: freq_ranked_age_unique ! unique age weighting INTEGER ( i4b ), DIMENSION ( NPATCH2D , NDISTURB ) :: ranked_age_unique ! unique age INTEGER ( i4b ), DIMENSION ( NDISTURB ) :: n_age ! number of unique ages REAL ( dp ), DIMENSION ( NLAYER ) :: biomass ! landscape stem biomass (weighted mean over patches) REAL ( dp ), DIMENSION ( NLAYER ) :: density ! landscape tree density (weighted mean over patches) REAL ( dp ), DIMENSION ( NLAYER ) :: hmean ! landscape mean treen height (weighted mean over patches) REAL ( dp ), DIMENSION ( NLAYER ) :: hmax ! landscape max tree height REAL ( dp ), DIMENSION ( HEIGHT_BINS ) :: cmass_stem_bin ! biomass by height bin REAL ( dp ), DIMENSION ( HEIGHT_BINS ) :: densindiv_bin ! density by height bin REAL ( dp ), DIMENSION ( HEIGHT_BINS ) :: height_bin ! mean height in each bin REAL ( dp ), DIMENSION ( HEIGHT_BINS ) :: diameter_bin ! mean diameter in each bin CHARACTER ( 100 ), DIMENSION ( HEIGHT_BINS ) :: bin_labels ! text strings for bin bounds REAL ( dp ) :: cmass_sum ! landscape biomass REAL ( dp ) :: cmass_sum_old ! landscape biomass REAL ( dp ) :: cheartwood_sum ! landscape biomass (heart wood) REAL ( dp ) :: csapwood_sum ! landscape biomass (sap wood) REAL ( dp ) :: csapwood_sum_old ! landscape biomass REAL ( dp ) :: densindiv ! landscape density of individuals REAL ( dp ) :: height_mean REAL ( dp ) :: height_max REAL ( dp ) :: basal_area REAL ( dp ) :: sapwood_loss ! (kg C m-2 y-1) ! total sapwood loss (turnover + mortality) REAL ( dp ) :: sapwood_area_loss ! ( m2/m-2 y-1) sapwood area loss (mortality only) REAL ( dp ) :: stress_mortality ! (kg C m-2 y-1) REAL ( dp ) :: crowding_mortality ! (kg C m-2 y-1) REAL ( dp ) :: fire_mortality ! (kg C m-2 y-1) REAL ( dp ) :: cat_mortality ! (kg C m-2 y-1) REAL ( dp ) :: res_mortality ! (kg C m-2 y-1) REAL ( dp ) :: growth REAL ( dp ) :: area_growth ! m2/ha REAL ( dp ) :: crown_cover REAL ( dp ) :: crown_area REAL ( dp ) :: crown_volume REAL ( dp ) :: sapwood_area REAL ( dp ) :: sapwood_area_old REAL ( dp ) :: Kclump ! clumping factor INTEGER ( i4b ) :: npatch_active INTEGER ( i4b ) :: LU REAL ( dp ) :: smoothing_buffer REAL ( dp ) :: smoothing_buffer_cat REAL ( dp ) :: fire_mortality_smoothed REAL ( dp ) :: cat_mortality_smoothed REAL ( dp ), DIMENSION ( NYEAR_HISTORY ) :: fire_mortality_history REAL ( dp ), DIMENSION ( NYEAR_HISTORY ) :: cat_mortality_history REAL ( dp ), DIMENSION ( AGEMAX ) :: freq_age ! age weighting (by age in y: 0:AGE_MAX-1) REAL ( dp ), DIMENSION ( AGEMAX ) :: biomass_age END TYPE Landscape TYPE POP_TYPE TYPE ( Landscape ), DIMENSION (:), ALLOCATABLE :: pop_grid INTEGER , DIMENSION (:), Allocatable :: it_pop INTEGER :: np INTEGER , DIMENSION (:), Allocatable :: Iwood ! , LU END TYPE POP_TYPE END MODULE POP_Types !******************************************************************************* MODULE POPModule !------------------------------------------------------------------------------- ! * This module contains all subroutines for POP calcs at a single time step. !------------------------------------------------------------------------------- USE TYPEdef , ONLY : sp , i4b USE POP_Types USE POP_Constants IMPLICIT NONE CONTAINS !******************************************************************************* SUBROUTINE ZeroPOP ( POP , n ) #ifdef __MPI__ use mpi , only : MPI_Abort #endif IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP INTEGER , OPTIONAL , INTENT ( IN ) :: n INTEGER :: g , k , l , c , np , a , b #ifdef __MPI__ integer :: ierr #endif IF (. NOT . ALLOCATED ( pop % pop_grid )) THEN WRITE ( * , * ) \" POP not allocated! Abort in ZeroPOP.\" #ifdef __MPI__ call MPI_Abort ( 0 , 84 , ierr ) ! Do not know comm nor rank here #else stop 84 #endif ENDIF np = SIZE ( pop % pop_grid ) ! optional integer n intended for zeroing secondary forest tiles IF ( PRESENT ( n )) THEN a = n b = n !pop%LU(n) = 2 POP % pop_grid ( n )% LU = 2 ELSE a = 1 b = np !pop%LU = 1 POP % pop_grid % LU = 1 endif DO g = a , b POP % pop_grid ( g )% freq = 0.0_dp ! patch weighting POP % pop_grid ( g )% freq_old = 0.0_dp ! patch weighting POP % pop_grid ( g )% fire_freq = 0.0_dp POP % pop_grid ( g )% fire_freq_old = 0.0_dp POP % pop_grid ( g )% cat_freq = 0.0_dp POP % pop_grid ( g )% cat_freq_old = 0.0_dp POP % pop_grid ( g )% freq_ranked_age_unique = 0.0_dp POP % pop_grid ( g )% ranked_age_unique = 0 POP % pop_grid ( g )% n_age = 0 POP % pop_grid ( g )% biomass = 0.0_dp ! landscape stem biomass (weighted mean over patches) POP % pop_grid ( g )% density = 0.0_dp ! landscape tree density (weighted mean over patches) POP % pop_grid ( g )% hmean = 0.0_dp ! landscape mean treen height (weighted mean over patches) POP % pop_grid ( g )% hmax = 0.0_dp ! landscape max tree height POP % pop_grid ( g )% cmass_stem_bin = 0.0_dp ! biomass by height bin POP % pop_grid ( g )% densindiv_bin = 0.0_dp ! density by height bin POP % pop_grid ( g )% height_bin = 0.0_dp ! mean height in each bin POP % pop_grid ( g )% diameter_bin = 0.0_dp ! mean diameter in each bin POP % pop_grid ( g )% bin_labels = ' ' ! text strings for bin bounds POP % pop_grid ( g )% cmass_sum = 0.0_dp ! landscape biomass POP % pop_grid ( g )% cmass_sum_old = 0.0_dp ! landscape biomass POP % pop_grid ( g )% cheartwood_sum = 0.0_dp ! landscape biomass POP % pop_grid ( g )% csapwood_sum = 0.0_dp ! landscape biomass POP % pop_grid ( g )% csapwood_sum_old = 0.0_dp ! landscape biomass POP % pop_grid ( g )% densindiv = 0.0_dp ! landscape density of individuals POP % pop_grid ( g )% height_mean = 0.0_dp POP % pop_grid ( g )% height_max = 0.0_dp POP % pop_grid ( g )% basal_area = 0.0_dp POP % pop_grid ( g )% sapwood_loss = 0.0_dp POP % pop_grid ( g )% sapwood_area_loss = 0.0_dp POP % pop_grid ( g )% stress_mortality = 0.0_dp ! (kg C m-2 y-1) POP % pop_grid ( g )% crowding_mortality = 0.0_dp ! (kg C m-2 y-1) POP % pop_grid ( g )% fire_mortality = 0.0_dp ! (kg C m-2 y-1) POP % pop_grid ( g )% cat_mortality = 0.0_dp ! (kg C m-2 y-1) POP % pop_grid ( g )% res_mortality = 0.0_dp ! (kg C m-2 y-1) POP % pop_grid ( g )% growth = 0.0_dp POP % pop_grid ( g )% area_growth = 0.0_dp POP % pop_grid ( g )% crown_cover = 0.0_dp POP % pop_grid ( g )% crown_area = 0.0_dp POP % pop_grid ( g )% crown_volume = 0.0_dp POP % pop_grid ( g )% sapwood_area = 0.0_dp POP % pop_grid ( g )% sapwood_area_old = 0.0_dp POP % pop_grid ( g )% Kclump = 1.0_dp POP % pop_grid ( g )% npatch_active = 0 POP % pop_grid ( g )% smoothing_buffer = 0.0_dp POP % pop_grid ( g )% smoothing_buffer_cat = 0.0_dp POP % pop_grid ( g )% fire_mortality_smoothed = 0.0_dp POP % pop_grid ( g )% cat_mortality_smoothed = 0.0_dp POP % pop_grid ( g )% fire_mortality_history = 0.0_dp POP % pop_grid ( g )% cat_mortality_history = 0.0_dp POP % pop_grid ( g )% freq_age = 0.0_dp IF ( PRESENT ( n )) THEN POP % pop_grid ( g )% freq_age ( 1 ) = 1.0_dp ENDIF POP % pop_grid ( g )% biomass_age = 0.0_dp DO k = 1 , NPATCH2D POP % pop_grid ( g )% patch ( k )% factor_recruit = 0.0_dp POP % pop_grid ( g )% patch ( k )% pgap = 0.0_dp POP % pop_grid ( g )% patch ( k )% lai = 0.0_dp POP % pop_grid ( g )% patch ( k )% biomass = 0.0_dp ! total biomass in patch POP % pop_grid ( g )% patch ( k )% biomass_old = 0.0_dp POP % pop_grid ( g )% patch ( k )% sapwood = 0.0_dp ! total biomass in patch (sapwood) POP % pop_grid ( g )% patch ( k )% heartwood = 0.0_dp ! total biomass in patch (heartwood) POP % pop_grid ( g )% patch ( k )% sapwood_old = 0.0_dp POP % pop_grid ( g )% patch ( k )% sapwood_area = 0.0_dp POP % pop_grid ( g )% patch ( k )% sapwood_area_old = 0.0_dp POP % pop_grid ( g )% patch ( k )% stress_mortality = 0.0_dp ! biomass lost in each patch due to stress POP % pop_grid ( g )% patch ( k )% fire_mortality = 0.0_dp ! biomass lost in each patch due to fire partial dist POP % pop_grid ( g )% patch ( k )% cat_mortality = 0.0_dp ! biomass lost in each patch due to fire partial dist POP % pop_grid ( g )% patch ( k )% crowding_mortality = 0.0_dp POP % pop_grid ( g )% patch ( k )% cpc = 0.0_dp POP % pop_grid ( g )% patch ( k )% mortality = 0.0_dp POP % pop_grid ( g )% patch ( k )% sapwood_loss = 0.0_dp POP % pop_grid ( g )% patch ( k )% sapwood_area_loss = 0.0_dp POP % pop_grid ( g )% patch ( k )% growth = 0.0_dp ! biomass growth in each patch due stem increment POP % pop_grid ( g )% patch ( k )% area_growth = 0.0_dp POP % pop_grid ( g )% patch ( k )% disturbance_interval = 0 ! prescribed disturbance(s) interval for this patch POP % pop_grid ( g )% patch ( k )% first_disturbance_year = 0 POP % pop_grid ( g )% patch ( k )% age = 0 ! number of years since last disturbance(s) POP % pop_grid ( g )% patch ( k )% id = 0 POP % pop_grid ( g )% patch ( k )% frac_NPP = 0.0_dp POP % pop_grid ( g )% patch ( k )% frac_respiration = 0.0_dp POP % pop_grid ( g )% patch ( k )% frac_light_uptake = 0.0_dp POP % pop_grid ( g )% patch ( k )% fire_top_kill_density = 0.0_dp DO l = 1 , NLAYER POP % pop_grid ( g )% patch ( k )% Layer ( L )% ncohort = 0 ! number of cohorts with density >0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% biomass = 0.0_dp ! layer biomass POP % pop_grid ( g )% patch ( k )% Layer ( L )% density = 0.0_dp ! layer tree density POP % pop_grid ( g )% patch ( k )% Layer ( L )% hmean = 0.0_dp ! layer mean tree height (weighted mean over patches) POP % pop_grid ( g )% patch ( k )% Layer ( L )% hmax = 0.0_dp ! layer max tree height DO c = 1 , NCOHORT_MAX POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% id = 0 POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% age = 0 ! cohort age POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% biomass = 0.0_dp ! cohort biomass ! landscape tree density (weighted mean over patches) POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% density = 0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% frac_resource_uptake = 0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% frac_light_uptake = 0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% frac_interception = 0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% frac_respiration = 0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% frac_NPP = 0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% respiration_scalar = 0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% crown_area = 0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% Pgap = 0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% height = 0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% diameter = 0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% sapwood = 0.0_dp ! cohort sapwood POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% heartwood = 0.0_dp ! cohort heartwood POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% sapwood_area = 0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% basal_area = 0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% LAI = 0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% Cleaf = 0.0_dp POP % pop_grid ( g )% patch ( k )% Layer ( L )% cohort ( c )% Croot = 0.0_dp ENDDO ! NCOHORT_MAX ENDDO ! NLAYER ENDDO ! NPATCH2D ENDDO ! pop_grid%np END SUBROUTINE ZeroPOP !******************************************************************************* SUBROUTINE InitPOP2D_Poisson ( POP , mean_disturbance_interval , m ) ! Initialises vector of patches with maximum age correpondding to 95% of pdf ! Starting year: uniform distribution up to maximum age IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP INTEGER ( i4b ), INTENT ( IN ) :: mean_disturbance_interval (:,:) INTEGER ( i4b ), INTENT ( IN ), optional :: m INTEGER ( i4b ) :: j , k , g , ipatch , idist , p , c , i INTEGER ( i4b ) :: disturbance_interval INTEGER ( i4b ) :: Poisson_age ( 1000 ) REAL ( dp ) :: Poisson_weight ( 1000 ), CumPoisson_weight ( 1000 ) INTEGER :: i_max INTEGER :: np REAL ( dp ) :: disturbance_freq INTEGER :: tmp2 ( PATCH_REPS1 ), tmp3 ( PATCH_REPS2 ) INTEGER :: a , b np = SIZE ( POP % pop_grid ) a = 1 b = np IF ( PRESENT ( m )) THEN a = m b = m ENDIF DO g = a , b ! calculate Poisson weights for each of the 2 mean disturbance intervals IF ( NPATCH . gt . 1 ) THEN DO idist = 1 , NDISTURB disturbance_freq = 1.0_dp / REAL ( mean_disturbance_interval ( g , idist ), dp ) DO p = 1 , 1000 Poisson_age ( p ) = p Poisson_weight ( p ) = Exponential ( disturbance_freq , p ) CumPoisson_weight ( p ) = CumExponential ( disturbance_freq , REAL ( p , dp )) ENDDO ! set max age to correspond to 95% percentile of cum pdf DO k = 1 , NPATCH2D i_max = MAXLOC ( Poisson_age , 1 , CumPoisson_weight . LE . 0.95_dp ) POP % pop_grid ( g )% patch ( k )% disturbance_interval ( idist ) = Poisson_age ( i_max ) POP % pop_grid ( g )% patch ( k )% id = k POP % pop_grid ( g )% patch ( k )% age = 0 ENDDO ENDDO DO idist = 1 , ndisturb ! set first disturbance year for first dist interval class if ( idist . eq . 1 ) then disturbance_interval = POP % pop_grid ( g )% patch ( 1 )% disturbance_interval ( idist ) DO c = 1 , PATCH_REPS1 if ( c == 1 ) then tmp2 ( 1 ) = 1 else tmp2 ( 1 ) = max ( disturbance_interval * ( c - 1 ) / ( PATCH_REPS1 ), 1 ) + 1 endif tmp2 ( 2 ) = max ( disturbance_interval * c / ( PATCH_REPS1 ), 1 ) tmp2 ( 3 ) = tmp2 ( 1 ) !    write(*,*) 'tmp2', c, disturbance_interval, tmp2(1),tmp2(2) DO j = 1 , PATCH_REPS2 ipatch = ( c - 1 ) * PATCH_REPS2 + j POP % pop_grid ( g )% patch ( ipatch )% first_disturbance_year ( idist ) = tmp2 ( 3 ) tmp2 ( 3 ) = tmp2 ( 3 ) + 1 if ( tmp2 ( 3 ) > tmp2 ( 2 )) then tmp2 ( 3 ) = tmp2 ( 1 ) ENDIF ENDDO ENDDO ! ! set first disturbance year for first dist interval class ! idist = 1 ! disturbance_interval = POP%pop_grid(g)%patch(1)%disturbance_interval(idist) ! DO c = 1,PATCH_REPS1 !    tmp2(c) = max(disturbance_interval*c/(PATCH_REPS1),1) ! ENDDO ! DO c = 1,PATCH_REPS1 !    i = 0 !    DO j = 1,PATCH_REPS2 !       ipatch = (j-1)*PATCH_REPS1 + c !       i = i+1 !       IF (i.gt.PATCH_REPS1) then !          i = 1 !       ENDIF !       do while ((tmp2(i+1).eq. tmp2(i)).and.(i.lt.PATCH_REPS1)) !          i = i+1 !          IF (i.gt.PATCH_REPS1) then !             i = 1 !          ENDIF !       ENDDO !       write(*,*) i, tmp2(i) !       POP%pop_grid(g)%patch(ipatch)%first_disturbance_year(idist) = tmp2(i) !    ENDDO ! ENDDO ! set first disturbance year for first 2nd interval class ELSEIF ( idist . eq . 2 ) then disturbance_interval = POP % pop_grid ( g )% patch ( 1 )% disturbance_interval ( idist ) DO c = 1 , PATCH_REPS2 tmp3 ( c ) = max ( disturbance_interval * ( c - 1 ) / ( PATCH_REPS2 ), 1 ) ENDDO DO c = 1 , PATCH_REPS2 i = 0 DO j = 1 , PATCH_REPS1 ipatch = ( j - 1 ) * PATCH_REPS2 + c POP % pop_grid ( g )% patch ( ipatch )% first_disturbance_year ( idist ) = & tmp3 ( c ) + ( j - 1 ) * max (( tmp3 ( idist ) - tmp3 ( 1 )) / PATCH_REPS1 , 1 ) !  i = i+1 !  if (i.gt.(tmp3(2)-tmp3(1))) i = 0 ENDDO ENDDO ENDIF ENDDO ELSE ! NPATCH =1 (single patch mode) k = 1 DO idist = 1 , NDISTURB POP % pop_grid ( g )% patch ( k )% disturbance_interval ( idist ) = mean_disturbance_interval ( g , idist ) POP % pop_grid ( g )% patch ( k )% first_disturbance_year ( idist ) = 113 POP % pop_grid ( g )% patch ( k )% age = 0 POP % pop_grid ( g )% patch ( k )% id = k ENDDO ENDIF POP % pop_grid ( g )% npatch_active = NPATCH ENDDO END SUBROUTINE InitPOP2D_Poisson !******************************************************************************* SUBROUTINE POPStep ( POP , StemNPP , disturbance_interval , disturbance_intensity , LAI , Cleaf , Croot , & NPPtoGPP , StemNPP_av , frac_intensity1 , precip ) IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP REAL ( dp ), INTENT ( IN ) :: StemNPP (:,:) REAL ( dp ), INTENT ( IN ) :: disturbance_intensity (:,:) INTEGER ( i4b ), INTENT ( IN ) :: disturbance_interval (:,:) REAL ( dp ), INTENT ( IN ) :: LAI (:) REAL ( dp ), INTENT ( IN ) :: Cleaf (:) REAL ( dp ), INTENT ( IN ) :: Croot (:) REAL ( dp ), INTENT ( IN ) :: NPPtoGPP (:) REAL ( dp ), INTENT ( IN ), OPTIONAL :: frac_intensity1 (:), precip (:) REAL ( dp ), INTENT ( IN ), OPTIONAL :: StemNPP_av (:) INTEGER ( i4b ) :: idisturb , np , g INTEGER ( i4b ), allocatable :: it (:) !INTEGER, INTENT(IN) :: wlogn pop % it_pop = pop % it_pop + 1 !it = pop%it_pop(1) np = SIZE ( POP % POP_grid ) allocate ( it ( np )) do g = 1 , np it ( g ) = maxval ( pop % pop_grid ( g )% patch (:)% age ( 1 )) + 1 enddo ! DO idisturb = 1,NDISTURB !    CALL GetUniqueAgeFrequencies(POP, disturbance_interval, idisturb) ! ENDDO ! CALL GetPatchFrequencies(POP) !call flush(wlogn) IF ( PRESENT ( precip )) THEN IF ( PRESENT ( StemNPP_av )) THEN CALL PatchAnnualDynamics ( POP , StemNPP , NPPtoGPP , it , precip = precip , StemNPP_av = StemNPP_av ) ELSE CALL PatchAnnualDynamics ( POP , StemNPP , NPPtoGPP , it , precip = precip ) ENDIF ELSE IF ( PRESENT ( StemNPP_av )) THEN CALL PatchAnnualDynamics ( POP , StemNPP , NPPtoGPP , it , StemNPP_av = StemNPP_av ) ELSE CALL PatchAnnualDynamics ( POP , StemNPP , NPPtoGPP , it ) ENDIF ENDIF IF ( NDISTURB . EQ . 1 ) THEN IF ( PRESENT ( precip )) THEN !   CALL Patch_disturb(POP,it,1,precip) CALL Patch_partial_disturb2 ( POP , 1 ) ELSE CALL Patch_disturb ( POP , 1 ) ! CALL Patch_partial_disturb2(POP,it) ENDIF ELSEIF ( NDISTURB . EQ . 2 ) THEN IF ( PRESENT ( frac_intensity1 )) THEN CALL Patch_partial_disturb ( POP , 1 , disturbance_intensity , frac_intensity1 = frac_intensity1 ) ELSE CALL Patch_partial_disturb ( POP , 1 , disturbance_intensity ) ENDIF IF ( PRESENT ( precip )) THEN !CALL Patch_partial_disturb2(POP,it,2) CALL Patch_disturb ( POP , 2 , precip ) ELSE ! CALL Patch_partial_disturb2(POP,it,2) CALL Patch_disturb ( POP , 2 ) ENDIF ENDIF DO idisturb = 1 , NDISTURB CALL GetUniqueAgeFrequencies ( POP , disturbance_interval , idisturb ) ENDDO CALL GetPatchFrequencies ( POP ) IF ( PRESENT ( precip )) THEN CALL GetDiagnostics ( pop , LAI , Cleaf , Croot , disturbance_interval , it , precip ) ELSE CALL GetDiagnostics ( pop , LAI , Cleaf , Croot , disturbance_interval , it ) ENDIF END SUBROUTINE POPStep !******************************************************************************* SUBROUTINE PatchAnnualDynamics ( pop , StemNPP , NPPtoGPP , it , StemNPP_av , precip ) IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: pop REAL ( dp ), INTENT ( IN ) :: StemNPP (:,:) REAL ( dp ), INTENT ( IN ) :: NPPtoGPP (:) REAL ( dp ), INTENT ( IN ), OPTIONAL :: precip (:) REAL ( dp ), OPTIONAL , INTENT ( IN ) :: StemNPP_av (:) INTEGER ( i4b ), INTENT ( IN ) :: it (:) REAL ( dp ) :: densindiv REAL ( dp ) :: tmp , tmp_light , tmp_respiration , tmp_fracnpp , cmass_stem_inc INTEGER ( i4b ) :: j , k , c , idist INTEGER ( i4b ) :: ivec ( NCOHORT_MAX ), nc , np REAL ( dp ) :: growth_efficiency , cmass_stem REAL ( dp ) :: mort REAL ( dp ) :: cpc , crown_area REAL ( dp ) :: mort_cpc REAL ( dp ) :: ht , diam , area_growth_grid , basal_grid , basal_new , basal_old REAL ( dp ) :: tmp2 ( NCOHORT_MAX ), freq np = SIZE ( POP % POP_grid ) ! growth ! Distributes layer biomass increment among cohorts and increments age ! calculate fractional resource uptake by each cohort DO j = 1 , np basal_grid = 0.0_dp area_growth_grid = 0.0_dp pop % pop_grid ( j )% sapwood_area_old = pop % pop_grid ( j )% sapwood_area pop % pop_grid ( j )% freq_old = pop % pop_grid ( j )% freq pop % pop_grid ( j )% fire_freq_old = pop % pop_grid ( j )% fire_freq pop % pop_grid ( j )% cat_freq_old = pop % pop_grid ( j )% cat_freq ! Get fraction allocation for each patch tmp = 0.0_dp tmp_light = 0.0_dp tmp_respiration = 0.0_dp tmp_fracNPP = 0.0_dp if ( NPATCH2D > 1 . and . it ( j ) > 1 . and . RESOURCE_SWITCH > 0 ) then DO k = 1 , NPATCH2D freq = pop % pop_grid ( j )% freq ( pop % pop_grid ( j )% patch ( k )% id ) nc = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort DO c = 1 , nc pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_light_uptake = & pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% frac_interception ! defined in terms of Pgap ! total autotrophic resp, summed over all cohorts and patches tmp_respiration = tmp_respiration + & freq * pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% respiration_scalar ENDDO tmp_light = tmp_light + freq * ( 1.0_dp - pop % pop_grid ( j )% patch ( k )% Pgap ) ENDDO IF ( tmp_respiration . gt . 1.0e-8_dp . and . tmp_light . gt . 1.0e-8_dp ) then DO k = 1 , NPATCH2D ! fraction respiration and un-normalised NPP for each patch nc = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort freq = pop % pop_grid ( j )% freq ( pop % pop_grid ( j )% patch ( k )% id ) ! frac autotrophic resp pop % pop_grid ( j )% patch ( k )% frac_respiration = & sum ( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : nc )% respiration_scalar ) / tmp_respiration ! frac gpp pop % pop_grid ( j )% patch ( k )% frac_light_uptake = & ( 1.0_dp - pop % pop_grid ( j )% patch ( k )% pgap ) / tmp_light ! frac npp pop % pop_grid ( j )% patch ( k )% frac_NPP = & max ( pop % pop_grid ( j )% patch ( k )% frac_light_uptake * ( 1.0_dp / NPPtoGPP ( j )) - & pop % pop_grid ( j )% patch ( k )% frac_respiration * ( 1.0_dp / NPPtoGPP ( j ) - 1.0_dp ), 0.0_dp ) tmp_fracNPP = tmp_fracNPP + freq * pop % pop_grid ( j )% patch ( k )% frac_NPP ENDDO ! normalised fraction NPP DO k = 1 , NPATCH2D pop % pop_grid ( j )% patch ( k )% frac_NPP = & pop % pop_grid ( j )% patch ( k )% frac_NPP / tmp_fracNPP ENDDO ELSE pop % pop_grid ( j )% patch (:)% frac_NPP = 1.0_dp pop % pop_grid ( j )% patch (:)% frac_respiration = 1.0_dp pop % pop_grid ( j )% patch (:)% frac_light_uptake = 1.0_dp ENDIF else pop % pop_grid ( j )% patch (:)% frac_NPP = 1.0_dp pop % pop_grid ( j )% patch (:)% frac_respiration = 1.0_dp pop % pop_grid ( j )% patch (:)% frac_light_uptake = 1.0_dp endif ! End Get fraction allocation for each patch ! Get fraction allocation for each cohort in each patch DO k = 1 , NPATCH2D tmp = 0.0_dp tmp_light = 0.0_dp tmp_respiration = 0.0_dp tmp_fracNPP = 0.0_dp if ( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort > 1 ) then nc = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort DO c = 1 , pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort cmass_stem = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% biomass densindiv = pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% density ! get initial basal area IF ( PRESENT ( precip ) ) THEN CALL GET_ALLOMETRY ( ALLOM_SWITCH , cmass_stem , densindiv , ht , diam , basal_old , precip ( j )) ELSE CALL GET_ALLOMETRY ( ALLOM_SWITCH , cmass_stem , densindiv , ht , diam , basal_old ) ENDIF if ( ALLOM_SWITCH . eq . 1 ) then !! assumes crown radius (m) = 0.1492 * dbh (cm) (from G. Cook, pers. comm.) crown_area = densindiv * PI * ( diam * 10 0.0_dp * 0.1492_dp ) ** 2 else crown_area = densindiv * PI * ((( k_allom1 * diam ** k_rp ) / PI ) ** 0.5_dp ) ** 2 endif tmp = tmp + ( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% biomass / & ! sum over all cohorts pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% density ) ** POWERbiomass * & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% density tmp_light = tmp_light + pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_interception tmp_respiration = tmp_respiration + pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% respiration_scalar tmp2 ( c ) = sum (( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c : nc )% biomass / & ! sum over all cohorts c:nc pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c : nc )% density ) ** POWERbiomass * & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c : nc )% density ) ENDDO ! un-normalised fractional gross resource uptake: weighted combination of components ! where cohort competes with older cohorts and where it does not DO c = 1 , pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort if ( RESOURCE_SWITCH == 1 ) then pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_interception = & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_interception / tmp_light else pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_interception = 1.0_dp endif ENDDO !normalised fractional gross resource uptake nc = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort DO c = 1 , pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort !normalised fractional gross resource uptake pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_light_uptake = & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_interception / & sum ( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : nc )% frac_interception ) ENDDO ! fraction respiration and un-normalised NPP DO c = 1 , pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_respiration = & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% respiration_scalar / tmp_respiration pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_NPP = & max ( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_light_uptake * ( 1.0_dp / NPPtoGPP ( j )) - & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_respiration * ( 1.0_dp / NPPtoGPP ( j ) - 1.0_dp ), 0.0_dp ) tmp_fracNPP = tmp_fracNPP + pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_NPP ENDDO ! normalised fraction NPP DO c = 1 , pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_NPP = & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_NPP / tmp_fracNPP ENDDO ! fraction net resource uptake DO c = 1 , pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort if ( RESOURCE_SWITCH == 0 ) then ! default net fraction resource uptake pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_resource_uptake = & ( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% biomass / & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% density ) ** POWERbiomass * & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% density / tmp elseif ( RESOURCE_SWITCH == 1 ) then ! fraction net resource uptake = fraction NPP pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_resource_uptake = & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_NPP * & pop % pop_grid ( j )% patch ( k )% frac_NPP endif ENDDO else c = 1 pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_NPP = 1 tmp_fracNPP = 1 pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_respiration = 1 pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_light_uptake = 1 pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_resource_uptake = 1 if ( RESOURCE_SWITCH == 1 ) then pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_resource_uptake = pop % pop_grid ( j )% patch ( k )% frac_NPP endif endif ENDDO tmp = 0 DO k = 1 , NPATCH2D pop % pop_grid ( j )% patch ( k )% sapwood_loss = 0.0_dp pop % pop_grid ( j )% patch ( k )% sapwood_area_loss = 0.0_dp pop % pop_grid ( j )% patch ( k )% sapwood_old = pop % pop_grid ( j )% patch ( k )% sapwood pop % pop_grid ( j )% patch ( k )% sapwood_area_old = pop % pop_grid ( j )% patch ( k )% sapwood_area pop % pop_grid ( j )% patch ( k )% biomass_old = pop % pop_grid ( j )% patch ( k )% biomass pop % pop_grid ( j )% patch ( k )% growth = 0.0_dp pop % pop_grid ( j )% patch ( k )% area_growth = 0.0_dp nc = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort freq = pop % pop_grid ( j )% freq ( pop % pop_grid ( j )% patch ( k )% id ) DO c = 1 , pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort cmass_stem = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% biomass densindiv = pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% density ! get initial basal area IF ( PRESENT ( precip ) ) THEN CALL GET_ALLOMETRY ( ALLOM_SWITCH , cmass_stem , densindiv , ht , diam , basal_old , precip ( j )) ELSE CALL GET_ALLOMETRY ( ALLOM_SWITCH , cmass_stem , densindiv , ht , diam , basal_old ) ENDIF ! increment biomass in cohort pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% biomass = & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% biomass + & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_resource_uptake * StemNPP ( j , 1 ) cmass_stem = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% biomass tmp = tmp + freq * pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_resource_uptake ! get incremented basal area IF ( PRESENT ( precip ) ) THEN CALL GET_ALLOMETRY ( ALLOM_SWITCH , cmass_stem , densindiv , ht , diam , basal_new , precip ( j )) ELSE CALL GET_ALLOMETRY ( ALLOM_SWITCH , cmass_stem , densindiv , ht , diam , basal_new ) ENDIF ! increment sapwood in cohort pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood = & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood + & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_resource_uptake * StemNPP ( j , 1 ) ! increment heartwood in cohort pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% heartwood = & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% heartwood + & ksapwood * pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood ! keep track of patch-level sapwood loss pop % pop_grid ( j )% patch ( k )% sapwood_loss = pop % pop_grid ( j )% patch ( k )% sapwood_loss + & ksapwood * pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood ! decrease sapwood in cohort (accounting for loss to heartwood) pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood = & ( 1.0_dp - ksapwood ) * pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood !if ( pop%pop_grid(j)%patch(k)%Layer(1)%cohort(c)%density.gt.1e-9) then ! patch biomass increment pop % pop_grid ( j )% patch ( k )% growth = pop % pop_grid ( j )% patch ( k )% growth + & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_resource_uptake * StemNPP ( j , 1 ) ! patch sapwood area increment pop % pop_grid ( j )% patch ( k )% area_growth = pop % pop_grid ( j )% patch ( k )% area_growth + & basal_new - basal_old !  endif ! increment cohort age pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% age = & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% age + 1 ENDDO ! Layer biomass (summed over cohorts) nc = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% biomass = SUM ( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : nc )% biomass ) ENDDO ENDDO ! Mortality !Implements resource stress mortality and crowding mortality for all cohorts in layer DO j = 1 , np DO k = 1 , NPATCH2D nc = 0 ivec = 0 pop % pop_grid ( j )% patch ( k )% stress_mortality = 0.0_dp pop % pop_grid ( j )% patch ( k )% crowding_mortality = 0.0_dp pop % pop_grid ( j )% patch ( k )% mortality = 0.0_dp crown_area = 0.0_dp DO c = 1 , pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort cmass_stem = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% biomass cmass_stem_inc = StemNPP ( j , 1 ) * pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_resource_uptake if ( present ( StemNPP_av )) then growth_efficiency = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% frac_resource_uptake * & StemNPP_av ( j ) / ( cmass_stem ** ( POWERGrowthEfficiency )) else growth_efficiency = cmass_stem_inc / ( cmass_stem ** ( POWERGrowthEfficiency )) endif ! growth_efficiency=cmass_stem_inc/(pop%pop_grid(j)%patch(k)%Layer(1)%cohort(c)%sapwood**(POWERGrowthEfficiency)) mort = MORT_MAX / ( 1.0_dp + ( growth_efficiency / GROWTH_EFFICIENCY_MIN ) ** Pmort ) ! mort = 0 ! test pop % pop_grid ( j )% patch ( k )% stress_mortality = pop % pop_grid ( j )% patch ( k )% stress_mortality & + mort * cmass_stem IF ( pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% diameter * 100_dp . GT . 1.0_dp ) THEN if ( ALLOM_SWITCH . eq . 1 ) then ! assumes crown radius (m) = 0.14 * dbh (cm) crown_area = crown_area + pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% density * & PI * ( pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% diameter * 10 0.0_dp * 0.14_dp ) ** 2 else crown_area = crown_area + pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% density * & k_allom1 * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% diameter ** k_rp endif ELSE crown_area = crown_area + 0.5_dp * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% LAI ENDIF cpc = 1.0_dp - exp ( - crown_area ) pop % pop_grid ( j )% patch ( k )% cpc = cpc if ( cpc . gt . 1.0e-3_dp . and . alpha_cpc * ( 1.0_dp - 1.0_dp / cpc ). gt . - 5 0.0_dp ) then mort_cpc = exp ( alpha_cpc * ( 1.0_dp - 1.0_dp / cpc )) else mort_cpc = 0.0_dp endif !mort_cpc = 0 ! test pop % pop_grid ( j )% patch ( k )% crowding_mortality = pop % pop_grid ( j )% patch ( k )% crowding_mortality + & min (( mort_cpc * CrowdingFactor ), cmass_stem_inc / cmass_stem ) * cmass_stem pop % pop_grid ( j )% patch ( k )% mortality = pop % pop_grid ( j )% patch ( k )% mortality + & mort * cmass_stem pop % pop_grid ( j )% patch ( k )% sapwood_loss = pop % pop_grid ( j )% patch ( k )% sapwood_loss + & mort * pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood pop % pop_grid ( j )% patch ( k )% sapwood_area_loss = pop % pop_grid ( j )% patch ( k )% sapwood_area_loss + & mort * pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood_area pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% biomass = cmass_stem * ( 1.0_dp - mort ) pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% heartwood = & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% heartwood * ( 1.0_dp - mort ) pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood = & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood * ( 1.0_dp - mort ) pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% density = & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% density * ( 1.0_dp - mort ) IF ( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% density . LT . DENSINDIV_MIN ) THEN ! remove cohort pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% density = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% id = 0 pop % pop_grid ( j )% patch ( k )% stress_mortality = pop % pop_grid ( j )% patch ( k )% stress_mortality + & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% biomass pop % pop_grid ( j )% patch ( k )% sapwood_loss = pop % pop_grid ( j )% patch ( k )% sapwood_loss + & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood pop % pop_grid ( j )% patch ( k )% sapwood_area_loss = pop % pop_grid ( j )% patch ( k )% sapwood_area_loss + & pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood_area pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% biomass = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% heartwood = 0.0_dp ELSE pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% id = 1 !COMMLN Why is id here 1 instead of c or sth useful? Call it differently nc = nc + 1 ivec ( nc ) = c ENDIF ENDDO ! SHUFFLE if necessary to remove zero-density cohorts IF ( nc . LT . pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort ) THEN pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : nc ) = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( ivec ( 1 : nc )) pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort = nc pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% density = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% id = 0 pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% biomass = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% sapwood = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% sapwood_area = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% basal_area = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% heartwood = 0.0_dp ENDIF ! Layer biomass (summed over cohorts) nc = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% biomass = SUM ( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : nc )% biomass ) ENDDO ENDDO ! recruitment IF ( PRESENT ( precip )) THEN CALL layer_recruitment ( pop , precip ) ELSE CALL layer_recruitment ( pop ) ENDIF ! Update time since last patch disturbance DO j = 1 , np DO k = 1 , NPATCH2D DO idist = 1 , NDISTURB pop % pop_grid ( j )% patch ( k )% age ( idist ) = pop % pop_grid ( j )% patch ( k )% age ( idist ) + 1 ENDDO ENDDO ENDDO END SUBROUTINE PatchAnnualDynamics !******************************************************************************* SUBROUTINE GetUniqueAgeFrequencies ( pop , disturbance_interval , idisturb ) IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP INTEGER ( i4b ), INTENT ( IN ) :: disturbance_interval (:,:), idisturb INTEGER ( i4b ) :: g , i , j , k , agecopy , idcopy REAL ( dp ), ALLOCATABLE :: midpoint (:) INTEGER ( i4b ), ALLOCATABLE :: ranked_age (:), ranked_age_init (:) INTEGER ( i4b ) :: age_tmp INTEGER ( i4b ), ALLOCATABLE :: ranked_age_unique_id (:), ranked_age_id (:), counter (:) REAL ( dp ), ALLOCATABLE :: tmp (:), freq_tmp (:), freq_tmp1 (:) REAL ( dp ) :: freq INTEGER ( i4b ) :: n_age ! number of unique ages INTEGER ( i4b ) :: npatch_active ! number of active patches REAL ( dp ) :: disturbance_freq INTEGER ( i4b ) :: i_max , Poisson_age ( 1000 ), np REAL ( dp ) :: CumPoisson_weight ( 1000 ) INTEGER ( i4b ), ALLOCATABLE :: bound (:,:), unique_age (:) !Fills array freq with weights (frequencies across landscape) for each unique age ! given specified mean disturbance interval np = SIZE ( POP % POP_grid ) DO g = 1 , np npatch_active = NPATCH2D IF (. NOT . ALLOCATED ( midpoint )) ALLOCATE ( midpoint ( npatch_active )) IF (. NOT . ALLOCATED ( counter )) ALLOCATE ( counter ( npatch_active )) IF (. NOT . ALLOCATED ( ranked_age )) ALLOCATE ( ranked_age ( npatch_active )) IF (. NOT . ALLOCATED ( ranked_age_init )) ALLOCATE ( ranked_age_init ( npatch_active )) IF (. NOT . ALLOCATED ( ranked_age_id )) ALLOCATE ( ranked_age_id ( npatch_active )) IF (. NOT . ALLOCATED ( ranked_age_unique_id )) ALLOCATE ( ranked_age_unique_id ( npatch_active )) IF (. NOT . ALLOCATED ( tmp )) ALLOCATE ( tmp ( npatch_active )) IF (. NOT . ALLOCATED ( freq_tmp )) ALLOCATE ( freq_tmp ( npatch_active )) IF (. NOT . ALLOCATED ( freq_tmp1 )) ALLOCATE ( freq_tmp1 ( npatch_active )) ! rank patches in order of age pop % pop_grid ( g )% ranked_age_unique (:, idisturb ) = 0 ranked_age_init = pop % pop_grid ( g )% patch % age ( idisturb ) ranked_age = pop % pop_grid ( g )% patch % age ( idisturb ) ranked_age_id = pop % pop_grid ( g )% patch % id ranked_age_unique_id = 0 freq_tmp = 0.0_dp freq = 0.0_dp pop % pop_grid ( g )% freq_ranked_age_unique (:, idisturb ) = 0.0_dp midpoint = 0.0_dp DO i = 1 , npatch_active - 1 DO j = i + 1 , npatch_active IF ( ranked_age ( i ). GT . ranked_age ( j )) THEN agecopy = ranked_age ( i ) idcopy = ranked_age_id ( i ) ranked_age ( i ) = ranked_age ( j ) ranked_age_id ( i ) = ranked_age_id ( j ) ranked_age ( j ) = agecopy ranked_age_id ( j ) = idcopy ENDIF ENDDO ENDDO ! subset to unique ages k = 0 age_tmp = - 1 DO i = 1 , npatch_active IF ( ranked_age ( i ). NE . age_tmp ) k = k + 1 pop % pop_grid ( g )% ranked_age_unique ( k , idisturb ) = ranked_age ( i ) ranked_age_unique_id ( k ) = ranked_age_id ( i ) age_tmp = ranked_age ( i ) n_age = k ENDDO disturbance_freq = 1.0_dp / REAL ( disturbance_interval ( g , idisturb ), dp ) DO i = 1 , 1000 Poisson_age ( i ) = i CumPoisson_weight ( i ) = CumExponential ( disturbance_freq , REAL ( i , dp )) ENDDO ! construct upper and lower bounds for each unique age: these set the range of ages to be ! represented by an unique age ALLOCATE ( bound ( n_age , 2 )) ALLOCATE ( unique_age ( n_age )) bound = 0 unique_age = pop % pop_grid ( g )% ranked_age_unique ( 1 : n_age , idisturb ) DO i = 1 , n_age IF ( unique_age ( i ). EQ . 0 ) THEN bound ( i , 1 ) = 0 bound ( i , 2 ) = 0 ELSEIF (( i . EQ . 1 ). AND .( unique_age ( i ). GT . 0 )) THEN bound ( i , 1 ) = 0 bound ( i , 2 ) = unique_age ( i ) ELSEIF (( unique_age ( i ). GT . 0 ). AND .( i . GT . 1 ). AND .( unique_age ( i - 1 ). EQ . unique_age ( i ) - 1 )) THEN bound ( i , 1 ) = unique_age ( i ) IF ( i . LT . n_age ) THEN bound ( i , 2 ) = unique_age ( i ) ELSE i_max = MAXLOC ( Poisson_age , 1 , CumPoisson_weight . LE . 0.99_dp ) bound ( i , 2 ) = Poisson_age ( i_max ) ENDIF ELSEIF (( unique_age ( i ). GT . 0 ). AND .( i . GT . 1 ). AND .( unique_age ( i - 1 ). NE . unique_age ( i ) - 1 )) THEN bound ( i , 1 ) = bound ( i - 1 , 2 ) + 1 IF ( i . LT . n_age ) THEN bound ( i , 2 ) = ( unique_age ( i ) + unique_age ( i + 1 )) / 2 ELSE i_max = MAXLOC ( Poisson_age , 1 , CumPoisson_weight . LE . 0.99_dp ) bound ( i , 2 ) = Poisson_age ( i_max ) ENDIF ENDIF ENDDO ! calculate weighting for each unique age DO i = 1 , n_age DO j = bound ( i , 1 ), bound ( i , 2 ) !IF (pop%LU(g)==2) THEN  ! secondary forest IF ( POP % pop_grid ( g )% LU == 2 ) THEN freq_tmp ( i ) = freq_tmp ( i ) + pop % pop_grid ( g )% freq_age ( j + 1 ) ELSE freq_tmp ( i ) = freq_tmp ( i ) + REALExponential ( disturbance_freq , REAL ( j , dp )) ENDIF ENDDO ENDDO pop % pop_grid ( g )% freq_ranked_age_unique ( 1 : npatch_active , idisturb ) = freq_tmp pop % pop_grid ( g )% n_age ( idisturb ) = n_age DEALLOCATE ( bound ) DEALLOCATE ( unique_age ) ENDDO END SUBROUTINE GetUniqueAgeFrequencies !******************************************************************************* SUBROUTINE GetPatchFrequencies ( pop ) IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP INTEGER ( i4b ) :: n1 , n2 , g , REPCOUNT , np , idist REAL ( dp ) :: sum_freq np = SIZE ( Pop % pop_grid ) DO g = 1 , np pop % pop_grid ( g )% freq = 0.0_dp DO idist = 1 , NDISTURB IF ( idist . EQ . 1 ) THEN DO n1 = 1 , pop % pop_grid ( g )% n_age ( 1 ) repcount = COUNT ( pop % pop_grid ( g )% patch (:)% age ( 1 ). EQ . pop % pop_grid ( g )% ranked_age_unique ( n1 , 1 )) WHERE ( pop % pop_grid ( g )% patch (:)% age ( 1 ). EQ . pop % pop_grid ( g )% ranked_age_unique ( n1 , 1 )) pop % pop_grid ( g )% freq = pop % pop_grid ( g )% freq_ranked_age_unique ( n1 , 1 ) / REAL ( repcount , dp ) ENDWHERE ENDDO ELSEIF ( idist . EQ . 2 ) THEN ! first calculate weights for patches with age(2)>age(1) DO n1 = 1 , pop % pop_grid ( g )% n_age ( 1 ) DO n2 = 1 , pop % pop_grid ( g )% n_age ( idist ) repcount = COUNT (( pop % pop_grid ( g )% patch ( 1 : NPATCH )% age ( 1 ) . EQ . & pop % pop_grid ( g )% ranked_age_unique ( n1 , 1 )). AND . & ( pop % pop_grid ( g )% patch ( 1 : NPATCH )% age ( idist ) . EQ . & pop % pop_grid ( g )% ranked_age_unique ( n2 , idist ))) WHERE (( pop % pop_grid ( g )% patch ( 1 : NPATCH )% age ( 1 ). EQ . pop % pop_grid ( g )% ranked_age_unique ( n1 , 1 )). AND . & ( pop % pop_grid ( g )% patch ( 1 : NPATCH )% age ( idist ). EQ . pop % pop_grid ( g )% ranked_age_unique ( n2 , idist ))) pop % pop_grid ( g )% freq ( 1 : NPATCH ) = pop % pop_grid ( g )% freq_ranked_age_unique ( n1 , 1 ) * & pop % pop_grid ( g )% freq_ranked_age_unique ( n2 , idist ) & / REAL ( repcount , dp ) ENDWHERE ENDDO ENDDO ENDIF ENDDO ! end loop over idist sum_freq = SUM ( pop % pop_grid ( g )% freq ) if ( sum_freq . gt . 0.0_dp ) pop % pop_grid ( g )% freq = pop % pop_grid ( g )% freq / sum_freq ENDDO END SUBROUTINE GetPatchFrequencies !******************************************************************************* SUBROUTINE GetDiagnostics ( pop , LAI , Cleaf , Croot , disturbance_interval , it , precip ) ! Gets diagnostic data for current landscape structure IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP REAL ( dp ), INTENT ( IN ) :: LAI (:) REAL ( dp ), INTENT ( IN ) :: Cleaf (:) REAL ( dp ), INTENT ( IN ) :: Croot (:) INTEGER ( i4b ), INTENT ( IN ) :: disturbance_interval (:,:) REAL ( dp ), INTENT ( IN ), OPTIONAL :: precip (:) INTEGER ( i4b ), INTENT ( IN ) :: it (:) INTEGER ( i4b ) :: P , g , i , j , ct , ct_highres REAL ( dp ) :: limits ( HEIGHT_BINS + 1 ) REAL ( dp ) :: ht , cmass_stem , densindiv , freq , freq_old CHARACTER ( len = 12 ) :: string1 , string2 CHARACTER ( len = 9 ) :: fmt INTEGER ( i4b ) :: npatch_active ! number of active patches INTEGER ( i4b ) :: np , nc , i_height REAL ( dp ) :: diam , basal , cump REAL ( dp ) :: patch_crown_area ( NPATCH2D ), patch_crown_cover ( NPATCH2D ) REAL ( dp ), ALLOCATABLE :: height_list (:), height_list_weight (:) REAL ( dp ) :: height_copy , weight_copy , Pwc , FAVD INTEGER ( i4b ), PARAMETER :: HEIGHT_BINS_highres = 100 ! bins for assessing height_max REAL ( dp ), ALLOCATABLE :: limits_highres (:), DENSINDIV_HIGHRES (:) REAL ( dp ) :: tmp2 integer :: arg1 fmt = '(f5.1)' limits ( 1 ) = 0.0_dp IF (. NOT . ALLOCATED ( limits_highres )) ALLOCATE ( limits_highres ( HEIGHT_BINS_highres + 1 )) IF (. NOT . ALLOCATED ( DENSINDIV_HIGHRES )) ALLOCATE ( DENSINDIV_HIGHRES ( HEIGHT_BINS_highres )) limits_highres ( 1 ) = 0.0_dp np = SIZE ( Pop % pop_grid ) DO g = 1 , np npatch_active = NPATCH2D IF ( MAX_HEIGHT_SWITCH . EQ . 1 ) THEN ALLOCATE ( height_list ( NPATCH2D * NCOHORT_MAX )) ALLOCATE ( height_list_weight ( NPATCH2D * NCOHORT_MAX )) ENDIF !  IF(.NOT.ALLOCATED(MASK)) ALLOCATE(MASK(POP%pop_grid%npatch_active)) DO i = 1 , HEIGHT_BINS limits ( i + 1 ) = BIN_POWER ** REAL ( i , dp ) WRITE ( string1 , fmt ) ( limits ( i )) WRITE ( string2 , fmt ) ( limits ( i + 1 )) pop % pop_grid ( g )% bin_labels ( i ) = 'Height_' // TRIM ( ADJUSTL ( string1 )) // '-' // TRIM ( ADJUSTL ( string2 )) // 'm' pop % pop_grid ( g )% cmass_stem_bin ( i ) = 0.0_dp pop % pop_grid ( g )% densindiv_bin ( i ) = 0.0_dp pop % pop_grid ( g )% cmass_stem_bin ( i ) = 0.0_dp pop % pop_grid ( g )% height_bin ( i ) = REAL ( limits ( i ) + limits ( i + 1 ), dp ) / 2.0_dp pop % pop_grid ( g )% diameter_bin ( i ) = ( ( REAL ( limits ( i ), dp ) / Kbiometric ) ** ( 3.0_dp / 2.0_dp ) + & ( REAL ( limits ( i + 1 ), dp ) / Kbiometric ) ** ( 3.0_dp / 2.0_dp ) ) / 2.0_dp ENDDO DO i = 1 , HEIGHT_BINS_highres limits_highres ( i + 1 ) = REAL ( i , dp ) ENDDO IF ( MAX_HEIGHT_SWITCH . EQ . 1 ) THEN height_list = 0.0_dp height_list_weight = 0.0_dp ENDIF i_height = 0 pop % pop_grid ( g )% cmass_sum_old = pop % pop_grid ( g )% cmass_sum pop % pop_grid ( g )% csapwood_sum_old = pop % pop_grid ( g )% csapwood_sum pop % pop_grid ( g )% cmass_sum = 0.0_dp pop % pop_grid ( g )% csapwood_sum = 0.0_dp pop % pop_grid ( g )% cheartwood_sum = 0.0_dp pop % pop_grid ( g )% height_mean = 0.0_dp pop % pop_grid ( g )% fire_mortality = 0.0_dp pop % pop_grid ( g )% cat_mortality = 0.0_dp pop % pop_grid ( g )% res_mortality = 0.0_dp pop % pop_grid ( g )% stress_mortality = 0.0_dp pop % pop_grid ( g )% crowding_mortality = 0.0_dp pop % pop_grid ( g )% sapwood_loss = 0.0_dp pop % pop_grid ( g )% sapwood_area_loss = 0.0_dp pop % pop_grid ( g )% growth = 0.0_dp pop % pop_grid ( g )% area_growth = 0.0_dp pop % pop_grid ( g )% basal_area = 0.0_dp pop % pop_grid ( g )% densindiv = 0.0_dp pop % pop_grid ( g )% height_max = 0.0_dp pop % pop_grid ( g )% crown_cover = 0.0_dp pop % pop_grid ( g )% crown_area = 0.0_dp pop % pop_grid ( g )% sapwood_area = 0.0_dp pop % pop_grid ( g )% crown_volume = 0.0_dp densindiv_highres = 0.0_dp ! loop through patches DO P = 1 , npatch_active pop % pop_grid ( g )% patch ( p )% biomass = 0.0_dp pop % pop_grid ( g )% patch ( p )% sapwood = 0.0_dp pop % pop_grid ( g )% patch ( p )% sapwood_area = 0.0_dp pop % pop_grid ( g )% patch ( p )% heartwood = 0.0_dp pop % pop_grid ( g )% patch ( p )% layer ( 1 )% biomass = 0.0_dp pop % pop_grid ( g )% patch ( p )% layer ( 1 )% density = 0.0_dp patch_crown_area ( p ) = 0.0_dp patch_crown_cover ( p ) = 0.0_dp tmp2 = sum ( pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( 1 : pop % pop_grid ( g )% patch ( p )% layer ( 1 )% ncohort )% sapwood_area ) freq = pop % pop_grid ( g )% freq ( pop % pop_grid ( g )% patch ( p )% id ) freq_old = pop % pop_grid ( g )% freq_old ( pop % pop_grid ( g )% patch ( p )% id ) ! loop through cohorts DO i = 1 , pop % pop_grid ( g )% patch ( p )% layer ( 1 )% ncohort cmass_stem = pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% biomass densindiv = pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% density IF ( PRESENT ( precip ) ) THEN CALL GET_ALLOMETRY ( ALLOM_SWITCH , cmass_stem , densindiv , ht , diam , basal , precip ( g )) ELSE CALL GET_ALLOMETRY ( ALLOM_SWITCH , cmass_stem , densindiv , ht , diam , basal ) ENDIF pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% height = ht pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% diameter = diam ! basal area in each cohort pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% basal_area = basal ! sapwood area in each cohort pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% sapwood_area = basal - & ! m2 ha-1 pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% heartwood / ( ht * WD ) * 1.0e4_dp pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% sapwood_area = & max ( pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% sapwood_area , 0.0_dp ) ! get bin ct = 1 DO j = 1 , HEIGHT_BINS IF ( ht . GT . limits ( j )) ct = j ENDDO ! bins ! get high res bin ct_highres = 1 DO j = 1 , HEIGHT_BINS_highres IF ( ht . GT . limits_highres ( j )) ct_highres = j ENDDO ! bins pop % pop_grid ( g )% patch ( p )% layer ( 1 )% biomass = pop % pop_grid ( g )% patch ( p )% layer ( 1 )% biomass + cmass_stem pop % pop_grid ( g )% patch ( p )% layer ( 1 )% density = pop % pop_grid ( g )% patch ( p )% layer ( 1 )% density + densindiv IF ( diam * 10 0.0_dp . GT . 1.0_dp ) THEN patch_crown_area ( p ) = patch_crown_area ( p ) + densindiv * PI * ( diam * 10 0.0_dp * 0.1492_dp ) ** 2 ! uses GC relationship pop % pop_grid ( g )% crown_volume = pop % pop_grid ( g )% crown_volume + & freq * densindiv * ( 4.0_dp / 3.0_dp ) * PI * ( diam * 10 0.0_dp * 0.1492_dp ) ** 2 * ( 1.5_dp * ( diam * 10 0.0_dp * 0.1492_dp )) ! assumes vertical radius = 1.5 * horizontal radius ENDIF IF ( diam * 10 0.0_dp . GT . 5.0_dp ) THEN if ( ALLOM_SWITCH . eq . 1 ) then !! assumes crown radius (m) = 0.1492 * dbh (cm) (from G. Cook, pers. comm.) ! assumes vertical radius = 1.5 * horizontal radius pop % pop_grid ( g )% crown_volume = pop % pop_grid ( g )% crown_volume + & freq * densindiv * ( 4.0_dp / 3.0_dp ) * PI * ( diam * 10 0.0_dp * 0.1492_dp ) ** 2 * ( 1.5_dp * ( diam * 10 0.0_dp * 0.1492_dp )) else !! global allometry ! assumes vertical radius = 1.5 * horizontal radius pop % pop_grid ( g )% crown_volume = pop % pop_grid ( g )% crown_volume + & freq * densindiv * ( 4.0_dp / 3.0_dp ) * PI * 1.5_dp * (( k_allom1 * diam ** k_rp ) / PI ) ** 1.5_dp endif ENDIF pop % pop_grid ( g )% patch ( p )% sapwood = pop % pop_grid ( g )% patch ( p )% sapwood + & pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% sapwood pop % pop_grid ( g )% patch ( p )% sapwood_area = pop % pop_grid ( g )% patch ( p )% sapwood_area + & pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% sapwood_area pop % pop_grid ( g )% patch ( p )% heartwood = pop % pop_grid ( g )% patch ( p )% heartwood + & pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% heartwood pop % pop_grid ( g )% patch ( p )% biomass = pop % pop_grid ( g )% patch ( p )% biomass + cmass_stem pop % pop_grid ( g )% cmass_stem_bin ( ct ) = pop % pop_grid ( g )% cmass_stem_bin ( ct ) + freq * cmass_stem pop % pop_grid ( g )% densindiv_bin ( ct ) = pop % pop_grid ( g )% densindiv_bin ( ct ) + freq * densindiv pop % pop_grid ( g )% cmass_sum = pop % pop_grid ( g )% cmass_sum + freq * cmass_stem pop % pop_grid ( g )% csapwood_sum = pop % pop_grid ( g )% csapwood_sum + & freq * pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% sapwood pop % pop_grid ( g )% cheartwood_sum = pop % pop_grid ( g )% cheartwood_sum + & freq * pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% heartwood pop % pop_grid ( g )% densindiv = pop % pop_grid ( g )% densindiv + freq * densindiv pop % pop_grid ( g )% height_mean = pop % pop_grid ( g )% height_mean + ht * freq * densindiv pop % pop_grid ( g )% basal_area = pop % pop_grid ( g )% basal_area + basal * freq densindiv_highres ( ct_highres ) = densindiv_highres ( ct_highres ) + freq * densindiv IF ( MAX_HEIGHT_SWITCH . EQ . 1 ) THEN i_height = i_height + 1 height_list ( i_height ) = ht height_list_weight ( i_height ) = densindiv * freq ENDIF ENDDO ! cohorts pop % pop_grid ( g )% stress_mortality = pop % pop_grid ( g )% stress_mortality + & freq * pop % pop_grid ( g )% patch ( p )% stress_mortality pop % pop_grid ( g )% crowding_mortality = pop % pop_grid ( g )% crowding_mortality + & freq * pop % pop_grid ( g )% patch ( p )% crowding_mortality pop % pop_grid ( g )% sapwood_area = pop % pop_grid ( g )% sapwood_area + & freq * sum ( pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( 1 : pop % pop_grid ( g )% patch ( p )% layer ( 1 )% ncohort )% sapwood_area ) pop % pop_grid ( g )% sapwood_loss = pop % pop_grid ( g )% sapwood_loss + & freq * pop % pop_grid ( g )% patch ( p )% sapwood_loss pop % pop_grid ( g )% sapwood_loss = pop % pop_grid ( g )% sapwood_loss + & pop % pop_grid ( g )% patch ( p )% sapwood_old * ( freq_old - freq ) pop % pop_grid ( g )% sapwood_area_loss = pop % pop_grid ( g )% sapwood_area_loss + & freq * pop % pop_grid ( g )% patch ( p )% sapwood_area_loss pop % pop_grid ( g )% sapwood_area_loss = pop % pop_grid ( g )% sapwood_area_loss + & pop % pop_grid ( g )% patch ( p )% sapwood_area_old * ( freq_old - freq ) pop % pop_grid ( g )% cat_mortality = pop % pop_grid ( g )% cat_mortality + & freq * pop % pop_grid ( g )% patch ( p )% cat_mortality pop % pop_grid ( g )% res_mortality = pop % pop_grid ( g )% res_mortality + & pop % pop_grid ( g )% patch ( p )% biomass_old * ( freq_old - freq ) pop % pop_grid ( g )% fire_mortality = pop % pop_grid ( g )% fire_mortality + & freq * pop % pop_grid ( g )% patch ( p )% fire_mortality pop % pop_grid ( g )% growth = pop % pop_grid ( g )% growth + freq_old * pop % pop_grid ( g )% patch ( p )% growth pop % pop_grid ( g )% area_growth = pop % pop_grid ( g )% area_growth + & freq * pop % pop_grid ( g )% patch ( p )% area_growth ENDDO ! patches IF ( INTERP_SWITCH == 1. and . NDISTURB . eq . 2 ) then !CALL INTERPOLATE_BIOMASS_2D(pop, disturbance_interval,it) CALL INTERPOLATE_BIOMASS_2D ( pop , disturbance_interval , it ( g ), g ) ELSEIF ( INTERP_SWITCH == 1. and . NDISTURB . eq . 1 ) then CALL INTERPOLATE_BIOMASS_1D ( pop , disturbance_interval , it ( g ), g ) ENDIF arg1 = NYEAR_HISTORY IF ( SMOOTH_SWITCH == 1 ) THEN IF ( it ( g ). LE . NYEAR_HISTORY ) THEN CALL SMOOTH_FLUX ( POP , g , it ( g )) ELSE CALL SMOOTH_FLUX ( POP , g , int ( arg1 , i4b )) ENDIF ENDIF ! leaf area index in each cohort DO P = 1 , npatch_active freq = pop % pop_grid ( g )% freq ( pop % pop_grid ( g )% patch ( p )% id ) ! loop through cohorts DO i = 1 , pop % pop_grid ( g )% patch ( p )% layer ( 1 )% ncohort cmass_stem = pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% biomass densindiv = pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% density basal = PI * ( pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% diameter / 2.0_dp ) * & ( pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% diameter / 2.0_dp ) * densindiv * 1.0e4_dp ! leaf area index in each cohort pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% LAI = LAI ( g ) * & min ( pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% sapwood_area & / max ( pop % pop_grid ( g )% sapwood_area , 1.0e-3_dp ), 1 0.0_dp ) pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% Cleaf = Cleaf ( g ) * & min ( pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% sapwood_area & / max ( pop % pop_grid ( g )% sapwood_area , 1.0e-3_dp ), 1 0.0_dp ) pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% Croot = Croot ( g ) * & min ( pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% sapwood_area & / max ( pop % pop_grid ( g )% sapwood_area , 1.0e-3_dp ), 1 0.0_dp ) ENDDO ! cohorts pop % pop_grid ( g )% patch ( p )% LAI = sum ( pop % pop_grid ( g )% patch ( p )% layer ( 1 )% & cohort ( 1 : pop % pop_grid ( g )% patch ( p )% layer ( 1 )% ncohort )% LAI ) ENDDO ! patches ! PGap = (1-fcover) calculation if ( pop % pop_grid ( g )% crown_volume > 0.0_dp ) then FAVD = LAI ( g ) / pop % pop_grid ( g )% crown_volume ! foliage area volume density else FAVD = 0.0_dp endif DO P = 1 , npatch_active freq = pop % pop_grid ( g )% freq ( pop % pop_grid ( g )% patch ( p )% id ) nc = pop % pop_grid ( g )% patch ( p )% layer ( 1 )% ncohort ! loop through cohorts DO i = 1 , nc cmass_stem = pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% biomass densindiv = pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% density IF ( PRESENT ( precip ) ) THEN CALL GET_ALLOMETRY ( ALLOM_SWITCH , cmass_stem , densindiv , ht , diam , basal , precip ( g )) ELSE CALL GET_ALLOMETRY ( ALLOM_SWITCH , cmass_stem , densindiv , ht , diam , basal ) ENDIF IF ( diam * 10 0.0_dp . GT . 1.0_dp ) THEN if ( ALLOM_SWITCH . eq . 1 ) then !! assumes crown radius (m) = 0.1492 * dbh (cm) (from G. Cook, pers. comm.) pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% crown_area = densindiv * PI * ( diam * 10 0.0_dp * 0.1492_dp ) ** 2 Pwc = EXP ( - 0.5_dp * pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% LAI / & pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% crown_area ) pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% crown_area = & densindiv * PI * ( diam * 10 0.0_dp * 0.1492_dp ) ** 2 * ( 1.0_dp - Pwc ) else !! global allometry pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% crown_area = & densindiv * PI * ((( k_allom1 * diam ** k_rp ) / PI ) ** 0.5_dp ) ** 2 Pwc = EXP ( max ( - 0.5_dp * pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% LAI / & max ( pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% crown_area , 1.e-3_dp ), - 2 0.0_dp )) pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% crown_area = & pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% crown_area * ( 1.0_dp - Pwc ) ! *1.4142 endif ELSE pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% crown_area = & 0.5_dp * pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% LAI ! *1.4142 ENDIF pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% crown_area = & max ( pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% crown_area , 0.01_dp ) pop % pop_grid ( g )% crown_area = pop % pop_grid ( g )% crown_area + & freq * pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% crown_area IF ( i . eq . 1 ) THEN ! top cohort pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% Pgap = & exp ( - pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% crown_area ) pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% frac_interception = & 1 - exp ( - pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% crown_area ) ELSE pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% Pgap = & pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i - 1 )% Pgap * & exp ( - pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% crown_area ) pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% frac_interception = & pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i - 1 )% Pgap - & pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% Pgap ENDIF pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% respiration_scalar = & pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% sapwood / shootfrac / CtoNw + & pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% Cleaf / CtoNl + & pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( i )% Croot / CtoNr ENDDO ! cohorts IF ( nc > 0 ) THEN pop % pop_grid ( g )% patch ( p )% pgap = & pop % pop_grid ( g )% patch ( p )% layer ( 1 )% cohort ( nc )% Pgap ELSE pop % pop_grid ( g )% patch ( p )% pgap = 1 ENDIF ENDDO ! patches pop % pop_grid ( g )% Kclump = max ( pop % pop_grid ( g )% crown_area / ( 0.5_dp * LAI ( g )), 0.1_dp ) pop % pop_grid ( g )% crown_cover = 1.0_dp - EXP ( - pop % pop_grid ( g )% crown_area ) pop % pop_grid ( g )% height_mean = pop % pop_grid ( g )% height_mean / max ( pop % pop_grid ( g )% densindiv , 1.0e-5_dp ) ! Height Diagnostics IF ( MAX_HEIGHT_SWITCH . EQ . 0 ) THEN ! Set landscape maximum height to centre of bin with <5% of trees in a bin of higher size classes cump = 0.0_dp j = 1 DO WHILE ( cump . LT . 0.95_dp ) cump = cump + pop % pop_grid ( g )% densindiv_bin ( j ) / max ( pop % pop_grid ( g )% densindiv , 1.0e-5_dp ) pop % pop_grid ( g )% height_max = pop % pop_grid ( g )% height_bin ( j ) j = j + 1 ENDDO ELSEIF ( MAX_HEIGHT_SWITCH . EQ . 1 ) THEN ! sort height list DO i = 1 , i_height - 1 DO j = i + 1 , i_height IF ( height_list ( i ). GT . height_list ( j )) THEN height_copy = height_list ( i ) weight_copy = height_list_weight ( i ) height_list ( i ) = height_list ( j ) height_list_weight ( i ) = height_list_weight ( j ) height_list ( j ) = height_copy height_list_weight ( j ) = weight_copy ENDIF ENDDO ENDDO ! end sort height list ! normailse height list weights height_list_weight = height_list_weight / SUM ( height_list_weight ( 1 : i_height )) cump = 0.0_dp j = 1 DO WHILE ( cump . LT . 0.95_dp ) cump = cump + height_list_weight ( j ) pop % pop_grid ( g )% height_max = height_list ( j ) j = j + 1 ENDDO DEALLOCATE ( height_list ) DEALLOCATE ( height_list_weight ) ELSEIF ( MAX_HEIGHT_SWITCH . EQ . 2 ) THEN cump = 0.0_dp j = 1 densindiv_highres = densindiv_highres / max ( SUM ( densindiv_highres ), 1.0e-5_dp ) DO WHILE (( cump . LT . 0.95_dp ). AND .( j . LE . HEIGHT_BINS_highres )) cump = cump + densindiv_highres ( j ) pop % pop_grid ( g )% height_max = ( limits_highres ( j + 1 ) + limits_highres ( j )) / 2.0_dp j = j + 1 ENDDO ENDIF !deallocate(MASK) ENDDO ! end loop over grid cells END SUBROUTINE GetDiagnostics !******************************************************************************* SUBROUTINE Patch_partial_disturb ( pop , idisturb , intensity , frac_intensity1 ) IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP INTEGER ( i4b ), INTENT ( IN ) :: idisturb REAL ( dp ), INTENT ( IN ) :: intensity (:,:) REAL ( dp ), INTENT ( IN ), OPTIONAL :: frac_intensity1 (:) INTEGER ( i4b ) :: j , k , c , nc , np INTEGER ( i4b ) :: ivec ( NCOHORT_MAX ) REAL ( dp ) :: ht , diam REAL ( dp ) :: Psurvival_s , Psurvival , char_height np = SIZE ( Pop % pop_grid ) ! Kills a fraction of biomass in patch when prescribed disturbance interval is reached DO j = 1 , np DO k = 1 , NPATCH pop % pop_grid ( j )% patch ( k )% fire_mortality = 0.0_dp IF ((( pop % pop_grid ( j )% patch ( k )% first_disturbance_year ( idisturb ). NE . 0 ). AND . & ( pop % pop_grid ( j )% patch ( k )% first_disturbance_year ( idisturb ). EQ . pop % pop_grid ( j )% patch ( k )% age ( idisturb ))). OR . & ( pop % pop_grid ( j )% patch ( k )% disturbance_interval ( idisturb ). EQ . pop % pop_grid ( j )% patch ( k )% age ( idisturb ))) THEN ! loop through cohorts ivec = 0 nc = 0 DO c = 1 , pop % pop_grid ( j )% patch ( k )% layer ( 1 )% ncohort ! kill fraction of each cohort char_height = 3.7_dp * ( 1.0_dp - EXP ( - 0.19_dp * Intensity ( j , 1 ))) ht = pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% height diam = pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% diameter * 10 0.0_dp ! diameter in cm IF (( ht . GT . 8.5_dp ). AND .( ht . GT . char_height )) THEN Psurvival_s = ( - 0.0011_dp * Intensity ( j , 1 ) - 0.00002_dp ) * ht & + ( 0.0075_dp * Intensity ( j , 1 ) + 1.0_dp ) ELSEIF (( ht . LE . 8.5_dp ). AND .( ht . GT . char_height )) THEN Psurvival_s = ( 0.0178_dp * Intensity ( j , 1 ) + 0.0144_dp ) * ht & + ( - 0.1174_dp * Intensity ( j , 1 ) + 0.9158_dp ) ELSE Psurvival_s = 0.0_dp ENDIF Psurvival_s = MIN ( Psurvival_s , 1.0_dp ) Psurvival_s = MAX ( Psurvival_s , 1.0e-3_dp ) Psurvival = Psurvival_s IF ( PRESENT ( frac_intensity1 )) THEN char_height = 3.7_dp * ( 1.0_dp - EXP ( - 0.19_dp * Intensity ( j , 2 ))) ht = pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% height IF (( ht . GT . 8.5_dp ). AND .( ht . GT . char_height )) THEN Psurvival_s = ( - 0.0011_dp * Intensity ( j , 2 ) - 0.00002_dp ) * ht & + ( 0.0075_dp * Intensity ( j , 2 ) + 1.0_dp ) ELSEIF (( ht . LE . 8.5_dp ). AND .( ht . GT . char_height )) THEN Psurvival_s = ( 0.0178_dp * Intensity ( j , 2 ) + 0.0144_dp ) * ht & + ( - 0.1174_dp * Intensity ( j , 2 ) + 0.9158_dp ) ELSE Psurvival_s = 0.0_dp ENDIF Psurvival_s = MIN ( Psurvival_s , 1.0_dp ) Psurvival_s = MAX ( Psurvival_s , 1.0e-3_dp ) Psurvival = Psurvival_s * ( 1.0_dp - frac_intensity1 ( j )) + Psurvival * frac_intensity1 ( j ) ENDIF ! Psurvival = 1.0_dp ! test pop % pop_grid ( j )% patch ( k )% fire_mortality = pop % pop_grid ( j )% patch ( k )% fire_mortality + & ( 1.0_dp - Psurvival ) * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% biomass pop % pop_grid ( j )% patch ( k )% sapwood_loss = pop % pop_grid ( j )% patch ( k )% sapwood_loss + & ( 1.0_dp - Psurvival ) * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% sapwood pop % pop_grid ( j )% patch ( k )% sapwood_area_loss = pop % pop_grid ( j )% patch ( k )% sapwood_area_loss + & ( 1.0_dp - Psurvival ) * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% sapwood_area pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% biomass = & Psurvival * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% biomass pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% sapwood = & Psurvival * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% sapwood pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% heartwood = & Psurvival * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% heartwood pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% density = & Psurvival * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% density IF ( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% density . LT . DENSINDIV_MIN ) THEN ! remove cohort pop % pop_grid ( j )% patch ( k )% fire_mortality = pop % pop_grid ( j )% patch ( k )% fire_mortality + & pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% biomass pop % pop_grid ( j )% patch ( k )% sapwood_loss = pop % pop_grid ( j )% patch ( k )% sapwood_loss + & pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% sapwood pop % pop_grid ( j )% patch ( k )% sapwood_area_loss = pop % pop_grid ( j )% patch ( k )% sapwood_area_loss + & pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% sapwood_area pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% density = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% id = 0 pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% biomass = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% heartwood = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood_area = 0.0_dp ELSE pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% id = 1 nc = nc + 1 ivec ( nc ) = c ENDIF ENDDO ! SHUFFLE if necessary to remove zero-density cohorts IF ( nc . LT . pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort ) THEN pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : nc ) = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( ivec ( 1 : nc )) pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort = nc pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% density = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% id = 0 pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% biomass = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% sapwood = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% sapwood_area = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% heartwood = 0.0_dp ENDIF pop % pop_grid ( j )% patch ( k )% age ( idisturb ) = 0 pop % pop_grid ( j )% patch ( k )% first_disturbance_year ( idisturb ) = 0 ENDIF ENDDO ENDDO END SUBROUTINE Patch_partial_disturb !******************************************************************************* SUBROUTINE Patch_partial_disturb2 ( pop , idisturb ) IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP INTEGER ( i4b ), INTENT ( IN ) :: idisturb INTEGER ( i4b ) :: j , k , c , nc , np INTEGER ( i4b ) :: ivec ( NCOHORT_MAX ) REAL ( dp ) :: Psurvival , frac_mort , Pmort np = SIZE ( Pop % pop_grid ) ! Kills a fraction (80%) biomass in patch when prescribed disturbance interval is reached DO j = 1 , np DO k = 1 , NPATCH2D pop % pop_grid ( j )% patch ( k )% cat_mortality = 0.0_dp ! Layer biomass (summed over cohorts) nc = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% biomass = SUM ( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : nc )% biomass ) IF ((( pop % pop_grid ( j )% patch ( k )% first_disturbance_year ( idisturb ). NE . 0 ). AND . & ( pop % pop_grid ( j )% patch ( k )% first_disturbance_year ( idisturb ). EQ . pop % pop_grid ( j )% patch ( k )% age ( idisturb ))). OR . & ( pop % pop_grid ( j )% patch ( k )% disturbance_interval ( idisturb ). EQ . pop % pop_grid ( j )% patch ( k )% age ( idisturb ))) THEN ! loop through cohorts ivec = 0 nc = 0 frac_mort = 0.0_dp pop % pop_grid ( j )% patch ( k )% cat_mortality = 0.0_dp DO c = 1 , pop % pop_grid ( j )% patch ( k )% layer ( 1 )% ncohort ! kill fraction of each cohort, up to 80% of patch biomass if ( pop % pop_grid ( j )% patch ( k )% cat_mortality < 0.8_dp * pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% biomass ) then Pmort = min ( ( 0.8_dp * pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% biomass - pop % pop_grid ( j )% patch ( k )% fire_mortality ) & / pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% biomass , 1.0_dp ) else Pmort = 0.0_dp endif Psurvival = 1.0_dp - Pmort pop % pop_grid ( j )% patch ( k )% cat_mortality = pop % pop_grid ( j )% patch ( k )% cat_mortality + & ( 1.0_dp - Psurvival ) * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% biomass pop % pop_grid ( j )% patch ( k )% sapwood_loss = pop % pop_grid ( j )% patch ( k )% sapwood_loss + & ( 1.0_dp - Psurvival ) * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% sapwood pop % pop_grid ( j )% patch ( k )% sapwood_area_loss = pop % pop_grid ( j )% patch ( k )% sapwood_area_loss + & ( 1.0_dp - Psurvival ) * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% sapwood_area pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% biomass = & Psurvival * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% biomass pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% sapwood = & Psurvival * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% sapwood pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% heartwood = & Psurvival * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% heartwood pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% density = & Psurvival * pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% density IF ( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% density . LT . DENSINDIV_MIN ) THEN ! remove cohort pop % pop_grid ( j )% patch ( k )% cat_mortality = pop % pop_grid ( j )% patch ( k )% cat_mortality + & pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% biomass pop % pop_grid ( j )% patch ( k )% sapwood_loss = pop % pop_grid ( j )% patch ( k )% sapwood_loss + & pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% sapwood pop % pop_grid ( j )% patch ( k )% sapwood_area_loss = pop % pop_grid ( j )% patch ( k )% sapwood_area_loss + & pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( c )% sapwood_area pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% density = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% id = 0 pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% biomass = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% heartwood = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood_area = 0.0_dp ELSE pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( c )% id = 1 nc = nc + 1 ivec ( nc ) = c ENDIF ENDDO ! SHUFFLE if necessary to remove zero-density cohorts IF ( nc . LT . pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort ) THEN pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : nc ) = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( ivec ( 1 : nc )) pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort = nc pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% density = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% id = 0 pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% biomass = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% sapwood = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% sapwood_area = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( nc + 1 : NCOHORT_MAX )% heartwood = 0.0_dp ENDIF pop % pop_grid ( j )% patch ( k )% age ( idisturb ) = 0 pop % pop_grid ( j )% patch ( k )% first_disturbance_year ( idisturb ) = 0 ENDIF ENDDO ENDDO END SUBROUTINE Patch_partial_disturb2 !******************************************************************************* SUBROUTINE Patch_disturb ( pop , idisturb , precip ) IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP REAL ( dp ), INTENT ( IN ), OPTIONAL :: precip (:) !INTEGER(i4b), INTENT(IN) :: it(:),idisturb INTEGER ( i4b ), INTENT ( IN ) :: idisturb INTEGER ( i4b ) :: j , k , np , nc np = SIZE ( Pop % pop_grid ) ! Kills all biomass in patch when prescribed disturbance interval is reached ! Should be called after accounting for this year DO j = 1 , np DO k = 1 , NPATCH2D pop % pop_grid ( j )% patch ( k )% cat_mortality = 0.0_dp IF ( pop % pop_grid ( j )% patch ( k )% first_disturbance_year ( idisturb ). NE . 0 ) THEN IF (( pop % pop_grid ( j )% patch ( k )% first_disturbance_year ( idisturb ). EQ . pop % pop_grid ( j )% patch ( k )% age ( idisturb )). or . & ( pop % pop_grid ( j )% patch ( k )% disturbance_interval ( idisturb ). EQ . pop % pop_grid ( j )% patch ( k )% age ( idisturb )) ) THEN ! kill entire layer nc = pop % pop_grid ( j )% patch ( k )% layer ( 1 )% ncohort ! pop%pop_grid(j)%patch(k)%fire_mortality = SUM(pop%pop_grid(j)%patch(k)%layer(1)%cohort(1:nc)%biomass) pop % pop_grid ( j )% patch ( k )% cat_mortality = SUM ( pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( 1 : nc )% biomass ) pop % pop_grid ( j )% patch ( k )% sapwood_loss = pop % pop_grid ( j )% patch ( k )% sapwood_loss + & SUM ( pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( 1 : nc )% sapwood ) pop % pop_grid ( j )% patch ( k )% sapwood_area_loss = pop % pop_grid ( j )% patch ( k )% sapwood_area_loss + & SUM ( pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( 1 : nc )% sapwood_area ) pop % pop_grid ( j )% patch ( k )% layer ( 1 : NLayer )% ncohort = 0 pop % pop_grid ( j )% patch ( k )% layer ( 1 : NLayer )% biomass = 0.0_dp pop % pop_grid ( j )% patch ( k )% layer ( 1 : NLayer )% density = 0.0_dp pop % pop_grid ( j )% patch ( k )% layer ( 1 : NLayer )% hmean = 0.0_dp pop % pop_grid ( j )% patch ( k )% layer ( 1 : NLayer )% hmax = 0.0_dp pop % pop_grid ( j )% patch ( k )% age ( idisturb ) = 0 pop % pop_grid ( j )% patch ( k )% first_disturbance_year ( idisturb ) = 0 pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% density = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% id = 0 pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% biomass = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% sapwood = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% sapwood_area = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% heartwood = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% age = 0 pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% lai = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% height = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% pgap = 1.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% frac_resource_uptake = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% frac_light_uptake = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% frac_interception = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% frac_respiration = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% frac_NPP = 0.0_dp pop % pop_grid ( j )% patch ( k )% area_growth = 0.0_dp pop % pop_grid ( j )% patch ( k )% pgap = 1.0_dp ! understorey recruitment IF ( PRESENT ( precip )) THEN CALL layer_recruitment_single_patch ( pop , k , j , precip ) ELSE CALL layer_recruitment_single_patch ( pop , k , j ) ENDIF ENDIF ELSEIF ( pop % pop_grid ( j )% patch ( k )% disturbance_interval ( idisturb ). EQ . pop % pop_grid ( j )% patch ( k )% age ( idisturb )) THEN ! kill entire layer nc = pop % pop_grid ( j )% patch ( k )% layer ( 1 )% ncohort pop % pop_grid ( j )% patch ( k )% sapwood_loss = pop % pop_grid ( j )% patch ( k )% sapwood_loss + & SUM ( pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( 1 : nc )% sapwood ) pop % pop_grid ( j )% patch ( k )% sapwood_area_loss = pop % pop_grid ( j )% patch ( k )% sapwood_area_loss + & SUM ( pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( 1 : nc )% sapwood_area ) pop % pop_grid ( j )% patch ( k )% cat_mortality = SUM ( pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( 1 : nc )% biomass ) pop % pop_grid ( j )% patch ( k )% layer ( 1 : NLayer )% ncohort = 0 pop % pop_grid ( j )% patch ( k )% layer ( 1 : NLayer )% biomass = 0.0_dp pop % pop_grid ( j )% patch ( k )% layer ( 1 : NLayer )% density = 0.0_dp pop % pop_grid ( j )% patch ( k )% layer ( 1 : NLayer )% hmean = 0.0_dp pop % pop_grid ( j )% patch ( k )% layer ( 1 : NLayer )% hmax = 0.0_dp pop % pop_grid ( j )% patch ( k )% age ( idisturb ) = 0 pop % pop_grid ( j )% patch ( k )% first_disturbance_year ( idisturb ) = 0 pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% density = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% id = 0 pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% biomass = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% sapwood = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% sapwood_area = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% heartwood = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% age = 0 pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% lai = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% height = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% pgap = 1.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% frac_resource_uptake = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% frac_light_uptake = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% frac_interception = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% frac_respiration = 0.0_dp pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( 1 : NCOHORT_MAX )% frac_NPP = 0.0_dp pop % pop_grid ( j )% patch ( k )% area_growth = 0.0_dp pop % pop_grid ( j )% patch ( k )% pgap = 1.0_dp ! understorey recruitment IF ( PRESENT ( precip )) THEN CALL layer_recruitment_single_patch ( pop , k , j , precip ) ELSE CALL layer_recruitment_single_patch ( pop , k , j ) ENDIF ENDIF ENDDO ENDDO END SUBROUTINE Patch_disturb !******************************************************************************* SUBROUTINE layer_recruitment ( pop , precip ) IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP REAL ( dp ), INTENT ( IN ), OPTIONAL :: precip (:) REAL ( dp ) :: f , mu , densindiv , cmass , ht INTEGER ( i4b ) :: j , k , ncohort , np REAL ( dp ) :: diam , basal np = SIZE ( Pop % pop_grid ) DO j = 1 , np DO k = 1 , NPATCH2D IF ( RECRUIT_SWITCH == 0 ) THEN pop % pop_grid ( j )% patch ( k )% factor_recruit = EXP ( - 0.6_dp * (( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% biomass ) ** ( 0.6667_dp ))) ELSEIF ( RECRUIT_SWITCH == 1 ) THEN pop % pop_grid ( j )% patch ( k )% factor_recruit = max ( pop % pop_grid ( j )% patch ( k )% pgap , 1.0e-3_dp ) ENDIF f = pop % pop_grid ( j )% patch ( k )% factor_recruit mu = EXP ( max ( FULTON_ALPHA * ( 1.0_dp - 2.0_dp * THETA_recruit / & ( f + 1.0_dp - SQRT (( f + 1.0_dp ) * ( f + 1.0_dp ) - 4.0_dp * THETA_recruit * f ))), & - 5 0.0_dp )) densindiv = DENSINDIV_MAX * mu + pop % pop_grid ( j )% patch ( k )% fire_top_kill_density cmass = CMASS_STEM_INIT * densindiv / DENSINDIV_MAX !write(5599,*),  pop%pop_grid(j)%patch(k)%fire_top_kill_density,  densindiv, pop%pop_grid(j)%patch(k)%Layer(1)%ncohort !COMMLN below: should not be cohort +1 or .LE. ! IF ( cmass > EPS * 1 0.0_dp . AND . densindiv > DENSINDIV_MIN . AND . & ( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort + 1 ). LT . NCOHORT_MAX ) THEN ! create a new cohort pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort + 1 ncohort = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( ncohort )% biomass = cmass pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( ncohort )% density = densindiv pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( ncohort )% sapwood = cmass IF ( PRESENT ( precip ) ) THEN CALL GET_ALLOMETRY ( ALLOM_SWITCH , cmass , densindiv , ht , diam , basal , precip ( j )) ELSE CALL GET_ALLOMETRY ( ALLOM_SWITCH , cmass , densindiv , ht , diam , basal ) ENDIF pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( ncohort )% height = ht pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( ncohort )% diameter = diam ENDIF pop % pop_grid ( j )% patch ( k )% fire_top_kill_density = 0.0_dp ENDDO ENDDO END SUBROUTINE layer_recruitment !******************************************************************************* SUBROUTINE layer_recruitment_single_patch ( pop , index , grid_index , precip ) IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP REAL ( dp ), INTENT ( IN ), OPTIONAL :: precip (:) INTEGER ( i4b ), INTENT ( IN ) :: index , grid_index REAL ( dp ) :: f , mu , densindiv , cmass , ht INTEGER ( i4b ) :: j , k , ncohort , np REAL ( dp ) :: diam , basal np = SIZE ( Pop % pop_grid ) DO j = grid_index , grid_index DO k = index , index IF ( RECRUIT_SWITCH == 0 ) THEN pop % pop_grid ( j )% patch ( k )% factor_recruit = EXP ( - 0.6_dp * (( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% biomass ) ** ( 0.6667_dp ))) ELSEIF ( RECRUIT_SWITCH == 1 ) THEN !pop%pop_grid(j)%patch(k)%factor_recruit = pop%pop_grid(j)%patch(k)%pgap pop % pop_grid ( j )% patch ( k )% factor_recruit = 1 ENDIF f = pop % pop_grid ( j )% patch ( k )% factor_recruit mu = EXP ( FULTON_ALPHA * ( 1.0_dp - 2.0_dp * THETA_recruit / ( f + 1.0_dp - SQRT (( f + 1.0_dp ) * ( f + 1.0_dp ) - 4.0_dp * THETA_recruit * f )))) densindiv = DENSINDIV_MAX * mu cmass = CMASS_STEM_INIT * densindiv / DENSINDIV_MAX IF ( cmass > EPS * 1 0.0_dp . AND . densindiv > DENSINDIV_MIN . AND . & ( pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort + 1 ). LT . NCOHORT_MAX ) THEN ! create a new cohort pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort + 1 ncohort = pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% ncohort pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( ncohort )% biomass = cmass pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( ncohort )% density = densindiv pop % pop_grid ( j )% patch ( k )% Layer ( 1 )% cohort ( ncohort )% sapwood = cmass IF ( PRESENT ( precip ) ) THEN CALL GET_ALLOMETRY ( ALLOM_SWITCH , cmass , densindiv , ht , diam , basal , precip ( j )) ELSE CALL GET_ALLOMETRY ( ALLOM_SWITCH , cmass , densindiv , ht , diam , basal ) ENDIF pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( ncohort )% height = ht pop % pop_grid ( j )% patch ( k )% layer ( 1 )% cohort ( ncohort )% diameter = diam ENDIF ENDDO ENDDO END SUBROUTINE layer_recruitment_single_patch !******************************************************************************* ! Exponential distribution ! Returns probability of a given time-between-events (x) ! Given a Poisson process with expected frequency (events per unit time) lambda ! Reference: http://en.wikipedia.org/wiki/Exponential_distribution ! Use to determine average age (x, years) of patches with a given random disturbance ! frequency lambda (disturbances per year) REAL ( dp ) FUNCTION Exponential ( lambda , x ) IMPLICIT NONE INTEGER ( i4b ), INTENT ( IN ) :: x REAL ( dp ), INTENT ( IN ) :: lambda IF ( x . LT . 0.0_dp ) THEN ! Shouldn't happen but ... Exponential = 0.0_dp ELSE Exponential = lambda * EXP ( - lambda * x ) ENDIF END FUNCTION Exponential !******************************************************************************* ! Exponential distribution ! Returns probability of a given time-between-events (x) ! Given a Poisson process with expected frequency (events per unit time) lambda ! Reference: http://en.wikipedia.org/wiki/Exponential_distribution ! Use to determine average age (x, years) of patches with a given random disturbance ! frequency lambda (disturbances per year) REAL ( dp ) FUNCTION REALExponential ( lambda , x ) IMPLICIT NONE REAL ( dp ), INTENT ( IN ) :: x REAL ( dp ), INTENT ( IN ) :: lambda IF ( x . LT . 0.0_dp ) THEN ! Shouldn't happen but ... REALExponential = 0.0_dp ELSE REALExponential = lambda * EXP ( - lambda * x ) ENDIF END FUNCTION REALExponential !******************************************************************************* REAL ( dp ) FUNCTION CumExponential ( lambda , x ) IMPLICIT NONE REAL ( dp ), INTENT ( IN ) :: x REAL ( dp ), INTENT ( IN ) :: lambda IF ( x . LT . 0.0_dp ) THEN ! Shouldn't happen but ... CumExponential = 0.0_dp ELSE CumExponential = 1.0_dp - EXP ( - lambda * x ) ENDIF END FUNCTION CumExponential !******************************************************************************* REAL ( dp ) FUNCTION Factorial ( n ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: n INTEGER :: i REAL ( dp ) :: Ans Ans = 1.0_dp DO i = 1 , n Ans = Ans * REAL ( i , dp ) END DO Factorial = Ans END FUNCTION Factorial !******************************************************************************* ! ALLOMETRY !******************************************************************************* SUBROUTINE GET_ALLOMETRY ( ALLOM_SWITCH , biomass , density , ht , diam , basal , precip ) #ifdef __MPI__ use mpi , only : MPI_Abort #endif IMPLICIT NONE INTEGER ( i4b ), INTENT ( IN ) :: ALLOM_SWITCH REAL ( dp ), INTENT ( IN ) :: biomass REAL ( dp ), INTENT ( IN ) :: density REAL ( dp ), INTENT ( IN ), OPTIONAL :: precip REAL ( dp ), INTENT ( OUT ) :: ht , diam , basal #ifdef __MPI__ integer :: ierr #endif ! Standard Allometry IF ( ALLOM_SWITCH . EQ . 0 ) THEN ht = ( Kbiometric ** ( 3.0_dp / 4.0_dp )) * ( 4.0_dp * biomass / ( max ( density , 1.0e-5_dp ) * WD * PI )) ** ( 1.0_dp / 4.0_dp ) diam = ( ht / Kbiometric ) ** ( 1.5_dp ) basal = PI * ( diam / 2.0_dp ) * ( diam / 2.0_dp ) * density * 1.0e4_dp ! Top-End Allometry following G.Cook ELSEIF ( ALLOM_SWITCH . EQ . 1. AND . PRESENT ( precip )) THEN ht = GetHeight ( precip , biomass , density ) CALL Allometry ( ht , biomass , density , diam , basal ) ! Allometry following Williams 2005, Model 5b ELSEIF ( ALLOM_SWITCH . EQ . 2 ) THEN CALL Williams_Allometry ( biomass , density , ht , diam , basal ) ELSE WRITE ( * , * ) \"Invalid Allometry settings in POP!\" WRITE ( * , * ) \"ALLOM_SWITCH   = \" , ALLOM_SWITCH WRITE ( * , * ) \"Precip present = \" , PRESENT ( precip ) #ifdef __MPI__ call MPI_Abort ( 0 , 85 , ierr ) ! Do not know comm nor rank here #else stop 85 #endif ENDIF END SUBROUTINE GET_ALLOMETRY !******************************************************************************* ! TOP-END ALLOMETRY STARTS HERE !******************************************************************************* ! Tree height based on precipitation and Gary Cook Top-End allometry ! Bisection solution for tree height (m) based on modified height-DBH relationship ! from Garry Cook (pers. comm. 15/4/2013) ! \"I have been using H=0.054xExp(0.0014xRF)xD + 4.05*exp(-0.00032*rf) with Rf in mm, D in cm and height in m.\" ! Since the above expression does not go to zero at diameter=0 it is linked to a simple linear equation ! for initial height growth (H=50*D with D in m) using a non-rectangular hyperbola to smooth between the two ! Mathematical derivation: see POP documentation ! Arguments: ! precip  = annual precipitation (mm) ! biomass = tree stem C biomass across patch (kgC/m2) ! density = tree density (indiv/m2) REAL ( dp ) FUNCTION GetHeight ( precip , biomass , density ) IMPLICIT NONE REAL ( dp ), INTENT ( IN ) :: precip REAL ( dp ), INTENT ( IN ) :: biomass REAL ( dp ), INTENT ( IN ) :: density REAL ( dp ), PARAMETER :: THETA = 0.99_dp ! Shape parameter, should be slightly <1 REAL ( dp ), PARAMETER :: HMIN = 0.001_dp ! min bound for tree height REAL ( dp ), PARAMETER :: HMAX = 10 0.0_dp ! max bound for tree height REAL ( dp ), PARAMETER :: EPS = 0.01_dp ! precision of the root INTEGER ( i4b ), PARAMETER :: MAXTRIES = 25 REAL ( dp ) :: alpha , beta , delta , rh , st , x1 , x2 , rtbis , dx , fmid , xmid , lhs , rhs INTEGER ( i4b ) :: b alpha = 4.05_dp * EXP ( - 0.00032_dp * precip ) beta = 5.4_dp * EXP ( 0.0014_dp * precip ) delta = 2.0_dp * SQRT ( biomass / density / WD / PI ) x1 = HMIN x2 = HMAX rtbis = x1 dx = x2 - x1 b = 0 fmid = EPS + 1.0_dp DO WHILE ( ABS ( dx ). GT . EPS . AND . b . LE . MAXTRIES ) b = b + 1 dx = dx * 0.5_dp xmid = rtbis + dx ! Evaluate LHS-RHS at height=xmid ! LHS-RHS should increase with increasing height lhs = xmid rh = 1.0_dp / SQRT ( xmid ) st = alpha + beta * delta * rh + 10 0.0_dp * delta * rh rhs = 1.0_dp / 2.0_dp / THETA * & ( st - SQRT ( st * st - 40 0.0_dp * THETA * alpha * delta * rh - & 40 0.0_dp * THETA * beta * delta * delta / xmid )) fmid = lhs - rhs IF ( fmid . LT . 0.0_dp ) rtbis = xmid ENDDO GetHeight = xmid END FUNCTION GetHeight !******************************************************************************* SUBROUTINE INTERPOLATE_BIOMASS_1D ( pop , disturbance_interval , it , g ) IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP INTEGER ( i4b ), INTENT ( IN ) :: disturbance_interval (:,:) INTEGER ( i4b ), INTENT ( IN ) :: it , g INTEGER ( i4b ) :: nage , iage , i_min , i_max INTEGER ( i4b ) :: i_min_growth , i_max_growth REAL ( dp ) :: disturbance_freq , tmp_min , tmp_max , tmp1_min , tmp1_max , tmp_array ( NPATCH2D ) REAL ( dp ) :: tmp2_min , tmp2_max REAL ( dp ) :: tmp3_min , tmp3_max REAL ( dp ) :: tmp4_min , tmp4_max LOGICAL :: MASK ( NPATCH2D ) INTEGER ( i4b ) :: age_min , age_max INTEGER ( i4b ) :: age_min_growth , age_max_growth INTEGER ( i4b ), ALLOCATABLE :: age (:) REAL ( dp ), ALLOCATABLE :: cmass_age (:), stress_mort_age (:), crowd_mort_age (:) REAL ( dp ), ALLOCATABLE :: csapwood_age (:), sapwood_area_age (:), growth_age (:) REAL ( dp ), ALLOCATABLE :: freq_age (:) ! get interpolated biomass,sapwood, stress mortality, crowding mortality, disturbance mortality POP % pop_grid ( g )% cmass_sum = 0.0_dp POP % pop_grid ( g )% stress_mortality = 0.0_dp POP % pop_grid ( g )% cat_mortality = 0.0_dp pop % pop_grid ( g )% crowding_mortality = 0.0_dp pop % pop_grid ( g )% csapwood_sum = 0.0_dp pop % pop_grid ( g )% sapwood_area = 0.0_dp tmp_array = 0.0_dp nage = min ( POP % pop_grid ( g )% patch ( 1 )% disturbance_interval ( 1 ), it ) + 1 ! maximum age !nage = maxval(pop%pop_grid(g)%patch(:)%age(1)) IF ( POP % pop_grid ( g )% LU == 2 ) then ! secondary forest nage = AGEMAX DO iage = AGEMAX , 1 , - 1 IF ( pop % pop_grid ( g )% freq_age ( iage ) > 0 ) THEN EXIT ELSE nage = nage - 1 ENDIF ENDDO ENDIF disturbance_freq = 1.0_dp / REAL ( disturbance_interval ( g , 1 ), dp ) IF (. NOT . ALLOCATED ( age )) ALLOCATE ( age ( nage )) IF (. NOT . ALLOCATED ( freq_age )) ALLOCATE ( freq_age ( nage )) IF (. NOT . ALLOCATED ( cmass_age )) ALLOCATE ( cmass_age ( nage )) IF (. NOT . ALLOCATED ( growth_age )) ALLOCATE ( growth_age ( nage )) IF (. NOT . ALLOCATED ( csapwood_age )) ALLOCATE ( csapwood_age ( nage )) IF (. NOT . ALLOCATED ( sapwood_area_age )) ALLOCATE ( sapwood_area_age ( nage )) IF (. NOT . ALLOCATED ( stress_mort_age )) ALLOCATE ( stress_mort_age ( nage )) IF (. NOT . ALLOCATED ( crowd_mort_age )) ALLOCATE ( crowd_mort_age ( nage )) !pop%pop_grid(g)%biomass_age(2:agemax) = pop%pop_grid(g)%biomass_age(1:agemax-1) !pop%pop_grid(g)%biomass_age(1) = 0.0 !cmass_age = pop%pop_grid(g)%biomass_age tmp_min = 0.0_dp tmp_max = 0.0_dp pop % pop_grid ( g )% biomass_age = 0.0_dp !IF (pop%LU(g)==2) THEN  ! secondary forest IF ( POP % pop_grid ( g )% LU == 2 ) then ! secondary forest DO iage = 1 , nage age ( iage ) = iage - 1 freq_age ( iage ) = pop % pop_grid ( g )% freq_age ( iage ) ENDDO ELSE DO iage = 1 , nage age ( iage ) = iage - 1 freq_age ( iage ) = REALExponential ( disturbance_freq , REAL ( age ( iage ), dp )) pop % pop_grid ( g )% freq_age ( iage ) = freq_age ( iage ) END DO ENDIF if ( sum ( freq_age ) > 0.0_dp ) freq_age = freq_age / sum ( freq_age ) DO iage = 1 , nage ! get nearest ages bracketing age(iage) if ( any ( pop % pop_grid ( g )% patch (:)% age ( 1 ). LE . age ( iage ))) then age_min = MAXVAL ( pop % pop_grid ( g )% patch (:)% age ( 1 ), & pop % pop_grid ( g )% patch (:)% age ( 1 ). LE . age ( iage )) i_min = MAXLOC ( pop % pop_grid ( g )% patch (:)% age ( 1 ), 1 , & pop % pop_grid ( g )% patch (:)% age ( 1 ). LE . age ( iage )) else age_min = 0 i_min = 0 endif if ( any ( pop % pop_grid ( g )% patch (:)% age ( 1 ). GE . age ( iage ))) then age_max = MINVAL ( pop % pop_grid ( g )% patch (:)% age ( 1 ), & pop % pop_grid ( g )% patch (:)% age ( 1 ). GE . age ( iage )) i_max = MINLOC ( pop % pop_grid ( g )% patch (:)% age ( 1 ), 1 , & pop % pop_grid ( g )% patch (:)% age ( 1 ). GE . age ( iage )) else age_max = 0 i_max = 0 endif age_min_growth = age_min age_max_growth = age_max i_min_growth = i_min i_max_growth = i_max if (( i_min . gt . 0 ). and .( i_max . gt . 0 ). and .( age_max . eq . age_min )) then ! no need to interpolate MASK = pop % pop_grid ( g )% patch (:)% age ( 1 ). eq . age_min where ( MASK ) tmp_array = 1.0_dp elsewhere tmp_array = 0.0_dp endwhere cmass_age ( iage ) = & SUM ( pop % pop_grid ( g )% patch (:)% layer ( 1 )% biomass , MASK ) / SUM ( tmp_array ) growth_age ( iage ) = & SUM ( pop % pop_grid ( g )% patch (:)% growth , MASK ) / SUM ( tmp_array ) csapwood_age ( iage ) = SUM ( pop % pop_grid ( g )% patch (:)% sapwood , MASK ) / SUM ( tmp_array ) sapwood_area_age ( iage ) = & SUM ( pop % pop_grid ( g )% patch (:)% sapwood_area , MASK ) / SUM ( tmp_array ) stress_mort_age ( iage ) = & SUM ( pop % pop_grid ( g )% patch (:)% stress_mortality , MASK ) / SUM ( tmp_array ) crowd_mort_age ( iage ) = & SUM ( pop % pop_grid ( g )% patch (:)% crowding_mortality , MASK ) / SUM ( tmp_array ) else ! interpolate or extrapolate if (( i_min . eq . 0 ). and .( i_max . gt . 0 )) then ! interpolate to zero age_min = 0 i_min = 0 elseif (( i_max . eq . 0 ). and .( i_min . gt . 0 )) then ! extrapolate to higher age age_max = age_min i_max = i_min age_min = MAXVAL ( pop % pop_grid ( g )% patch (:)% age ( 1 ), & pop % pop_grid ( g )% patch (:)% age ( 1 ). LT . age_max ) i_min = MAXLOC ( pop % pop_grid ( g )% patch (:)% age ( 1 ), 1 , & pop % pop_grid ( g )% patch (:)% age ( 1 ). LT . age_max ) endif ! interpolate or extrapolate (growth) if (( i_min_growth . eq . 0 ). and .( i_max_growth . gt . 0 ). and . age ( iage ). LE . 2 ) then ! interpolate to zero age_min_growth = 0 i_min_growth = 0 elseif ((( age_min_growth . LE . 2 ). OR .( i_min_growth . eq . 0 )). and . & ( i_max_growth . gt . 0 ). and . age ( iage ). GT . 2 ) then ! extrapolate to lower age age_min_growth = age_max_growth i_min_growth = i_max_growth age_max_growth = MINVAL ( pop % pop_grid ( g )% patch (:)% age ( 1 ), & pop % pop_grid ( g )% patch (:)% age ( 1 ). GT . age_min_growth ) i_max_growth = MINLOC ( pop % pop_grid ( g )% patch (:)% age ( 1 ), 1 , & pop % pop_grid ( g )% patch (:)% age ( 1 ). GT . age_min_growth ) elseif (( i_max_growth . eq . 0 ). and .( i_min_growth . gt . 0 )) then ! extrapolate to higher age age_max_growth = age_min_growth i_max_growth = i_min_growth age_min_growth = MAXVAL ( pop % pop_grid ( g )% patch (:)% age ( 1 ), & pop % pop_grid ( g )% patch (:)% age ( 1 ). LT . age_max_growth ) i_min_growth = MAXLOC ( pop % pop_grid ( g )% patch (:)% age ( 1 ), 1 , & pop % pop_grid ( g )% patch (:)% age ( 1 ). LT . age_max_growth ) endif if ( i_min . ne . 0. and . age_min . ne . 0 ) then MASK = pop % pop_grid ( g )% patch (:)% age ( 1 ). eq . age_min where ( MASK ) tmp_array = 1.0_dp elsewhere tmp_array = 0.0_dp endwhere tmp_min = SUM ( pop % pop_grid ( g )% patch (:)% layer ( 1 )% biomass , MASK ) / SUM ( tmp_array ) tmp1_min = SUM ( pop % pop_grid ( g )% patch (:)% stress_mortality , MASK ) / SUM ( tmp_array ) tmp2_min = SUM ( pop % pop_grid ( g )% patch (:)% crowding_mortality , MASK ) / SUM ( tmp_array ) tmp3_min = SUM ( pop % pop_grid ( g )% patch (:)% sapwood , MASK ) / SUM ( tmp_array ) tmp4_min = SUM ( pop % pop_grid ( g )% patch (:)% sapwood_area , MASK ) / SUM ( tmp_array ) else tmp_min = 0.0_dp tmp1_min = 0.0_dp tmp2_min = 0.0_dp tmp3_min = 0.0_dp tmp4_min = 0.0_dp endif MASK = pop % pop_grid ( g )% patch (:)% age ( 1 ). eq . age_max where ( MASK ) tmp_array = 1.0_dp elsewhere tmp_array = 0.0_dp endwhere tmp_max = SUM ( pop % pop_grid ( g )% patch (:)% layer ( 1 )% biomass , MASK ) / SUM ( tmp_array ) tmp1_max = SUM ( pop % pop_grid ( g )% patch (:)% stress_mortality , MASK ) / SUM ( tmp_array ) tmp2_max = SUM ( pop % pop_grid ( g )% patch (:)% crowding_mortality , MASK ) / SUM ( tmp_array ) tmp3_max = SUM ( pop % pop_grid ( g )% patch (:)% sapwood , MASK ) / SUM ( tmp_array ) tmp4_max = SUM ( pop % pop_grid ( g )% patch (:)% sapwood_area , MASK ) / SUM ( tmp_array ) cmass_age ( iage ) = tmp_min + ( tmp_max - tmp_min ) / real ( age_max - age_min , dp ) * & real ( age ( iage ) - age_min , dp ) stress_mort_age ( iage ) = tmp1_min + ( tmp1_max - tmp1_min ) / real ( age_max - age_min , dp ) * & real ( age ( iage ) - age_min , dp ) crowd_mort_age ( iage ) = tmp2_min + ( tmp2_max - tmp2_min ) / real ( age_max - age_min , dp ) * & real ( age ( iage ) - age_min , dp ) csapwood_age ( iage ) = tmp3_min + ( tmp3_max - tmp3_min ) / real ( age_max - age_min , dp ) * & real ( age ( iage ) - age_min , dp ) sapwood_area_age ( iage ) = tmp4_min + ( tmp4_max - tmp4_min ) / real ( age_max - age_min , dp ) * & real ( age ( iage ) - age_min , dp ) if ( i_min_growth . ne . 0. and . age_min_growth . ne . 0 ) then MASK = pop % pop_grid ( g )% patch (:)% age ( 1 ). eq . age_min_growth where ( MASK ) tmp_array = 1.0_dp elsewhere tmp_array = 0.0_dp endwhere tmp_min = SUM ( pop % pop_grid ( g )% patch (:)% growth , MASK ) / SUM ( tmp_array ) else tmp_min = 0.0_dp endif MASK = pop % pop_grid ( g )% patch (:)% age ( 1 ). eq . age_max_growth where ( MASK ) tmp_array = 1.0_dp elsewhere tmp_array = 0.0_dp endwhere tmp_max = SUM ( pop % pop_grid ( g )% patch (:)% growth , MASK ) / SUM ( tmp_array ) growth_age ( iage ) = tmp_min + ( tmp_max - tmp_min ) / real ( age_max_growth - age_min_growth , dp ) * & real ( age ( iage ) - age_min_growth , dp ) !cmass_age(iage) = cmass_age(iage) + growth_age(iage) -  stress_mort_age(iage) - crowd_mort_age(iage) endif ! write(*,*) 'age_min, age_max 1:', age(iage), age_min, age_max, i_min, i_max !if (it.eq.403) then !   witer(58,*) age(iage),age_min, age_max, tmp1_min, tmp1_max,  stress_mort_age(iage), i_min !endif POP % pop_grid ( g )% cmass_sum = POP % pop_grid ( g )% cmass_sum + & freq_age ( iage ) * cmass_age ( iage ) POP % pop_grid ( g )% csapwood_sum = POP % pop_grid ( g )% csapwood_sum + & freq_age ( iage ) * csapwood_age ( iage ) POP % pop_grid ( g )% sapwood_area = POP % pop_grid ( g )% sapwood_area + & freq_age ( iage ) * sapwood_area_age ( iage ) !$if (g==2) then !$write(71, \"(2i4, 350e16.6)\")  it,  iage, freq_age(iage), cmass_age(iage), growth_age(iage),  stress_mort_age(iage), & !$ crowd_mort_age(iage), tmp_min, tmp_max, real(age_max_growth), real(age_min_growth) !$endif !$if (g==2) write(72, \"(2i4, 350e16.6)\")  it,  iage, freq_age(iage), cmass_age(iage) !$if (g==1) write(71, \"(2i4, 350e16.6)\")  it,  iage, freq_age(iage), cmass_age(iage) POP % pop_grid ( g )% stress_mortality = POP % pop_grid ( g )% stress_mortality + & freq_age ( iage ) * stress_mort_age ( iage ) POP % pop_grid ( g )% crowding_mortality = POP % pop_grid ( g )% crowding_mortality + & freq_age ( iage ) * crowd_mort_age ( iage ) pop % pop_grid ( g )% biomass_age ( iage ) = cmass_age ( iage ) enddo POP % pop_grid ( g )% cat_mortality = POP % pop_grid ( g )% growth - & POP % pop_grid ( g )% stress_mortality - & POP % pop_grid ( g )% crowding_mortality - & ( POP % pop_grid ( g )% cmass_sum - POP % pop_grid ( g )% cmass_sum_old ) POP % pop_grid ( g )% fire_mortality = 0.0_dp POP % pop_grid ( g )% res_mortality = 0.0_dp !$if (g==4) then !$   write(*,*) 'it, nage, growth', it, nage !$write(*,*) 'patch biomass', pop%pop_grid(g)%patch(1:5)%layer(1)%biomass !$write(*,*) 'patch growth', pop%pop_grid(g)%patch(1:5)%growth !$write(*,*) 'stress mort', pop%pop_grid(g)%patch(1:5)%stress_mortality !$   write(591, \"(350e16.6)\") freq_age !$   write(601,\"(350e16.6)\") cmass_age !$   write(602,\"(350e16.6)\") stress_mort_age !$   write(603,\"(350e16.6)\") real(age) !$if (it==5) stop !$endif DEALLOCATE ( age ) DEALLOCATE ( freq_age ) DEALLOCATE ( cmass_age ) DEALLOCATE ( stress_mort_age ) END SUBROUTINE INTERPOLATE_BIOMASS_1D !******************************************************************************* SUBROUTINE INTERPOLATE_FIREMORTALITY ( pop , disturbance_interval , it , g ) IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP INTEGER ( i4b ), INTENT ( IN ) :: disturbance_interval (:,:) INTEGER ( i4b ), INTENT ( IN ) :: it , g INTEGER ( i4b ) :: nage , iage , i_min , i_max INTEGER ( i4b ) :: i_min_growth , i_max_growth REAL ( dp ) :: disturbance_freq , tmp_min , tmp_max , tmp_array ( NPATCH2D ) REAL ( dp ) :: tmp5_min , tmp5_max LOGICAL :: MASK ( NPATCH2D ) INTEGER ( i4b ) :: age_min , age_max INTEGER ( i4b ) :: age_min_growth , age_max_growth INTEGER ( i4b ), ALLOCATABLE :: age (:) REAL ( dp ), ALLOCATABLE :: fire_mort_age (:) REAL ( dp ), ALLOCATABLE :: freq_age (:) ! get interpolated fire mortality POP % pop_grid ( g )% fire_mortality = 0.0_dp tmp_array = 0.0_dp nage = min ( POP % pop_grid ( g )% patch ( 1 )% disturbance_interval ( 1 ), it ) + 1 ! maximum age IF ( POP % pop_grid ( g )% LU == 2 ) then ! secondary forest nage = AGEMAX DO iage = AGEMAX , 1 , - 1 IF ( pop % pop_grid ( g )% freq_age ( iage ) > 0 ) THEN EXIT ELSE nage = nage - 1 ENDIF ENDDO ENDIF disturbance_freq = 1.0_dp / REAL ( disturbance_interval ( g , 1 ), dp ) IF (. NOT . ALLOCATED ( age )) ALLOCATE ( age ( nage )) IF (. NOT . ALLOCATED ( freq_age )) ALLOCATE ( freq_age ( nage )) IF (. NOT . ALLOCATED ( fire_mort_age )) ALLOCATE ( fire_mort_age ( nage )) tmp_min = 0.0_dp tmp_max = 0.0_dp pop % pop_grid ( g )% biomass_age = 0.0_dp IF ( POP % pop_grid ( g )% LU == 2 ) then ! secondary forest DO iage = 1 , nage age ( iage ) = iage - 1 freq_age ( iage ) = pop % pop_grid ( g )% freq_age ( iage ) ENDDO ELSE DO iage = 1 , nage age ( iage ) = iage - 1 freq_age ( iage ) = REALExponential ( disturbance_freq , REAL ( age ( iage ), dp )) pop % pop_grid ( g )% freq_age ( iage ) = freq_age ( iage ) END DO ENDIF if ( sum ( freq_age ) > 0.0_dp ) freq_age = freq_age / sum ( freq_age ) DO iage = 1 , nage ! get nearest ages bracketing age(iage) if ( any ( pop % pop_grid ( g )% patch (:)% age ( 1 ). LE . age ( iage ))) then age_min = MAXVAL ( pop % pop_grid ( g )% patch (:)% age ( 1 ), & pop % pop_grid ( g )% patch (:)% age ( 1 ). LE . age ( iage )) i_min = MAXLOC ( pop % pop_grid ( g )% patch (:)% age ( 1 ), 1 , & pop % pop_grid ( g )% patch (:)% age ( 1 ). LE . age ( iage )) else age_min = 0 i_min = 0 endif if ( any ( pop % pop_grid ( g )% patch (:)% age ( 1 ). GE . age ( iage ))) then age_max = MINVAL ( pop % pop_grid ( g )% patch (:)% age ( 1 ), & pop % pop_grid ( g )% patch (:)% age ( 1 ). GE . age ( iage )) i_max = MINLOC ( pop % pop_grid ( g )% patch (:)% age ( 1 ), 1 , & pop % pop_grid ( g )% patch (:)% age ( 1 ). GE . age ( iage )) else age_max = 0 i_max = 0 endif age_min_growth = age_min age_max_growth = age_max i_min_growth = i_min i_max_growth = i_max if (( i_min . gt . 0 ). and .( i_max . gt . 0 ). and .( age_max . eq . age_min )) then ! no need to interpolate MASK = pop % pop_grid ( g )% patch (:)% age ( 1 ). eq . age_min where ( MASK ) tmp_array = 1.0_dp elsewhere tmp_array = 0.0_dp endwhere fire_mort_age ( iage ) = & SUM ( pop % pop_grid ( g )% patch (:)% fire_mortality , MASK ) / SUM ( tmp_array ) else ! interpolate or extrapolate if (( i_min . eq . 0 ). and .( i_max . gt . 0 )) then ! interpolate to zero age_min = 0 i_min = 0 elseif (( i_max . eq . 0 ). and .( i_min . gt . 0 )) then ! extrapolate to higher age age_max = age_min i_max = i_min age_min = MAXVAL ( pop % pop_grid ( g )% patch (:)% age ( 1 ), & pop % pop_grid ( g )% patch (:)% age ( 1 ). LT . age_max ) i_min = MAXLOC ( pop % pop_grid ( g )% patch (:)% age ( 1 ), 1 , & pop % pop_grid ( g )% patch (:)% age ( 1 ). LT . age_max ) endif if ( i_min . ne . 0. and . age_min . ne . 0 ) then MASK = pop % pop_grid ( g )% patch (:)% age ( 1 ). eq . age_min where ( MASK ) tmp_array = 1.0_dp elsewhere tmp_array = 0.0_dp endwhere tmp5_min = SUM ( pop % pop_grid ( g )% patch (:)% fire_mortality , MASK ) / SUM ( tmp_array ) else tmp5_min = 0.0_dp endif MASK = pop % pop_grid ( g )% patch (:)% age ( 1 ). eq . age_max where ( MASK ) tmp_array = 1.0_dp elsewhere tmp_array = 0.0_dp endwhere tmp5_max = SUM ( pop % pop_grid ( g )% patch (:)% fire_mortality , MASK ) / SUM ( tmp_array ) fire_mort_age ( iage ) = tmp5_min + ( tmp5_max - tmp5_min ) / real ( age_max - age_min , dp ) * & real ( age ( iage ) - age_min , dp ) endif POP % pop_grid ( g )% fire_mortality = POP % pop_grid ( g )% fire_mortality + & freq_age ( iage ) * fire_mort_age ( iage ) enddo DEALLOCATE ( age ) DEALLOCATE ( freq_age ) DEALLOCATE ( fire_mort_age ) END SUBROUTINE INTERPOLATE_FIREMORTALITY !******************************************************************************* SUBROUTINE ADJUST_POP_FOR_FIRE ( pop , disturbance_interval , burned_area , FLI ) ! reduces biomass on a cohort basis according to mortality vs dbh function ! interpolates patch-based fire mortality to get grid-cell mortality IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: pop INTEGER ( i4b ), INTENT ( IN ) :: disturbance_interval (:,:) REAL ( dp ), INTENT ( IN ) :: burned_area (:), FLI (:) INTEGER ( i4b ) :: g , np , c , k , it , nc REAL ( dp ) :: mort , cmass_stem , dbh np = SIZE ( POP % POP_grid ) mort = 0.0 DO g = 1 , np POP % pop_grid ( g )% fire_mortality = 0.0_dp if ( burned_area ( g ) > 0.0_dp ) then it = maxval ( pop % pop_grid ( g )% patch (:)% age ( 1 )) + 1 DO k = 1 , NPATCH nc = pop % pop_grid ( g )% patch ( k )% Layer ( 1 )% ncohort pop % pop_grid ( g )% patch ( k )% fire_mortality = 0.0_dp DO c = 1 , nc dbh = pop % pop_grid ( g )% patch ( k )% layer ( 1 )% cohort ( c )% diameter * 10 0.0_dp cmass_stem = pop % pop_grid ( g )% patch ( k )% layer ( 1 )% cohort ( c )% biomass mort = TopKill_Collins ( dbh , FLI ( g )) * burned_area ( g ) pop % pop_grid ( g )% patch ( k )% fire_mortality = mort * & pop % pop_grid ( g )% patch ( k )% Layer ( 1 )% cohort ( c )% biomass + & pop % pop_grid ( g )% patch ( k )% fire_mortality pop % pop_grid ( g )% patch ( k )% Layer ( 1 )% cohort ( c )% biomass = cmass_stem * ( 1.0_dp - mort ) pop % pop_grid ( g )% patch ( k )% Layer ( 1 )% cohort ( c )% heartwood = & pop % pop_grid ( g )% patch ( k )% Layer ( 1 )% cohort ( c )% heartwood * ( 1.0_dp - mort ) pop % pop_grid ( g )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood = & pop % pop_grid ( g )% patch ( k )% Layer ( 1 )% cohort ( c )% sapwood * ( 1.0_dp - mort ) pop % pop_grid ( g )% patch ( k )% fire_top_kill_density = & pop % pop_grid ( g )% patch ( k )% fire_top_kill_density + & pop % pop_grid ( g )% patch ( k )% Layer ( 1 )% cohort ( c )% density * mort pop % pop_grid ( g )% patch ( k )% Layer ( 1 )% cohort ( c )% density = & pop % pop_grid ( g )% patch ( k )% Layer ( 1 )% cohort ( c )% density * ( 1.0_dp - mort ) ENDDO nc = pop % pop_grid ( g )% patch ( k )% Layer ( 1 )% ncohort pop % pop_grid ( g )% patch ( k )% biomass_old = pop % pop_grid ( g )% patch ( k )% Layer ( 1 )% biomass pop % pop_grid ( g )% patch ( k )% Layer ( 1 )% biomass = & SUM ( pop % pop_grid ( g )% patch ( k )% Layer ( 1 )% cohort ( 1 : nc )% biomass ) ! need to remove cohorts with very low density? ! This will get done at the end of the year anyway ENDDO ENDIF ! INTREPOLATE amongst patches to get total biomass lost to fire ! creates new value for  POP%pop_grid(g)%fire_mortality CALL INTERPOLATE_FIREMORTALITY ( pop , disturbance_interval , it , g ) POP % pop_grid ( g )% cmass_sum = POP % pop_grid ( g )% cmass_sum - POP % pop_grid ( g )% fire_mortality ENDDO END SUBROUTINE ADJUST_POP_FOR_FIRE !******************************************************************************* SUBROUTINE INTERPOLATE_BIOMASS_2D ( pop , disturbance_interval , it , g ) use mo_utils , only : eq #ifdef __MPI__ use mpi , only : MPI_Abort #endif IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP INTEGER ( i4b ), INTENT ( IN ) :: disturbance_interval (:,:) INTEGER ( i4b ), INTENT ( IN ) :: it , g INTEGER ( i4b ), allocatable :: A1 (:), A2 (:) ! interpolated ages INTEGER ( i4b ), allocatable :: xobs (:), yobs (:) ! observed ages REAL ( dp ), allocatable :: z1obs (:), z2obs (:), z3obs (:) ! observed biomass, stress_mort, crowd_mort REAL ( dp ), allocatable :: z1interp (:), z2interp (:), z3interp (:) ! interpolated biomass, stress mortality, crowding mortality REAL ( dp ), allocatable :: freq_interp (:) ! weightings for interpolated age pairs REAL ( dp ), allocatable :: zp (:) ! euclidean distance from interpolated age pair to observed age pairs INTEGER ( i4b ) :: age_max ( 2 ), nrep ( NPATCH2D + 1 ) INTEGER ( i4b ) :: tmp1 , tmp2 , I1 , I2 , I3 , I4 INTEGER ( i4b ) :: x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4 INTEGER ( i4b ) :: p , j , k , n , np , nobs , count_extrap , ct LOGICAL :: flag REAL ( dp ) :: biomass ( NPATCH2D + 1 ), stress_mort ( NPATCH2D + 1 ), crowd_mort ( NPATCH2D + 1 ) INTEGER ( i4b ) :: age1 ( NPATCH2D + 1 ), age2 ( NPATCH2D + 1 ) REAL ( dp ) :: zmin INTEGER ( i4b ), allocatable :: interp_case (:), tmp_array (:), tmp (:) REAL ( dp ) :: area ( 4 , 4 ), x ( 4 ), y ( 4 ), disturbance_freq1 , disturbance_freq2 INTEGER ( i4b ) :: triangle_points ( 4 , 3 ), I_inside_triangle , Ineighbour ( 8 ) LOGICAL :: MASK_INSIDE_TRIANGLE ( 4 ), IS_NEIGHBOUR ( 8 ), tmp_logical LOGICAL , allocatable :: MASK2 (:), MASK3 (:), MASK4 (:) INTEGER ( i4b ), allocatable :: address (:,:) #ifdef __MPI__ integer :: ierr #endif POP % pop_grid ( g )% cmass_sum = 0.0_dp POP % pop_grid ( g )% stress_mortality = 0.0_dp POP % pop_grid ( g )% crowding_mortality = 0.0_dp ! Construct Age  Interpolating Grid age_max ( 1 ) = min ( POP % pop_grid ( g )% patch ( 1 )% disturbance_interval ( 1 ), it ) + 1 ! maximum age age_max ( 2 ) = min ( POP % pop_grid ( g )% patch ( 1 )% disturbance_interval ( NDISTURB ), it ) + 1 ! maximum age p = 0 DO j = 0 , age_max ( 1 ) DO k = 0 , age_max ( 2 ) IF ( k > j ) THEN p = p + 1 ENDIF ENDDO ENDDO np = p ALLOCATE ( A1 ( np )) ALLOCATE ( A2 ( np )) ALLOCATE ( z1interp ( np )) ALLOCATE ( z2interp ( np )) ALLOCATE ( z3interp ( np )) ALLOCATE ( freq_interp ( np )) ALLOCATE ( interp_case ( np )) ALLOCATE ( tmp_array ( np )) ALLOCATE ( tmp ( np )) ALLOCATE ( address ( age_max ( 1 ) + 1 , age_max ( 2 ) + 1 )) p = 0 address = - 9999 DO j = 0 , age_max ( 1 ) DO k = 0 , age_max ( 2 ) IF ( k > j ) THEN p = p + 1 A1 ( p ) = j A2 ( p ) = k address ( j + 1 , k + 1 ) = p ENDIF ENDDO ENDDO ! Construct Age observations nrep = 1 flag = . false . j = 1 ! create \"observed\" age pair (0,0) with zero biomass stress_mort ( j ) = 0.0_dp biomass ( j ) = 0.0_dp crowd_mort ( j ) = 0.0_dp age1 ( j ) = 0 age2 ( j ) = 0 j = j + 1 do k = 1 , NPATCH2D tmp1 = pop % pop_grid ( g )% patch ( k )% age ( 1 ) tmp2 = pop % pop_grid ( g )% patch ( k )% age ( NDISTURB ) if ( j . gt . 1 ) then do n = 1 , j - 1 if ( tmp1 == age1 ( n ) . and . tmp2 == age2 ( n )) then flag = . true . nrep ( n ) = nrep ( n ) + 1 biomass ( n ) = biomass ( n ) + pop % pop_grid ( g )% patch ( k )% layer ( 1 )% biomass stress_mort ( n ) = stress_mort ( n ) + pop % pop_grid ( g )% patch ( k )% stress_mortality crowd_mort ( n ) = crowd_mort ( n ) + pop % pop_grid ( g )% patch ( k )% crowding_mortality endif enddo endif if ( flag . eqv . . false .) then age1 ( j ) = tmp1 age2 ( j ) = tmp2 biomass ( j ) = pop % pop_grid ( g )% patch ( k )% layer ( 1 )% biomass stress_mort ( j ) = pop % pop_grid ( g )% patch ( k )% stress_mortality crowd_mort ( j ) = pop % pop_grid ( g )% patch ( k )% crowding_mortality if ( k . ne . NPATCH2D ) j = j + 1 else flag = . false . endif enddo nobs = j biomass ( 1 : nobs ) = biomass ( 1 : nobs ) / nrep ( 1 : nobs ) stress_mort ( 1 : nobs ) = stress_mort ( 1 : nobs ) / nrep ( 1 : nobs ) crowd_mort ( 1 : nobs ) = crowd_mort ( 1 : nobs ) / nrep ( 1 : nobs ) ALLOCATE ( xobs ( nobs )) ALLOCATE ( yobs ( nobs )) ALLOCATE ( z1obs ( nobs )) ALLOCATE ( z2obs ( nobs )) ALLOCATE ( z3obs ( nobs )) ALLOCATE ( zp ( nobs )) ALLOCATE ( MASK2 ( nobs )) ALLOCATE ( MASK3 ( nobs )) ALLOCATE ( MASK4 ( nobs )) xobs = age1 ( 1 : nobs ) yobs = age2 ( 1 : nobs ) z1obs = biomass ( 1 : nobs ) z2obs = stress_mort ( 1 : nobs ) z3obs = crowd_mort ( 1 : nobs ) if ( it . eq . 500 ) then do k = 1 , nobs write ( 502 , \"(2i5,2e16.6,i5)\" ) xobs ( k ), yobs ( k ), z1obs ( k ), z3obs ( k ), nrep ( k ) enddo endif ! get weightings for each interpolated age pair do k = 1 , np disturbance_freq1 = 1.0_dp / REAL ( disturbance_interval ( g , 1 ), dp ) disturbance_freq2 = 1.0_dp / REAL ( disturbance_interval ( g , 2 ), dp ) freq_interp ( k ) = REALExponential ( disturbance_freq1 , REAL ( A1 ( k ), dp )) * & REALExponential ( disturbance_freq2 , REAL ( A2 ( k ), dp )) ENDDO freq_interp = freq_interp / sum ( freq_interp ) ! interpolate DO p = 1 , np ! loop over interpolated age pairs ! get distance to all observations DO j = 1 , nobs zp ( j ) = sqrt (( real ( A1 ( p ), dp ) - real ( xobs ( j ), dp )) ** 2 + ( real ( A2 ( p ), dp ) - real ( yobs ( j ), dp )) ** 2 ) ENDDO ! get closest point zmin = MINVAL ( zp ) I1 = MINLOC ( zp , 1 ) x1 = xobs ( I1 ) y1 = yobs ( I1 ) ! check for obs locations forming a quadrangle around interpolating point MASK2 = ( sign ( 1 , A1 ( p ) - xobs ) == - sign ( 1 , A1 ( p ) - x1 )). AND .( sign ( 1 , A2 ( p ) - yobs ) == sign ( 1 , A2 ( p ) - y1 ). and . A1 ( p ). NE . xobs ) MASK3 = ( sign ( 1 , A1 ( p ) - xobs ) == sign ( 1 , A1 ( p ) - x1 )). AND .( sign ( 1 , A2 ( p ) - yobs ) == - sign ( 1 , A2 ( p ) - y1 ). and . A2 ( p ). NE . yobs ) MASK4 = ( sign ( 1 , A1 ( p ) - xobs ) == - sign ( 1 , A1 ( p ) - x1 )). AND .( sign ( 1 , A2 ( p ) - yobs ) == - sign ( 1 , A2 ( p ) - y1 ) & . and . A1 ( p ). NE . xobs . and . A2 ( p ). NE . yobs ) IF (( ANY ( MASK2 )). and .( ANY ( MASK3 )). and .( ANY ( MASK4 ))) THEN ! get nearest point with opposing sign of x displacement I2 = MINLOC ( zp , 1 , MASK2 ) x2 = xobs ( I2 ) y2 = yobs ( I2 ) ! get nearest point with opposing sign of y displacement I3 = MINLOC ( zp , 1 , MASK3 ) x3 = xobs ( I3 ) y3 = yobs ( I3 ) ! get nearest point with opposing sign of x & y displacements I4 = MINLOC ( zp , 1 , MASK4 ) x4 = xobs ( I4 ) y4 = yobs ( I4 ) tmp_logical = . NOT .( ( x2 . eq . 0. and . y2 . eq . 0 ). OR .( x3 . eq . 0. and . y3 . eq . 0 ). OR .( x4 . eq . 0. and . y4 . eq . 0 )) ENDIF IF (( A1 ( p ) == x1 ). and .( A2 ( p ) == y1 )) THEN interp_case ( p ) = 1 ELSEIF (( ANY ( MASK2 )). and .( ANY ( MASK3 )). and .( ANY ( MASK4 )) . AND . tmp_logical ) THEN ! quadrangle (without (0,0)) exists interp_case ( p ) = 2 ELSE interp_case ( p ) = 3 ENDIF !j=1 select case ( interp_case ( p )) case ( 1 ) ! interpolated point is the same as observation z1interp ( p ) = z1obs ( I1 ) z2interp ( p ) = z2obs ( I1 ) z3interp ( p ) = z3obs ( I1 ) case ( 3 ) ! extrapolation required: set to value of nearest observation z1interp ( p ) = z1obs ( I1 ) z2interp ( p ) = z2obs ( I1 ) z3interp ( p ) = z3obs ( I1 ) case ( 2 ) ! quadrangle ! get nearest point with opposing sign of x displacement I2 = MINLOC ( zp , 1 , MASK2 ) x2 = xobs ( I2 ) y2 = yobs ( I2 ) ! get nearest point with opposing sign of y displacement I3 = MINLOC ( zp , 1 , MASK3 ) x3 = xobs ( I3 ) y3 = yobs ( I3 ) ! get nearest point with opposing sign of x & y displacements I4 = MINLOC ( zp , 1 , MASK4 ) x4 = xobs ( I4 ) y4 = yobs ( I4 ) x = real (( / x1 , x2 , x3 , x4 / ), dp ) y = real (( / y1 , y2 , y3 , y4 / ), dp ) ! get area of four possible triangles from 4 vertices, and corresponding 3 partial ! triangles, with observation as one vertex area = 0.0_dp triangle_points = 0 triangle_points ( 1 ,:) = ( / I1 , I2 , I3 / ) area ( 1 , 1 ) = area_triangle ( x ( 1 ), y ( 1 ), x ( 2 ), y ( 2 ), x ( 3 ), y ( 3 )) area ( 1 , 2 ) = area_triangle ( real ( A1 ( p ), dp ), real ( A2 ( p ), dp ), x ( 2 ), y ( 2 ), x ( 3 ), y ( 3 )) area ( 1 , 3 ) = area_triangle ( real ( A1 ( p ), dp ), real ( A2 ( p ), dp ), x ( 1 ), y ( 1 ), x ( 3 ), y ( 3 )) area ( 1 , 4 ) = area_triangle ( real ( A1 ( p ), dp ), real ( A2 ( p ), dp ), x ( 1 ), y ( 1 ), x ( 2 ), y ( 2 )) triangle_points ( 2 ,:) = ( / I1 , I2 , I4 / ) area ( 2 , 1 ) = area_triangle ( x ( 1 ), y ( 1 ), x ( 2 ), y ( 2 ), x ( 4 ), y ( 4 )) area ( 2 , 2 ) = area_triangle ( real ( A1 ( p ), dp ), real ( A2 ( p ), dp ), x ( 2 ), y ( 2 ), x ( 4 ), y ( 4 )) area ( 2 , 3 ) = area_triangle ( real ( A1 ( p ), dp ), real ( A2 ( p ), dp ), x ( 1 ), y ( 1 ), x ( 4 ), y ( 4 )) area ( 2 , 4 ) = area_triangle ( real ( A1 ( p ), dp ), real ( A2 ( p ), dp ), x ( 1 ), y ( 1 ), x ( 2 ), y ( 2 )) triangle_points ( 3 ,:) = ( / I1 , I4 , I3 / ) area ( 3 , 1 ) = area_triangle ( x ( 1 ) , y ( 1 ), x ( 3 ), y ( 3 ), x ( 4 ), y ( 4 )) area ( 3 , 2 ) = area_triangle ( real ( A1 ( p ), dp ), real ( A2 ( p ), dp ), x ( 4 ), y ( 4 ), x ( 3 ), y ( 3 )) area ( 3 , 3 ) = area_triangle ( real ( A1 ( p ), dp ), real ( A2 ( p ), dp ), x ( 1 ), y ( 1 ), x ( 3 ), y ( 3 )) area ( 3 , 4 ) = area_triangle ( real ( A1 ( p ), dp ), real ( A2 ( p ), dp ), x ( 1 ), y ( 1 ), x ( 4 ), y ( 4 )) triangle_points ( 4 ,:) = ( / I2 , I4 , I3 / ) area ( 4 , 1 ) = area_triangle ( x ( 2 ), y ( 2 ), x ( 3 ), y ( 3 ), x ( 4 ), y ( 4 )); area ( 4 , 2 ) = area_triangle ( real ( A1 ( p ), dp ), real ( A2 ( p ), dp ), x ( 4 ), y ( 4 ), x ( 3 ), y ( 3 )) area ( 4 , 3 ) = area_triangle ( real ( A1 ( p ), dp ), real ( A2 ( p ), dp ), x ( 2 ), y ( 2 ), x ( 3 ), y ( 3 )) area ( 4 , 4 ) = area_triangle ( real ( A1 ( p ), dp ), real ( A2 ( p ), dp ), x ( 2 ), y ( 2 ), x ( 4 ), y ( 4 )) MASK_INSIDE_TRIANGLE = eq ( area (:, 1 ), sum ( area (:, 2 : 4 ), 2 )) I_inside_triangle = MINLOC ( area (:, 1 ), 1 , MASK_INSIDE_TRIANGLE ) z1interp ( p ) = SUM ( z1obs ( triangle_points ( I_inside_triangle ,:)) * & area ( I_inside_triangle , 2 : 4 )) / sum ( area ( I_inside_triangle , 2 : 4 )) z2interp ( p ) = SUM ( z2obs ( triangle_points ( I_inside_triangle ,:)) * & area ( I_inside_triangle , 2 : 4 )) / sum ( area ( I_inside_triangle , 2 : 4 )) z3interp ( p ) = SUM ( z3obs ( triangle_points ( I_inside_triangle ,:)) * & area ( I_inside_triangle , 2 : 4 )) / sum ( area ( I_inside_triangle , 2 : 4 )) case default write ( * , * ) \" illegal interpolation case.\" #ifdef __MPI__ call MPI_Abort ( 0 , 86 , ierr ) ! Do not know comm nor rank here #else stop 86 #endif end select ! interpolation case ENDDO ! loop over interpolated age pairs p = 0 ! counter for while loop count_extrap = 0 ! Extrapolation IF ( ANY ( interp_case . NE . 3 )) THEN DO WHILE ( ANY ( interp_case == 3 )) DO ct = 3 , 3 DO p = 1 , np ! find number of neighbours for each extrapolable point is_neighbour = . FALSE . Ineighbour = 1 tmp ( p ) = 0 IF ( interp_case ( p ) == 3 ) THEN DO k = 1 , 8 if ( k == 1 ) then tmp1 = A1 ( p ) - 1 tmp2 = A2 ( p ) elseif ( k == 2 ) then tmp1 = A1 ( p ) + 1 tmp2 = A2 ( p ) elseif ( k == 3 ) then tmp1 = A1 ( p ) tmp2 = A2 ( p ) - 1 elseif ( k == 4 ) then tmp1 = A1 ( p ) tmp2 = A2 ( p ) + 1 elseif ( k == 5 ) then tmp1 = A1 ( p ) - 1 tmp2 = A2 ( p ) - 1 elseif ( k == 6 ) then tmp1 = A1 ( p ) + 1 tmp2 = A2 ( p ) + 1 elseif ( k == 7 ) then tmp1 = A1 ( p ) + 1 tmp2 = A2 ( p ) - 1 elseif ( k == 8 ) then tmp1 = A1 ( p ) - 1 tmp2 = A2 ( p ) + 1 endif IF ( tmp1 . ge . 0. and . tmp1 . LE . age_max ( 1 ). and . tmp2 . ge . 0. and . tmp2 . LE . age_max ( 2 ). and . tmp2 . gt . tmp1 ) THEN is_neighbour ( k ) = ( interp_case ( address ( tmp1 + 1 , tmp2 + 1 )). ne . 3 ) Ineighbour ( k ) = address ( tmp1 + 1 , tmp2 + 1 ) ENDIF ENDDO tmp ( p ) = COUNT ( is_neighbour ) if ( tmp ( p ). GE . ct ) then z1interp ( p ) = sum ( z1interp ( Ineighbour ) , is_neighbour ) / real ( tmp ( p ), dp ) z2interp ( p ) = sum ( z2interp ( Ineighbour ) , is_neighbour ) / real ( tmp ( p ), dp ) z3interp ( p ) = sum ( z3interp ( Ineighbour ) , is_neighbour ) / real ( tmp ( p ), dp ) interp_case ( p ) = 2 endif ENDIF ENDDO !1, np ENDDO IF ( ALL ( tmp . lt . 3 )) THEN ! maximum of one neighbour p = MAXLOC ( tmp , 1 ) is_neighbour = . FALSE . Ineighbour = 1 tmp ( p ) = 0 DO k = 1 , 8 if ( k == 1 ) then tmp1 = A1 ( p ) - 1 tmp2 = A2 ( p ) elseif ( k == 2 ) then tmp1 = A1 ( p ) + 1 tmp2 = A2 ( p ) elseif ( k == 3 ) then tmp1 = A1 ( p ) tmp2 = A2 ( p ) - 1 elseif ( k == 4 ) then tmp1 = A1 ( p ) tmp2 = A2 ( p ) + 1 elseif ( k == 5 ) then tmp1 = A1 ( p ) - 1 tmp2 = A2 ( p ) - 1 elseif ( k == 6 ) then tmp1 = A1 ( p ) + 1 tmp2 = A2 ( p ) + 1 elseif ( k == 7 ) then tmp1 = A1 ( p ) + 1 tmp2 = A2 ( p ) - 1 elseif ( k == 8 ) then tmp1 = A1 ( p ) - 1 tmp2 = A2 ( p ) + 1 endif IF ( tmp1 . ge . 0. and . tmp1 . LE . age_max ( 1 ). and . tmp2 . ge . 0. and . tmp2 . LE . age_max ( 2 ). and . tmp2 . gt . tmp1 ) THEN is_neighbour ( k ) = ( interp_case ( address ( tmp1 + 1 , tmp2 + 1 )). ne . 3 ) Ineighbour ( k ) = address ( tmp1 + 1 , tmp2 + 1 ) ENDIF ENDDO tmp ( p ) = COUNT ( is_neighbour ) z1interp ( p ) = sum ( z1interp ( Ineighbour ) , is_neighbour ) / real ( tmp ( p ), dp ) z2interp ( p ) = sum ( z2interp ( Ineighbour ) , is_neighbour ) / real ( tmp ( p ), dp ) z3interp ( p ) = sum ( z3interp ( Ineighbour ) , is_neighbour ) / real ( tmp ( p ), dp ) interp_case ( p ) = 2 ENDIF ! ALL(tmp.lt.2) ENDDO ! do while ENDIF DO p = 1 , np POP % pop_grid ( g )% cmass_sum = POP % pop_grid ( g )% cmass_sum + & freq_interp ( p ) * z1interp ( p ) POP % pop_grid ( g )% stress_mortality = POP % pop_grid ( g )% stress_mortality + & freq_interp ( p ) * z2interp ( p ) POP % pop_grid ( g )% crowding_mortality = POP % pop_grid ( g )% crowding_mortality + & freq_interp ( p ) * z3interp ( p ) ENDDO POP % pop_grid ( g )% cat_mortality = POP % pop_grid ( g )% cmass_sum * disturbance_freq2 POP % pop_grid ( g )% fire_mortality = POP % pop_grid ( g )% growth - & POP % pop_grid ( g )% cat_mortality - & POP % pop_grid ( g )% stress_mortality - & POP % pop_grid ( g )% crowding_mortality - & ( POP % pop_grid ( g )% cmass_sum - POP % pop_grid ( g )% cmass_sum_old ) DEALLOCATE ( xobs ) DEALLOCATE ( yobs ) DEALLOCATE ( z1obs ) DEALLOCATE ( z2obs ) DEALLOCATE ( z3obs ) DEALLOCATE ( zp ) DEALLOCATE ( MASK2 ) DEALLOCATE ( MASK3 ) DEALLOCATE ( MASK4 ) DEALLOCATE ( A1 ) DEALLOCATE ( A2 ) DEALLOCATE ( z1interp ) DEALLOCATE ( z2interp ) DEALLOCATE ( z3interp ) DEALLOCATE ( freq_interp ) DEALLOCATE ( interp_case ) DEALLOCATE ( tmp ) DEALLOCATE ( tmp_array ) DEALLOCATE ( address ) END SUBROUTINE INTERPOLATE_BIOMASS_2D !****************************************************************************** SUBROUTINE SMOOTH_FLUX ( POP , g , t ) IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP INTEGER ( i4b ), INTENT ( IN ) :: g , t INTEGER ( i4b ), PARAMETER :: SPAN = NYEAR_WINDOW REAL ( dp ) :: x ( NYEAR_SMOOTH ), y ( NYEAR_SMOOTH ), a , b , r REAL ( dp ) :: sumflux , sumsmooth , flux ( NYEAR_HISTORY ), smoothed_flux REAL ( dp ) :: dbuf INTEGER ( i4b ) :: t0 , tt , n , k ! update fire_mortality_history IF ( t . gt . NYEAR_HISTORY ) THEN DO k = 1 , NYEAR_HISTORY - 1 POP % pop_grid ( g )% fire_mortality_history ( k ) = POP % pop_grid ( g )% fire_mortality_history ( k + 1 ) ENDDO ENDIF POP % pop_grid ( g )% fire_mortality_history ( t ) = POP % pop_grid ( g )% fire_mortality flux = POP % pop_grid ( g )% fire_mortality_history t0 = t - SPAN n = 0 sumflux = 0.0_dp sumsmooth = 0.0_dp DO tt = 1 , NYEAR_SMOOTH IF (( t0 + tt ). GE . 1 . AND . ( t0 + tt ). LE . t + 1 ) THEN sumflux = sumflux + flux ( t0 + tt ) y ( tt ) = flux ( t0 + tt ) x ( tt ) = real ( tt , dp ) n = n + 1 IF (( t0 + tt ). eq . t + 1 ) THEN CALL regress ( x , y , n , a , b , r ) ENDIF ELSE sumflux = sumflux + ( a + b * tt ) n = n + 1 ENDIF ENDDO dbuf = POP % pop_grid ( g )% smoothing_buffer / ( real ( NYEAR_SMOOTH , dp ) / 2.0_dp ) smoothed_flux = max ( sumflux / real ( n ) + dbuf , 0.0_dp ) POP % pop_grid ( g )% smoothing_buffer = POP % pop_grid ( g )% smoothing_buffer + flux ( t ) - smoothed_flux POP % pop_grid ( g )% fire_mortality_smoothed = smoothed_flux END SUBROUTINE SMOOTH_FLUX !****************************************************************************** SUBROUTINE SMOOTH_FLUX_cat ( POP , g , t ) IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP INTEGER ( i4b ), INTENT ( IN ) :: g , t INTEGER ( i4b ), PARAMETER :: SPAN = NYEAR_WINDOW REAL ( dp ) :: x ( NYEAR_SMOOTH ), y ( NYEAR_SMOOTH ), a , b , r REAL ( dp ) :: sumflux , sumsmooth , flux ( NYEAR_HISTORY ), smoothed_flux REAL ( dp ) :: dbuf INTEGER ( i4b ) :: t0 , tt , n , k ! update cat_mortality_history IF ( t . gt . NYEAR_HISTORY ) THEN DO k = 1 , NYEAR_HISTORY - 1 POP % pop_grid ( g )% cat_mortality_history ( k ) = POP % pop_grid ( g )% cat_mortality_history ( k + 1 ) ENDDO ENDIF POP % pop_grid ( g )% cat_mortality_history ( t ) = POP % pop_grid ( g )% cat_mortality flux = POP % pop_grid ( g )% cat_mortality_history t0 = t - SPAN n = 0 sumflux = 0.0_dp sumsmooth = 0.0_dp DO tt = 1 , NYEAR_SMOOTH IF (( t0 + tt ). GE . 1 . AND . ( t0 + tt ). LE . t + 1 ) THEN sumflux = sumflux + flux ( t0 + tt - 1 ) y ( tt ) = flux ( t0 + tt - 1 ) x ( tt ) = real ( tt , dp ) n = n + 1 IF (( t0 + tt ). eq . t + 1 ) THEN CALL regress ( x , y , n , a , b , r ) ENDIF ELSE sumflux = sumflux + ( a + b * tt ) n = n + 1 ENDIF ENDDO dbuf = POP % pop_grid ( g )% smoothing_buffer_cat / ( real ( NYEAR_SMOOTH , dp ) / 2.0_dp ) smoothed_flux = max ( sumflux / real ( n ) + dbuf , 0.0_dp ) POP % pop_grid ( g )% smoothing_buffer_cat = POP % pop_grid ( g )% smoothing_buffer_cat + flux ( t ) - smoothed_flux POP % pop_grid ( g )% cat_mortality_smoothed = smoothed_flux END SUBROUTINE SMOOTH_FLUX_cat !****************************************************************************** SUBROUTINE REGRESS ( x , y , n , a , b , r ) IMPLICIT NONE REAL ( dp ), INTENT ( IN ) :: x (:), y (:) REAL ( dp ), INTENT ( OUT ) :: a , b , r INTEGER ( i4b ), INTENT ( IN ) :: n REAL ( dp ) :: sx , sy , sxx , sxy , delta , meanx , meany , sdx , sdy INTEGER ( i4b ) :: i ! Performs a linear regression of array y on array x (n values) ! returning parameters a and b in the fitted model: y=a+bx ! Source: Press et al 1986, Sect 14.2 ! also returns Pearson r sx = 0.0_dp sy = 0.0_dp sxx = 0.0_dp sxy = 0.0_dp DO i = 1 , n sx = sx + x ( i ) sy = sy + y ( i ) sxx = sxx + x ( i ) * y ( i ) sxy = sxy + x ( i ) * y ( i ) ENDDO delta = real ( n , dp ) * sxx - sx * sx a = ( sxx * sy - sx * sxy ) / delta b = ( real ( n , dp ) * sxy - sx * sy ) / delta meanx = sx / real ( n , dp ) meany = sy / real ( n , dp ) sdx = 0.0_dp sdy = 0.0_dp DO i = 1 , n sdx = sdx + ( x ( i ) - meanx ) * ( x ( i ) - meanx ) sdy = sdy + ( y ( i ) - meany ) * ( y ( i ) - meany ) ENDDO sdx = sqrt ( sdx / real ( n - 1 , dp )) sdy = sqrt ( sdy / real ( n - 1 , dp )) if (( abs ( sdx ) . lt . tiny ( 0.0_dp )) . or . ( abs ( sdy ) . lt . tiny ( 0.0_dp ))) then r = 0.0_dp else r = b * sdx / sdy ENDIF END SUBROUTINE REGRESS !****************************************************************************** REAL ( dp ) FUNCTION Area_Triangle ( x1 , y1 , x2 , y2 , x3 , y3 ) IMPLICIT NONE REAL ( dp ), INTENT ( IN ) :: x1 , y1 , x2 , y2 , x3 , y3 area_triangle = abs (( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 )) / 2.0_dp ) END FUNCTION Area_Triangle !****************************************************************************** ! Fraction of topkill by DBH , according to Fig. 2 of Collins, J. Ec., 2020 REAL ( dp ) FUNCTION TopKill_Collins ( dbh , FLI ) IMPLICIT NONE REAL ( dp ), INTENT ( IN ) :: dbh , FLI REAL ( dp ), PARAMETER :: a = 0.79130437_dp , b = 0.07999477_dp , c = 0.06326282_dp IF (( FLI > 300 0.0_dp ). and .( FLI < 700 0.0_dp )) then TopKill_Collins = 0.08_dp ELSEIF ( FLI > 700 0.0_dp ) then TopKill_Collins = max ( a * exp ( - b * dbh ) + c , 0.08_dp ) ELSE ! low intensity fires TopKill_Collins = 0.0_dp ENDIF END FUNCTION TopKill_Collins !****************************************************************************** ! Top-End Allometry ! Computes tree stem diameter (m) and basal area (m2/ha) ! given height (m), stem biomass (kgC/m2) and tree population density (indiv/m2) SUBROUTINE Allometry ( height , biomass , density , diam , basal ) IMPLICIT NONE REAL ( dp ), INTENT ( IN ) :: height REAL ( dp ), INTENT ( IN ) :: biomass REAL ( dp ), INTENT ( IN ) :: density REAL ( dp ), INTENT ( OUT ) :: diam REAL ( dp ), INTENT ( OUT ) :: basal REAL ( dp ) :: delta , rh delta = 2.0_dp * SQRT ( biomass / density / WD / PI ) rh = 1.0_dp / SQRT ( height ) diam = delta * rh basal = PI * ( diam / 2.0_dp ) * ( diam / 2.0_dp ) * density * 1.0e4_dp END SUBROUTINE Allometry !******************************************************************************* SUBROUTINE Williams_Allometry ( agBiomass , density , height , dbh , basal ) IMPLICIT NONE ! Allometry following Williams 2005, Model 5b (see table 2) ! Williams et al., \"Allometry for estimating aboveground tree biomass in tropical ! and subtropical eucalypt woodlands: towards general predictive equations\", ! Australian Journal of Botany, 2005, 53, 607-619 ! INPUT ! agbiomass: above ground biomass [kg(C)/m2] ! density  : tree population density [m-2] ! OUTPUT ! height   : tree height [m] ! dbh      : Diameter at breast height [m] ! basal    : Basal area [m2/ha] REAL ( dp ), INTENT ( IN ) :: agbiomass , density REAL ( dp ), INTENT ( OUT ) :: height , dbh , basal REAL ( dp ), PARAMETER :: beta0 = - 2.3046_dp REAL ( dp ), PARAMETER :: beta1 = 2.5243_dp REAL ( dp ), PARAMETER :: gC2DM = 1.0_dp / 0.49_dp ! ratio Dry matter mass to g(C) ! Compute dbh using model 5b and converting from cm -> m dbh = ( agbiomass * gC2DM / density / exp ( beta0 ) ) ** ( 1.0_dp / beta1 ) dbh = dbh * 0.01_dp ! Compute basal area [m&#94;2/m&#94;2] basal = PI * ( 0.5_dp * dbh ) ** 2 * density ! Compute Height using cylindrical approach height = agBiomass / ( WD * basal ) ! Basal Area [m&#94;2/m&#94;2]->[m&#94;2/ha] basal = basal * 1.0e4_dp END SUBROUTINE Williams_Allometry !******************************************************************************* SUBROUTINE POP_init ( POP , disturbance_interval , np , Iwood , precip ) USE POP_types , ONLY : POP_TYPE USE TypeDef , ONLY : i4b IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP INTEGER ( i4b ), INTENT ( IN ) :: disturbance_interval (:,:) INTEGER ( i4b ), INTENT ( IN ) :: np INTEGER ( i4b ), INTENT ( IN ) :: Iwood (:) REAL ( dp ), INTENT ( IN ), OPTIONAL :: precip (:) INTEGER ( i4b ) :: j , k CALL alloc_POP ( pop , int ( np )) POP % np = np POP % Iwood = Iwood POP % it_pop = 0 ! POP%LU = 1  ! initialise to primary forest POP % pop_grid (:)% LU = 1 CALL ZeroPOP ( pop ) CALL InitPOP2D_Poisson ( pop , int ( disturbance_interval , i4b )) DO j = 1 , np DO k = 1 , NPATCH2D ! understorey recruitment IF ( PRESENT ( precip )) THEN CALL layer_recruitment_single_patch ( pop , k , j , precip ) ELSE CALL layer_recruitment_single_patch ( pop , k , j ) ENDIF ENDDO ENDDO END SUBROUTINE POP_init !******************************************************************************* SUBROUTINE POP_init_single ( POP , disturbance_interval , n , precip ) USE POP_types , ONLY : POP_TYPE USE TypeDef , ONLY : i4b IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP INTEGER ( i4b ), INTENT ( IN ) :: disturbance_interval (:,:) INTEGER ( i4b ), INTENT ( IN ) :: n REAL ( dp ), INTENT ( IN ), OPTIONAL :: precip (:) INTEGER ( i4b ) :: j , k POP % it_pop ( n ) = 0 CALL ZeroPOP ( pop , n ) CALL InitPOP2D_Poisson ( pop , INT ( disturbance_interval , i4b ), n ) DO j = n , n DO k = 1 , NPATCH2D ! understorey recruitment IF ( PRESENT ( precip )) THEN CALL layer_recruitment_single_patch ( pop , k , j , precip ) ELSE CALL layer_recruitment_single_patch ( pop , k , j ) ENDIF ENDDO ENDDO END SUBROUTINE POP_init_single !******************************************************************************* SUBROUTINE alloc_POP ( POP , arraysize ) USE POP_Types , Only : POP_TYPE IMPLICIT NONE TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP INTEGER , INTENT ( IN ) :: arraysize IF (. NOT . ALLOCATED ( POP % POP_Grid )) ALLOCATE ( POP % POP_Grid ( arraysize )) IF (. NOT . ALLOCATED ( POP % Iwood )) ALLOCATE ( POP % Iwood ( arraysize )) ! IF (.NOT. ALLOCATED(POP%LU)) ALLOCATE (POP%LU(arraysize)) IF (. NOT . ALLOCATED ( POP % it_pop )) ALLOCATE ( POP % it_pop ( arraysize )) END SUBROUTINE alloc_POP !******************************************************************************* END MODULE POPModule !*******************************************************************************","tags":"","loc":"sourcefile/pop.f90.html"},{"title":"casa_cnp.F90 – POP","text":"This file depends on sourcefile~~casa_cnp.f90~~EfferentGraph sourcefile~casa_cnp.f90 casa_cnp.F90 sourcefile~casa_variable.f90 casa_variable.F90 sourcefile~casa_cnp.f90->sourcefile~casa_variable.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~casa_cnp.f90~~AfferentGraph sourcefile~casa_cnp.f90 casa_cnp.F90 sourcefile~casa_cable.f90 casa_cable.F90 sourcefile~casa_cable.f90->sourcefile~casa_cnp.f90 sourcefile~casa_inout.f90 casa_inout.F90 sourcefile~casa_cable.f90->sourcefile~casa_inout.f90 sourcefile~casa_inout.f90->sourcefile~casa_cnp.f90 sourcefile~casaonly_luc.f90 CASAONLY_LUC.F90 sourcefile~casaonly_luc.f90->sourcefile~casa_cable.f90 sourcefile~casaonly_luc.f90->sourcefile~casa_inout.f90 sourcefile~spincasacnp.f90 spincasacnp.F90 sourcefile~spincasacnp.f90->sourcefile~casa_cable.f90 sourcefile~spincasacnp.f90->sourcefile~casa_inout.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules casa_cnp_module Source Code casa_cnp.F90 Source Code ! ============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: subroutines for calculating carbon, nitrogen, phosphorus cycle !          including plant growth ! ! Called from: biogeochem (mostly) or casa_xnp ! ! Contact: Yingping.Wang@csiro.au ! ! History: Developed by Yingping Wang (Wang et al., BG, 2011) !          Current version uses fixed phenology. ! ! Sep 2015: option of climate-driven phenology (V. Haverd) !           search for cable_user%PHENOLOGY_SWITCH (Ticket #110) ! May 2016: option of acclimation of auttrophic respiration (V. Haverd) !            search for cable_user%CALL_climate (Ticket#110) !         : fixes to prevent carbon and nitrogen pools from going negative !           search for Ticket#108 (V.Haverd) !         : alternative functional form of vcmax, called when cable_user%vcmax=='Walker2014' !           (V.Haverd) !         : alternative allocation switch integer: LALLOC=3. (V.Haverd) !           leaf:wood allocation set to maintain LA:SA ratio !           below target value (requires casaflux%sapwood_area !           inherited from POP demography module. (Ticket#61) ! Feb 2019 : DAMM Enzyme kinetics implemented as a switchable option for soil and litter ! carbon tunover responses to temperature and moisture ! Feb 2020 : additional turnover of plant and litter pools due to fire (inherited from BLAZE) ! ============================================================================== ! ! This module contains the following subroutines: !   casa_xnp !   casa_allocation !   casa_rplant !   casa_xrateplant,        casa_xratesoil !   casa_coeffplant,        casa_coeffsoil !   casa_delplant,          casa_delsoil !   avgsoil !   casa_xkN !   casa_nuptake,           casa_puptake !   casa_Nrequire,          casa_Prequire !   casa_cnpcycle !   casa_poolzero !   casa_cnpbal !   casa_ndummy !   phenology MODULE casa_cnp_module USE cable_def_types_mod USE casadimension USE casaparm USE casavariable USE phenvariable USE cable_IO_vars_module , ONLY : wlogn USE cable_common_module , only : cable_user ! Custom soil respiration: Ticket #42 implicit none real ( r_2 ), parameter :: zero = 0.0_r_2 real ( r_2 ), parameter :: one = 1.0_r_2 CONTAINS SUBROUTINE casa_xnp ( xnplimit , xNPuptake , veg , casabiome , casapool , casaflux , casamet ) IMPLICIT NONE REAL ( r_2 ), DIMENSION ( mp ), INTENT ( OUT ) :: xnplimit REAL ( r_2 ), DIMENSION ( mp ), INTENT ( OUT ) :: xNPuptake TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet ! local variables INTEGER :: np REAL ( r_2 ), DIMENSION ( mp ) :: xnlimit , xplimit REAL ( r_2 ), DIMENSION ( mp ) :: xncleaf , xpcleaf REAL ( r_2 ), DIMENSION ( mp ) :: xnCnpp , xpCnpp REAL ( r_2 ), DIMENSION ( mp , mplant ) :: Nreqmax , Nreqmin , NtransPtoP REAL ( r_2 ), DIMENSION ( mp ) :: totNreqmax , totNreqmin REAL ( r_2 ), DIMENSION ( mp ) :: xNuptake , xPuptake REAL ( r_2 ), DIMENSION ( mp , mplant ) :: Preqmax , Preqmin , PtransPtoP REAL ( r_2 ), DIMENSION ( mp ) :: totPreqmax , totPreqmin xnlimit = 1.0_r_2 xplimit = 1.0_r_2 xnplimit = 1.0_r_2 casaflux % fracClabile (:) = 0.0_r_2 SELECT CASE ( icycle ) CASE ( 2 ) WHERE ( casamet % iveg2 /= icewater ) xncleaf (:) = casapool % nplant (:, leaf ) / ( casapool % cplant (:, leaf ) + 1.0e-10_r_2 ) !xnlimit(:) = xncleaf(:)/(xncleaf(:)+casabiome%KminN(veg%iveg(:))) xnlimit (:) = xncleaf (:) / ( xncleaf (:) + 0.01_r_2 ) xplimit (:) = 1.0_r_2 xnplimit (:) = min ( xnlimit (:), xplimit (:)) * casabiome % xnpmax ( veg % iveg (:)) ENDWHERE CASE ( 3 ) WHERE ( casamet % iveg2 /= icewater ) xncleaf (:) = casapool % nplant (:, leaf ) / ( casapool % cplant (:, leaf ) + 1.0e-10_r_2 ) xnlimit (:) = xncleaf (:) / ( xncleaf (:) + 0.01_r_2 ) xpcleaf (:) = casapool % pplant (:, leaf ) / ( casapool % cplant (:, leaf ) + 1.0e-10_r_2 ) !xplimit(:) = xpcleaf(:)/(xpcleaf(:)+casabiome%Kuplabp(veg%iveg(:))) xplimit (:) = xpcleaf (:) / ( xpcleaf (:) + 0.0006_r_2 ) !xnplimit(:) = min(1.0_r_2,casabiome%Kuptake(veg%iveg(:))*min(xnlimit(:),xplimit(:))) xnplimit (:) = min ( xnlimit (:), xplimit (:)) * casabiome % xnpmax ( veg % iveg (:)) ENDWHERE END SELECT ! now check if soil nutrient supply can meet the plant uptake, ! otherwise reduce NPP xNuptake = 1.0_r_2 xPuptake = 1.0_r_2 IF ( icycle > 1 ) THEN Nreqmin (:,:) = 0.0_r_2 Nreqmax (:,:) = 0.0_r_2 NtransPtoP (:,:) = 0.0_r_2 totNreqmax = 0.0_r_2 totNreqmin = 0.0_r_2 xNuptake = 1.0_r_2 xnCnpp = max ( 0.0_r_2 , casaflux % Cnpp ) call casa_Nrequire ( xnCnpp , Nreqmin , Nreqmax , NtransPtoP , veg , & casabiome , casapool , casaflux , casamet ) DO np = 1 , mp IF ( casamet % iveg2 ( np ) /= icewater ) THEN totNreqmax ( np ) = Nreqmax ( np , leaf ) + Nreqmax ( np , wood ) + Nreqmax ( np , froot ) totNreqmin ( np ) = Nreqmin ( np , leaf ) + Nreqmin ( np , wood ) + Nreqmin ( np , froot ) xNuptake ( np ) = MAX ( 0.0_r_2 , MIN ( 1.0_r_2 , casapool % Nsoilmin ( np ) & / ( totNreqmin ( np ) * deltpool + 1.e-10_r_2 ))) ENDIF ENDDO ENDIF IF ( icycle > 2 ) THEN Preqmin (:,:) = 0.0_r_2 Preqmax (:,:) = 0.0_r_2 PtransPtoP (:,:) = 0.0_r_2 totPreqmax = 0.0_r_2 totPreqmin = 0.0_r_2 xPuptake = 1.0_r_2 xpCnpp = max ( 0.0_r_2 , casaflux % Cnpp ) call casa_Prequire ( xpCnpp , Preqmin , Preqmax , PtransPtoP , veg , & casabiome , casapool , casaflux , casamet ) DO np = 1 , mp IF ( casamet % iveg2 ( np ) /= icewater ) THEN totPreqmax ( np ) = Preqmax ( np , leaf ) + Preqmax ( np , wood ) + Preqmax ( np , froot ) totPreqmin ( np ) = Preqmin ( np , leaf ) + Preqmin ( np , wood ) + Preqmin ( np , froot ) xPuptake ( np ) = MAX ( 0.0_r_2 , MIN ( 1.0_r_2 , casapool % psoillab ( np ) & / ( totPreqmin ( np ) * deltpool + 1.e-10_r_2 ))) ENDIF ENDDO ENDIF xnplimit (:) = 1.0_r_2 xNPuptake (:) = min ( xnuptake (:), xpuptake (:)) do np = 1 , mp if ( casamet % iveg2 ( np ) /= icewater . and . casaflux % cnpp ( np ) > 0.0_r_2 . and . xNPuptake ( np ) < 1.0_r_2 ) then if ( casaflux % fHarvest ( np ) . lt . 0.1_r_2 ) then ! N limitation on growth not applied to crop/pasture casaflux % fracClabile ( np ) = min ( 1.0_r_2 , max ( 0.0_r_2 , ( 1.0_r_2 - xNPuptake ( np )))) * & max ( 0.0_r_2 , casaflux % cnpp ( np )) / ( casaflux % cgpp ( np ) + 1.e-10_r_2 ) casaflux % cnpp ( np ) = casaflux % cnpp ( np ) - casaflux % fracClabile ( np ) * casaflux % cgpp ( np ) endif endif enddo END SUBROUTINE casa_xnp SUBROUTINE casa_allocation ( veg , soil , casabiome , casaflux , casapool , casamet , phen , LALLOC ) ! compute fraction of net photosynthate allocated to leaf, wood and froot ! ! inputs !   moistavg(mp)           as an argument (volume fraction) !   tsoilavg(mp)           as an argument (K) !   btran(mp)              as an argument (dimensionless) ! outputs: !   fracCalloc(mp,mplant1) ! ! modified Piere's alocation scheme ! input: leaf stage !        leaf area IMPLICIT NONE TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil ! soil parameters TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( phen_variable ), INTENT ( INOUT ) :: phen INTEGER , INTENT ( IN ) :: LALLOC ! local variables REAL ( r_2 ), DIMENSION ( mp , mplant ) :: fracCallocx REAL ( r_2 ), DIMENSION ( mp ) :: xLalloc , xwsalloc , xTalloc REAL ( r_2 ), DIMENSION ( mp ) :: xWorNalloc , xNalloc , xWalloc REAL ( r_2 ), DIMENSION ( mp ) :: totfracCalloc REAL ( r_2 ), DIMENSION ( mp ) :: newLAI ! initlization casaflux % fracCalloc = 0.0_r_2 !casaflux%fracClabile = 0.0_r_2 fracCallocx = 0.0_r_2 newLAI = 0.0_r_2 SELECT CASE ( LALLOC ) CASE ( 2 ) ! ! calculate the allocation coefficients call casa_wolf ( veg , casabiome , casaflux , casapool , casamet ) CASE ( 1 ) ! dynamic allocation WHERE ( casamet % iveg2 /= icewater ) xLalloc (:) = min ( 1.0_r_2 , max ( 0.0_r_2 , exp ( - 0.5_r_2 * casamet % glai (:)))) ! L limiting ! Pseudo-nutrient limitation calculation WHERE ( casamet % tsoilavg > 0.0_r_2 ) xwsalloc (:) = min ( max ( casamet % moistavg (:) - soil % swilt (:), 0.0_r_2 ) & / ( soil % sfc (:) - soil % swilt (:)), 1.0_r_2 ) ELSE WHERE xwsalloc (:) = 0.01_r_2 END WHERE xTalloc (:) = min ( 1.0_r_2 , max ( 0.0_r_2 , Q10alloc ** & (( casamet % tsoilavg (:) - TkzeroC - 3 0.0_r_2 ) / 1 0.0_r_2 ) )) !T limiting xNalloc (:) = min ( 1.0_r_2 , max ( 0.0_r_2 , xwsalloc (:) * xTalloc (:))) !N limiting xWalloc (:) = min ( 1.0_r_2 , max ( 0.0_r_2 , casamet % btran (:))) !W limiting xWorNalloc (:) = min ( xWalloc (:), xNalloc (:)) WHERE ( casamet % lnonwood == 0 ) casaflux % fracCalloc (:, FROOT ) = R0 * 3.0_r_2 * xLalloc (:) & / ( xLalloc (:) + 2.0_r_2 * xWorNalloc (:)) casaflux % fracCalloc (:, WOOD ) = S0 * 3.0_r_2 * xWorNalloc (:) & / ( 2.0_r_2 * xLalloc (:) + xWorNalloc (:)) casaflux % fracCalloc (:, LEAF ) = 1.0_r_2 - casaflux % fracCalloc (:, FROOT ) & - casaflux % fracCalloc (:, WOOD ) ELSE WHERE casaflux % fracCalloc (:, FROOT ) = R0 * 3.0_r_2 * xLalloc (:) & / ( xLalloc (:) + 2.0_r_2 * xWorNalloc (:)) casaflux % fracCalloc (:, WOOD ) = 0.0_r_2 casaflux % fracCalloc (:, LEAF ) = 1.0_r_2 - casaflux % fracCalloc (:, FROOT ) END WHERE END WHERE CASE ( 0 ) ! fixed allocation casaflux % fracCalloc (:,:) = casabiome % fracnpptop ( veg % iveg (:),:) CASE ( 3 ) ! leaf:wood allocation set to maintain LA:SA ratio ! below target value of casabiome%la_to_sa, where phen%phase = 1 or 2 !(requires casaflux%sapwood_area, which is inherited from the ! POP tree demography module. (Ticket #61) WHERE ( casamet % lnonwood == 0 ) casaflux % fracCalloc (:, FROOT ) = casabiome % fracnpptop ( veg % iveg (:), FROOT ) casaflux % fracCalloc (:, WOOD ) = 0.01_r_2 casaflux % fracCalloc (:, LEAF ) = 1.0_r_2 - casaflux % fracCalloc (:, FROOT ) - & casaflux % fracCalloc (:, WOOD ) newLAI = casamet % glai + ( casaflux % fracCalloc (:, LEAF ) * casaflux % cnpp - & casaflux % kplant_tot (:, leaf ) * casapool % cplant (:, LEAF )) * casabiome % sla ( veg % iveg (:)) where ( ( casaflux % sapwood_area . gt . 1.0e-6_r_2 ) . and . & ( newLAI . gt .( casabiome % la_to_sa ( veg % iveg (:)) * casaflux % sapwood_area )) . and . & ( casaflux % cnpp . gt . 0.0_r_2 ) ) casaflux % fracCalloc (:, LEAF ) = ( ( casabiome % la_to_sa ( veg % iveg (:)) * casaflux % sapwood_area & - casamet % glai ) / casabiome % sla ( veg % iveg (:)) & + casaflux % kplant_tot (:, leaf ) * casapool % cplant (:, LEAF ) ) / casaflux % cnpp casaflux % fracCalloc (:, LEAF ) = max ( 0.0_r_2 , casaflux % fracCalloc (:, LEAF )) casaflux % fracCalloc (:, LEAF ) = min ( 1.0_r_2 - casaflux % fracCalloc (:, FROOT ) - & casaflux % fracCalloc (:, WOOD ), casaflux % fracCalloc (:, LEAF )) casaflux % fracCalloc (:, WOOD ) = 1.0_r_2 - casaflux % fracCalloc (:, FROOT ) - & casaflux % fracCalloc (:, LEAF ) end where ELSEWHERE casaflux % fracCalloc (:, FROOT ) = casabiome % fracnpptop ( veg % iveg (:), FROOT ) casaflux % fracCalloc (:, WOOD ) = 0.0_r_2 casaflux % fracCalloc (:, LEAF ) = casabiome % fracnpptop ( veg % iveg (:), LEAF ) ENDWHERE END SELECT ! during leaf growth phase 0 or 3, no carbon is allocated to leaf, ! during maximal leaf growth phase, all C is allocated to leaf ! during steady growth period, C allocation is estimated in such ! a way that approach the allometric relationship ! the relationships are:(all pools in g C/m2) ! for forests !   fineroot/totalC C=0.3192-0.0485*(totalC)&#94;0.1755, see mokany et al. (2003) !   fineroot = ratiofrootleaf*cleaf ! for grassland !   root=ratiofinerootleaf*cleaf ! vh edit to avoid overwriting CASE(3) for woody veg !! vh_js !! IF ( LALLOC . ne .( 3 )) THEN WHERE ( casamet % iveg2 /= icewater ) WHERE ( phen % phase == 0 ) casaflux % fracCalloc (:, leaf ) = 0.0_r_2 casaflux % fracCalloc (:, froot ) = casaflux % fracCalloc (:, froot ) & / ( casaflux % fracCalloc (:, froot ) & + casaflux % fracCalloc (:, wood )) casaflux % fracCalloc (:, wood ) = 1.0_r_2 - casaflux % fracCalloc (:, froot ) END WHERE WHERE ( phen % phase == 1 ) casaflux % fracCalloc (:, leaf ) = 0.95_r_2 WHERE ( casamet % lnonwood == 0 ) !woodland or forest casaflux % fracCalloc (:, froot ) = 0.5_r_2 * ( 1.0_r_2 - casaflux % fracCalloc (:, leaf )) casaflux % fracCalloc (:, wood ) = 0.5_r_2 * ( 1.0_r_2 - casaflux % fracCalloc (:, leaf )) ELSEWHERE !grassland casaflux % fracCalloc (:, froot ) = 1.0_r_2 - casaflux % fracCalloc (:, leaf ) ENDWHERE END WHERE WHERE ( phen % phase == 3 ) !      casaflux%fracClabile(:)  = casaflux%fracCalloc(:,leaf) casaflux % fracCalloc (:, froot ) = 1.0_r_2 - casaflux % fracCalloc (:, wood ) casaflux % fracCalloc (:, leaf ) = 0.0_r_2 ENDWHERE ! IF Prognostic LAI reached glaimax, no C is allocated to leaf ! Q.Zhang 17/03/2011 WHERE ( casamet % glai (:) >= casabiome % glaimax ( veg % iveg (:))) casaflux % fracCalloc (:, leaf ) = 0.0_r_2 casaflux % fracCalloc (:, froot ) = casaflux % fracCalloc (:, froot ) & / ( casaflux % fracCalloc (:, froot ) & + casaflux % fracCalloc (:, wood )) casaflux % fracCalloc (:, wood ) = 1.0_r_2 - casaflux % fracCalloc (:, froot ) ENDWHERE ! added in for negative NPP and one of biomass pool being zero ypw 27/jan/2014 WHERE ( casaflux % Cnpp < 0.0_r_2 ) casaflux % fracCalloc (:, leaf ) = casaflux % Crmplant (:, leaf ) / sum ( casaflux % Crmplant , 2 ) casaflux % fracCalloc (:, wood ) = casaflux % Crmplant (:, wood ) / sum ( casaflux % Crmplant , 2 ) casaflux % fracCalloc (:, froot ) = casaflux % Crmplant (:, froot ) / sum ( casaflux % Crmplant , 2 ) ENDWHERE !! vh_js !! !! as long as biomass is positive, adjust allocation to be !! proportional to stock when NPP -ve (Ticket#108) WHERE ( casaflux % Cnpp < 0.0_r_2 . and . sum ( casapool % Cplant , 2 ) > 0.0_r_2 ) casaflux % fracCalloc (:, leaf ) = casapool % Cplant (:, leaf ) / sum ( casapool % Cplant , 2 ) casaflux % fracCalloc (:, wood ) = casapool % Cplant (:, wood ) / sum ( casapool % Cplant , 2 ) casaflux % fracCalloc (:, froot ) = casapool % Cplant (:, froot ) / sum ( casapool % Cplant , 2 ) ENDWHERE ENDWHERE ELSE WHERE ( casamet % iveg2 /= icewater ) WHERE ( phen % phase == 0 ) casaflux % fracCalloc (:, leaf ) = 0.0_r_2 casaflux % fracCalloc (:, froot ) = casaflux % fracCalloc (:, froot ) & / ( casaflux % fracCalloc (:, froot ) + casaflux % fracCalloc (:, wood ) ) WHERE ( casamet % lnonwood == 0 ) casaflux % fracCalloc (:, wood ) = 1.0_r_2 - casaflux % fracCalloc (:, froot ) ELSEWHERE casaflux % fracCalloc (:, wood ) = 0.0_r_2 ENDWHERE END WHERE WHERE ( phen % phase == 1. and . casamet % lnonwood == 1 ) casaflux % fracCalloc (:, leaf ) = 0.80_r_2 casaflux % fracCalloc (:, froot ) = 1.0_r_2 - casaflux % fracCalloc (:, leaf ) casaflux % fracCalloc (:, wood ) = 0.0_r_2 ENDWHERE WHERE ( phen % phase == 3 ) ! casaflux%fracClabile(:) = casaflux%fracCalloc(:,leaf) casaflux % fracCalloc (:, froot ) = 1.0_r_2 - casaflux % fracCalloc (:, wood ) casaflux % fracCalloc (:, leaf ) = 0.0_r_2 ENDWHERE !! vh !! ! This fix can lead to over-allocation to roots, in turn bumping up N-uptake, ! leading to decline in mineral nitrogen availability and spikes in fracCalloc, ! causing spikes in tree mortality and lack of model convergence in productive ! regions where LAI is hitting LAImax: for woody pfts, ensure that LAImax ! parameter is very high (eg 10) ! IF Prognostic LAI reached glaimax, no C is allocated to leaf ! Q.Zhang 17/03/2011 WHERE ( casamet % glai (:) >= casabiome % glaimax ( veg % iveg (:))) casaflux % fracCalloc (:, leaf ) = 0.0_r_2 casaflux % fracCalloc (:, froot ) = casaflux % fracCalloc (:, froot ) & / ( casaflux % fracCalloc (:, froot ) + casaflux % fracCalloc (:, wood ) ) WHERE ( casamet % lnonwood == 0 ) casaflux % fracCalloc (:, wood ) = 1.0_r_2 - casaflux % fracCalloc (:, froot ) ELSEWHERE casaflux % fracCalloc (:, wood ) = 0.0_r_2 ENDWHERE ENDWHERE WHERE ( casamet % glai (:) < casabiome % glaimin ( veg % iveg (:))) casaflux % fracCalloc (:, leaf ) = 0.8_r_2 WHERE ( casamet % lnonwood == 0 ) ! woodland or forest casaflux % fracCalloc (:, froot ) = 0.5_r_2 * ( 1.0_r_2 - casaflux % fracCalloc (:, leaf )) casaflux % fracCalloc (:, wood ) = 0.5_r_2 * ( 1.0_r_2 - casaflux % fracCalloc (:, leaf )) ELSEWHERE ! grassland casaflux % fracCalloc (:, froot ) = 1.0_r_2 - casaflux % fracCalloc (:, leaf ) casaflux % fracCalloc (:, wood ) = 0.0_r_2 ENDWHERE ENDWHERE ! added in for negative NPP and one of biomass pool being zero ypw 27/jan/2014 WHERE ( casaflux % Cnpp < 0.0_r_2 ) WHERE ( casamet % lnonwood == 0 ) !woodland or forest casaflux % fracCalloc (:, leaf ) = casaflux % Crmplant (:, leaf ) / sum ( casaflux % Crmplant , 2 ) casaflux % fracCalloc (:, wood ) = casaflux % Crmplant (:, wood ) / sum ( casaflux % Crmplant , 2 ) casaflux % fracCalloc (:, froot ) = casaflux % Crmplant (:, froot ) / sum ( casaflux % Crmplant , 2 ) ELSEWHERE casaflux % fracCalloc (:, leaf ) = casaflux % Crmplant (:, leaf ) / sum ( casaflux % Crmplant , 2 ) casaflux % fracCalloc (:, wood ) = 0.0_r_2 casaflux % fracCalloc (:, froot ) = casaflux % Crmplant (:, froot ) / sum ( casaflux % Crmplant , 2 ) ENDWHERE ENDWHERE !! vh_js !!  Ticket#108 WHERE ( casaflux % Cnpp < 0.0_r_2 . and . sum ( casapool % Cplant , 2 ) > 0.0_r_2 ) WHERE ( casamet % lnonwood == 0 ) !woodland or forest casaflux % fracCalloc (:, leaf ) = casapool % Cplant (:, leaf ) / sum ( casapool % Cplant , 2 ) casaflux % fracCalloc (:, wood ) = casapool % Cplant (:, wood ) / sum ( casapool % Cplant , 2 ) casaflux % fracCalloc (:, froot ) = casapool % Cplant (:, froot ) / sum ( casapool % Cplant , 2 ) ELSEWHERE casaflux % fracCalloc (:, leaf ) = casapool % Cplant (:, leaf ) / sum ( casapool % Cplant , 2 ) casaflux % fracCalloc (:, wood ) = 0.0_r_2 casaflux % fracCalloc (:, froot ) = casapool % Cplant (:, froot ) / sum ( casapool % Cplant , 2 ) ENDWHERE ENDWHERE ENDWHERE ENDIF ! LALLOC=3 ! normalization the allocation fraction to ensure they sum up to 1 totfracCalloc (:) = sum ( casaflux % fracCalloc (:,:), 2 ) casaflux % fracCalloc (:, leaf ) = casaflux % fracCalloc (:, leaf ) / totfracCalloc (:) casaflux % fracCalloc (:, wood ) = casaflux % fracCalloc (:, wood ) / totfracCalloc (:) casaflux % fracCalloc (:, froot ) = casaflux % fracCalloc (:, froot ) / totfracCalloc (:) END SUBROUTINE casa_allocation SUBROUTINE casa_wolf ( veg , casabiome , casaflux , casapool , casamet ) ! carbon allocation based on ! Wolf, Field and Berry, 2011. Ecological Applications, p1546-1556 ! Wolf et al. 2011. Global Biogeochemical Cycles, 25, GB3015, doi:10.1019/2010GB003917 IMPLICIT NONE TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg ! vegetation parameters TYPE ( casa_biome ), INTENT ( IN ) :: casabiome TYPE ( casa_met ), INTENT ( IN ) :: casamet TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux real ( r_2 ), parameter :: wolf_alpha1 = 6.22_r_2 real ( r_2 ), parameter :: wolf_beta = - 1.33_r_2 real ( r_2 ), parameter :: wolf_c1 = - wolf_alpha1 / ( 1.0_r_2 + wolf_beta ) real ( r_2 ), parameter :: wolf_c2 = 1.0_r_2 / ( 1.0_r_2 + wolf_beta ) ! ! local variables integer npt real ( r_2 ), dimension ( mp ) :: totbmdm , ntree , nppdm real ( r_2 ), dimension ( mp ) :: gleaf , gwood , gcroot , gfroot , gtot ! ! input !  totleaf, totwood, totcroot, totfroot :    g C m-2 !  totnpp:                                   g C m-2 d-1 ! output !  fracleaf,fracwood, fraccroot, fracfroot:  fractions ! do npt = 1 , mp IF ( casamet % iveg2 ( npt ) == 3. and . casaflux % cnpp ( npt ) > 0.0001_r_2 ) THEN !forest types totbmdm ( npt ) = sum ( casapool % cplant ( npt ,:)) * 1 0.0_r_2 / fracCbiomass !10.0 for convert gc/m2 to kg/ha totbmdm ( npt ) = max ( 3000 0.0_r_2 , totbmdm ( npt )) ! calculate tree stocking density ntree ( npt ) = 1 0.0_r_2 ** ( wolf_c1 + wolf_c2 * log10 ( totbmdm ( npt ))) ! tree ha-1, based on eqn (4) of Wolf et al. 2011, GBC ntree ( npt ) = min ( 20000 0.0_r_2 , ntree ( npt )) ! changed by ypw 23/april/2012 to avoid negative npp nppdm ( npt ) = ( abs ( casaflux % cnpp ( npt )) * 36 5.0_r_2 * 0.001_r_2 / fracCbiomass ) / ( 0.0001_r_2 * ntree ( npt )) ! in kg dm tree-1 yr-1 gleaf ( npt ) = 0.156_r_2 * ( nppdm ( npt ) ** 1.106_r_2 ) ! Figure 2a of Wolf, Field and Berry (2011) gwood ( npt ) = 0.232_r_2 * ( nppdm ( npt ) ** 1.165_r_2 ) ! Figure 2b of Wolf, Field and Berry (2011) gcroot ( npt ) = 0.0348_r_2 * ( nppdm ( npt ) ** 1.310_r_2 ) ! Figure 2d of Wolf, Field and Berry (2011) gfroot ( npt ) = 0.247_r_2 * ( nppdm ( npt ) ** 0.987_r_2 ) ! Figure 2c of Wolf, Field and Berry (2011) gtot ( npt ) = gleaf ( npt ) + gwood ( npt ) + gcroot ( npt ) + gfroot ( npt ) casaflux % fracCalloc ( npt , leaf ) = gleaf ( npt ) / gtot ( npt ) casaflux % fracCalloc ( npt , wood ) = gwood ( npt ) / gtot ( npt ) casaflux % fracCalloc ( npt , froot ) = ( gcroot ( npt ) + gfroot ( npt )) / gtot ( npt ) ! write(87,*) 'allocation = ',npt,casamet%iveg2(npt), totbmdm(npt),ntree(npt),nppdm(npt),casaflux%fracCalloc(npt,:) ELSE ! other types casaflux % fracCalloc ( npt ,:) = casabiome % fracnpptop ( veg % iveg ( npt ),:) ENDIF enddo END SUBROUTINE casa_wolf SUBROUTINE casa_rplant ( veg , casabiome , casapool , casaflux , casamet , climate ) ! maintenance respiration of woody tisse and fineroots ! see Sitch et al. (2003), GCB, reqn (23) implicit none type ( veg_parameter_type ), intent ( inout ) :: veg ! vegetation parameters type ( casa_biome ), intent ( inout ) :: casabiome type ( casa_pool ), intent ( inout ) :: casapool type ( casa_flux ), intent ( inout ) :: casaflux type ( casa_met ), intent ( inout ) :: casamet type ( climate_type ), intent ( in ) :: climate integer :: npt , ivt real ( r_2 ), dimension ( mp ) :: Ygrow ! growth efficiency Q.Zhang 22/02/2011 real ( r_2 ), dimension ( mp , mplant ) :: ratioPNplant ! Q.Zhang 22/02/2011 real ( r_2 ), dimension ( mp ) :: delcrmwood , delcrmfroot ! reduction in wood and root respiration when NPP <0.0 real ( r_2 ), dimension ( mp ) :: resp_coeff_root , resp_coeff_sapwood real ( r_2 ), dimension ( mp ) :: nleaf , pleaf , vcmaxmax real ( r_2 ) :: c1 , c2 , c3 , c5 ! coefficients for acclimation of maintenance respiration resp_coeff_root = 1.0_r_2 resp_coeff_sapwood = 1.0_r_2 ratioPNplant = 0.0_r_2 Ygrow = 0.0_r_2 WHERE ( casapool % Nplant > 0.0_r_2 ) ratioPNplant = casapool % Pplant / ( casapool % Nplant + 1.e-10_r_2 ) ENDWHERE Ygrow (:) = 0.65_r_2 + 0.2_r_2 * ratioPNplant (:, leaf ) / ( ratioPNplant (:, leaf ) + 1.0_r_2 / 1 5.0_r_2 ) casaflux % crmplant (:, wood ) = 0.0_r_2 casaflux % crmplant (:, froot ) = 0.0_r_2 delcrmwood = 0.0_r_2 delcrmfroot = 0.0_r_2 casaflux % crgplant = 0.0_r_2 casaflux % clabloss = 0.0_r_2 if ( cable_user % CALL_climate ) then ! coefficients required to implement T-acclimation of autotrophic respiration (Ticket # 110) ! adapted from Atkin et al., New Phyt., 2015) do npt = 1 , mp ivt = veg % iveg ( npt ) ! max leaf N in g N m-2 leaf nleaf ( npt ) = casabiome % ratioNCplantmax ( ivt , leaf ) / casabiome % sla ( ivt ) ! max leaf P in g P m-2 leaf pleaf ( npt ) = casabiome % ratioPcplantmax ( ivt , leaf ) / casabiome % sla ( ivt ) if ( ivt . eq . 7 ) then ! special for C4 grass: set here to value from  parameter file vcmaxmax ( npt ) = real ( veg % vcmax ( npt ), r_2 ) else vcmaxmax ( npt ) = vcmax_np ( nleaf ( npt ), pleaf ( npt )) * casabiome % vcmax_scalar ( ivt ) endif if ( veg % iveg ( npt ). eq . 2 . or . veg % iveg ( npt ). eq . 4 ) then ! broadleaf forestNESP2pt9_BLAZE c1 = 1.2818_r_2 * 1.e-6_r_2 ! c1 = 1.3805e-6_r_2 ! null model elseif ( veg % iveg ( npt ). eq . 1 . or . veg % iveg ( npt ). eq . 3 ) then ! needleleaf forest c1 = 1.2877_r_2 * 1.e-6_r_2 ! c1 = 1.3247e-6_r_2 ! null model elseif ( veg % iveg ( npt ). eq . 6 . or . veg % iveg ( npt ). eq . 8 . or . veg % iveg ( npt ). eq . 9 ) then ! C3 grass, tundra, crop c1 = 1.6737_r_2 * 1.e-6_r_2 ! c1 = 1.8904e-6_r_2 ! null model else ! shrubs and other (C4 grass and crop) c1 = 1.5758_r_2 * 1.0e-6_r_2 !c1 = 1.7265e-6_r_2 ! null model endif c2 = 0.0116_r_2 c3 = - 0.0334_r_2 * 1.e-6_r_2 c5 = 1.0_r_2 / vcmaxmax ( npt ) / 0.0116_r_2 * 0.60_r_2 resp_coeff_root ( npt ) = casapool % nplant ( npt , froot ) * c5 * & ( c1 + c2 * vcmaxmax ( npt ) * climate % frec ( npt ) + c3 * climate % qtemp_max_last_year ( npt ) ) resp_coeff_sapwood ( npt ) = casapool % nplant ( npt , wood ) * casaflux % frac_sapwood ( npt ) * c5 * & ( c1 + c2 * vcmaxmax ( npt ) * climate % frec ( npt ) + c3 * climate % qtemp_max_last_year ( npt ) ) ! null model (use this with null-model c1 coefft to turn off T-acclimation) ! resp_coeff_root(npt) = casapool%nplant(npt,froot) *c1 ! resp_coeff_sapwood(npt) = casapool%nplant(npt,wood) *casaflux%frac_sapwood(npt)*c1 enddo ! npt=1,mp endif ! cable_user%CALL_climate - end coefficients for acclimation of autotrophic respiration ticket #110 if ( cable_user % CALL_climate ) then !  acclimation of autotrophic respiration Ticket #110 where ( casamet % iveg2 /= icewater ) where ( casamet % tairk > 25 0.0_r_2 ) where ( casapool % cplant (:, wood ) > 1.e-6_r_2 ) casaflux % crmplant (:, wood ) = resp_coeff_sapwood * & casabiome % rmplant ( veg % iveg (:), wood ) & * exp ( 30 8.56_r_2 * ( 1.0_r_2 / 5 6.02_r_2 - & 1.0_r_2 / ( casamet % tairk (:) + 4 6.02_r_2 - tkzeroc )) ) endwhere !vh! prevent floating underflow with this mask where ( casapool % Clabile (:) > 1.0e-8_r_2 ) casaflux % clabloss (:) = casabiome % kclabrate ( veg % iveg (:)) & * max ( 0.0_r_2 , casapool % Clabile (:)) & * exp ( 30 8.56_r_2 * ( 1.0_r_2 / 5 6.02_r_2 - & 1.0_r_2 / ( casamet % tairk (:) + 4 6.02_r_2 - tkzeroc )) ) endwhere endwhere where (( casamet % tsoilavg > 25 0.0_r_2 ) . and . ( casapool % cplant (:, froot ) > 1.0e-6_r_2 )) casaflux % crmplant (:, froot ) = resp_coeff_root * & casabiome % rmplant ( veg % iveg (:), froot ) & * exp ( 30 8.56_r_2 * ( 1.0_r_2 / 5 6.02_r_2 - & 1.0_r_2 / ( casamet % tsoilavg (:) + 4 6.02_r_2 - tkzeroc )) ) endwhere where (( casaflux % Cgpp - sum ( Casaflux % crmplant , 2 )) > 0.0_r_2 ) !casaflux%crgplant(:)  = 0.25* max(0.0_r_2,casaflux%Cgpp(:)-SUM(casaflux%crmplant(:,:),2)) ! Growth efficiency correlated to leaf N:P ratio. Q.Zhang @ 22/02/2011 casaflux % crgplant (:) = ( 1.0_r_2 - Ygrow (:)) * & max ( 0.0_r_2 , casaflux % Cgpp (:) - SUM ( casaflux % crmplant (:,:), 2 )) elsewhere casaflux % crgplant (:) = 0.0_r_2 endwhere endwhere ! /= icewater casaflux % Cnpp (:) = casaflux % Cgpp (:) - sum ( casaflux % Crmplant (:,:), 2 ) - casaflux % Crgplant (:) else ! cable_user%CALL_climate where ( casamet % iveg2 /= icewater ) where ( casamet % tairk > 25 0.0_r_2 ) where ( casapool % cplant (:, wood ) > 1.e-6_r_2 ) casaflux % crmplant (:, wood ) = casaflux % frac_sapwood (:) * & casabiome % rmplant ( veg % iveg (:), wood ) & * casapool % nplant (:, wood ) & * exp ( 30 8.56_r_2 * ( 1.0_r_2 / 5 6.02_r_2 - & 1.0_r_2 / ( casamet % tairk (:) + 4 6.02_r_2 - tkzeroc ))) endwhere casaflux % clabloss (:) = casabiome % kclabrate ( veg % iveg (:)) & * max ( 0.0_r_2 , casapool % Clabile (:)) & * exp ( 30 8.56_r_2 * ( 1.0_r_2 / 5 6.02_r_2 - & 1.0_r_2 / ( casamet % tairk (:) + 4 6.02_r_2 - tkzeroc ))) endwhere where (( casamet % tsoilavg > 25 0.0_r_2 ) . and . ( casapool % cplant (:, froot ) > 1.0e-6_r_2 )) casaflux % crmplant (:, froot ) = casabiome % rmplant ( veg % iveg (:), froot ) & * casapool % nplant (:, froot ) & * exp ( 30 8.56_r_2 * ( 1.0_r_2 / 5 6.02_r_2 - & 1.0_r_2 / ( casamet % tsoilavg (:) + 4 6.02_r_2 - tkzeroc ))) endwhere !    casaflux%crmplant(:,leaf) = casaflux%crmplant(:,leaf) + casaflux%clabloss(:) where (( casaflux % Cgpp - sum ( casaflux % crmplant , 2 )) > 0.0_r_2 ) !casaflux%crgplant(:)  = 0.25* max(0.0,casaflux%Cgpp(:)-SUM(casaflux%crmplant(:,:),2)) ! Growth efficiency correlated to leaf N:P ratio. Q.Zhang @ 22/02/2011 casaflux % crgplant (:) = ( 1.0_r_2 - Ygrow (:)) * & max ( 0.0_r_2 , casaflux % Cgpp (:) - SUM ( casaflux % crmplant (:,:), 2 )) elsewhere casaflux % crgplant (:) = 0.0_r_2 endwhere !casaflux%Cnpp(:) = MAX(0.0_r_2,(casaflux%Cgpp(:)-SUM(casaflux%crmplant(:,:),2) & !                 - casaflux%crgplant(:))) ! changes made by yp wang 5 april 2013 casaflux % Cnpp (:) = casaflux % Cgpp (:) - sum ( casaflux % Crmplant (:,:), 2 ) - casaflux % Crgplant (:) endwhere ! /= icewater endif ! cable_user%CALL_climate END SUBROUTINE casa_rplant SUBROUTINE casa_xrateplant ( xkleafcold , xkleafdry , xkleaf , veg , casabiome , & casamet , phen ) ! use xleafcold and xleafdry to account for ! cold and drought stress on death rate of leaf ! inputs: !     ivt(mp)  :       biome type !     phase(mp):       leaf growth stage !     tairk(mp):   air temperature in K ! outputs !     xkleafcold(mp):  cold stress induced leaf senescence rate (1/day) !     xkleafdry(mp):   drought-induced leaf senescence rate (1/day) !     xkleaf(mp):      set to 0.0 during maximal leaf growth phase use mo_utils , only : ge , le IMPLICIT NONE REAL ( r_2 ), DIMENSION ( mp ), INTENT ( OUT ) :: xkleafcold REAL ( r_2 ), DIMENSION ( mp ), INTENT ( OUT ) :: xkleafdry REAL ( r_2 ), DIMENSION ( mp ), INTENT ( OUT ) :: xkleaf TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( phen_variable ), INTENT ( INOUT ) :: phen ! local variables REAL ( r_2 ), DIMENSION ( mp ) :: xcoldleaf INTEGER :: npt xkleafcold (:) = 0.0_r_2 xkleafdry (:) = 0.0_r_2 xkleaf (:) = 1.0_r_2 ! BP changed the WHERE construct to DO-IF for Mk3L (jun2010) DO npt = 1 , mp IF ( casamet % iveg2 ( npt ) /= icewater ) THEN ! following the formulation of Arora (2005) on the ! effect of cold or drought stress on leaf litter fall ! calculate cold stress (eqn (18), Arora 2005, GCB 11:39-59) IF ( ge ( casamet % tairk ( npt ), phen % TKshed ( veg % iveg ( npt )))) THEN xcoldleaf ( npt ) = 1.0_r_2 ELSE IF ( le ( casamet % tairk ( npt ), ( phen % TKshed ( veg % iveg ( npt )) - 5.0_r_2 ) ) ) THEN xcoldleaf ( npt ) = 0.0_r_2 ELSE !MC - Error? ->  ( casamet%tairk(npt) - (phen%TKshed(veg%iveg(npt))-5.0_r_2) ) / 5.0_r_2 xcoldleaf ( npt ) = ( casamet % tairk ( npt ) - phen % TKshed ( veg % iveg ( npt )) - 5.0_r_2 ) / 5.0_r_2 ENDIF ENDIF xcoldleaf ( npt ) = min ( 1.0_r_2 , max ( 0.0_r_2 , xcoldleaf ( npt ))) xkleafcold ( npt ) = casabiome % xkleafcoldmax ( veg % iveg ( npt )) & * ( 1.0_r_2 - xcoldleaf ( npt )) ** casabiome % xkleafcoldexp ( veg % iveg ( npt )) xkleafdry ( npt ) = casabiome % xkleafdrymax ( veg % iveg ( npt )) & * ( 1.0_r_2 - casamet % btran ( npt )) ** casabiome % xkleafdryexp ( veg % iveg ( npt )) IF ( phen % phase ( npt ) == 1 ) xkleaf ( npt ) = 0.0_r_2 ! vh ! account for high rate of leaf loss during senescence if ( trim ( cable_user % PHENOLOGY_SWITCH ) == 'climate' ) then ! increases base turnover rate by a factor of 13 ! (for base turnover time of 1y, this reduces it to 4 weeks) IF (( phen % phase ( npt ) == 3 . or . phen % phase ( npt ) == 0 ) . and . casamet % lnonwood ( npt ) == 0 ) & xkleaf ( npt ) = 1 3.0_r_2 IF (( phen % phase ( npt ) == 3 . or . phen % phase ( npt ) == 0 ) . and . casamet % lnonwood ( npt ) == 1 ) & xkleaf ( npt ) = 1 3.0_r_2 * 0.5_r_2 endif if ( xkleafcold ( npt ) < 0.0_r_2 ) print * , 'ERR KK01 ' , npt , xkleafcold ( npt ), casabiome % xkleafcoldmax ( veg % iveg ( npt )), & ( 1.0_r_2 - xcoldleaf ( npt )) , casabiome % xkleafcoldexp ( veg % iveg ( npt )) if ( xkleafdry ( npt ) < 0.0_r_2 ) print * , 'ERR KK02 ' , npt , xkleafdry ( npt ), casabiome % xkleafdrymax ( veg % iveg ( npt )), & ( 1.0_r_2 - casamet % btran ( npt )), casabiome % xkleafdryexp ( veg % iveg ( npt )) if ( xkleaf ( npt ) < 0.0_r_2 ) print * , 'ERR KK03 ' , npt , xkleaf ( npt ) END IF END DO !  WHERE(casamet%iveg2/=icewater) !  !    following the formulation of Arora (2005) on the !  !    effect of cold or drought stress on leaf litter fall !  !    calculate cold stress (eqn (18), Arora 2005, GCB 11:39-59) !    WHERE(casamet%tairk(:)>=phen%TKshed(veg%iveg(:))) !      xcoldleaf(:) = 1.0_r_2 !    ELSEWHERE !      WHERE(casamet%tairk(:)<=(phen%TKshed(veg%iveg(:))-5.0)) !        xcoldleaf(:)=0.0_r_2 !      ELSEWHERE !        xcoldleaf(:) = (casamet%tairk(:)-phen%TKshed(veg%iveg(:))-5.0)/5.0 !      ENDWHERE !    ENDWHERE !    xcoldleaf(:) = min(1.0_r_2,max(0.0_r_2,xcoldleaf(:))) !    xkleafcold(:) = casabiome%xkleafcoldmax(veg%iveg(:)) * (1.0_r_2-xcoldleaf(:)) & !                 ** casabiome%xkleafcoldexp(veg%iveg(:)) !    xkleafdry(:) = casabiome%xkleafdrymax(veg%iveg(:))*(1.0_r_2-casamet%btran(:))& !                 ** casabiome%xkleafdryexp(veg%iveg(:)) !    WHERE(phen%phase(:)==1) xkleaf(:)= 0.0_r_2 !  ENDWHERE END SUBROUTINE casa_xrateplant SUBROUTINE casa_xratesoil ( xklitter , xksoil , veg , soil , casamet , casabiome ) !  to account for cold and drought stress on death rate of leaf: xleafcold,xleafdry !  to account for effects of T and W on litter decomposition: xk, xksurf !  inputs: !     ivt(mp)  :       biome type !     tsoilavg(mp):    soil temperature in K !     moistavg(mp):    volumetric soil moisture ! !  outputs !     xk(mp):          modifier of soil litter decomposition rate (dimensionless) IMPLICIT NONE REAL ( r_2 ), DIMENSION ( mp ), INTENT ( OUT ) :: xklitter , xksoil TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil ! soil parameters TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome ! local variables REAL ( r_2 ), parameter :: wfpscoefa = 0.55_r_2 ! Kelly et al. (2000) JGR, Figure 2b), optimal wfps REAL ( r_2 ), parameter :: wfpscoefb = 1.70_r_2 ! Kelly et al. (2000) JGR, Figure 2b) REAL ( r_2 ), parameter :: wfpscoefc = - 0.007_r_2 ! Kelly et al. (2000) JGR, Figure 2b) REAL ( r_2 ), parameter :: wfpscoefd = 3.22_r_2 ! Kelly et al. (2000) JGR, Figure 2b) REAL ( r_2 ), parameter :: wfpscoefe = 6.6481_r_2 ! =wfpscoefd*(wfpscoefb-wfpscoefa)/(wfpscoefa-wfpscoefc) ! ! Kirschbaum function parameters ! REAL(r_2), parameter :: xkalpha=-3.764   ! Kirschbaum (1995, SBB) ! REAL(r_2), parameter :: xkbeta=0.204 ! REAL(r_2), parameter :: xktoptc=36.9 ! Trudinger2016 function parameters (from Trudinger 2016) REAL ( r_2 ), parameter :: wfpswidth1 = 1.2160310E+00_r_2 REAL ( r_2 ), parameter :: wfpswidth2 = 6.4620150E-01_r_2 REAL ( r_2 ), parameter :: wfpswidth3 = 4.9625073E-01_r_2 REAL ( r_2 ), parameter :: wfpsscale1 = 1.6193957E+00_r_2 REAL ( r_2 ), parameter :: wfpswidth0 = 1.3703876E-02_r_2 REAL ( r_2 ), parameter :: wfpsquad = 8.0000000E-01_r_2 ! Trudinger2016 function parameters (corresponds to Haverd 2013) ! REAL(r_2), parameter :: wfpswidth1=0.78_r_2 ! REAL(r_2), parameter :: wfpswidth2=0_r_2 ! REAL(r_2), parameter :: wfpswidth3=1.5_r_2 ! REAL(r_2), parameter :: wfpsscale1=10.0_r_2 ! REAL(r_2), parameter :: wfpswidth0 = 0.0_r_2 ! REAL(r_2), parameter :: wfpsquad=0.0_r_2 ! DAMM temporary variables REAL ( r_2 ) :: O2 , vol_air_content , Enz , Dliq , Dva REAL ( r_2 ), DIMENSION ( mp ) :: xkwater , xktemp REAL ( r_2 ), DIMENSION ( mp ) :: fwps , tsavg ! Custom soil respiration - see Ticket #42 REAL ( r_2 ), DIMENSION ( mp ) :: smrf , strf , slopt , wlt , tsoil , sopt REAL ( r_2 ) :: f0 !,tsurfavg  !!, msurfavg INTEGER :: npt xklitter (:) = 1.0_r_2 xksoil (:) = 1.0_r_2 fwps (:) = casamet % moistavg (:) / soil % ssat (:) tsavg (:) = casamet % tsoilavg (:) ! Custom soil respiration - see Ticket #42 tsoil (:) = tsavg (:) - TKzeroC !tsoil in C strf (:) = 1.0_r_2 smrf (:) = 1.0_r_2 slopt (:) = 1.0_r_2 sopt (:) = 1.0_r_2 ! BP changed the WHERE construct to DO-IF for Mk3L (jun2010) DO npt = 1 , mp IF ( casamet % iveg2 ( npt ) /= icewater ) THEN xktemp ( npt ) = casabiome % q10soil ( veg % iveg ( npt )) ** ( 0.1_r_2 * ( tsavg ( npt ) - TKzeroC - 3 5.0_r_2 )) xkwater ( npt ) = (( fwps ( npt ) - wfpscoefb ) / ( wfpscoefa - wfpscoefb )) ** wfpscoefe & * (( fwps ( npt ) - wfpscoefc ) / ( wfpscoefa - wfpscoefc )) ** wfpscoefd IF ( veg % iveg ( npt ) == cropland . OR . veg % iveg ( npt ) == croplnd2 ) & xkwater ( npt ) = 1.0_r_2 xklitter ( npt ) = casabiome % xkoptlitter ( veg % iveg ( npt )) * xktemp ( npt ) * xkwater ( npt ) IF ( . NOT . cable_user % SRF ) THEN ! Use original function, ELSE Ticket #42 xksoil ( npt ) = casabiome % xkoptsoil ( veg % iveg ( npt )) * xktemp ( npt ) * xkwater ( npt ) ELSE ! Custom soil respiration - see Ticket #42 ! Implementing alternative parameterizations !MC - wlt used but never set before in cable_user%SMRF_NAME=='SOILN' and 'TRIFFID' IF ( trim ( cable_user % SMRF_NAME ) == 'CASA-CNP' ) THEN smrf ( npt ) = xkwater ( npt ) ELSE IF ( trim ( cable_user % SMRF_NAME ) == 'SOILN' ) then sopt ( npt ) = 0.92_r_2 slopt ( npt ) = wlt ( npt ) + 0.1_r_2 !SLOPT is the lower optimum IF ( fwps ( npt ) > sopt ( npt )) THEN smrf ( npt ) = 0.2_r_2 + 0.8_r_2 * ( 1.0_r_2 - fwps ( npt )) / ( 1.0_r_2 - sopt ( npt )) ELSE IF ( slopt ( npt ) <= fwps ( npt ) . AND . fwps ( npt ) <= sopt ( npt )) THEN smrf ( npt ) = 1.0_r_2 ELSE IF ( wlt ( npt ) <= fwps ( npt ) . AND . fwps ( npt ) < slopt ( npt )) THEN smrf ( npt ) = 0.01_r_2 + 0.99_r_2 * ( fwps ( npt ) - wlt ( npt )) / ( slopt ( npt ) - wlt ( npt )) ELSE IF ( fwps ( npt ) < wlt ( npt )) THEN smrf ( npt ) = 0.01_r_2 END IF ELSE IF ( trim ( cable_user % SMRF_NAME ) == 'TRIFFID' ) THEN sopt ( npt ) = 0.5_r_2 * ( 1.0_r_2 + wlt ( npt )) IF ( fwps ( npt ) > sopt ( npt )) THEN smrf ( npt ) = 1.0_r_2 - 0.8_r_2 * ( fwps ( npt ) - sopt ( npt )) ELSE IF ( wlt ( npt ) < fwps ( npt ) . AND . fwps ( npt ) <= sopt ( npt )) THEN smrf ( npt ) = 0.01_r_2 + 0.8_r_2 * (( fwps ( npt ) - wlt ( npt )) / ( sopt ( npt ) - wlt ( npt ))) ELSE IF ( fwps ( npt ) < wlt ( npt )) THEN smrf ( npt ) = 0.2_r_2 END IF ELSE IF ( trim ( cable_user % SMRF_NAME ) == 'Trudinger2016' ) THEN if ( fwps ( npt ) . le . wfpswidth0 ) then smrf ( npt ) = wfpsquad * fwps ( npt ) ** 2 else if ( fwps ( npt ) . le . ( wfpswidth0 + wfpswidth1 )) then f0 = 0.5_r_2 * ( 1.0_r_2 - cos ( 3.1415_r_2 * (( wfpsscale1 - 1 ) * wfpswidth1 ) / ( wfpswidth1 * wfpsscale1 ))) smrf ( npt ) = max (( wfpsquad * fwps ( npt ) ** 2 ), & (( 0.5_r_2 * ( 1.0_r_2 - cos ( 3.1415_r_2 * ( fwps ( npt ) - wfpswidth0 + ( wfpsscale1 - 1 ) * wfpswidth1 ) / & ( wfpswidth1 * wfpsscale1 ))) - f0 ) / ( 1.0_r_2 - f0 ))) else if ( fwps ( npt ) . le . wfpswidth0 + wfpswidth1 + wfpswidth2 ) then smrf ( npt ) = 1.0_r_2 else smrf ( npt ) = 0.5_r_2 * ( 1.0_r_2 + cos ( 3.1415_r_2 * ( fwps ( npt ) - wfpswidth0 - wfpswidth1 - wfpswidth2 ) & / wfpswidth3 )) endif endif endif END IF IF ( trim ( cable_user % STRF_NAME ) == 'CASA-CNP' ) THEN strf ( npt ) = xktemp ( npt ) ELSE if ( trim ( cable_user % STRF_NAME ) == 'K1995' ) THEN !Kirschbaum from Kirschbaum 1995, eq (4) in SBB, .66 is to collapse smrf !to same area strf ( npt ) = exp ( - 3.764_r_2 + 0.204_r_2 * tsoil ( npt ) * ( 1.0_r_2 - 0.5_r_2 * tsoil ( npt ) / 3 6.9_r_2 )) / 0.66_r_2 ELSE IF ( trim ( cable_user % STRF_NAME ) == 'PnET-CN' ) THEN strf ( npt ) = 0.68_r_2 * exp ( 0.1_r_2 * ( tsoil ( npt ) - 7.1_r_2 )) / 1 2.64_r_2 ELSE if ( trim ( cable_user % STRF_NAME ) == 'LT1994' ) THEN ! Lloyd & Taylor, Func. Ec. 8, 315, 1994, Eq 11. ! Normalised to 10 deg C strf ( npt ) = exp ( 30 8.56_r_2 * ( 1.0_r_2 / 5 6.02_r_2 - 1.0_r_2 & / ( max ( tsoil ( npt ), - 2 0.0_r_2 ) + 4 6.02_r_2 ))) / & ( exp ( 30 8.56_r_2 * ( 1.0_r_2 / 5 6.02_r_2 - 1.0_r_2 & / ( 1 0.0_r_2 + 4 6.02_r_2 )))) ELSE if ( trim ( cable_user % STRF_NAME ) == 'Q10' ) THEN ! Q10 normalised to 10 deg C strf ( npt ) = casabiome % q10soil ( veg % iveg ( npt )) ** ( 0.1_r_2 * ( tsavg ( npt ) - TKzeroC - 1 0.0_r_2 )) END IF IF ( trim ( cable_user % STRF_NAME ) == 'DAMM' . and . trim ( cable_user % SMRF_NAME ) == 'DAMM' ) THEN ! Implementation follows Sihi et al., AFM 252 (2018) 155-166. ! The key difference is that we use the DAMM model to provide rate constant modifiers ! for soil and litter carbon turnover, whereas Sihi et al. apply the model directly ! to heterotrophic respiration. Also, we account here for T-dependence of O2 diffusion ! and diffusivity of Enzyme in the liquid phase (T-dependences of diffusivities taken from ! (Haverd and Cuntz 2010, J. Hyd., 388, (2010), 438-455 ). vol_air_content = max ( soil % ssat ( npt ) - casamet % moistavg ( npt ), 0.0_r_2 ) Dva = 1.67_r_2 * 0.209_r_2 * (( casamet % tsoilavg ( npt ) / TKzeroC ) ** 1.88_r_2 ) / & ((( 1 0.0_r_2 + TKzeroC ) / TKzeroC ) ** 1.88_r_2 ) O2 = Dva * ( vol_air_content ** ( 4._r_2 / 3._r_2 )) Dliq = 3.17_r_2 * ( casamet % moistavg ( npt ) ** 3 ) * exp ( - 57 7.0_r_2 / ( casamet % tsoilavg ( npt ) - 14 5._r_2 )) / & exp ( - 57 7.0_r_2 / (( 1 0.0_r_2 + 27 3.15_r_2 ) - 14 5._r_2 )) Enz = casabiome % DAMM_EnzPool ( veg % iveg ( npt )) * Dliq ! Arrhenius temperature response function, normalised to 10 deg C. strf ( npt ) = exp ( - casabiome % DAMM_Ea ( veg % iveg ( npt )) / ( 8.314e-3_r_2 & * ( casamet % tsoilavg ( npt )))) / & ( exp ( - casabiome % DAMM_Ea ( veg % iveg ( npt )) / ( 8.314e-3_r_2 & * 28 3.0_r_2 ))) ! moisture response function smrf ( npt ) = ( Enz / ( Enz + casabiome % DAMM_KMcp ( veg % iveg ( npt )))) & * ( O2 / ( casabiome % DAMM_KMO2 ( veg % iveg ( npt )) + O2 )) xksoil ( npt ) = ( 1 0.0_r_2 ** casabiome % DAMM_alpha ( veg % iveg ( npt ))) * smrf ( npt ) * strf ( npt ) xklitter ( npt ) = xksoil ( npt ) ELSE ! xksoil(npt) = casabiome%xkoptsoil(veg%iveg(npt))*strf(npt)*smrf(npt) ! xklitter(npt) = casabiome%xkoptlitter(veg%iveg(npt)) *strf(npt)*smrf(npt) xksoil ( npt ) = strf ( npt ) * smrf ( npt ) xklitter ( npt ) = strf ( npt ) * smrf ( npt ) ENDIF END IF END IF END DO END SUBROUTINE casa_xratesoil SUBROUTINE casa_coeffplant ( xkleafcold , xkleafdry , xkleaf , veg , casabiome , casapool , & casaflux , casamet ) ! calculate the plant litter fall rate, litter fall and SOM decomposition rate (1/day) ! and the transfer coefficients between different pools ! ! inputs: !     xkleafcold(mp):  cold stress induced leaf senescence rate (1/day) !     xkleafdry(mp):   drought-induced leaf senescence rate (1/day) !     xkleaf(mp):      set to 0.0 during maximal leaf growth phase ! ! outputs: !     kplant(mp,mplant):        senescence rate of plant pool (1/day) !     fromPtoL(mp,mlitter,mplant): fraction of senesced plant biomass to litter pool (fraction) implicit none real ( r_2 ), dimension ( mp ), intent ( in ) :: xkleafcold , xkleafdry , xkleaf type ( veg_parameter_type ), intent ( inout ) :: veg ! vegetation parameters type ( casa_biome ), intent ( inout ) :: casabiome type ( casa_pool ), intent ( inout ) :: casapool type ( casa_flux ), intent ( inout ) :: casaflux type ( casa_met ), intent ( inout ) :: casamet ! local variables real ( r_2 ), dimension ( mp , mplant ) :: ratioligninton integer :: npt casaflux % fromPtoL (:,:,:) = 0.0_r_2 casaflux % kplant (:,:) = 0.0_r_2 casaflux % kplant_tot (:,:) = 0.0_r_2 where ( casamet % iveg2 /= icewater ) ! using max function to avoid dividing by zero, ypw 14/may/2008 ratioLignintoN (:, leaf ) = ( casapool % Cplant (:, leaf ) & / ( max ( 1.0e-10_r_2 , casapool % Nplant (:, leaf )) * casabiome % ftransNPtoL ( veg % iveg (:), leaf ) ) ) & * casabiome % fracLigninplant ( veg % iveg (:), leaf ) ratioLignintoN (:, froot ) = ( casapool % Cplant (:, froot ) & / ( max ( 1.0e-10_r_2 , casapool % Nplant (:, froot )) * casabiome % ftransNPtoL ( veg % iveg (:), froot ) ) ) & * casabiome % fracLigninplant ( veg % iveg (:), froot ) casaflux % fromPtoL (:, metb , leaf ) = max ( 0.001_r_2 , 0.85_r_2 - 0.018_r_2 * ratioLignintoN (:, leaf )) casaflux % fromPtoL (:, metb , froot ) = max ( 0.001_r_2 , 0.85_r_2 - 0.018_r_2 * ratioLignintoN (:, froot )) casaflux % fromPtoL (:, str , leaf ) = 1.0_r_2 - casaflux % fromPtoL (:, metb , leaf ) casaflux % fromPtoL (:, str , froot ) = 1.0_r_2 - casaflux % fromPtoL (:, metb , froot ) casaflux % fromPtoL (:, cwd , wood ) = 1.0_r_2 casaflux % kplant (:, leaf ) = casabiome % plantrate ( veg % iveg (:), leaf ) * xkleaf (:) + xkleafcold (:) + xkleafdry (:) casaflux % kplant (:, wood ) = casabiome % plantrate ( veg % iveg (:), wood ) casaflux % kplant (:, froot ) = casabiome % plantrate ( veg % iveg (:), froot ) endwhere if ( any ( casaflux % kplant (:, leaf ) < 0.0_r_2 )) then do npt = 1 , mp if ( casaflux % kplant ( npt , leaf ) < 0.0_r_2 ) then print * , 'ERR KK10 ' , npt , casaflux % kplant ( npt , leaf ) print * , 'ERR KK11 ' , npt , casabiome % plantrate ( veg % iveg ( npt ), leaf ), xkleaf ( npt ), xkleafcold ( npt ), xkleafdry ( npt ) endif enddo endif ! set leaf turnover to be the same as froot turnover for C3 & C4 grass where ( veg % iveg == 7 . OR . veg % iveg == 6 ) casaflux % kplant (:, froot ) = casaflux % kplant (:, leaf ) where ( casamet % iveg2 /= icewater ) ! total turnover rate includes turnover by fire casaflux % kplant_tot (:, leaf ) = casaflux % kplant (:, leaf ) + & ( 1.0_r_2 - casaflux % kplant (:, leaf )) * casaflux % kplant_fire (:, leaf ) casaflux % kplant_tot (:, froot ) = casaflux % kplant (:, froot ) + & ( 1.0_r_2 - casaflux % kplant (:, froot )) * casaflux % kplant_fire (:, froot ) casaflux % kplant_tot (:, wood ) = casaflux % kplant (:, wood ) + & ( 1.0_r_2 - casaflux % kplant (:, wood )) * casaflux % kplant_fire (:, wood ) ! adjust leaf flux to litter for crop/pasture removal casaflux % fromPtoL (:, str , leaf ) = casaflux % fromPtoL (:, str , leaf ) * ( 1.0_r_2 - casaflux % fharvest ) casaflux % fromPtoL (:, metb , leaf ) = casaflux % fromPtoL (:, metb , leaf ) * ( 1.0_r_2 - casaflux % fharvest ) endwhere ! When glai<glaimin, leaf biomass will not decrease anymore. (Q.Zhang 10/03/2011) do npt = 1 , mp if ( casamet % glai ( npt ) . le . casabiome % glaimin ( veg % iveg ( npt ))) then casaflux % kplant ( npt , leaf ) = 0.0_r_2 casaflux % kplant_tot ( npt , leaf ) = 0.0_r_2 endif enddo END SUBROUTINE casa_coeffplant SUBROUTINE casa_coeffsoil ( xklitter , xksoil , veg , soil , casabiome , casaflux , casamet ) !  calculate the plant litter fall rate, litter fall and sOM decomposition rate (1/day) !  and the transfer coefficients between different pools ! ! inputs: !     xk(mp):          modifier of soil litter decomposition rate (dimensionless) ! ! outputs: !     klitter(mp,mlitter):      decomposition rate of litter pool (1/day) !     ksoil(mp,msoil):          decomposition rate of soil pool (1/day) !     fromLtoS(mp,mlitter,msoil):  fraction of decomposed litter to soil (fraction) !     fromStoS(mp,msoil,msoil):    fraction of decomposed soil C to another soil pool (fraction) !     fromLtoCO2(mp,mlitter):      fraction of decomposed litter emitted as CO2 (fraction) !     fromStoCO2(mp,msoil):        fraction of decomposed soil C emitted as Co2 (fraction) implicit none real ( r_2 ), dimension ( mp ), intent ( in ) :: xklitter , xksoil type ( veg_parameter_type ), intent ( inout ) :: veg ! vegetation parameters type ( soil_parameter_type ), intent ( inout ) :: soil ! soil parameters type ( casa_biome ), intent ( inout ) :: casabiome type ( casa_flux ), intent ( inout ) :: casaflux type ( casa_met ), intent ( inout ) :: casamet ! local variables integer :: j , k , kk , nland ! i: for plant pool, j for litter, k for soil casaflux % fromLtoS (:,:,:) = 0.0_r_2 casaflux % fromStoS (:,:,:) = 0.0_r_2 do k = 1 , msoil casaflux % fromStoS (:, k , k ) = - 1.0_r_2 ! flow from soil to soil enddo casaflux % fromLtoCO2 (:,:) = 0.0_r_2 ! flow from L or S to CO2 casaflux % fromStoCO2 (:,:) = 0.0_r_2 casaflux % klitter (:,:) = 0.0_r_2 ! initialize klitter (Q.Zhang 03/03/2011) casaflux % klitter_tot (:,:) = 0.0_r_2 where ( casamet % iveg2 /= icewater ) casaflux % klitter (:, metb ) = xklitter (:) * casabiome % litterrate ( veg % iveg (:), metb ) casaflux % klitter (:, str ) = xklitter (:) * casabiome % litterrate ( veg % iveg (:), str ) * & exp ( - 3.0_r_2 * casabiome % fracLigninplant ( veg % iveg (:), leaf )) casaflux % klitter (:, cwd ) = xklitter (:) * casabiome % litterrate ( veg % iveg (:), cwd ) ! add fire turnover of litter casaflux % klitter_tot (:, metb ) = casaflux % klitter (:, metb ) + & ( 1.0_r_2 - casaflux % klitter (:, metb )) * casaflux % klitter_fire (:, metb ) casaflux % klitter_tot (:, str ) = casaflux % klitter (:, str ) + & ( 1.0_r_2 - casaflux % klitter (:, str )) * casaflux % klitter_fire (:, str ) casaflux % klitter_tot (:, cwd ) = casaflux % klitter (:, cwd ) + & ( 1.0_r_2 - casaflux % klitter (:, cwd )) * casaflux % klitter_fire (:, cwd ) ! soil turnover casaflux % ksoil (:, mic ) = xksoil (:) * casabiome % soilrate ( veg % iveg (:), mic ) * & ( 1.0_r_2 - 0.75_r_2 * ( soil % silt (:) + soil % clay (:))) casaflux % ksoil (:, slow ) = xksoil (:) * casabiome % soilrate ( veg % iveg (:), slow ) casaflux % ksoil (:, pass ) = xksoil (:) * casabiome % soilrate ( veg % iveg (:), pass ) casaflux % kplab (:) = xksoil (:) * casabiome % xkplab ( casamet % isorder (:)) casaflux % kpsorb (:) = xksoil (:) * casabiome % xkpsorb ( casamet % isorder (:)) casaflux % kpocc (:) = xksoil (:) * casabiome % xkpocc ( casamet % isorder (:)) where ( veg % iveg == cropland ) ! for cultivated land type casaflux % ksoil (:, mic ) = casaflux % ksoil (:, mic ) * 1.25_r_2 casaflux % ksoil (:, slow ) = casaflux % ksoil (:, slow ) * 1.5_r_2 casaflux % ksoil (:, pass ) = casaflux % ksoil (:, pass ) * 1.5_r_2 endwhere ! where ( casaflux % fcrop > 0.1_r_2 ) ! 50% increase in soil C turnover in cropping areas casaflux % ksoil (:, mic ) = casaflux % ksoil (:, mic ) * (( 1.0_r_2 - casaflux % fcrop ) + 1.5_r_2 * casaflux % fcrop ) casaflux % ksoil (:, slow ) = casaflux % ksoil (:, slow ) * (( 1.0_r_2 - casaflux % fcrop ) + 1.5_r_2 * casaflux % fcrop ) casaflux % ksoil (:, pass ) = casaflux % ksoil (:, pass ) * (( 1.0_r_2 - casaflux % fcrop ) + 1.5_r_2 * casaflux % fcrop ) endwhere ! flow from litter to soil casaflux % fromLtoS (:, mic , metb ) = 0.45_r_2 ! metb -> mic casaflux % fromLtoS (:, mic , str ) = 0.45_r_2 * ( 1.0_r_2 - casabiome % fracLigninplant ( veg % iveg (:), leaf )) ! str  -> mic casaflux % fromLtoS (:, slow , str ) = 0.7_r_2 * casabiome % fracLigninplant ( veg % iveg (:), leaf ) ! str  -> slow casaflux % fromLtoS (:, mic , cwd ) = 0.40_r_2 * ( 1.0_r_2 - casabiome % fracLigninplant ( veg % iveg (:), wood )) ! cwd  -> fmic casaflux % fromLtoS (:, slow , cwd ) = 0.7_r_2 * casabiome % fracLigninplant ( veg % iveg (:), wood ) ! cwd  -> slow ! set the following two backflow to set (see Bolker 199x) !   casaflux%fromStoS(:,mic,slow)  = 0.45_r_2 * (0.997_r_2 - 0.009_r_2 *soil%clay(:)) !   casaflux%fromStoS(:,mic,pass)  = 0.45_r_2 casaflux % fromStoS (:, slow , mic ) = ( 0.85_r_2 - 0.68_r_2 * ( soil % clay (:) + soil % silt (:))) * ( 0.997_r_2 - 0.032_r_2 * soil % clay (:)) casaflux % fromStoS (:, pass , mic ) = ( 0.85_r_2 - 0.68_r_2 * ( soil % clay (:) + soil % silt (:))) * ( 0.003_r_2 + 0.032_r_2 * soil % clay (:)) casaflux % fromStoS (:, pass , slow ) = 0.45_r_2 * ( 0.003_r_2 + 0.009_r_2 * soil % clay (:)) endwhere ! /= icewater do nland = 1 , mp if ( casamet % iveg2 ( nland ) /= icewater ) then do j = 1 , mlitter do k = 1 , msoil casaflux % fromLtoCO2 ( nland , j ) = casaflux % fromLtoCO2 ( nland , j ) + casaflux % fromLtoS ( nland , k , j ) enddo casaflux % fromLtoCO2 ( nland , j ) = 1.0_r_2 - casaflux % fromLtoCO2 ( nland , j ) enddo do k = 1 , msoil do kk = 1 , msoil casaflux % fromStoCO2 ( nland , k ) = casaflux % fromStoCO2 ( nland , k ) + casaflux % fromStoS ( nland , kk , k ) enddo enddo casaflux % fromStoCO2 ( nland ,:) = - casaflux % fromStoCO2 ( nland ,:) endif ! /= icewater enddo ! nland END SUBROUTINE casa_coeffsoil ! modified by ypw following Chris Lu 5/nov/2012 SUBROUTINE casa_delplant ( veg , casabiome , casapool , casaflux , casamet , & cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd , & nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd , & pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd ) !  calculate the chnage in plant C, N and P pools !  uptake of N and P will be computed in casa_uptake !  labile C pool will be computed casa_labile implicit none type ( veg_parameter_type ), intent ( inout ) :: veg ! vegetation parameters type ( casa_biome ), intent ( inout ) :: casabiome type ( casa_pool ), intent ( inout ) :: casapool type ( casa_flux ), intent ( inout ) :: casaflux type ( casa_met ), intent ( inout ) :: casamet ! added by ypwang following Chris Lu 5/nov/2012 real ( r_2 ), dimension ( mp ), intent ( out ) :: cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd , & nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd , & pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd integer :: npt , nL , nP real ( r_2 ) :: Ygrow , ratioPNplant ! real(r_2) :: dF ! casa casaflux % FluxCtolitter = 0.0_r_2 casaflux % FluxNtolitter = 0.0_r_2 casaflux % FluxPtolitter = 0.0_r_2 ! fire casaflux % fluxCtoCO2_plant_fire = 0.0_r_2 casaflux % fluxNtoAtm_fire = 0.0_r_2 ! 13C casaflux % FluxFromPtoL = 0.0_r_2 casaflux % FluxFromPtoCO2 = 0.0_r_2 casaflux % FluxFromPtoHarvest = 0.0_r_2 ! added by ypwang following Chris Lu 5/nov/2012 cleaf2met = 0.0_r_2 cleaf2str = 0.0_r_2 croot2met = 0.0_r_2 croot2str = 0.0_r_2 cwood2cwd = 0.0_r_2 nleaf2met = 0.0_r_2 nleaf2str = 0.0_r_2 nroot2met = 0.0_r_2 nroot2str = 0.0_r_2 nwood2cwd = 0.0_r_2 pleaf2met = 0.0_r_2 pleaf2str = 0.0_r_2 proot2met = 0.0_r_2 proot2str = 0.0_r_2 pwood2cwd = 0.0_r_2 !MPI do npt = 1 , mp if ( casamet % iveg2 ( npt ) /= icewater ) then casapool % dcplantdt ( npt ,:) = casaflux % Cnpp ( npt ) * casaflux % fracCalloc ( npt ,:) & - casaflux % kplant_tot ( npt ,:) * casapool % cplant ( npt ,:) !! vh_js !! ! adjust turnover and autotrophic respiration to avoid negative stocks ! Ticket#108 where ( ( ( casapool % dcplantdt ( npt , 2 : 3 ) * deltpool + casapool % cplant ( npt , 2 : 3 )) . lt . 0.0_r_2 ) & . or . ( ( casapool % dcplantdt ( npt , 2 : 3 ) * deltpool + casapool % cplant ( npt , 2 : 3 )) & . lt . 0.5_r_2 * casapool % cplant ( npt , 2 : 3 ) ) ) casaflux % kplant ( npt , 2 : 3 ) = 0.0_r_2 casaflux % kplant_tot ( npt , 2 : 3 ) = 0.0_r_2 !MCfire - casaflux%kplant_fire(npt,2:3) = 0.0_r_2 ? casaflux % crmplant ( npt , 2 : 3 ) = 0.0_r_2 endwhere if ( any (( casapool % cplant ( npt ,:) + casapool % dcplantdt ( npt ,:) * deltpool ) . lt . 0.0_r_2 )) then casaflux % kplant ( npt , 1 ) = 0.0_r_2 casaflux % kplant_tot ( npt , 1 ) = 0.0_r_2 !MCfire - casaflux%kplant_fire(npt,1) = 0.0_r_2 ? casaflux % crmplant ( npt , 1 ) = min ( casaflux % crmplant ( npt , 1 ), 0.5_r_2 * casaflux % cgpp ( npt )) endif ! revise turnover and NPP and dcplantdt to reflect above adjustments casaflux % Cplant_turnover ( npt ,:) = casaflux % kplant_tot ( npt ,:) * casapool % cplant ( npt ,:) if ( any (( casapool % cplant ( npt ,:) + casapool % dcplantdt ( npt ,:) * deltpool ) . lt . 0.0_r_2 ) & . or . any (( casapool % cplant ( npt , 2 : 3 ) + casapool % dcplantdt ( npt , 2 : 3 ) * deltpool ) & . lt . 0.5_r_2 * casapool % cplant ( npt , 2 : 3 )) ) then ratioPNplant = 0.0_r_2 if ( casapool % Nplant ( npt , leaf ) > 0.0_r_2 ) & ratioPNplant = casapool % Pplant ( npt , leaf ) / ( casapool % Nplant ( npt , leaf ) + 1.e-10_r_2 ) Ygrow = 0.65_r_2 + 0.2_r_2 * ratioPNplant / ( ratioPNplant + 1.0_r_2 / 1 5.0_r_2 ) IF (( casaflux % Cgpp ( npt ) - SUM ( casaflux % crmplant ( npt ,:))) > 0.0_r_2 ) THEN ! Growth efficiency correlated to leaf N:P ratio. Q.Zhang @ 22/02/2011 casaflux % crgplant ( npt ) = ( 1.0_r_2 - Ygrow ) * max ( 0.0_r_2 , casaflux % Cgpp ( npt ) - & SUM ( casaflux % crmplant ( npt ,:))) ELSE casaflux % crgplant ( npt ) = 0.0_r_2 ENDIF endif ! recalc in any case so that all consistent casaflux % Cnpp ( npt ) = casaflux % Cgpp ( npt ) - sum ( casaflux % Crmplant ( npt ,:)) - casaflux % Crgplant ( npt ) - & casaflux % fracClabile ( npt ) * casaflux % Cgpp ( npt ) casapool % dcplantdt ( npt ,:) = casaflux % Cnpp ( npt ) * casaflux % fracCalloc ( npt ,:) - & casaflux % kplant_tot ( npt ,:) * casapool % cplant ( npt ,:) !! vh_js !! end of adjustments to avoid negative stocks Ticket#108 ! MC - above is not enough to keep Cplant >= 0, !      e.g. casaflux%Cgpp(npt)-sum(casaflux%crmplant(npt,:)) < 0. while Cplant<< if ( any (( casapool % cplant ( npt ,:) + casapool % dcplantdt ( npt ,:) * deltpool ) < 0.0_r_2 ) ) then ! 1st, no plant internal turnover where ( ( casapool % cplant ( npt ,:) + casapool % dcplantdt ( npt ,:) * deltpool ) < 0.0_r_2 ) casaflux % kplant ( npt ,:) = 0.0_r_2 casaflux % kplant_tot ( npt ,:) = 0.0_r_2 !MCfire - casaflux%kplant_fire(npt,1) = 0.0_r_2 ? casaflux % Cplant_turnover ( npt ,:) = 0.0_r_2 endwhere ! 2nd, nothing to labile pool casaflux % fracClabile ( npt ) = 0.0_r_2 ! 3rd, only respire less than available carbon if (( casaflux % Cgpp ( npt ) - sum ( casaflux % Crmplant ( npt ,:))) < 0.0_r_2 ) then casaflux % Crgplant ( npt ) = 0.0_r_2 where ( casaflux % fracCalloc ( npt ,:) > 0.0_r_2 ) casaflux % Crmplant ( npt ,:) = min ( casaflux % Crmplant ( npt ,:), & casaflux % Cgpp ( npt ) + casapool % Cplant ( npt ,:) / casaflux % fracCalloc ( npt ,:) / deltpool ) elsewhere casaflux % Crmplant ( npt ,:) = 0.0_r_2 endwhere endif ! recalc casaflux % Cnpp ( npt ) = casaflux % Cgpp ( npt ) - sum ( casaflux % Crmplant ( npt ,:)) - casaflux % Crgplant ( npt ) - & casaflux % fracClabile ( npt ) * casaflux % Cgpp ( npt ) casapool % dCplantdt ( npt ,:) = casaflux % Cnpp ( npt ) * casaflux % fracCalloc ( npt ,:) - & casaflux % kplant_tot ( npt ,:) * casapool % Cplant ( npt ,:) if ( any (( casapool % Cplant ( npt ,:) + casapool % dCplantdt ( npt ,:) * deltpool ) < 0.0_r_2 ) ) & write ( * , * ) 'ERR Tonnerre de Brest !' endif ! change here made by ypw on 26 august 2011 ! calculate fraction C to labile pool as a fraction of gpp, not npp ! casapool%dClabiledt(npt) = casaflux%Cnpp(npt) * casaflux%fracClabile(npt) casapool % dClabiledt ( npt ) = casaflux % Cgpp ( npt ) * casaflux % fracClabile ( npt ) - casaflux % clabloss ( npt ) ! added by ypwang 5/nov/2012 cleaf2met ( npt ) = casaflux % fromPtoL ( npt , metb , leaf ) * casaflux % kplant ( npt , leaf ) * casapool % cplant ( npt , leaf ) cleaf2str ( npt ) = casaflux % fromPtoL ( npt , str , leaf ) * casaflux % kplant ( npt , leaf ) * casapool % cplant ( npt , leaf ) croot2met ( npt ) = casaflux % fromPtoL ( npt , metb , froot ) * casaflux % kplant ( npt , froot ) * casapool % cplant ( npt , froot ) croot2str ( npt ) = casaflux % fromPtoL ( npt , str , froot ) * casaflux % kplant ( npt , froot ) * casapool % cplant ( npt , froot ) cwood2cwd ( npt ) = casaflux % fromPtoL ( npt , cwd , wood ) * casaflux % kplant ( npt , wood ) * casapool % cplant ( npt , wood ) if ( cleaf2met ( npt ) < 0.0_r_2 ) print * , 'ERR PP01 ' , npt , cleaf2met ( npt ), & casaflux % fromPtoL ( npt , metb , leaf ), casaflux % kplant ( npt , leaf ), casapool % cplant ( npt , leaf ) if ( cleaf2str ( npt ) < 0.0_r_2 ) print * , 'ERR PP02 ' , npt , cleaf2str ( npt ), & casaflux % fromPtoL ( npt , str , leaf ), casaflux % kplant ( npt , leaf ), casapool % cplant ( npt , leaf ) if ( croot2met ( npt ) < 0.0_r_2 ) print * , 'ERR PP03 ' , npt , croot2met ( npt ), & casaflux % fromPtoL ( npt , metb , froot ), casaflux % kplant ( npt , froot ), casapool % cplant ( npt , froot ) if ( croot2str ( npt ) < 0.0_r_2 ) print * , 'ERR PP04 ' , npt , croot2str ( npt ), & casaflux % fromPtoL ( npt , str , froot ), casaflux % kplant ( npt , froot ), casapool % cplant ( npt , froot ) if ( cwood2cwd ( npt ) < 0.0_r_2 ) print * , 'ERR PP05 ' , npt , cwood2cwd ( npt ), & casaflux % fromPtoL ( npt , cwd , wood ), casaflux % kplant ( npt , wood ), casapool % cplant ( npt , wood ) ! add fire component to above fluxes cleaf2met ( npt ) = cleaf2met ( npt ) + casaflux % fromPtoL_fire ( npt , metb , leaf ) & * ( 1.0_r_2 - casaflux % kplant ( npt , leaf )) * casaflux % kplant_fire ( npt , leaf ) * casapool % cplant ( npt , leaf ) cleaf2str ( npt ) = cleaf2str ( npt ) + casaflux % fromPtoL_fire ( npt , str , leaf ) & * ( 1.0_r_2 - casaflux % kplant ( npt , leaf )) * casaflux % kplant_fire ( npt , leaf ) * casapool % cplant ( npt , leaf ) croot2met ( npt ) = croot2met ( npt ) + casaflux % fromPtoL_fire ( npt , metb , froot ) & * ( 1.0_r_2 - casaflux % kplant ( npt , froot )) * casaflux % kplant_fire ( npt , froot ) * casapool % cplant ( npt , froot ) croot2str ( npt ) = croot2str ( npt ) + casaflux % fromPtoL_fire ( npt , str , froot ) & * ( 1.0_r_2 - casaflux % kplant ( npt , froot )) * casaflux % kplant_fire ( npt , froot ) * casapool % cplant ( npt , froot ) cwood2cwd ( npt ) = cwood2cwd ( npt ) + casaflux % fromPtoL_fire ( npt , cwd , wood ) & * ( 1.0_r_2 - casaflux % kplant ( npt , wood )) * casaflux % kplant_fire ( npt , wood ) * casapool % cplant ( npt , wood ) if ( cleaf2met ( npt ) < 0.0_r_2 ) print * , 'ERR PP06 ' , npt , cleaf2met ( npt ), & casaflux % fromPtoL_fire ( npt , metb , leaf ), & ( 1.0_r_2 - casaflux % kplant ( npt , leaf )), casaflux % kplant_fire ( npt , leaf ), casapool % cplant ( npt , leaf ) if ( cleaf2str ( npt ) < 0.0_r_2 ) print * , 'ERR PP07 ' , npt , cleaf2str ( npt ), & casaflux % fromPtoL_fire ( npt , str , leaf ), & ( 1.0_r_2 - casaflux % kplant ( npt , leaf )), casaflux % kplant_fire ( npt , leaf ), casapool % cplant ( npt , leaf ) if ( croot2met ( npt ) < 0.0_r_2 ) print * , 'ERR PP08 ' , npt , croot2met ( npt ), & casaflux % fromPtoL_fire ( npt , metb , froot ), & ( 1.0_r_2 - casaflux % kplant ( npt , froot )), casaflux % kplant_fire ( npt , froot ), casapool % cplant ( npt , froot ) if ( croot2str ( npt ) < 0.0_r_2 ) print * , 'ERR PP09 ' , npt , croot2str ( npt ), & casaflux % fromPtoL_fire ( npt , str , froot ), & ( 1.0_r_2 - casaflux % kplant ( npt , froot )), casaflux % kplant_fire ( npt , froot ), casapool % cplant ( npt , froot ) if ( cwood2cwd ( npt ) < 0.0_r_2 ) print * , 'ERR PP10 ' , npt , cwood2cwd ( npt ), & casaflux % fromPtoL_fire ( npt , cwd , wood ), & ( 1.0_r_2 - casaflux % kplant ( npt , wood )), casaflux % kplant_fire ( npt , wood ), casapool % cplant ( npt , wood ) ! fire flux to atmosphere from burnt plant material casaflux % fluxCtoCO2_plant_fire ( npt ) = 0.0_r_2 casaflux % FluxFromPtoCO2 ( npt ,:) = 0.0_r_2 do nP = 1 , mplant casaflux % FluxFromPtoCO2 ( npt , nP ) = & ( 1.0_r_2 - casaflux % kplant ( npt , nP )) * casaflux % kplant_fire ( npt , nP ) * & casapool % cplant ( npt , nP ) * & ( 1.0_r_2 - sum ( casaflux % fromPtoL_fire ( npt ,:, nP ))) casaflux % fluxCtoCO2_plant_fire ( npt ) = casaflux % fluxCtoCO2_plant_fire ( npt ) + & casaflux % FluxFromPtoCO2 ( npt , nP ) enddo ! Crop Harvest Flux casaflux % Charvest ( npt ) = casaflux % Charvest ( npt ) + & casaflux % fharvest ( npt ) * casaflux % kplant ( npt , leaf ) * casapool % cplant ( npt , leaf ) ! ! MC - assure that sum(FluxFrom) = k*C  numerically ! dF = casaflux%kplant_tot(npt,leaf) * casapool%Cplant(npt,leaf) - & !      cleaf2met(npt) - cleaf2str(npt) ! cleaf2met(npt) = cleaf2met(npt) + dF ! dF = casaflux%kplant_tot(npt,froot) * casapool%Cplant(npt,froot) - & !      croot2met(npt) - croot2str(npt) ! croot2met(npt) = croot2met(npt) + dF ! dF = casaflux%kplant_tot(npt,wood) * casapool%Cplant(npt,wood) - & !      cwood2cwd(npt) ! cwood2cwd(npt) = cwood2cwd(npt) + dF ! between-pool fluxes for 13CO2 casaflux % FluxFromPtoL ( npt , leaf , metb ) = cleaf2met ( npt ) casaflux % FluxFromPtoL ( npt , froot , metb ) = croot2met ( npt ) casaflux % FluxFromPtoL ( npt , wood , metb ) = 0.0_r_2 casaflux % FluxFromPtoL ( npt , leaf , str ) = cleaf2str ( npt ) casaflux % FluxFromPtoL ( npt , froot , str ) = croot2str ( npt ) casaflux % FluxFromPtoL ( npt , wood , str ) = 0.0_r_2 casaflux % FluxFromPtoL ( npt , leaf , cwd ) = 0.0_r_2 casaflux % FluxFromPtoL ( npt , froot , cwd ) = 0.0_r_2 casaflux % FluxFromPtoL ( npt , wood , cwd ) = cwood2cwd ( npt ) casaflux % FluxFromPtoHarvest ( npt ) = casaflux % FluxFromPtoHarvest ( npt ) + & casaflux % fharvest ( npt ) * casaflux % kplant ( npt , leaf ) * casapool % cplant ( npt , leaf ) ! Nitrogen IF ( icycle > 1 ) THEN IF ( casaflux % fracNalloc ( npt , leaf ) > 0.0_r_2 ) THEN casapool % dNplantdt ( npt , leaf ) = - casaflux % kplant ( npt , leaf ) * casapool % Nplant ( npt , leaf ) & * casabiome % ftransNPtoL ( veg % iveg ( npt ), leaf ) ! add turnover due to fire casapool % dNplantdt ( npt , leaf ) = casapool % dNplantdt ( npt , leaf ) - & ( 1.0_r_2 - casaflux % kplant ( npt , leaf )) * casaflux % kplant_fire ( npt , leaf ) * casapool % Nplant ( npt , leaf ) else casapool % dNplantdt ( npt , leaf ) = - casaflux % kplant_tot ( npt , leaf ) * casapool % Nplant ( npt , leaf ) ENDIF IF ( casamet % lnonwood ( npt ) == 0 ) THEN casapool % dNplantdt ( npt , wood ) = - casaflux % kplant ( npt , wood ) * casapool % Nplant ( npt , wood ) & * casabiome % ftransNPtoL ( veg % iveg ( npt ), wood ) ! add turnover due to fire casapool % dNplantdt ( npt , wood ) = casapool % dNplantdt ( npt , wood ) - & ( 1.0_r_2 - casaflux % kplant ( npt , wood )) * casaflux % kplant_fire ( npt , wood ) * casapool % Nplant ( npt , wood ) ELSE casapool % dNplantdt ( npt , wood ) = 0.0_r_2 ENDIF casapool % dNplantdt ( npt , froot ) = - casaflux % kplant ( npt , froot ) * casapool % Nplant ( npt , froot ) & * casabiome % ftransNPtoL ( veg % iveg ( npt ), froot ) ! add turnover due to fire casapool % dNplantdt ( npt , froot ) = casapool % dNplantdt ( npt , froot ) - & ( 1.0_r_2 - casaflux % kplant ( npt , froot )) * casaflux % kplant_fire ( npt , froot ) * casapool % Nplant ( npt , froot ) nleaf2str ( npt ) = casaflux % fromPtoL ( npt , str , leaf ) * casaflux % kplant ( npt , leaf ) & * casapool % cplant ( npt , leaf ) * ratioNCstrfix nroot2str ( npt ) = casaflux % fromPtoL ( npt , str , froot ) * casaflux % kplant ( npt , froot ) & * casapool % cplant ( npt , froot ) * ratioNCstrfix ! add N flux from leaves and roots to structural litter due to fire nleaf2str ( npt ) = nleaf2str ( npt ) + casaflux % fromPtoL_fire ( npt , str , leaf ) * & ( 1.0_r_2 - casaflux % kplant ( npt , leaf )) * & casaflux % kplant_fire ( npt , leaf ) * casapool % cplant ( npt , leaf ) * ratioNCstrfix nroot2str ( npt ) = nroot2str ( npt ) + casaflux % fromPtoL_fire ( npt , str , froot ) * & ( 1.0_r_2 - casaflux % kplant ( npt , froot )) * & casaflux % kplant_fire ( npt , froot ) * casapool % cplant ( npt , froot ) * ratioNCstrfix ! flux of leaf N to met litter: need to deduct harvest losses nleaf2met ( npt ) = - casapool % dNplantdt ( npt , leaf ) - nleaf2str ( npt ) & - casaflux % kplant ( npt , leaf ) * casapool % nplant ( npt , leaf ) * casaflux % fharvest ( npt ) nroot2met ( npt ) = - casapool % dNplantdt ( npt , froot ) - nroot2str ( npt ) nwood2cwd ( npt ) = - casapool % dNplantdt ( npt , wood ) ! Nitrogen lost to harvest casaflux % Nharvest ( npt ) = casaflux % Nharvest ( npt ) + & casaflux % kplant ( npt , leaf ) * casapool % nplant ( npt , leaf ) * casaflux % fharvest ( npt ) ! Nitrogen lost to fire casaflux % fluxNtoAtm_fire ( npt ) = ( 1.0_r_2 - casaflux % kplant ( npt , leaf )) * & casaflux % kplant_fire ( npt , leaf ) * casapool % Nplant ( npt , leaf ) & * ( 1.0_r_2 - casaflux % fromPtoL_fire ( npt , str , leaf )) + & ( 1.0_r_2 - casaflux % kplant ( npt , froot )) * casaflux % kplant_fire ( npt , froot ) * & casapool % Nplant ( npt , froot ) & * ( 1.0_r_2 - casaflux % fromPtoL_fire ( npt , str , froot )) + & ( 1.0_r_2 - casaflux % kplant ( npt , wood )) * casaflux % kplant_fire ( npt , wood ) * & casapool % Nplant ( npt , wood ) & * ( 1.0_r_2 - casaflux % fromPtoL_fire ( npt , str , wood )) ENDIF ! Phosphorus IF ( icycle > 2 ) THEN IF ( casaflux % fracPalloc ( npt , leaf ) > 0.0_r_2 ) THEN casapool % dPplantdt ( npt , leaf ) = - casaflux % kplant ( npt , leaf ) * casapool % Pplant ( npt , leaf ) & * casabiome % ftransPPtoL ( veg % iveg ( npt ), leaf ) else casapool % dPplantdt ( npt , leaf ) = - casaflux % kplant ( npt , leaf ) * casapool % Pplant ( npt , leaf ) ENDIF casapool % dPplantdt ( npt , froot ) = - casaflux % kplant ( npt , froot ) * casapool % Pplant ( npt , froot ) & * casabiome % ftransPPtoL ( veg % iveg ( npt ), froot ) casapool % dPplantdt ( npt , wood ) = - casaflux % kplant ( npt , wood ) * casapool % Pplant ( npt , wood ) & * casabiome % ftransPPtoL ( veg % iveg ( npt ), wood ) pleaf2str ( npt ) = casaflux % fromPtoL ( npt , str , leaf ) * casaflux % kplant ( npt , leaf ) & * casapool % cplant ( npt , leaf ) * ratioNCstrfix / ratioNPstrfix proot2str ( npt ) = casaflux % fromPtoL ( npt , str , froot ) * casaflux % kplant ( npt , froot ) & * casapool % cplant ( npt , froot ) * ratioNCstrfix / ratioNPstrfix ! add P loss by fire casapool % dPplantdt ( npt , leaf ) = casapool % dPplantdt ( npt , leaf ) - & ( 1.0_r_2 - casaflux % kplant ( npt , leaf ) ) * casaflux % kplant_fire ( npt , leaf ) * casapool % Pplant ( npt , leaf ) casapool % dPplantdt ( npt , froot ) = casapool % dPplantdt ( npt , froot ) - & ( 1.0_r_2 - casaflux % kplant ( npt , froot ) ) * casaflux % kplant_fire ( npt , froot ) * casapool % Pplant ( npt , froot ) casapool % dPplantdt ( npt , wood ) = casapool % dPplantdt ( npt , wood ) - & ( 1.0_r_2 - casaflux % kplant ( npt , wood ) ) * casaflux % kplant_fire ( npt , wood ) * casapool % Pplant ( npt , wood ) ! pleaf2str(npt) = pleaf2str(npt) + casaflux%fromPtoL_fire(npt,str,leaf) * casaflux%kplant_fire(npt,leaf)*  & !      (1. - casaflux%kplant(npt,leaf)) * ratioNCstrfix/ratioNPstrfix * casapool%cplant(npt,leaf) ! proot2str(npt) = proot2str(npt) + casaflux%fromPtoL_fire(npt,str,froot) * casaflux%kplant_fire(npt,froot)*  & !      (1. - casaflux%kplant(npt,froot)) * ratioNCstrfix/ratioNPstrfix * casapool%cplant(npt,froot) ! assume all plant phosphorous release by fire goes to litter pleaf2str ( npt ) = pleaf2str ( npt ) + casaflux % kplant_fire ( npt , leaf ) * & ( 1.0_r_2 - casaflux % kplant ( npt , leaf )) * ratioNCstrfix / ratioNPstrfix * casapool % cplant ( npt , leaf ) proot2str ( npt ) = proot2str ( npt ) + casaflux % kplant_fire ( npt , froot ) * & ( 1.0_r_2 - casaflux % kplant ( npt , froot )) * ratioNCstrfix / ratioNPstrfix * casapool % cplant ( npt , froot ) ! end Ploss by fire ! P lost to harvest casaflux % Pharvest ( npt ) = casaflux % kplant ( npt , leaf ) * casaflux % fharvest ( npt ) * & ratioNCstrfix / ratioNPstrfix * casapool % cplant ( npt , froot ) pleaf2met ( npt ) = - casapool % dPplantdt ( npt , leaf ) - pleaf2str ( npt ) - casaflux % Pharvest ( npt ) proot2met ( npt ) = - casapool % dPplantdt ( npt , froot ) - proot2str ( npt ) pwood2cwd ( npt ) = - casapool % dPplantdt ( npt , wood ) ENDIF ! icycle > 2 do nL = 1 , mlitter do nP = 1 , mplant casaflux % FluxCtolitter ( npt , nL ) = casaflux % FluxCtolitter ( npt , nL ) & + casaflux % fromPtoL ( npt , nL , nP ) * casaflux % kplant ( npt , nP ) * & casapool % cplant ( npt , nP ) & ! inputs from fire + casaflux % kplant_fire ( npt , nP ) * ( 1.0_r_2 - casaflux % kplant ( npt , nP )) * & casapool % cplant ( npt , nP ) * casaflux % fromPtoL_fire ( npt , nL , nP ) enddo enddo ! Nitrogen IF ( icycle > 1 ) THEN ! casaflux%FluxNtolitter(npt,str) = casaflux%fromPtoL(npt,str,leaf) * casaflux%kplant(npt,leaf)  & !                         * casapool%cplant(npt,leaf)       * ratioNCstrfix              & !                         + casaflux%fromPtoL(npt,str,froot)* casaflux%kplant(npt,froot) & !                         * casapool%cplant(npt,froot)      * ratioNCstrfix !vh! to avoid -ve Nitrogen pools Ticket#108 ! vh ! need to include fire fluxes here? casaflux % FluxNtolitter ( npt , str ) = min ( casaflux % fromPtoL ( npt , str , leaf ) * & casaflux % kplant ( npt , leaf ) & * casapool % cplant ( npt , leaf ) * ratioNCstrfix & , - casapool % dNplantdt ( npt , leaf )) & + min ( casaflux % fromPtoL ( npt , str , froot ) * casaflux % kplant ( npt , froot ) & * casapool % cplant ( npt , froot ) * ratioNCstrfix & , - casapool % dNplantdt ( npt , froot )) ! casaflux%FluxNtolitter(npt,str) =  min(nleaf2str(npt),  -casapool%dNplantdt(npt,leaf)) & !      + min(nroot2str(npt), -casapool%dNplantdt(npt,froot)) casaflux % FluxNtolitter ( npt , metb ) = - casapool % dNplantdt ( npt , leaf ) - casapool % dNplantdt ( npt , froot ) & - casaflux % FluxNtolitter ( npt , str ) casaflux % FluxNtolitter ( npt , CWD ) = - casapool % dNplantdt ( npt , wood ) ! adding N uptake casapool % dNplantdt ( npt ,:) = casapool % dNplantdt ( npt ,:) & + casaflux % Nminuptake ( npt ) * casaflux % fracNalloc ( npt ,:) !       casapool%Nsoilmin(npt)    = casapool%Nsoilmin(npt) - casaflux%Nminuptake(npt) *deltpool ENDIF !end \"icycle >1\" ! Phosphorus IF ( icycle > 2 ) THEN ! casaflux%FluxPtolitter(npt,str) = casaflux%fromPtoL(npt,str,leaf) * casaflux%kplant(npt,leaf)  & !      * casapool%cplant(npt,leaf)       * ratioNCstrfix/ratioNPstrfix        & !      + casaflux%fromPtoL(npt,str,froot)* casaflux%kplant(npt,froot) & !      * casapool%cplant(npt,froot)      * ratioNCstrfix/ratioNPstrfix casaflux % FluxPtolitter ( npt , str ) = min ( pleaf2str ( npt ), - casapool % dPplantdt ( npt , leaf )) & + min ( proot2str ( npt ), - casapool % dPplantdt ( npt , froot )) casaflux % FluxPtolitter ( npt , metb ) = - casapool % dPplantdt ( npt , leaf ) - casapool % dPplantdt ( npt , froot ) & - casaflux % FluxPtolitter ( npt , str ) casaflux % FluxPtolitter ( npt , CWD ) = - casapool % dPplantdt ( npt , wood ) ! add P uptake casapool % dPplantdt ( npt ,:) = casapool % dPplantdt ( npt ,:) & + casaflux % Plabuptake ( npt ) * casaflux % fracPalloc ( npt ,:) !       casapool%Psoillab(npt)    = casapool%Psoillab(npt) - casaflux%Plabuptake(npt) * deltpool ENDIF ! icycle > 2 endif ! /= icewater enddo ! npt=1,mp END SUBROUTINE casa_delplant SUBROUTINE casa_delsoil ( veg , casapool , casaflux , casamet , casabiome ) ! calculate changes in litter and soil pools implicit none type ( veg_parameter_type ), intent ( inout ) :: veg ! vegetation parameters type ( casa_pool ), intent ( inout ) :: casapool type ( casa_flux ), intent ( inout ) :: casaflux type ( casa_met ), intent ( inout ) :: casamet type ( casa_biome ), intent ( inout ) :: casabiome ! local variables real ( r_2 ), dimension ( mp ) :: xdplabsorb , fluxptase integer :: j , jj , k , kk , kkk , nL , nS , nSS , nland real ( r_2 ) :: iflux ! casa casaflux % fluxCtoCO2 = 0.0_r_2 casaflux % fluxCtosoil = 0.0_r_2 casaflux % fluxNtosoil = 0.0_r_2 casaflux % fluxPtosoil = 0.0_r_2 casaflux % Crsoil = 0.0_r_2 ! initialization added by BP jul2010 casapool % dClitterdt = 0.0_r_2 casapool % dCsoildt = 0.0_r_2 casapool % dNlitterdt = 0.0_r_2 casapool % dNsoildt = 0.0_r_2 casapool % dNsoilmindt = 0.0_r_2 casaflux % Nsmin = 0.0_r_2 casaflux % Nsimm = 0.0_r_2 casaflux % Nsnet = 0.0_r_2 casaflux % Nminloss = 0.0_r_2 casaflux % Nminleach = 0.0_r_2 casaflux % Nlittermin = 0.0_r_2 casapool % dPlitterdt = 0.0_r_2 casapool % dPsoildt = 0.0_r_2 casapool % dPsoillabdt = 0.0_r_2 casapool % dPsoilsorbdt = 0.0_r_2 casapool % dPsoiloccdt = 0.0_r_2 casaflux % Psmin = 0.0_r_2 casaflux % Psimm = 0.0_r_2 casaflux % Psnet = 0.0_r_2 casaflux % Pleach = 0.0_r_2 casaflux % Ploss = 0.0_r_2 casaflux % Plittermin = 0.0_r_2 fluxptase = 0.0_r_2 !13C casaflux % fluxCtoCO2_litter_fire = 0.0_r_2 casaflux % FluxFromLtoS = 0.0_r_2 casaflux % FluxFromStoS = 0.0_r_2 casaflux % FluxFromStoCO2 = 0.0_r_2 casaflux % FluxFromLtoCO2 = 0.0_r_2 do nland = 1 , mp if ( casamet % iveg2 ( nland ) /= icewater ) then ! MC - avoid -ve litter pools where (( casapool % clitter ( nland ,:) + ( casaflux % fluxCtolitter ( nland ,:) - & casaflux % klitter_tot ( nland ,:) * casapool % clitter ( nland ,:)) * deltpool ) < 0.0_r_2 ) casaflux % klitter ( nland ,:) = 0.0_r_2 casaflux % klitter_tot ( nland ,:) = 0.0_r_2 !MCfire - casaflux%klitter_fire(nland,:) = 0.0_r_2 ? end where if ( icycle > 1 ) then !vh! set klitter to zero where Nlitter will go -ve ! (occurs occasionally for metabolic litter pool) Ticket#108 where ( casaflux % klitter ( nland ,:) * max ( 0.0_r_2 , casapool % Nlitter ( nland ,:)) > & casapool % Nlitter ( nland ,:) + casaflux % fluxNtolitter ( nland ,:)) casaflux % klitter ( nland ,:) = 0.0_r_2 casaflux % klitter_tot ( nland ,:) = 0.0_r_2 !MCfire - casaflux%klitter_fire(nland,:) = 0.0_r_2 ? end where endif if ( icycle > 2 ) then !vh! set klitter to zero where Plitter will go -ve ! (occurs occasionally for metabolic litter pool) Ticket#108 where ( casaflux % klitter ( nland ,:) * max ( 0.0_r_2 , casapool % Plitter ( nland ,:)). gt . & casapool % Plitter ( nland ,:) + casaflux % fluxPtolitter ( nland ,:)) casaflux % klitter ( nland ,:) = 0.0_r_2 casaflux % klitter_tot ( nland ,:) = 0.0_r_2 !MCfire - casaflux%klitter_fire(nland,:) = 0.0_r_2 ? end where endif ! fire flux to atmosphere from burnt litter material do nL = 1 , mlitter iflux = ( 1.0_r_2 - casaflux % klitter ( nland , nL )) * casaflux % klitter_fire ( nland , nL ) * & casapool % clitter ( nland , nL ) casaflux % fluxCtoCO2_litter_fire ( nland ) = casaflux % fluxCtoCO2_litter_fire ( nland ) + iflux casaflux % FluxFromLtoCO2 ( nland , nL ) = casaflux % FluxFromLtoCO2 ( nland , nL ) + iflux iflux = casaflux % fromLtoCO2 ( nland , nL ) * casaflux % klitter ( nland , nL ) * & casapool % clitter ( nland , nL ) casaflux % fluxCtoCO2 ( nland ) = casaflux % fluxCtoCO2 ( nland ) + iflux casaflux % FluxFromLtoCO2 ( nland , nL ) = casaflux % FluxFromLtoCO2 ( nland , nL ) + iflux enddo do nS = 1 , msoil do nL = 1 , mlitter iflux = casaflux % fromLtoS ( nland , nS , nL ) * casaflux % klitter ( nland , nL ) * casapool % clitter ( nland , nL ) casaflux % fluxCtosoil ( nland , nS ) = casaflux % fluxCtosoil ( nland , nS ) + iflux casaflux % FluxFromLtoS ( nland , nL , nS ) = casaflux % FluxFromLtoS ( nland , nL , nS ) + iflux enddo enddo ! MC - avoid -ve soil pools where (( casapool % csoil ( nland ,:) + ( casaflux % fluxCtosoil ( nland ,:) - & casaflux % ksoil ( nland ,:) * casapool % csoil ( nland ,:)) * deltpool ) < 0.0_r_2 ) casaflux % ksoil ( nland ,:) = 0.0_r_2 end where do nS = 1 , msoil do nSS = 1 , msoil if ( nSS /= nS ) then iflux = casaflux % fromStoS ( nland , nS , nSS ) * casaflux % ksoil ( nland , nSS ) * casapool % csoil ( nland , nSS ) casaflux % fluxCtosoil ( nland , nS ) = casaflux % fluxCtosoil ( nland , nS ) + iflux casaflux % FluxFromStoS ( nland , nSS , nS ) = casaflux % FluxFromStoS ( nland , nSS , nS ) + iflux endif enddo iflux = casaflux % fromStoCO2 ( nland , nS ) * casaflux % ksoil ( nland , nS ) * casapool % csoil ( nland , nS ) casaflux % fluxCtoCO2 ( nland ) = casaflux % fluxCtoCO2 ( nland ) + iflux casaflux % FluxFromStoCO2 ( nland , nS ) = casaflux % FluxFromStoCO2 ( nland , nS ) + iflux enddo ! Nitrogen IF ( icycle > 1 ) THEN DO j = 1 , mlitter casaflux % Nlittermin ( nland ) = casaflux % Nlittermin ( nland ) & + casaflux % klitter ( nland , j ) * casapool % Nlitter ( nland , j ) ENDDO DO k = 1 , msoil casaflux % Nsmin ( nland ) = casaflux % Nsmin ( nland ) & + casaflux % ksoil ( nland , k ) * casapool % Nsoil ( nland , k ) ENDDO !gross mineralisation DO kk = 1 , msoil DO jj = 1 , mlitter ! immobilisation from litter to soil casaflux % Nsimm ( nland ) = casaflux % Nsimm ( nland ) & - casaflux % fromLtoS ( nland , kk , jj ) & * casaflux % klitter ( nland , jj ) & * casapool % Clitter ( nland , jj ) & * casapool % ratioNCsoilnew ( nland , kk ) ENDDO DO kkk = 1 , msoil ! immobilisation from soil to soil IF ( kkk . ne . kk ) THEN casaflux % Nsimm ( nland ) = casaflux % Nsimm ( nland ) & - casaflux % fromStoS ( nland , kk , kkk ) & * casaflux % ksoil ( nland , kkk ) & * casapool % Csoil ( nland , kkk ) & * casapool % ratioNCsoilnew ( nland , kk ) ENDIF ENDDO ENDDO ! immobilization casaflux % Nsnet ( nland ) = casaflux % Nlittermin ( nland ) & + casaflux % Nsmin ( nland ) & + casaflux % Nsimm ( nland ) ! net mineralization IF ( casapool % Nsoilmin ( nland ) > 2.0_r_2 . AND . casamet % tsoilavg ( nland ) > 27 3.12_r_2 ) THEN casaflux % Nminloss ( nland ) = casaflux % fNminloss ( nland ) & * MAX ( 0.0_r_2 , casaflux % Nsnet ( nland )) casaflux % Nminleach ( nland ) = casaflux % fNminleach ( nland ) & * MAX ( 0.0_r_2 , casapool % Nsoilmin ( nland )) ELSE casaflux % Nminloss ( nland ) = casaflux % fNminloss ( nland ) & * MAX ( 0.0_r_2 , casaflux % Nsnet ( nland )) & * MAX ( 0.0_r_2 , casapool % Nsoilmin ( nland ) / 2.0_r_2 ) casaflux % Nminleach ( nland ) = casaflux % fNminleach ( nland ) & * MAX ( 0.0_r_2 , casapool % Nsoilmin ( nland )) & * MAX ( 0.0_r_2 , casapool % Nsoilmin ( nland ) / 2.0_r_2 ) ENDIF DO k = 1 , msoil DO j = 1 , mlitter casaflux % FluxNtosoil ( nland , k ) = casaflux % FluxNtosoil ( nland , k ) & + casaflux % fromLtoS ( nland , k , j ) & * casaflux % klitter ( nland , j ) & * casapool % Clitter ( nland , j ) & * casapool % ratioNCsoilnew ( nland , k ) ENDDO ! end of \"j\" DO kk = 1 , msoil IF ( kk . ne . k ) THEN casaflux % FluxNtosoil ( nland , k ) = casaflux % FluxNtosoil ( nland , k ) & + casaflux % fromStoS ( nland , k , kk ) & * casaflux % ksoil ( nland , kk ) & * casapool % Csoil ( nland , kk ) & * casapool % ratioNCsoilnew ( nland , k ) ENDIF ENDDO ! end of \"kk\" ENDDO ! end of \"k\" ENDIF ! end of icycle > 1 ! Phosphorus IF ( icycle > 2 ) THEN DO j = 1 , mlitter casaflux % Plittermin ( nland ) = casaflux % Plittermin ( nland ) & + casaflux % klitter ( nland , j ) * casapool % Plitter ( nland , j ) ENDDO DO k = 1 , msoil casaflux % Psmin ( nland ) = casaflux % Psmin ( nland ) & + casaflux % ksoil ( nland , k ) * casapool % Psoil ( nland , k ) ENDDO !gross mineralisation DO kk = 1 , msoil DO jj = 1 , mlitter ! immobilisation from litter to soil casaflux % Psimm ( nland ) = casaflux % Psimm ( nland ) & - casaflux % fromLtoS ( nland , kk , jj ) & * casaflux % klitter ( nland , jj ) & * casapool % Nlitter ( nland , jj ) & / casapool % ratioNPsoil ( nland , kk ) ! * casapool%ratioPCsoil(nland,kk)/casapool%ratioNCsoil(nland,kk) ENDDO DO kkk = 1 , msoil ! immobilisation from soil to soil IF ( kkk . ne . kk ) THEN casaflux % Psimm ( nland ) = casaflux % Psimm ( nland ) & - casaflux % fromStoS ( nland , kk , kkk ) & * casaflux % ksoil ( nland , kkk ) & * casapool % Nsoil ( nland , kkk ) & / casapool % ratioNPsoil ( nland , kk ) ! * casapool%ratioPCsoil(nland,kk)/casapool%ratioNCsoil(nland,kk) ENDIF ENDDO ENDDO ! immobilization casaflux % Psnet ( nland ) = casaflux % Plittermin ( nland ) & + casaflux % Psmin ( nland ) & + casaflux % Psimm ( nland ) ! net mineralization !      casaflux%Pleach(nland)  =  (1.0e-4) & !                                 * max(0.0_r_2,casapool%Psoillab(nland)) casaflux % Pleach ( nland ) = casaflux % fPleach ( nland ) & * max ( 0.0_r_2 , casapool % Psoillab ( nland )) DO k = 1 , msoil DO j = 1 , mlitter casaflux % FluxPtosoil ( nland , k ) = casaflux % FluxPtosoil ( nland , k ) & + casaflux % fromLtoS ( nland , k , j ) & * casaflux % klitter ( nland , j ) & * casapool % Nlitter ( nland , j ) & / casapool % ratioNPsoil ( nland , k ) ! * casapool%ratioPCsoil(nland,k)/casapool%ratioNCsoil(nland,k) ENDDO ! end of \"j\" DO kk = 1 , msoil IF ( kk . ne . k ) THEN ! casaflux%FluxPtosoil(nland,k) = casaflux%FluxPtosoil(nland,k)  & !                      + casaflux%fromStoS(nland,k,kk) & !                      * casaflux%ksoil(nland,kk)      & !                      * casapool%Csoil(nland,kk)      & !                      * casapool%ratioPCsoil(nland,k) casaflux % FluxPtosoil ( nland , k ) = casaflux % FluxPtosoil ( nland , k ) & + casaflux % fromStoS ( nland , k , kk ) & * casaflux % ksoil ( nland , kk ) & * casapool % Nsoil ( nland , kk ) & / casapool % ratioNPsoil ( nland , k ) ! * casapool%ratioPCsoil(nland,k)/casapool%ratioNCsoil(nland,k) ENDIF ENDDO ! end of \"kk\" ENDDO ! end of \"k\" ! need to account for flow from sorbed to occluded pool ENDIF ! end of icycle > 2 endif ! end of casamet%iveg2(nland) /= icewater enddo ! end of nland do nland = 1 , mp if ( casamet % iveg2 ( nland ) /= icewater ) then casapool % dClitterdt ( nland ,:) = casaflux % fluxCtolitter ( nland ,:) - & casaflux % klitter_tot ( nland ,:) * casapool % clitter ( nland ,:) casapool % dCsoildt ( nland ,:) = casaflux % fluxCtosoil ( nland ,:) - & casaflux % ksoil ( nland ,:) * casapool % csoil ( nland ,:) casaflux % Crsoil ( nland ) = casaflux % fluxCtoCO2 ( nland ) casaflux % cnep ( nland ) = casaflux % cnpp ( nland ) - casaflux % Crsoil ( nland ) ! Nitrogen IF ( icycle > 1 ) THEN casapool % dNlitterdt ( nland ,:) = casaflux % fluxNtolitter ( nland ,:) & - casaflux % klitter ( nland ,:) & * max ( 0.0_r_2 , casapool % Nlitter ( nland ,:)) casapool % dNsoildt ( nland ,:) = casaflux % FluxNtosoil ( nland ,:) & - casaflux % ksoil ( nland ,:) * casapool % Nsoil ( nland ,:) casapool % dNsoilmindt ( nland ) = casaflux % Nsnet ( nland )& + casaflux % Nmindep ( nland ) + casaflux % Nminfix ( nland ) & - casaflux % Nminloss ( nland ) & - casaflux % Nminleach ( nland ) & - casaflux % Nupland ( nland ) ENDIF ! end icycle>1 ! Phosphorus IF ( icycle > 2 ) THEN fluxptase ( nland ) = casabiome % prodptase ( veg % iveg ( nland ) ) * deltcasa & * max ( 0.0_r_2 , ( casapool % Psoil ( nland , 2 ) & * casaflux % ksoil ( nland , 2 ) & + casapool % Psoil ( nland , 3 ) & * casaflux % ksoil ( nland , 3 ) ) & ) & * max ( 0.0_r_2 , ( casabiome % costNPup ( veg % iveg ( nland ) ) & - 1 5.0_r_2 ) & ) & / ( max ( 0.0_r_2 , ( casabiome % costNPup ( veg % iveg ( nland ) ) & - 1 5.0_r_2 ) & ) + 15 0.0_r_2 & ) xdplabsorb ( nland ) = 1.0_r_2 + casaflux % Psorbmax ( nland ) * casaflux % kmlabp ( nland ) & / (( casaflux % kmlabp ( nland ) + casapool % Psoillab ( nland )) ** 2 ) casapool % dPlitterdt ( nland ,:) = casaflux % fluxPtolitter ( nland ,:) & - casaflux % klitter ( nland ,:) & * max ( zero , casapool % Plitter ( nland ,:)) casapool % dPsoildt ( nland , 1 ) = casaflux % FluxPtosoil ( nland , 1 ) & - casaflux % ksoil ( nland , 1 ) * casapool % Psoil ( nland , 1 ) casapool % dPsoildt ( nland , 2 ) = casaflux % FluxPtosoil ( nland , 2 ) & - casaflux % ksoil ( nland , 2 ) * casapool % Psoil ( nland , 2 ) & - fluxptase ( nland ) * casaflux % ksoil ( nland , 2 ) * casapool % Psoil ( nland , 2 ) & / ( casaflux % ksoil ( nland , 2 ) * casapool % Psoil ( nland , 2 ) + casaflux % ksoil ( nland , 3 ) * casapool % Psoil ( nland , 3 )) casapool % dPsoildt ( nland , 3 ) = casaflux % FluxPtosoil ( nland , 3 ) & - casaflux % ksoil ( nland , 3 ) * casapool % Psoil ( nland , 3 ) & - fluxptase ( nland ) * casaflux % ksoil ( nland , 3 ) * casapool % Psoil ( nland , 3 ) & / ( casaflux % ksoil ( nland , 2 ) * casapool % Psoil ( nland , 2 ) + casaflux % ksoil ( nland , 3 ) * casapool % Psoil ( nland , 3 )) casapool % dPsoillabdt ( nland ) = casaflux % Psnet ( nland ) + fluxptase ( nland ) & + casaflux % Pdep ( nland ) + casaflux % Pwea ( nland ) & - casaflux % Pleach ( nland ) - casaflux % pupland ( nland ) & - casaflux % kpsorb ( nland ) * casapool % Psoilsorb ( nland ) & + casaflux % kpocc ( nland ) * casapool % Psoilocc ( nland ) ! here the dPsoillabdt =(dPsoillabdt+dPsoilsorbdt) ! dPsoilsorbdt  = xdplabsorb !     write(*,*) 'dPsoillabdt: ' ,  casapool%dPsoillabdt,  xdplabsorb(nland) casapool % dPsoillabdt ( nland ) = casapool % dPsoillabdt ( nland ) / xdplabsorb ( nland ) !    write(*,*) 'dPsoillabdt: ' ,  casapool%dPsoillabdt casapool % dPsoilsorbdt ( nland ) = 0.0_r_2 casapool % dPsoiloccdt ( nland ) = casaflux % kpsorb ( nland ) * casapool % Psoilsorb ( nland ) & - casaflux % kpocc ( nland ) * casapool % Psoilocc ( nland ) ! P loss to non-ravailable P pools !      casaflux%Ploss(nland)        = casaflux%kpocc(nland) * casapool%Psoilocc(nland) !      casaflux%Ploss(nland)       = casaflux%fPleach(nland) & !                                 * max(zero,casapool%Psoillab(nland)) casaflux % Ploss ( nland ) = 0.0_r_2 ENDIF ! end icycle>2 endif ! end of casamet%iveg2(nland) /= icewater enddo ! end nland END SUBROUTINE casa_delsoil SUBROUTINE avgsoil ( veg , soil , casamet ) ! Get avg soil moisture, avg soil temperature ! need to estimate the land cell mean soil temperature and moisture weighted by the area fraction ! of each tile within the land cell implicit none type ( veg_parameter_type ), intent ( inout ) :: veg ! vegetation parameters type ( soil_parameter_type ), intent ( inout ) :: soil ! soil parameters type ( casa_met ), intent ( inout ) :: casamet integer :: ns , nland real ( r_2 ) :: froot , sfc , swilt casamet % tsoilavg = 0.0_r_2 casamet % moistavg = 0.0_r_2 casamet % btran = 0.0_r_2 do ns = 1 , ms do nland = 1 , mp froot = real ( veg % froot ( nland , ns ), r_2 ) sfc = real ( soil % sfc ( nland ), r_2 ) swilt = real ( soil % swilt ( nland ), r_2 ) casamet % tsoilavg ( nland ) = casamet % tsoilavg ( nland ) + froot * casamet % tsoil ( nland , ns ) if ( trim ( cable_user % SMRF_NAME ) == 'Trudinger2016' . or . & trim ( cable_user % SMRF_NAME ) == 'DAMM' ) then casamet % moistavg ( nland ) = casamet % moistavg ( nland ) + froot * casamet % moist ( nland , ns ) else casamet % moistavg ( nland ) = casamet % moistavg ( nland ) + & froot * min ( sfc , casamet % moist ( nland , ns )) endif ! Ticket#121 ! casamet%btran(nland)     = casamet%btran(nland) + veg%froot(nland,ns)  & !         * (min(soil%sfc(nland),casamet%moist(nland,ns))-soil%swilt(nland)) & !         /(soil%sfc(nland)-soil%swilt(nland)) casamet % btran ( nland ) = casamet % btran ( nland ) + & froot * max ( min ( sfc , casamet % moist ( nland , ns )) - swilt , 0.0_r_2 ) / ( sfc - swilt ) enddo ! nland=1, mp enddo ! ns=1, ms ! MC - secure kplant > 0. casamet % btran = min ( max ( casamet % btran , 0.0_r_2 ), 1.0_r_2 ) END SUBROUTINE avgsoil SUBROUTINE casa_xkN ( xkNlimiting , casapool , casaflux , casamet , casabiome , veg ) ! computing the reduction in litter and SOM decomposition ! when decomposition rate is N-limiting IMPLICIT NONE REAL ( r_2 ), DIMENSION ( mp ), INTENT ( INOUT ) :: xkNlimiting TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome ! TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg ! vegetation parameters ! local variables INTEGER :: j , k , kk , nland REAL ( r_2 ), DIMENSION ( mp ) :: xFluxNlittermin REAL ( r_2 ), DIMENSION ( mp ) :: xFluxNsoilmin REAL ( r_2 ), DIMENSION ( mp ) :: xFluxNsoilimm REAL ( r_2 ), DIMENSION ( mp ) :: xFluxNsoilminnet ! A maximum Clitter set to avoid positive feedback for litter accumulation ! when N mode is activated. (Q.Zhang 23/05/2011) !  real(r_2), dimension(17)         :: xClitter !  data xClitter/100.0,100.0,100.0,100.0,50.0,150.0,150.0,100.0,& !                150.0,150.0,100.0, 20.0,20.0, 20.0, 20.0, 20.0,20.0/ xkNlimiting = 1.0_r_2 !  set N mineral N fluxes to zero xFluxNlittermin (:) = 0.0_r_2 xFluxNsoilmin (:) = 0.0_r_2 xFluxNsoilimm (:) = 0.0_r_2 !negative for microbial upatek and postive for release of mineral N xFluxNsoilminnet (:) = 0.0_r_2 !  calculate gross mineralisation DO nland = 1 , mp IF ( casamet % iveg2 ( nland ) /= icewater ) THEN ! calculate C:N ratio of newly formed SOM as function of soil mineral N pool IF ( casapool % Nsoilmin ( nland ) < 2.0_r_2 ) THEN casapool % ratioNCsoilnew ( nland ,:) = casapool % ratioNCsoilmin ( nland ,:) & + ( casapool % ratioNCsoilmax ( nland ,:) & - casapool % ratioNCsoilmin ( nland ,:)) & * max ( 0.0_r_2 , casapool % Nsoilmin ( nland )) / 2.0_r_2 ELSE casapool % ratioNCsoilnew ( nland ,:) = casapool % ratioNCsoilmax ( nland ,:) ENDIF DO j = 1 , mlitter xFluxNlittermin ( nland ) = xFluxNlittermin ( nland ) & + casaflux % klitter ( nland , j ) * casapool % Nlitter ( nland , j ) ENDDO DO k = 1 , msoil xFluxNsoilmin ( nland ) = xFluxNsoilmin ( nland ) & + casaflux % ksoil ( nland , k ) * casapool % Nsoil ( nland , k ) ENDDO ! calculate N immobilisation from L to S and S to S DO kk = 1 , msoil DO j = 1 , mlitter ! immobilisation from litter to soil xFluxNsoilimm ( nland ) = xFluxNsoilimm ( nland ) & - casaflux % fromLtoS ( nland , kk , j ) * casaflux % klitter ( nland , j ) & * casapool % Clitter ( nland , j ) * casapool % ratioNCsoilnew ( nland , kk ) ENDDO DO k = 1 , msoil ! immobilisation from soil to soil IF ( k . ne . kk ) THEN xFluxNsoilimm ( nland ) = xFluxNsoilimm ( nland ) & - casaflux % fromStoS ( nland , kk , k ) * casaflux % ksoil ( nland , k ) & * casapool % Csoil ( nland , k ) * casapool % ratioNCsoilnew ( nland , kk ) ENDIF ENDDO ENDDO ENDIF ENDDO ! now check if there is sufficient mineral N xFluxNsoilminnet (:) = xFluxNlittermin (:) + xFluxNsoilmin (:) + xFluxNsoilimm (:) ! Q.Zhang 23/05/2011 test code according to YPW WHERE ( casamet % iveg2 (:) /= icewater ) WHERE (( xFluxNsoilminnet (:) * deltpool + ( casapool % Nsoilmin (:) - 2.0_r_2 )) > 0.0_r_2 & . OR . xFluxNsoilminnet (:) . ge . 0.0_r_2 ) xkNlimiting (:) = 1.0_r_2 ELSEWHERE xkNlimiting (:) = MAX ( 0.0_r_2 , - ( casapool % Nsoilmin (:) - 0.5_r_2 ) & / ( deltpool * xFluxNsoilminnet (:))) xkNlimiting (:) = MIN ( 1.0_r_2 , xkNlimiting (:)) ENDWHERE ! Q.Zhang 23/05/2011 test ! If pool size larger than xClitter, turnover rate will not constrained by Nsoilmin. !    where(casapool%clitter(:,1) > xClitter(veg%iveg(:))) !     xkNlimiting(:) = 1.0_r_2 !    end where ! end (Q.Zhang 23/05/2011) where ( sum ( casapool % clitter , 2 ) > casabiome % maxfinelitter ( veg % iveg (:)) + casabiome % maxcwd ( veg % iveg (:))) xkNlimiting (:) = 1.0_r_2 end where ENDWHERE END SUBROUTINE casa_xkN SUBROUTINE casa_nuptake ( veg , xkNlimiting , casabiome , casapool , casaflux , casamet ) ! (1) compute (1)N uptake by plants; ! (2) allocation of uptaken N to plants ! IMPLICIT NONE TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet REAL ( r_2 ), DIMENSION ( mp ), INTENT ( IN ) :: xkNlimiting ! local variables INTEGER :: np REAL ( r_2 ), DIMENSION ( mp , mplant ) :: Nreqmax , Nreqmin , NtransPtoP , xnuptake REAL ( r_2 ), DIMENSION ( mp ) :: totNreqmax , totNreqmin REAL ( r_2 ), DIMENSION ( mp ) :: xnCnpp Nreqmin (:,:) = 0.0_r_2 Nreqmax (:,:) = 0.0_r_2 NtransPtoP (:,:) = 0.0_r_2 totNreqmax = 0.0_r_2 totNreqmin = 0.0_r_2 casaflux % Nminuptake (:) = 0.0_r_2 casaflux % fracNalloc (:,:) = 0.0_r_2 xnCnpp = max ( 0.0_r_2 , casaflux % Cnpp ) call casa_Nrequire ( xnCnpp , Nreqmin , Nreqmax , NtransPtoP , veg , & casabiome , casapool , casaflux , casamet ) DO np = 1 , mp IF ( casamet % iveg2 ( np ) /= icewater ) THEN totNreqmax ( np ) = Nreqmax ( np , leaf ) + Nreqmax ( np , wood ) + Nreqmax ( np , froot ) totNreqmin ( np ) = Nreqmin ( np , leaf ) + Nreqmin ( np , wood ) + Nreqmin ( np , froot ) xnuptake ( np , leaf ) = Nreqmin ( np , leaf ) + xkNlimiting ( np ) * ( Nreqmax ( np , leaf ) - Nreqmin ( np , leaf )) & * casapool % Nsoilmin ( np ) / ( casapool % Nsoilmin ( np ) + casabiome % kminN ( veg % iveg ( np ))) xnuptake ( np , wood ) = Nreqmin ( np , wood ) + xkNlimiting ( np ) * ( Nreqmax ( np , wood ) - Nreqmin ( np , wood )) & * casapool % Nsoilmin ( np ) / ( casapool % Nsoilmin ( np ) + casabiome % kminN ( veg % iveg ( np ))) xnuptake ( np , froot ) = Nreqmin ( np , froot ) + xkNlimiting ( np ) * ( Nreqmax ( np , froot ) - Nreqmin ( np , froot )) & * casapool % Nsoilmin ( np ) / ( casapool % Nsoilmin ( np ) + casabiome % kminN ( veg % iveg ( np ))) casaflux % Nminuptake ( np ) = xnuptake ( np , leaf ) + xnuptake ( np , wood ) + xnuptake ( np , froot ) + 1.e-10_r_2 casaflux % fracNalloc ( np , leaf ) = xnuptake ( np , leaf ) / casaflux % Nminuptake ( np ) casaflux % fracNalloc ( np , wood ) = xnuptake ( np , wood ) / casaflux % Nminuptake ( np ) casaflux % fracNalloc ( np , froot ) = xnuptake ( np , froot ) / casaflux % Nminuptake ( np ) ENDIF ENDDO casaflux % Nupland = casaflux % Nminuptake END SUBROUTINE casa_nuptake SUBROUTINE casa_Nrequire ( xnCnpp , Nreqmin , Nreqmax , NtransPtoP , veg , & casabiome , casapool , casaflux , casamet ) ! IMPLICIT NONE REAL ( r_2 ), DIMENSION ( mp ), INTENT ( IN ) :: xnCnpp REAL ( r_2 ), DIMENSION ( mp , mplant ), INTENT ( INOUT ) :: Nreqmax , Nreqmin REAL ( r_2 ), DIMENSION ( mp , mplant ), INTENT ( INOUT ) :: NtransPtoP TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet ! local variable INTEGER :: np REAL ( r_2 ), DIMENSION ( mp , mplant ) :: ncplantmax Nreqmin (:,:) = 0.0_r_2 Nreqmax (:,:) = 0.0_r_2 NtransPtoP (:,:) = 0.0_r_2 DO np = 1 , mp IF ( casamet % iveg2 ( np ) /= icewater ) THEN if ( casapool % Nsoilmin ( np ) < 2.0 ) then ncplantmax ( np , leaf ) = casabiome % ratioNCplantmin ( veg % iveg ( np ), leaf ) & + ( casabiome % ratioNCplantmax ( veg % iveg ( np ), leaf ) - casabiome % ratioNCplantmin ( veg % iveg ( np ), leaf )) & * min ( 1.0_r_2 , max ( 0.0_r_2 , 2.0_r_2 ** ( 0.5_r_2 * casapool % Nsoilmin ( np )) - 1.0_r_2 )) ncplantmax ( np , wood ) = casabiome % ratioNCplantmin ( veg % iveg ( np ), wood ) & + ( casabiome % ratioNCplantmax ( veg % iveg ( np ), wood ) - casabiome % ratioNCplantmin ( veg % iveg ( np ), wood )) & * min ( 1.0_r_2 , max ( 0.0_r_2 , 2.0_r_2 ** ( 0.5_r_2 * casapool % Nsoilmin ( np )) - 1.0_r_2 )) ncplantmax ( np , froot ) = casabiome % ratioNCplantmin ( veg % iveg ( np ), froot ) & + ( casabiome % ratioNCplantmax ( veg % iveg ( np ), froot ) - casabiome % ratioNCplantmin ( veg % iveg ( np ), froot )) & * min ( 1.0_r_2 , max ( 0.0_r_2 , 2.0_r_2 ** ( 0.5_r_2 * casapool % Nsoilmin ( np )) - 1.0_r_2 )) else ncplantmax ( np , leaf ) = casabiome % ratioNCplantmax ( veg % iveg ( np ), leaf ) ncplantmax ( np , wood ) = casabiome % ratioNCplantmax ( veg % iveg ( np ), wood ) ncplantmax ( np , froot ) = casabiome % ratioNCplantmax ( veg % iveg ( np ), froot ) endif Nreqmax ( np , leaf ) = xnCnpp ( np ) * casaflux % fracCalloc ( np , leaf ) * ncplantmax ( np , leaf ) Nreqmax ( np , wood ) = xnCnpp ( np ) * casaflux % fracCalloc ( np , wood ) * ncplantmax ( np , wood ) Nreqmax ( np , froot ) = xnCnpp ( np ) * casaflux % fracCalloc ( np , froot ) * ncplantmax ( np , froot ) Nreqmin ( np , leaf ) = xnCnpp ( np ) * casaflux % fracCalloc ( np , leaf ) & * casabiome % ratioNCplantmin ( veg % iveg ( np ), leaf ) Nreqmin ( np , wood ) = xnCnpp ( np ) * casaflux % fracCalloc ( np , wood ) & * casabiome % ratioNCplantmin ( veg % iveg ( np ), wood ) Nreqmin ( np , froot ) = xnCnpp ( np ) * casaflux % fracCalloc ( np , froot ) & * casabiome % ratioNCplantmin ( veg % iveg ( np ), froot ) NtransPtoP ( np , leaf ) = casaflux % kplant ( np , leaf ) * casapool % Nplant ( np , leaf ) & * ( 1.0_r_2 - casabiome % ftransNPtoL ( veg % iveg ( np ), leaf )) NtransPtoP ( np , wood ) = casaflux % kplant ( np , wood ) * casapool % Nplant ( np , wood ) & * ( 1.0_r_2 - casabiome % ftransNPtoL ( veg % iveg ( np ), wood )) NtransPtoP ( np , froot ) = casaflux % kplant ( np , froot ) * casapool % Nplant ( np , froot ) & * ( 1.0_r_2 - casabiome % ftransNPtoL ( veg % iveg ( np ), froot )) Nreqmax ( np , leaf ) = max ( 0.0_r_2 , Nreqmax ( np , leaf ) - NtransPtoP ( np , leaf )) Nreqmax ( np , wood ) = max ( 0.0_r_2 , Nreqmax ( np , wood ) - NtransPtoP ( np , wood )) Nreqmax ( np , froot ) = max ( 0.0_r_2 , Nreqmax ( np , froot ) - NtransPtoP ( np , froot )) Nreqmin ( np , leaf ) = max ( 0.0_r_2 , Nreqmin ( np , leaf ) - NtransPtoP ( np , leaf )) Nreqmin ( np , wood ) = max ( 0.0_r_2 , Nreqmin ( np , wood ) - NtransPtoP ( np , wood )) Nreqmin ( np , froot ) = max ( 0.0_r_2 , Nreqmin ( np , froot ) - NtransPtoP ( np , froot )) if ( casapool % nplant ( np , leaf ) / ( casapool % cplant ( np , leaf ) + 1.0e-10_r_2 ) > casabiome % ratioNCplantmax ( veg % iveg ( np ), leaf )) then Nreqmax ( np , leaf ) = 0.0_r_2 Nreqmin ( np , leaf ) = 0.0_r_2 endif if ( casapool % nplant ( np , wood ) / ( casapool % cplant ( np , wood ) + 1.0e-10_r_2 ) > casabiome % ratioNCplantmax ( veg % iveg ( np ), wood )) then Nreqmax ( np , wood ) = 0.0_r_2 Nreqmin ( np , wood ) = 0.0_r_2 endif if ( casapool % nplant ( np , froot ) / ( casapool % cplant ( np , froot ) + 1.0e-10_r_2 ) > casabiome % ratioNCplantmax ( veg % iveg ( np ), froot )) then Nreqmax ( np , froot ) = 0.0_r_2 Nreqmin ( np , froot ) = 0.0_r_2 endif ENDIF ENDDO END SUBROUTINE casa_Nrequire SUBROUTINE casa_puptake ( veg , xkNlimiting , casabiome , casapool , casaflux , casamet ) ! (1) compute  P uptake by plants; ! (2) allocation of uptaken P to plants ! IMPLICIT NONE TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet REAL ( r_2 ), DIMENSION ( mp ), INTENT ( IN ) :: xkNlimiting ! local variables REAL ( r_2 ), DIMENSION ( mp , mplant ) :: Preqmax , Preqmin , PtransPtoP , xPuptake REAL ( r_2 ), DIMENSION ( mp ) :: totPreqmax , totPreqmin REAL ( r_2 ), DIMENSION ( mp ) :: xpCnpp Preqmin (:,:) = 0.0_r_2 Preqmax (:,:) = 0.0_r_2 PtransPtoP (:,:) = 0.0_r_2 casaflux % Plabuptake (:) = 0.0_r_2 casaflux % fracPalloc (:,:) = 0.0_r_2 totPreqmax = 0.0_r_2 totPreqmin = 0.0_r_2 xpCnpp = max ( 0.0_r_2 , casaflux % cnpp ) call casa_Prequire ( xpCnpp , Preqmin , Preqmax , PtransPtoP , veg , & casabiome , casapool , casaflux , casamet ) WHERE ( casamet % iveg2 /= icewater ) totPreqmax (:) = Preqmax (:, leaf ) + Preqmax (:, wood ) + Preqmax (:, froot ) totPreqmin (:) = Preqmin (:, leaf ) + Preqmin (:, wood ) + Preqmin (:, froot ) xpuptake (:, leaf ) = Preqmin (:, leaf ) + xkNlimiting (:) * ( Preqmax (:, leaf ) - Preqmin (:, leaf )) & * casapool % Psoillab (:) / ( casapool % Psoillab (:) + casabiome % KuplabP ( veg % iveg (:))) xpuptake (:, wood ) = Preqmin (:, wood ) + xkNlimiting (:) * ( Preqmax (:, wood ) - Preqmin (:, wood )) & * casapool % Psoillab (:) / ( casapool % Psoillab (:) + casabiome % KuplabP ( veg % iveg (:))) xpuptake (:, froot ) = Preqmin (:, froot ) + xkNlimiting (:) * ( Preqmax (:, froot ) - Preqmin (:, froot )) & * casapool % Psoillab (:) / ( casapool % Psoillab (:) + casabiome % KuplabP ( veg % iveg (:))) casaflux % Plabuptake (:) = xpuptake (:, leaf ) + xpuptake (:, wood ) + xpuptake (:, froot ) + 1.0e-10_r_2 casaflux % fracPalloc (:, leaf ) = xpuptake (:, leaf ) / casaflux % Plabuptake (:) casaflux % fracPalloc (:, wood ) = xpuptake (:, wood ) / casaflux % Plabuptake (:) casaflux % fracPalloc (:, froot ) = xpuptake (:, froot ) / casaflux % Plabuptake (:) ENDWHERE casaflux % Pupland = casaflux % Plabuptake !  ! only used in spinning up the model !  DO  np=1,mp !    casaflux%Plabuptake(np) = TotPreqmax(np) !    casaflux%Pupland(np)    = TotPreqmax(np) !    casaflux%Pwea(np)       = TotPreqmax(np) !  ENDDO END SUBROUTINE casa_puptake SUBROUTINE casa_Prequire ( xpCnpp , Preqmin , Preqmax , PtransPtoP , veg , & casabiome , casapool , casaflux , casamet ) IMPLICIT NONE REAL ( r_2 ), DIMENSION ( mp ), INTENT ( IN ) :: xpCnpp REAL ( r_2 ), DIMENSION ( mp , mplant ), INTENT ( INOUT ) :: Preqmax , Preqmin REAL ( r_2 ), DIMENSION ( mp , mplant ), INTENT ( INOUT ) :: PtransPtoP TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet ! local variables INTEGER :: np Preqmin (:,:) = 0.0_r_2 Preqmax (:,:) = 0.0_r_2 PtransPtoP (:,:) = 0.0_r_2 do np = 1 , mp if ( casamet % iveg2 ( np ) /= icewater ) then Preqmax ( np , leaf ) = xpCnpp ( np ) * casaflux % fracCalloc ( np , leaf ) & * ( casapool % Nplant ( np , leaf ) / ( casapool % Cplant ( np , leaf ) + 1.0e-10_r_2 )) & / casabiome % ratioNPplantmin ( veg % iveg ( np ), leaf ) Preqmax ( np , wood ) = xpCnpp ( np ) * casaflux % fracCalloc ( np , wood ) & * ( casapool % Nplant ( np , wood ) / ( casapool % Cplant ( np , wood ) + 1.0e-10_r_2 )) & / casabiome % ratioNPplantmin ( veg % iveg ( np ), wood ) Preqmax ( np , froot ) = xpCnpp ( np ) * casaflux % fracCalloc ( np , froot ) & * ( casapool % Nplant ( np , froot ) / ( casapool % Cplant ( np , froot ) + 1.0e-10_r_2 )) & / casabiome % ratioNPplantmin ( veg % iveg ( np ), froot ) Preqmin ( np , leaf ) = xpCnpp ( np ) * casaflux % fracCalloc ( np , leaf ) & * ( casapool % Nplant ( np , leaf ) / ( casapool % Cplant ( np , leaf ) + 1.0e-10_r_2 )) & / casabiome % ratioNPplantmax ( veg % iveg ( np ), leaf ) Preqmin ( np , wood ) = xpCnpp ( np ) * casaflux % fracCalloc ( np , wood ) & * ( casapool % Nplant ( np , wood ) / ( casapool % Cplant ( np , wood ) + 1.0e-10_r_2 )) & / casabiome % ratioNPplantmax ( veg % iveg ( np ), wood ) Preqmin ( np , froot ) = xpCnpp ( np ) * casaflux % fracCalloc ( np , froot ) & * ( casapool % Nplant ( np , froot ) / ( casapool % Cplant ( np , froot ) + 1.0e-10_r_2 )) & / casabiome % ratioNPplantmax ( veg % iveg ( np ), froot ) PtransPtoP ( np , leaf ) = casaflux % kplant ( np , leaf ) * casapool % Pplant ( np , leaf ) & * ( 1.0_r_2 - casabiome % ftransPPtoL ( veg % iveg ( np ), leaf )) PtransPtoP ( np , wood ) = casaflux % kplant ( np , wood ) * casapool % Pplant ( np , wood ) & * ( 1.0_r_2 - casabiome % ftransPPtoL ( veg % iveg ( np ), wood )) PtransPtoP ( np , froot ) = casaflux % kplant ( np , froot ) * casapool % Pplant ( np , froot ) & * ( 1.0_r_2 - casabiome % ftransPPtoL ( veg % iveg ( np ), froot )) Preqmax ( np , leaf ) = max ( 0.0_r_2 , Preqmax ( np , leaf ) - PtransPtoP ( np , leaf )) Preqmax ( np , wood ) = max ( 0.0_r_2 , Preqmax ( np , wood ) - PtransPtoP ( np , wood )) Preqmax ( np , froot ) = max ( 0.0_r_2 , Preqmax ( np , froot ) - PtransPtoP ( np , froot )) Preqmin ( np , leaf ) = max ( 0.0_r_2 , Preqmin ( np , leaf ) - PtransPtoP ( np , leaf )) Preqmin ( np , wood ) = max ( 0.0_r_2 , Preqmin ( np , wood ) - PtransPtoP ( np , wood )) Preqmin ( np , froot ) = max ( 0.0_r_2 , Preqmin ( np , froot ) - PtransPtoP ( np , froot )) if ( casapool % pplant ( np , leaf ) / ( casapool % nplant ( np , leaf ) + 1.0e-10_r_2 ) > & 1.0_r_2 / casabiome % ratioNPplantmin ( veg % iveg ( np ), leaf )) then Preqmax ( np , leaf ) = 0.0_r_2 Preqmin ( np , leaf ) = 0.0_r_2 endif if ( casapool % pplant ( np , wood ) / ( casapool % nplant ( np , wood ) + 1.0e-10_r_2 ) > & 1.0_r_2 / casabiome % ratioNPplantmin ( veg % iveg ( np ), wood )) then Preqmax ( np , wood ) = 0.0_r_2 Preqmin ( np , wood ) = 0.0_r_2 endif if ( casapool % pplant ( np , froot ) / ( casapool % nplant ( np , froot ) + 1.0e-10_r_2 ) > & 1.0_r_2 / casabiome % ratioNPplantmin ( veg % iveg ( np ), froot )) then Preqmax ( np , froot ) = 0.0_r_2 Preqmin ( np , froot ) = 0.0_r_2 endif endif enddo END SUBROUTINE casa_Prequire SUBROUTINE casa_cnpcycle ( veg , casabiome , casapool , casaflux , casamet ) ! update all pool sizes implicit none type ( veg_parameter_type ), intent ( inout ) :: veg ! vegetation parameters type ( casa_biome ), intent ( inout ) :: casabiome type ( casa_pool ), intent ( inout ) :: casapool type ( casa_flux ), intent ( inout ) :: casaflux type ( casa_met ), intent ( inout ) :: casamet ! local variables integer :: i , j , k , np do np = 1 , mp if ( casamet % iveg2 ( np ) == icewater ) then casamet % glai ( np ) = 0.0_r_2 else casapool % cplant ( np ,:) = casapool % cplant ( np ,:) + casapool % dcplantdt ( np ,:) * deltpool casapool % clabile ( np ) = casapool % clabile ( np ) + casapool % dclabiledt ( np ) * deltpool if ( casapool % cplant ( np , leaf ) > 0.0_r_2 ) then if ( icycle > 1 ) casapool % Nplant ( np ,:) = casapool % Nplant ( np ,:) + casapool % dNplantdt ( np ,:) * deltpool if ( icycle > 2 ) casapool % Pplant ( np ,:) = casapool % Pplant ( np ,:) + casapool % dPplantdt ( np ,:) * deltpool endif ! avoid high ratios of N to P in plant material casapool % Nplant ( np , 3 ) = min ( casapool % Nplant ( np , 3 ), & casabiome % ratioNCplantmax ( veg % iveg ( np ), froot ) * casapool % cplant ( np , 3 ) ) casamet % glai ( np ) = max ( casabiome % glaimin ( veg % iveg ( np )), & casabiome % sla ( veg % iveg ( np )) * casapool % cplant ( np , leaf )) ! vh ! !IF (LALLOC.ne.3) THEN casamet % glai ( np ) = min ( casabiome % glaimax ( veg % iveg ( np )), casamet % glai ( np )) !ENDIF casapool % clitter ( np ,:) = casapool % clitter ( np ,:) + casapool % dClitterdt ( np ,:) * deltpool casapool % csoil ( np ,:) = casapool % csoil ( np ,:) + casapool % dCsoildt ( np ,:) * deltpool IF ( icycle > 1 ) THEN casapool % Nlitter ( np ,:) = casapool % Nlitter ( np ,:) + casapool % dNlitterdt ( np ,:) * deltpool casapool % Nsoil ( np ,:) = casapool % Nsoil ( np ,:) + casapool % dNsoildt ( np ,:) * deltpool ! vh ! put lower bound of 1.0e-3 to prevent Nsoilmin from going negative ! Ticket #108 casapool % Nsoilmin ( np ) = max ( casapool % Nsoilmin ( np ) + casapool % dNsoilmindt ( np ) * deltpool , 1.0e-3_r_2 ) ENDIF IF ( icycle > 2 ) THEN casapool % Plitter ( np ,:) = casapool % Plitter ( np ,:) + casapool % dPlitterdt ( np ,:) * deltpool casapool % Psoil ( np ,:) = casapool % Psoil ( np ,:) + casapool % dPsoildt ( np ,:) * deltpool ! vh ! put lower bound of 1.0e-3 to prevent Psoillab from going negative casapool % Psoillab ( np ) = max ( casapool % Psoillab ( np ) + casapool % dPsoillabdt ( np ) * deltpool , 1.0e-3_r_2 ) casapool % Psoilsorb ( np ) = casaflux % Psorbmax ( np ) * casapool % Psoillab ( np ) / ( casaflux % kmlabp ( np ) + casapool % Psoillab ( np )) !      casapool%Psoilsorb(np) = casapool%Psoilsorb(np)  & !                             + casapool%dPsoilsorbdt(np) * deltpool casapool % Psoilocc ( np ) = casapool % Psoilocc ( np ) + casapool % dPsoiloccdt ( np ) * deltpool ENDIF do i = 1 , mplant if ( casapool % cplant ( np , i ) < 0.0_r_2 ) then write ( 57 , * ) 'Cpool: np,ivt' , np , casamet % lat ( np ), casamet % lon ( np ), & casamet % iveg2 ( np ), casapool % cplant ( np ,:) write ( * , * ) 'Cpool: np,ivt' , np , casamet % lat ( np ), casamet % lon ( np ), & casamet % iveg2 ( np ), casapool % cplant ( np ,:) call casa_poolzero ( np , 1 , casapool ) casapool % cplant ( np , i ) = max ( 0.0_r_2 , casapool % cplant ( np , i )) endif enddo IF ( icycle > 1 ) THEN DO i = 1 , mplant IF ( casapool % nplant ( np , i ) < 0.0_r_2 ) THEN WRITE ( 57 , * ) 'Npool:' , 'np,ivt,ipool' , np , casamet % iveg2 ( np ), casapool % nplant ( np ,:) call casa_poolzero ( np , 2 , casapool ) casapool % nplant ( np , i ) = max ( 0.0_r_2 , casapool % nplant ( np , i )) ENDIF ENDDO ENDIF ! end of \"icycle >1\" do j = 1 , mlitter if ( casapool % clitter ( np , j ) < 0.0_r_2 ) then write ( 57 , * ) 'Clitter: np,ivt2' , np , casamet % iveg2 ( np ), casapool % clitter ( np ,:) write ( * , * ) 'Clitter: np,ivt2' , np , casamet % iveg2 ( np ), casapool % clitter ( np ,:) call casa_poolzero ( np , 3 , casapool ) casapool % clitter ( np , j ) = max ( 0.0_r_2 , casapool % clitter ( np , j )) endif enddo do k = 1 , msoil if ( casapool % csoil ( np , k ) < 0.0_r_2 ) then write ( 57 , * ) 'Csoil: np,ivt2' , np , casamet % iveg2 ( np ), casapool % csoil ( np ,:) write ( * , * ) 'Csoil: np,ivt2' , np , casamet % iveg2 ( np ), casapool % csoil ( np ,:) call casa_poolzero ( np , 5 , casapool ) casapool % csoil ( np , k ) = max ( 0.0_r_2 , casapool % csoil ( np , k )) endif enddo !  check if any pool size, and terminate model run if any pool size is negative!! IF ( icycle > 1 ) THEN DO j = 1 , mlitter IF ( casapool % nlitter ( np , j ) < 0.0_r_2 ) THEN WRITE ( 57 , * ) 'Nlitter: np, ivt2 ' , np , casamet % iveg2 ( np ), casapool % Nlitter ( np , :) call casa_poolzero ( np , 4 , casapool ) casapool % nlitter ( np , j ) = max ( 0.0_r_2 , casapool % nlitter ( np , j )) ENDIF ENDDO DO k = 1 , msoil IF ( casapool % nsoil ( np , k ) < 0.0_r_2 ) THEN WRITE ( 57 , * ) 'Nsoil: np, ivt2' , np , casamet % iveg2 ( np ), casapool % nsoil ( np , :) call casa_poolzero ( np , 6 , casapool ) casapool % nsoil ( np , k ) = max ( 0.0_r_2 , casapool % nsoil ( np , k )) ENDIF ENDDO ENDIF !end of \"icycle >1\" endif ! == icewater enddo ! np=1,mp END SUBROUTINE casa_cnpcycle subroutine casa_poolzero ( n , ipool , casapool ) implicit none integer , intent ( in ) :: n , ipool type ( casa_pool ), intent ( inout ) :: casapool write ( 57 , * ) ' WARNING: negative pools are reset to ZERO!!' select case ( ipool ) case ( 1 ) write ( 57 , * ) 'plant carbon pool size negative!!' write ( 57 , * ) 'plant C pools: ' , n , casapool % cplant ( n , :) case ( 2 ) write ( 57 , * ) 'plant nitrogen pool size negative!!' write ( 57 , * ) 'plant C pools: ' , n , casapool % cplant ( n , :) write ( 57 , * ) 'plant N pools: ' , n , casapool % nplant ( n , :) case ( 3 ) write ( 57 , * ) 'litter carbon pool size negative!!' write ( 57 , * ) 'litter C pools: ' , n , casapool % clitter ( n , :) case ( 4 ) write ( 57 , * ) 'litter nitrogen pool size negative!!' write ( 57 , * ) 'carbon pool: ' , n , casapool % clitter ( n , :) write ( 57 , * ) 'nitrogen pools: ' , n , casapool % nlitter ( n , :) case ( 5 ) write ( 57 , * ) 'soil carbon pool size negative!!' write ( 57 , * ) 'soil C pools: ' , n , casapool % csoil ( n , :) case ( 6 ) write ( 57 , * ) 'soil nitrogen pool size negative!!' write ( 57 , * ) 'soil C pools: ' , n , casapool % csoil ( n , :) write ( 57 , * ) 'soil N pools: ' , n , casapool % nsoil ( n , :) end select end subroutine casa_poolzero SUBROUTINE casa_cnpbal ( casapool , casaflux , casabal , idoy ) IMPLICIT NONE TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal integer , intent ( in ) :: idoy ! local variables REAL ( r_2 ), DIMENSION ( mp ) :: cbalplant , nbalplant , pbalplant REAL ( r_2 ), DIMENSION ( mp ) :: cbalsoil , nbalsoil , pbalsoil real ( r_2 ), dimension ( mp ) :: tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 real ( r_2 ) :: tmp7 , tmp8 , tmp9 , tmp10 , tmp11 , tmp12 , tmp13 , tmp14 real ( r_2 ), parameter :: prec = 1.0e-10_r_2 integer :: i cbalplant (:) = 0.0_r_2 cbalsoil (:) = 0.0_r_2 nbalplant (:) = 0.0_r_2 nbalsoil (:) = 0.0_r_2 pbalplant (:) = 0.0_r_2 pbalsoil (:) = 0.0_r_2 casabal % cbalance (:) = 0.0_r_2 casabal % nbalance (:) = 0.0_r_2 casabal % pbalance (:) = 0.0_r_2 ! C balance ! plant (change in stock = npp - turnover of plant pools) tmp1 = sum ( casapool % cplant , 2 ) - sum ( casabal % cplantlast , 2 ) tmp2 = ( casaflux % Cnpp - sum (( casaflux % kplant_tot * casabal % cplantlast ), 2 )) * deltpool tmp3 = casapool % Clabile - casabal % Clabilelast tmp4 = casapool % dClabiledt * deltpool Cbalplant (:) = tmp1 - tmp2 + tmp3 - tmp4 if ( any ( abs ( tmp1 - tmp2 ) > prec ) . and . ( idoy > 0 )) then ! if idoy>1: do not report first time step of year write ( * , * ) 'Imbalance casapool%Cplant' do i = 1 , mp if ( abs ( tmp1 ( i ) - tmp2 ( i )) > prec ) then write ( * , * ) '  Index, Imbalance        ' , idoy , i , tmp1 ( i ) - tmp2 ( i ) write ( * , * ) '  Last, Current Cplant    ' , sum ( casabal % cplantlast ( i ,:)), sum ( casapool % cplant ( i ,:)) write ( * , * ) '  NPP flux, Pool turnover ' , casaflux % Cnpp ( i ) * deltpool , & sum ( casaflux % kplant_tot ( i ,:) * casabal % cplantlast ( i ,:)) * deltpool write ( * , * ) '  Diff Cplant, Fluxes     ' , tmp1 ( i ), tmp2 ( i ) endif enddo endif if ( any ( abs ( tmp3 - tmp4 ) > prec ) . and . ( idoy > 0 )) then write ( * , * ) 'Imbalance casapool%Clabile' do i = 1 , mp if ( abs ( tmp3 ( i ) - tmp4 ( i )) > prec ) then write ( * , * ) '  Index, Imbalance        ' , idoy , i , tmp3 ( i ) - tmp4 ( i ) write ( * , * ) '  Last, Current Clabile ' , casapool % Clabile ( i ), casabal % Clabilelast ( i ) write ( * , * ) '  Diff, Deriv Clabile   ' , tmp3 ( i ), tmp4 ( i ) endif enddo endif ! soil and litter: !   change in stock = (base plant turnover - harvest) !                    - heterotrophic resp !                    + plant turnover by fire (excl. fraction lost to atm) !                    - litter loss to atmosphere by fire tmp1 = sum ( casapool % clitter , 2 ) - sum ( casabal % clitterlast , 2 ) tmp2 = sum ( casapool % csoil , 2 ) - sum ( casabal % csoillast , 2 ) tmp3 = ( sum ( casaflux % kplant * casabal % cplantlast , 2 ) - & casaflux % kplant (:, leaf ) * casabal % cplantlast (:, leaf ) * casaflux % fharvest ) * deltpool tmp4 = casaflux % Crsoil (:) * deltpool tmp5 = sum (( 1.0_r_2 - casaflux % kplant ) * casaflux % kplant_fire * casabal % cplantlast , 2 ) * deltpool tmp6 = ( casaflux % fluxCtoCO2_plant_fire + casaflux % fluxCtoCO2_litter_fire ) * deltpool Cbalsoil (:) = tmp1 + tmp2 - tmp3 + tmp4 - tmp5 + tmp6 if ( any ( abs ( Cbalsoil ) > prec ) . and . ( idoy > 0 )) then write ( * , * ) 'Imbalance casapool%Clitter+casapool%Csoil' do i = 1 , mp if ( abs ( Cbalsoil ( i )) > prec ) then write ( * , * ) '  Index, Imbalance     ' , idoy , i , Cbalsoil ( i ) write ( * , * ) '  Diff Clitter         ' , tmp1 ( i ) write ( * , * ) '  Diff Csoil           ' , tmp2 ( i ) write ( * , * ) '  Plant turnover       ' , sum ( casaflux % kplant ( i ,:) * casabal % cplantlast ( i ,:)) * deltpool write ( * , * ) '  Harvest              ' , casaflux % kplant ( i , leaf ) * casabal % cplantlast ( i , leaf ) & * casaflux % fharvest ( i ) * deltpool write ( * , * ) '  Hetero respiration   ' , tmp4 ( i ) write ( * , * ) '  Fire turnover - atmo ' , tmp5 ( i ) - tmp6 ( i ) write ( * , * ) '  Diff Clitter+Csoil   ' , tmp1 ( i ) + tmp2 ( i ) write ( * , * ) '  Fluxes               ' , tmp3 ( i ) - tmp4 ( i ) + tmp5 ( i ) - tmp6 ( i ) ! fire debug - mass bal on litter tmp7 = sum ( casaflux % kplant ( i ,:) * casabal % cplantlast ( i ,:)) ! plant input tmp8 = sum ( casaflux % kplant_fire ( i ,:) * ( 1.0_r_2 - casaflux % kplant ( i ,:)) * casabal % cplantlast ( i ,:)) - & casaflux % fluxctoco2_plant_fire ( i ) tmp9 = sum ( casaflux % klitter ( i ,:) * casabal % clitterlast ( i ,:)) tmp10 = sum ( casaflux % klitter_fire ( i ,:) * ( 1.0_r_2 - casaflux % klitter ( i ,:)) * casabal % clitterlast ( i ,:)) tmp11 = sum ( casaflux % kplant_tot ( i ,:) * casabal % cplantlast ( i ,:)) tmp12 = casaflux % fluxCtoCO2_plant_fire ( i ) tmp13 = sum ( casaflux % klitter_tot ( i ,:) * casabal % clitterlast ( i ,:)) tmp14 = sum ( casaflux % kplant_fire ( i ,:) * ( 1.0_r_2 - casaflux % kplant ( i ,:)) * casabal % cplantlast ( i ,:)) write ( * , * ) '  plant input to litter (base turnover):        ' , tmp7 write ( * , * ) '  plant input to litter (fire):                 ' , tmp8 write ( * , * ) '  plant input to litter (base turnover + fire): ' , tmp7 + tmp8 write ( * , * ) '  fluxCtolitter:                                ' , sum ( casaflux % FluxCtolitter ( i ,:)) write ( * , * ) '  plant total turnover:                         ' , tmp11 write ( * , * ) '  plant loss to atm (fire):                     ' , tmp12 write ( * , * ) '  litter loss (base turnover):                  ' , tmp9 write ( * , * ) '  litter loss (fire):                           ' , tmp10 write ( * , * ) '  litter loss (base turnover + fire):           ' , tmp13 write ( * , * ) '  delta clitt2:                                 ' , tmp7 + tmp8 - tmp9 - tmp11 write ( * , * ) '  fluxCtolitter:                                ' , sum ( casaflux % fluxCtolitter ( i ,:)) write ( * , * ) '  frac plant fire flux to CO2:                  ' , casaflux % FluxFromPtoCO2 ( i ,:) write ( * , * ) '  frac plant fire flux to litter:               ' , sum ( casaflux % fromPtoL_fire ( i ,:,:), 1 ) write ( * , * ) '  plant loss (fire)                             ' , tmp14 endif enddo endif casabal % cbalance (:) = Cbalplant (:) + Cbalsoil (:) casapool % ctot_0 = sum ( casabal % cplantlast , 2 ) + sum ( casabal % clitterlast , 2 ) & + sum ( casabal % csoillast , 2 ) + casabal % clabilelast casapool % ctot = sum ( casapool % cplant , 2 ) + sum ( casapool % clitter , 2 ) & + sum ( casapool % csoil , 2 ) + casapool % clabile casabal % cplantlast = casapool % cplant casabal % clabilelast = casapool % clabile casabal % clitterlast = casapool % clitter casabal % csoillast = casapool % csoil casabal % sumcbal = casabal % sumcbal + casabal % cbalance IF ( icycle > 1 ) THEN Nbalplant (:) = sum ( casabal % nplantlast , 2 ) - sum ( casapool % nplant , 2 ) & + casaflux % Nminuptake (:) * deltpool Nbalsoil (:) = - sum ( casapool % nlitter , 2 ) - sum ( casapool % nsoil , 2 ) & - casapool % nsoilmin (:) + casabal % nsoilminlast (:) & + sum ( casabal % nlitterlast , 2 ) + sum ( casabal % nsoillast , 2 ) & + ( casaflux % Nmindep (:) + casaflux % Nminfix (:) - casaflux % Nminloss (:) & - casaflux % Nminleach (:) - casaflux % Nupland (:)) * deltpool casabal % nbalance (:) = Nbalplant (:) + Nbalsoil (:) casabal % nplantlast = casapool % nplant casabal % nlitterlast = casapool % nlitter casabal % nsoillast = casapool % nsoil casabal % nsoilminlast = casapool % nsoilmin casabal % sumnbal = casabal % sumnbal + casabal % nbalance ENDIF IF ( icycle > 2 ) THEN Pbalplant (:) = sum ( casabal % Pplantlast , 2 ) - sum ( casapool % Pplant , 2 ) & + casaflux % Plabuptake (:) * deltpool Pbalsoil (:) = - sum ( casapool % Plitter , 2 ) - sum ( casapool % Psoil , 2 ) & + sum ( casabal % Plitterlast , 2 ) + sum ( casabal % Psoillast , 2 ) & - casapool % psoillab (:) - casapool % psoilsorb (:) - casapool % psoilocc (:) & + casabal % psoillablast (:) + casabal % psoilsorblast (:) + casabal % psoilocclast (:) & + ( casaflux % Pdep (:) + casaflux % Pwea (:) & - casaflux % Pleach (:) - casaflux % Pupland (:) & - casaflux % Ploss (:)) * deltpool casabal % pbalance (:) = pbalplant (:) + pbalsoil (:) casabal % pplantlast = casapool % pplant casabal % plitterlast = casapool % plitter casabal % psoillast = casapool % psoil casabal % psoillablast = casapool % psoillab casabal % psoilsorblast = casapool % psoilsorb casabal % psoilocclast = casapool % psoilocc casabal % sumpbal = casabal % sumpbal + casabal % pbalance ENDIF END SUBROUTINE casa_cnpbal SUBROUTINE casa_ndummy ( casapool ) IMPLICIT NONE TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool casapool % Nplant (:,:) = casapool % Cplant (:,:) * casapool % ratioNCplant (:,:) END SUBROUTINE casa_ndummy SUBROUTINE casa_pdummy ( casapool ) IMPLICIT NONE TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool casapool % Pplant (:,:) = casapool % Nplant (:,:) / casapool % ratioNPplant (:,:) END SUBROUTINE casa_pdummy SUBROUTINE phenology ( iday , veg , phen ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: iday TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( phen_variable ), INTENT ( INOUT ) :: phen ! local variables (temprary) INTEGER :: np INTEGER , DIMENSION ( mp ) :: days , days1to2 , days2to3 , days3to4 , days4to1 DO np = 1 , mp days1to2 ( np ) = phen % doyphase ( np , 2 ) - phen % doyphase ( np , 1 ) days2to3 ( np ) = phen % doyphase ( np , 3 ) - phen % doyphase ( np , 2 ) days3to4 ( np ) = phen % doyphase ( np , 4 ) - phen % doyphase ( np , 3 ) days4to1 ( np ) = phen % doyphase ( np , 1 ) - phen % doyphase ( np , 4 ) IF ( days1to2 ( np ) < 0 ) days1to2 ( np ) = days1to2 ( np ) + 365 IF ( days2to3 ( np ) < 0 ) days2to3 ( np ) = days2to3 ( np ) + 365 IF ( days3to4 ( np ) < 0 ) days3to4 ( np ) = days3to4 ( np ) + 365 IF ( days4to1 ( np ) < 0 ) days4to1 ( np ) = days4to1 ( np ) + 365 ENDDO ! compute leaf phenology DO np = 1 , mp SELECT CASE ( phen % phase ( np )) CASE ( 0 ) days ( np ) = iday - phen % doyphase ( np , 4 ) IF ( days ( np ) < 0 ) days ( np ) = days ( np ) + 365 IF ( days ( np ) > days4to1 ( np )) phen % phase ( np ) = 1 CASE ( 1 ) days ( np ) = iday - phen % doyphase ( np , 1 ) IF ( days ( np ) < 0 ) days ( np ) = days ( np ) + 365 IF ( days ( np ) > days1to2 ( np )) phen % phase ( np ) = 2 CASE ( 2 ) days ( np ) = iday - phen % doyphase ( np , 2 ) IF ( days ( np ) < 0 ) days ( np ) = days ( np ) + 365 IF ( days ( np ) > days2to3 ( np )) phen % phase ( np ) = 3 CASE ( 3 ) days ( np ) = iday - phen % doyphase ( np , 3 ) IF ( days ( np ) < 0 ) days ( np ) = days ( np ) + 365 IF ( days ( np ) > days3to4 ( np )) phen % phase ( np ) = 0 END SELECT ENDDO WHERE ( veg % iveg == 1 . or . veg % iveg == 2 ) phen % phase = 2 ENDWHERE END SUBROUTINE phenology FUNCTION vcmax_np ( nleaf , pleaf ) use cable_def_types_mod , only : r_2 implicit none real ( r_2 ), intent ( in ) :: nleaf ! leaf N in g N m-2 leaf real ( r_2 ), intent ( in ) :: pleaf ! leaf P in g P m-2 leaf real ( r_2 ) :: vcmax_np ! Walker, A. P. et al.: The relationship of leaf photosynthetic traits - Vcmax and Jmax - !   to leaf nitrogen, leaf phosphorus, and specific leaf area: a meta-analysis and modeling study, !   Ecology and Evolution, 4, 3218-3235, 2014. vcmax_np = exp ( 3.946_r_2 + 0.921_r_2 * log ( nleaf ) + 0.121_r_2 * log ( pleaf ) + & 0.282_r_2 * log ( pleaf ) * log ( nleaf )) * 1.0e-6_r_2 ! units of mol m-2 (leaf) END FUNCTION vcmax_np END MODULE casa_cnp_module","tags":"","loc":"sourcefile/casa_cnp.f90.html"},{"title":"cable_adjustJVgm.F90 – POP","text":"Files dependent on this one sourcefile~~cable_adjustjvgm.f90~~AfferentGraph sourcefile~cable_adjustjvgm.f90 cable_adjustJVgm.F90 sourcefile~casa_cable.f90 casa_cable.F90 sourcefile~casa_cable.f90->sourcefile~cable_adjustjvgm.f90 sourcefile~casaonly_luc.f90 CASAONLY_LUC.F90 sourcefile~casaonly_luc.f90->sourcefile~casa_cable.f90 sourcefile~spincasacnp.f90 spincasacnp.F90 sourcefile~spincasacnp.f90->sourcefile~casa_cable.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules cable_adjust_JV_gm_module Source Code cable_adjustJVgm.F90 Source Code ! ! ============================================================================== ! Purpose: adjustment of Ci-based Jmax and Vcmax to their Cc-based values !          (accounting for a finite mesophyll conductance) using a nonlinear !          curve fitting routine as described in Knauer et al. 2019 GCB. ! ! Called from: SUBROUTINE bgcdriver in casa_cable.F90 ! ! History: Juergen Knauer July/August 2019 ! ============================================================================== ! MODULE cable_adjust_JV_gm_module use cable_def_types_mod , only : dp => r_2 use cable_def_types_mod , only : mp , veg_parameter_type use cable_data_module , only : icanopy_type , point2constants use cable_abort_module , only : nc_abort use cable_canopy_module , only : light_inhibition use netcdf use minpack type ( icanopy_type ) :: C integer , parameter :: nrci = 3000 integer , parameter :: nrcic4 = 1200 real ( dp ) :: gmmax25 , Vcmax25Ci , Jmax25Ci , Vcmax25Cc , Jmax25Cc , k25Ci , k25Cc real ( dp ) :: Rd real ( dp ) :: Kc_ci , Ko_ci , gammastar_ci , Km_ci real ( dp ) :: Kc_cc , Ko_cc , gammastar_cc , Km_cc ! gm LUT real ( dp ), dimension (:,:,:,:), allocatable :: LUT_VcmaxJmax ! Lookup table with Cc-based Vcmax and Jmax real ( dp ), dimension (:), allocatable :: LUT_gm ! gm values in gm LUT real ( dp ), dimension (:), allocatable :: LUT_Vcmax ! Vcmax_ci values in gm LUT real ( dp ), dimension (:), allocatable :: LUT_Rd ! Rd values in gm LUT CONTAINS SUBROUTINE adjust_JV_gm ( veg , p ) IMPLICIT NONE type ( veg_parameter_type ), intent ( inout ) :: veg ! vegetation parameters integer , intent ( in ) :: p ! vegetation type ! local variables logical :: Cc_based_OK , sw ! sw = stability switch integer :: i , k , z integer :: kmax = 20 ! maximum nr of iterations (inner loop) integer :: zmax = 8 ! maximum nr of iterations (outer loop) integer :: lAn real ( dp ) :: vstart , v real ( dp ) :: Vcmax25Cct1 ! Vcmax25Cc of previous iteration real ( dp ) :: Vcmax_diff real ( dp ) :: maxdiff = 0.002e-6_dp real ( dp ), dimension ( nrci ) :: An1 , Ci1 real ( dp ), dimension (:), allocatable :: An , Ci , Cc , An_Cc ! MINPACK params integer , parameter :: N = 2 ! Number of variables real ( dp ), dimension ( N ) :: X real ( dp ), allocatable :: fvec (:) integer :: info real ( dp ) :: tol = 0.00001_dp ! assign local ptrs to constants defined in cable_data_module call point2constants ( C ) Ci1 = ( / ( real ( i , dp ), i = 1 , nrci , 1 ) / ) / 2.0_dp * 1.0e-6_dp ! 1-1500 umol mol-1 Rd = real ( veg % cfrd ( p ) * veg % vcmax ( p ) * light_inhibition ( 120 0.0 ), dp ) gmmax25 = real ( veg % gm ( p ), dp ) Vcmax25Ci = real ( veg % vcmax ( p ), dp ) Jmax25Ci = real ( veg % ejmax ( p ), dp ) Kc_ci = real ( C % conkc0 , dp ) Ko_ci = real ( C % conko0 , dp ) gammastar_ci = real ( C % gam0 , dp ) Kc_cc = real ( C % conkc0cc , dp ) Ko_cc = real ( C % conko0cc , dp ) gammastar_cc = real ( C % gam0cc , dp ) Km_ci = Kc_ci * ( 1.0_dp + 0.21_dp / Ko_ci ) Km_cc = Kc_cc * ( 1.0_dp + 0.21_dp / Ko_cc ) if ( veg % frac4 ( p ) . lt . 0.001 ) then ! not C4 !! 1) Calculate An-Ci curve call photosyn25 ( Ci1 , nrci , Vcmax25Ci , Jmax25Ci , Rd , Km_ci , gammastar_ci , An1 ) !! 2) Exclude negative parts of the An-Ci curve lAn = count ( An1 > 0.0_dp ) allocate ( An ( lAn )) allocate ( An_Cc ( lAn )) allocate ( Ci ( lAn )) allocate ( Cc ( lAn )) allocate ( fvec ( lAn )) An = pack ( An1 , An1 > 0.0_dp ) Ci = pack ( Ci1 , An1 > 0.0_dp ) Cc_based_OK = . false . z = 0 ! 3) calculate Cc based on gm and An do while (. not . Cc_based_OK . and . z < zmax ) ! if it iterates more than once, check gm and Vcmax, Jmax z = z + 1 k = 0 X (:) = [ Vcmax25Ci , Jmax25Ci ] sw = . false . vstart = 1.0_dp Vcmax25Cct1 = Vcmax25Ci Vcmax_diff = 1.0e-6_dp An_Cc = An do while ( Vcmax_diff > maxdiff . AND . k < kmax ) k = k + 1 Cc = Ci - An_Cc / gmmax25 call lmdif1 ( photosyn25_f , lAn , N , X , fvec , tol , info , An_Cc , Cc , Rd , Km_cc , gammastar_cc ) Vcmax25Cc = X ( 1 ) Jmax25Cc = X ( 2 ) Vcmax_diff = abs ( Vcmax25Cc - Vcmax25Cct1 ) Vcmax25Cct1 = Vcmax25Cc call photosyn25 ( Cc , lAn , Vcmax25Cc , Jmax25Cc , Rd , Km_cc , gammastar_cc , An_Cc ) ! safety switch ensuring stability if ( minval ( An_Cc ) < 0.0_dp . and . (. not . sw )) then sw = . true . v = vstart endif if ( sw ) then v = max ( v - ( vstart / ( 0.8_dp * kmax )), 0.0_dp ) An_Cc = v * An + ( 1.0_dp - v ) * An_Cc endif end do !! Avoid unrealistic Vcmax and Jmax values if (( Vcmax25Cc < 0.9_dp * Vcmax25Ci ) . or . ( Vcmax25Cc > 2.5_dp * Vcmax25Ci ) & . or . ( Jmax25Cc < 0.9_dp * Jmax25Ci ) . or . ( jmax25cc > 1.5_dp * jmax25ci )) then gmmax25 = 1.2_dp * gmmax25 ! If no solution, try again with higher gmmax25 else Cc_based_OK = . true . veg % vcmaxcc ( p ) = real ( Vcmax25Cc ) veg % ejmaxcc ( p ) = real ( Jmax25Cc ) endif end do deallocate ( An ) deallocate ( An_Cc ) deallocate ( Ci ) deallocate ( Cc ) deallocate ( fvec ) ELSE ! C4 (Vcmax and Jmax do not change with gm in C4 plants) veg % vcmaxcc ( p ) = real ( Vcmax25Ci ) veg % ejmaxcc ( p ) = real ( Jmax25Ci ) endif ! c4 flag END SUBROUTINE adjust_JV_gm ! Function to use within LMDIF1 subroutine photosyn25_f ( M , N , X , fvec , iflag , Anx , Cix , Rd , Km , gammastar ) integer , intent ( in ) :: M , N , iflag real ( dp ), dimension ( N ), intent ( inout ) :: X real ( dp ), dimension ( M ), intent ( out ) :: fvec real ( dp ), dimension ( M ), intent ( in ) :: Anx , Cix real ( dp ), intent ( in ) :: Rd , Km , gammastar ! local real ( dp ), dimension ( M ) :: Ac , Aj Ac = ( X ( 1 ) * ( Cix - gammastar ) / ( Cix + Km )) Aj = ( X ( 2 ) * ( Cix - gammastar ) / 4.0 / ( Cix + 2.0 * gammastar )) ! avoid discontinuity (e.g. Duursma 2015, PLOS ONE) fvec = Anx - ( ( Ac + Aj - SQRT (( Ac + Aj ) ** 2 - 4.0 * 0.99999999_dp * Ac * Aj )) / & ( 2.0 * 0.99999999_dp ) - Rd ) END SUBROUTINE photosyn25_f ! Function to calculate An-Ci curve under standard conditions subroutine photosyn25 ( Ciz , nrci , Vcmax25 , Jmax25 , Rd , Km , gammastar , Anz ) integer , intent ( in ) :: nrci real ( dp ), dimension ( nrci ), intent ( in ) :: Ciz real ( dp ), intent ( in ) :: Vcmax25 , Jmax25 , Rd , Km , gammastar real ( dp ), dimension ( nrci ), intent ( out ) :: Anz ! local real ( dp ), dimension ( nrci ) :: Wc , We ! Rubisco-limited Wc = Vcmax25 * ( Ciz - gammastar ) / ( Ciz + Km ) ! RuBP regeneration-limited We = Jmax25 * ( Ciz - gammastar ) / 4.0 / ( Ciz + 2.0 * gammastar ) ! Net photosynthesis Anz = Min ( Wc , We ) - Rd END SUBROUTINE photosyn25 SUBROUTINE read_gm_LUT ( gm_LUT_file , LUT_VcmaxJmax , LUT_gm , LUT_vcmax , LUT_Rd ) ! Read lookup table needed for parameter conversion of photosynthetic parameters ! from Ci- to Cc-based values (the latter considering gm explicitly) use netcdf , only : nf90_open , nf90_nowrite , nf90_noerr , & nf90_inq_dimid , nf90_inquire_dimension , & nf90_inq_varid , nf90_get_var , & nf90_close implicit none character ( len =* ), intent ( in ) :: gm_LUT_file real ( dp ), dimension (:,:,:,:), allocatable , intent ( out ) :: LUT_VcmaxJmax real ( dp ), dimension (:), allocatable , intent ( out ) :: LUT_gm real ( dp ), dimension (:), allocatable , intent ( out ) :: LUT_vcmax real ( dp ), dimension (:), allocatable , intent ( out ) :: LUT_Rd ! local integer :: ncid_gmlut ! netcdf ID integer :: ok ! netcdf error status integer :: gm_dimid , vcmax_dimid , Rd_dimid ! dimension IDs integer :: gm_len , vcmax_len , Rd_len ! dimensions of LUT integer :: vcmax_id , jmax_id real ( dp ), dimension (:,:,:), allocatable :: tmp ! for reading ok = nf90_open ( trim ( gm_LUT_file ), nf90_nowrite , ncid_gmlut ) if ( ok /= NF90_NOERR ) call nc_abort ( ok , 'Error opening gm lookup table.' ) ok = nf90_inq_dimid ( ncid_gmlut , 'gm' , gm_dimid ) if ( ok /= NF90_NOERR ) call nc_abort ( ok , 'Error inquiring dimension gm from LUT.' ) ok = nf90_inq_dimid ( ncid_gmlut , 'Vcmax_Ci' , vcmax_dimid ) if ( ok /= NF90_NOERR ) call nc_abort ( ok , 'Error inquiring dimension Vcmax_Ci from LUT.' ) ok = nf90_inq_dimid ( ncid_gmlut , 'Rd' , Rd_dimid ) if ( ok /= NF90_NOERR ) call nc_abort ( ok , 'Error inquiring dimension Rd from LUT.' ) ok = nf90_inquire_dimension ( ncid_gmlut , gm_dimid , len = gm_len ) if ( ok /= NF90_NOERR ) call nc_abort ( ok , 'Error inquiring length of dimension gm from LUT.' ) ok = nf90_inquire_dimension ( ncid_gmlut , vcmax_dimid , len = vcmax_len ) if ( ok /= NF90_NOERR ) call nc_abort ( ok , 'Error inquiring length of dimension Vcmax_Ci from LUT.' ) ok = nf90_inquire_dimension ( ncid_gmlut , Rd_dimid , len = Rd_len ) if ( ok /= NF90_NOERR ) call nc_abort ( ok , 'Error inquiring length of dimension Rd from LUT.' ) write ( * , * ) 'gm LUT dimensions:' write ( * , * ) 'gm_len:' , gm_len write ( * , * ) 'vcmax_len:' , vcmax_len write ( * , * ) 'Rd_len:' , Rd_len ! allocate variables in veg structure allocate ( tmp ( Rd_len , vcmax_len , gm_len )) allocate ( LUT_VcmaxJmax ( 2 , Rd_len , vcmax_len , gm_len )) allocate ( LUT_gm ( gm_len )) allocate ( LUT_vcmax ( vcmax_len )) allocate ( LUT_Rd ( Rd_len )) ok = nf90_inq_varid ( ncid_gmlut , 'Vcmax' , vcmax_id ) if ( ok /= NF90_NOERR ) call nc_abort ( ok , 'Error inquiring variable Vcmax from LUT.' ) ok = nf90_inq_varid ( ncid_gmlut , 'Jmax' , jmax_id ) if ( ok /= NF90_NOERR ) call nc_abort ( ok , 'Error inquiring variable Jmax from LUT.' ) ok = nf90_get_var ( ncid_gmlut , vcmax_id , tmp ) if ( ok /= NF90_NOERR ) call nc_abort ( ok , 'Error getting variable Vcmax from LUT.' ) LUT_VcmaxJmax ( 1 , :, :, :) = tmp ok = nf90_get_var ( ncid_gmlut , jmax_id , tmp ) if ( ok /= NF90_NOERR ) call nc_abort ( ok , 'Error getting variable Jmax from LUT.' ) LUT_VcmaxJmax ( 2 , :, :, :) = tmp ok = nf90_get_var ( ncid_gmlut , gm_dimid , LUT_gm ) if ( ok /= NF90_NOERR ) call nc_abort ( ok , 'Error getting dimension gm from LUT.' ) ok = nf90_get_var ( ncid_gmlut , vcmax_dimid , LUT_vcmax ) if ( ok /= NF90_NOERR ) call nc_abort ( ok , 'Error getting dimension Vcmax_Ci from LUT.' ) ok = nf90_get_var ( ncid_gmlut , Rd_dimid , LUT_Rd ) if ( ok /= NF90_NOERR ) call nc_abort ( ok , 'Error getting dimension Rd from LUT.' ) ! convert values to those used in CABLE LUT_VcmaxJmax = LUT_VcmaxJmax * 1.0e-06 LUT_vcmax = LUT_vcmax * 1.0e-06 LUT_Rd = LUT_Rd * 1.0e-06 ok = nf90_close ( ncid_gmlut ) if ( ok /= NF90_NOERR ) call nc_abort ( ok , 'Error closing gm lookup table.' ) deallocate ( tmp ) END SUBROUTINE read_gm_LUT SUBROUTINE find_Vcmax_Jmax_LUT ( veg , p , LUT_VcmaxJmax , LUT_gm , LUT_vcmax , LUT_Rd ) ! JK: note that LUT is single precision at the moment implicit none type ( veg_parameter_type ), intent ( inout ) :: veg ! vegetation parameters integer , intent ( in ) :: p ! veg type (tile) real ( dp ), dimension (:,:,:,:), intent ( in ) :: LUT_VcmaxJmax ! Lookup table with Cc-based Vcmax and Jmax real ( dp ), dimension (:), intent ( in ) :: LUT_gm ! gm values in gm LUT real ( dp ), dimension (:), intent ( in ) :: LUT_vcmax ! Vcmax_ci values in gm LUT real ( dp ), dimension (:), intent ( in ) :: LUT_Rd ! Rd values in gm LUT ! local logical :: val_ok ! check for NAs integer :: maxit , i ! maximum nr of iterations in while loop, loop counter integer :: igm , ivc , ird ! indices for LUT if ( veg % frac4 ( p ) < 0.001 ) then ! not C4 ! determine current Ci-based values Rd = veg % cfrd ( p ) * veg % vcmax ( p ) * light_inhibition ( 120 0.0 ) gmmax25 = veg % gm ( p ) Vcmax25Ci = veg % vcmax ( p ) ! LUT assumes a given Jmax/Vcmax ratio! see details in nc LUT ! determine right indices of LUT igm = minloc ( abs ( gmmax25 - LUT_gm ), 1 ) ivc = minloc ( abs ( Vcmax25Ci - LUT_vcmax ), 1 ) ird = minloc ( abs ( Rd - LUT_Rd ), 1 ) i = 0 maxit = 50 val_ok = . false . do while (. not . val_ok . and . i . le . maxit ) i = i + 1 veg % vcmaxcc ( p ) = LUT_VcmaxJmax ( 1 , ird , ivc , igm ) veg % ejmaxcc ( p ) = LUT_VcmaxJmax ( 2 , ird , ivc , igm ) ! check for implausible parameter combinations that result in NAs if (( veg % vcmaxcc ( p ) > 0.0 ) . and . ( veg % ejmaxcc ( p ) > 0.0 )) then val_ok = . true . else write ( 64 , * ) \"gm-Vcmax relationship does not work! Vcmax_ci:\" , Vcmax25Ci write ( 64 , * ) \"iteration:\" , i igm = igm + 1 endif end do else ! C4 (Vcmax and Jmax do not change with gm in C4 plants) veg % vcmaxcc ( p ) = veg % vcmax ( p ) veg % ejmaxcc ( p ) = veg % ejmax ( p ) endif END SUBROUTINE find_Vcmax_Jmax_LUT ! conversion of k Parameter in Collatz et al. 1992 from implicit gm model ! to explicit gm model. Subroutine adjust_k_Collatz ( veg , p ) implicit none type ( veg_parameter_type ), intent ( inout ) :: veg ! vegetation parameters integer , intent ( in ) :: p ! vegetation type ! local integer :: i , k integer :: kmax = 1000 integer :: lAn real ( dp ) :: diff , diffx real ( dp ), dimension ( nrcic4 ) :: An_Ci1 , Ci1 , Aj_Ci , Ae_Ci real ( dp ), dimension (:), allocatable :: An_Ci , An_Cc , Ci , Cc real ( dp ) :: kinc = 0.001_dp ! increment of k if ( veg % frac4 ( p ) > 0.001 ) then ! C4 Ci1 = ( / ( real ( i , dp ), i = 1 , nrcic4 , 1 ) / ) / 4.0_dp * 1.0e-6_dp Rd = real ( veg % cfrd ( p ) * veg % vcmax ( p ) * light_inhibition ( 120 0.0 ), dp ) gmmax25 = real ( veg % gm ( p ), dp ) Vcmax25Ci = real ( veg % vcmax ( p ), dp ) k25Ci = real ( veg % c4kci ( p ), dp ) ! 1) calculate An-ci curves (no light limitation) Aj_Ci = Vcmax25Ci - Rd Ae_Ci = k25Ci * Ci1 - Rd An_Ci1 = min ( Aj_Ci , Ae_Ci ) ! 2) exclude negative An values and those not limited by Ci lAn = count (( An_Ci1 > 0.0_dp ) . and . ( An_Ci1 == Ae_Ci )) allocate ( An_Ci ( lAn )) allocate ( An_Cc ( lAn )) allocate ( Ci ( lAn )) allocate ( Cc ( lAn )) An_Ci = pack ( An_Ci1 , ( An_Ci1 > 0.0_dp ) . and . ( An_Ci1 == Ae_Ci )) Ci = pack ( Ci1 , ( An_Ci1 > 0.0_dp ) . and . ( An_Ci1 == Ae_Ci )) ! 3) calculate Cc Cc = Ci - An_Ci / gmmax25 ! 4) fit k to Cc-based model (a poor man's optimisation...) k = 0 diffx = 1.0e6_dp diff = 0.0_dp k25Cc = k25Ci do while (( diff < diffx ) . and . ( k < kmax )) if ( k > 0 ) then diffx = diff endif An_Cc = k25Cc * Cc - Rd diff = sqrt ( sum (( An_Cc - An_Ci ) ** 2 ) / lAn ) k25Cc = k25Cc + kinc k = k + 1 end do veg % c4kcc ( p ) = real ( k25Cc - 2.0_dp * kinc ) ! single precision ! subtract 2x the increment to get the right value else ! C3 (not used) veg % c4kcc ( p ) = 0.0 endif end subroutine adjust_k_Collatz END MODULE cable_adjust_JV_gm_module","tags":"","loc":"sourcefile/cable_adjustjvgm.f90.html"},{"title":"casa_cable.F90 – POP","text":"This file depends on sourcefile~~casa_cable.f90~~EfferentGraph sourcefile~casa_cable.f90 casa_cable.F90 sourcefile~cable_adjustjvgm.f90 cable_adjustJVgm.F90 sourcefile~casa_cable.f90->sourcefile~cable_adjustjvgm.f90 sourcefile~cable_optimisejvratio.f90 cable_optimiseJVratio.F90 sourcefile~casa_cable.f90->sourcefile~cable_optimisejvratio.f90 sourcefile~cable_phenology.f90 cable_phenology.F90 sourcefile~casa_cable.f90->sourcefile~cable_phenology.f90 sourcefile~casa_cnp.f90 casa_cnp.F90 sourcefile~casa_cable.f90->sourcefile~casa_cnp.f90 sourcefile~casa_inout.f90 casa_inout.F90 sourcefile~casa_cable.f90->sourcefile~casa_inout.f90 sourcefile~casa_variable.f90 casa_variable.F90 sourcefile~casa_cable.f90->sourcefile~casa_variable.f90 sourcefile~pop.f90 POP.F90 sourcefile~casa_cable.f90->sourcefile~pop.f90 sourcefile~cable_optimisejvratio.f90->sourcefile~pop.f90 sourcefile~cable_phenology.f90->sourcefile~casa_variable.f90 sourcefile~cable_phenology.f90->sourcefile~pop.f90 sourcefile~casa_cnp.f90->sourcefile~casa_variable.f90 sourcefile~casa_inout.f90->sourcefile~casa_cnp.f90 sourcefile~casa_inout.f90->sourcefile~casa_variable.f90 sourcefile~casa_inout.f90->sourcefile~pop.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~casa_cable.f90~~AfferentGraph sourcefile~casa_cable.f90 casa_cable.F90 sourcefile~casaonly_luc.f90 CASAONLY_LUC.F90 sourcefile~casaonly_luc.f90->sourcefile~casa_cable.f90 sourcefile~spincasacnp.f90 spincasacnp.F90 sourcefile~spincasacnp.f90->sourcefile~casa_cable.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules casa_cable Source Code casa_cable.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: bgcdriver - interface between casacnp and cable !          sumcflux  - accumulating carbon fluxes (not required for UM) ! ! Called from: cable_driver for offline version !              Not currently called/available for ACCESS version ! ! Contact: Yingping.Wang@csiro.au ! ! History: Model development by Yingping Wang, coupling to Mk3L by Bernard Pak !          ssoil changed to ssnow ! ! ============================================================================== module casa_cable implicit none contains !#define UM_BUILD YES SUBROUTINE bgcdriver ( ktau , kstart , dels , met , ssnow , canopy , veg , soil , & climate , casabiome , casapool , casaflux , casamet , casabal , phen , & pop , ktauday , idoy , loy , dump_read , & LALLOC , c13o2flux , c13o2pools ) USE cable_def_types_mod USE casadimension USE casaparm USE casavariable USE phenvariable USE cable_common_module , ONLY : CABLE_USER USE TypeDef , ONLY : dp USE POP_TYPES , ONLY : POP_TYPE USE cable_phenology_module , ONLY : cable_phenology_clim use casa_inout , only : biogeochem ! 13C use cable_c13o2_def , only : c13o2_pool , c13o2_flux use cable_c13o2 , only : c13o2_save_casapool , c13o2_update_pools IMPLICIT NONE INTEGER , INTENT ( IN ) :: ktau ! integration step number INTEGER , INTENT ( IN ) :: kstart ! starting value of ktau INTEGER , INTENT ( IN ) :: idoy , LOY ! day of year (1-365) , Length oy INTEGER , INTENT ( IN ) :: ktauday logical , INTENT ( IN ) :: dump_read INTEGER , INTENT ( IN ) :: LALLOC REAL , INTENT ( IN ) :: dels ! time setp size (s) TYPE ( met_type ), INTENT ( INOUT ) :: met ! met input variables TYPE ( soil_snow_type ), INTENT ( INOUT ) :: ssnow ! soil and snow variables TYPE ( canopy_type ), INTENT ( INOUT ) :: canopy ! vegetation variables TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil ! soil parameters TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal TYPE ( phen_variable ), INTENT ( INOUT ) :: phen TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP TYPE ( climate_type ), INTENT ( IN ) :: climate ! climate variables ! 13C type ( c13o2_flux ), intent ( inout ) :: c13o2flux type ( c13o2_pool ), intent ( inout ) :: c13o2pools ! local variables added ypwang 5/nov/2012 real ( r_2 ), dimension ( mp ) :: cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd real ( r_2 ), dimension ( mp ) :: nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd real ( r_2 ), dimension ( mp ) :: pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd real ( r_2 ), dimension ( mp ) :: xnplimit , xkNlimiting , xklitter , xksoil , xkleaf , xkleafcold , xkleafdry ! 13C real ( dp ), dimension (:,:), allocatable :: casasave ! 13C if ( cable_user % c13o2 ) allocate ( casasave ( c13o2pools % ntile , c13o2pools % npools )) IF (. NOT . dump_read ) THEN ! construct casa met and flux inputs from current CABLE run IF ( ( TRIM ( cable_user % MetType ) == 'cru' ) . OR . & ( TRIM ( cable_user % MetType ) == 'plume' ) . OR . & ( TRIM ( cable_user % MetType ) == 'site' ) ) THEN casaflux % Pdep = real ( met % Pdep , r_2 ) casaflux % Nmindep = real ( met % Ndep , r_2 ) ENDIF IF ( ktau == kstart ) THEN casamet % tairk = 0.0_r_2 casamet % tsoil = 0.0_r_2 casamet % moist = 0.0_r_2 ENDIF IF ( MOD ( ktau , ktauday ) == 1 ) THEN casamet % tairk = real ( met % tk , r_2 ) casamet % tsoil = real ( ssnow % tgg , r_2 ) ! casamet%moist = max(ssnow%wb - ssnow%wbice, 0.0) casamet % moist = max ( ssnow % wb , 0.0_r_2 ) casaflux % cgpp = real (( - canopy % fpn + canopy % frday ) * dels , r_2 ) casaflux % crmplant (:, leaf ) = real ( canopy % frday * dels , r_2 ) ! 13C if ( cable_user % c13o2 ) then c13o2flux % cAn12 = sum ( canopy % An , 2 ) * real ( dels , r_2 ) c13o2flux % cAn = sum ( c13o2flux % An , 2 ) * real ( dels , r_2 ) endif ELSE casamet % tairk = casamet % tairk + real ( met % tk , r_2 ) casamet % tsoil = casamet % tsoil + real ( ssnow % tgg , r_2 ) !casamet%moist = casamet%moist + max(ssnow%wb -  ssnow%wbice, 0.0_r_2) casamet % moist = casamet % moist + max ( ssnow % wb , 0.0_r_2 ) casaflux % cgpp = casaflux % cgpp + real (( - canopy % fpn + canopy % frday ) * dels , r_2 ) casaflux % crmplant (:, leaf ) = casaflux % crmplant (:, leaf ) + real ( canopy % frday * dels , r_2 ) ! 13C if ( cable_user % c13o2 ) then c13o2flux % cAn12 = c13o2flux % cAn12 + sum ( canopy % An , 2 ) * real ( dels , r_2 ) c13o2flux % cAn = c13o2flux % cAn + sum ( c13o2flux % An , 2 ) * real ( dels , r_2 ) endif ENDIF IF ( MOD (( ktau - kstart + 1 ), ktauday ) == 0 ) THEN ! end of day casamet % tairk = casamet % tairk / real ( ktauday , r_2 ) casamet % tsoil = casamet % tsoil / real ( ktauday , r_2 ) casamet % moist = casamet % moist / real ( ktauday , r_2 ) IF ( icycle > 0 ) THEN IF ( trim ( cable_user % PHENOLOGY_SWITCH ) == 'climate' ) THEN ! get climate_dependent phenology call cable_phenology_clim ( veg , climate , phen ) ENDIF ! 13C if ( cable_user % c13o2 ) call c13o2_save_casapool ( casapool , casasave ) CALL biogeochem ( idoy , LALLOC , veg , soil , casabiome , casapool , casaflux , & casamet , casabal , phen , POP , climate , xnplimit , xkNlimiting , xklitter , xksoil , & xkleaf , xkleafcold , xkleafdry , & cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd , & nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd , & pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd ) ! 13C #ifdef __C13DEBUG__ if ( cable_user % c13o2 ) call c13o2_update_pools ( casasave , casaflux , c13o2flux , c13o2pools , casapool ) #else if ( cable_user % c13o2 ) call c13o2_update_pools ( casasave , casaflux , c13o2flux , c13o2pools ) #endif IF ( cable_user % CALL_POP ) THEN ! accumulate annual variables for use in POP IF ( MOD ( ktau / ktauday , LOY ) == 1 ) THEN casaflux % stemnpp = casaflux % cnpp * casaflux % fracCalloc (:, 2 ) * 0.7_r_2 ! (assumes 70% of wood NPP is allocated above ground) casabal % LAImax = casamet % glai casabal % Cleafmean = casapool % cplant (:, 1 ) / real ( LOY , r_2 ) / 100 0.0_r_2 casabal % Crootmean = casapool % cplant (:, 3 ) / real ( LOY , r_2 ) / 100 0.0_r_2 ELSE casaflux % stemnpp = casaflux % stemnpp + casaflux % cnpp * casaflux % fracCalloc (:, 2 ) * 0.7_r_2 casabal % LAImax = max ( casamet % glai , casabal % LAImax ) casabal % Cleafmean = casabal % Cleafmean + casapool % cplant (:, 1 ) / real ( LOY , r_2 ) / 100 0.0_r_2 casabal % Crootmean = casabal % Crootmean + casapool % cplant (:, 3 ) / real ( LOY , r_2 ) / 100 0.0_r_2 ENDIF ELSE casaflux % stemnpp = 0.0_r_2 ENDIF ! CALL_POP ENDIF ! icycle > 0 ENDIF ! end of day ELSE ! dump_read: ! use casa met and flux inputs from dumpfile IF ( MOD (( ktau - kstart + 1 ), ktauday ) == 0 ) THEN ! end of day ! 13C if ( cable_user % c13o2 ) call c13o2_save_casapool ( casapool , casasave ) CALL biogeochem ( idoy , LALLOC , veg , soil , casabiome , casapool , casaflux , & casamet , casabal , phen , POP , climate , xnplimit , xkNlimiting , xklitter , xksoil , xkleaf , & xkleafcold , xkleafdry ,& cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd , & nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd , & pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd ) ! 13C #ifdef __C13DEBUG__ if ( cable_user % c13o2 ) call c13o2_update_pools ( casasave , casaflux , c13o2flux , c13o2pools , casapool ) #else if ( cable_user % c13o2 ) call c13o2_update_pools ( casasave , casaflux , c13o2flux , c13o2pools ) #endif IF ( cable_user % CALL_POP ) THEN ! accumulate annual variables for use in POP IF ( MOD ( ktau / ktauday , LOY ) == 1 ) THEN casaflux % stemnpp = casaflux % cnpp * casaflux % fracCalloc (:, 2 ) * 0.7_r_2 ! (assumes 70% of wood NPP is allocated above ground) casabal % LAImax = casamet % glai casabal % Cleafmean = casapool % cplant (:, 1 ) / real ( LOY , r_2 ) / 100 0.0_r_2 casabal % Crootmean = casapool % cplant (:, 3 ) / real ( LOY , r_2 ) / 100 0.0_r_2 ELSE casaflux % stemnpp = casaflux % stemnpp + casaflux % cnpp * casaflux % fracCalloc (:, 2 ) * 0.7_r_2 casabal % LAImax = max ( casamet % glai , casabal % LAImax ) casabal % Cleafmean = casabal % Cleafmean + casapool % cplant (:, 1 ) / real ( LOY , r_2 ) / 100 0.0_r_2 casabal % Crootmean = casabal % Crootmean + casapool % cplant (:, 3 ) / real ( LOY , r_2 ) / 100 0.0_r_2 ENDIF ELSE casaflux % stemnpp = 0.0_r_2 ENDIF ! CALL_POP ENDIF ! end of day ENDIF ! dump_read END SUBROUTINE bgcdriver ! ============================================================================== SUBROUTINE POPdriver ( casaflux , casabal , veg , POP ) use cable_def_types_mod use casadimension use casaparm use casavariable use phenvariable use cable_common_module , only : CABLE_USER use TypeDef , only : i4b , dp use POPModule , only : POPStep use POP_TYPES , only : POP_TYPE implicit none type ( casa_flux ), INTENT ( IN ) :: casaflux type ( casa_balance ), INTENT ( IN ) :: casabal type ( veg_parameter_type ), INTENT ( IN ) :: veg ! vegetation parameters type ( POP_TYPE ), INTENT ( INOUT ) :: POP real ( dp ) :: StemNPP ( mp , 2 ) real ( dp ), allocatable :: NPPtoGPP (:) real ( dp ), allocatable :: LAImax (:), Cleafmean (:), Crootmean (:) !! vh_js !! integer , allocatable :: Iw (:) ! array of indices corresponding to woody (shrub or forest) tiles if (. not . allocated ( LAIMax )) allocate ( LAIMax ( mp )) if (. not . allocated ( Cleafmean )) allocate ( Cleafmean ( mp )) if (. not . allocated ( Crootmean )) allocate ( Crootmean ( mp )) if (. not . allocated ( NPPtoGPP )) allocate ( NPPtoGPP ( mp )) if (. not . allocated ( Iw )) allocate ( Iw ( POP % np )) if ( cable_user % CALL_POP . and . POP % np . gt . 0 ) then ! CALL_POP Iw = POP % Iwood StemNPP (:, 1 ) = casaflux % stemnpp StemNPP (:, 2 ) = 0.0_dp where ( casabal % FCgppyear > 1.e-5_dp . and . casabal % FCnppyear > 1.e-5_dp ) NPPtoGPP = casabal % FCnppyear / casabal % FCgppyear elsewhere NPPtoGPP = 0.5_dp endwhere LAImax = casabal % LAImax Cleafmean = casabal % cleafmean Crootmean = casabal % Crootmean CALL POPStep ( pop , max ( StemNPP ( Iw ,:) / 100 0.0_dp , 0.0001_dp ), int ( veg % disturbance_interval ( Iw ,:), i4b ), & real ( veg % disturbance_intensity ( Iw ,:), dp ), & max ( LAImax ( Iw ), 0.001_dp ), Cleafmean ( Iw ), Crootmean ( Iw ), NPPtoGPP ( Iw )) endif ! CALL_POP END SUBROUTINE POPdriver ! ============================================================================== subroutine read_casa_dump ( ncfile , casamet , casaflux , phen , climate , c13o2flux , ncall , kend , allatonce ) use netcdf use cable_def_types_mod , only : r_2 , ms , mp , climate_type use casadimension , only : mplant , mdyear , icycle use casavariable , only : casa_met , casa_flux use phenvariable #ifndef UM_BUILD use cable_diag_module , only : get_var_nc , stderr_nc #endif use cable_common_module , only : cable_user ! 13C use cable_c13o2_def , only : c13o2_flux implicit none type ( casa_flux ), intent ( inout ) :: casaflux type ( casa_met ), intent ( inout ) :: casamet type ( phen_variable ), intent ( inout ) :: phen type ( climate_type ), intent ( inout ) :: climate ! climate variables ! 13C type ( c13o2_flux ), intent ( inout ) :: c13o2flux integer , intent ( in ) :: kend , ncall character ( len =* ), intent ( in ) :: ncfile logical , intent ( in ) :: allatonce !netcdf ids/ names integer , parameter :: num_vars = 29 integer , save :: ncrid ! netcdf file id !vars character ( len =* ), dimension ( num_vars ), parameter :: & var_name = ( / \"lat          \" , & \"lon          \" , & \"casamet_tairk\" , & \"tsoil        \" , & \"moist        \" , & \"cgpp         \" , & \"crmplant     \" , & \"phenphase    \" , & \"phendoyphase1\" , & \"phendoyphase2\" , & \"phendoyphase3\" , & \"phendoyphase4\" , & \"mtemp        \" , & \"frec         \" , & \"Ndep         \" , & \"Pdep         \" , & \"cAn12        \" , & \"cAn13        \" , & \"dprecip      \" , & \"aprecip_av20 \" , & \"du10_max     \" , & \"drhum        \" , & \"dtemp_max    \" , & \"dtemp_min    \" , & \"KBDI         \" , & \"D_MacArthur  \" , & \"FFDI         \" , & \"DSLR         \" , & \"last_precip  \" & / ) real ( r_2 ), dimension ( mp ) :: tairk , cgpp , mtemp , frec , Ndep , Pdep , cAn12 , cAn13 real ( r_2 ), dimension ( mp , ms ) :: tsoil , moist real ( r_2 ), dimension ( mp , mplant ) :: crmplant real ( r_2 ), dimension ( mp ) :: phenphase , phendoyphase1 , & phendoyphase2 , phendoyphase3 , phendoyphase4 real ( r_2 ), dimension ( mp ) :: dprecip , aprecip_av20 , du10_max , drhum , dtemp_max , & dtemp_min , KBDI , D_MacArthur , FFDI , DSLR , last_precip integer :: ncok , idoy #ifndef UM_BUILD if ( allatonce . or . ncall . eq . 1 ) then ncok = nf90_open ( trim ( ncfile ), nf90_nowrite , ncrid ) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 're-opening ' , ncfile ) endif if ( allatonce ) then do idoy = 1 , mdyear call get_var_nc ( ncrid , var_name ( 3 ), tairk , idoy ) call get_var_nc ( ncrid , var_name ( 4 ), tsoil , idoy , ms ) call get_var_nc ( ncrid , var_name ( 5 ), moist , idoy , ms ) call get_var_nc ( ncrid , var_name ( 6 ), cgpp , idoy ) call get_var_nc ( ncrid , var_name ( 7 ), crmplant , idoy , mplant ) call get_var_nc ( ncrid , var_name ( 8 ), phenphase , idoy ) call get_var_nc ( ncrid , var_name ( 9 ), phendoyphase1 , idoy ) call get_var_nc ( ncrid , var_name ( 10 ), phendoyphase2 , idoy ) call get_var_nc ( ncrid , var_name ( 11 ), phendoyphase3 , idoy ) call get_var_nc ( ncrid , var_name ( 12 ), phendoyphase4 , idoy ) call get_var_nc ( ncrid , var_name ( 13 ), mtemp , idoy ) call get_var_nc ( ncrid , var_name ( 14 ), frec , idoy ) if ( icycle > 1 ) call get_var_nc ( ncrid , var_name ( 15 ), Ndep , idoy ) if ( icycle > 2 ) call get_var_nc ( ncrid , var_name ( 16 ), Pdep , idoy ) ! 13C if ( cable_user % c13o2 ) then call get_var_nc ( ncrid , var_name ( 17 ), cAn12 , idoy ) call get_var_nc ( ncrid , var_name ( 18 ), cAn13 , idoy ) endif ! blaze if ( cable_user % call_blaze ) then call get_var_nc ( ncrid , var_name ( 19 ), dprecip , idoy ) call get_var_nc ( ncrid , var_name ( 20 ), aprecip_av20 , idoy ) call get_var_nc ( ncrid , var_name ( 21 ), du10_max , idoy ) call get_var_nc ( ncrid , var_name ( 22 ), drhum , idoy ) call get_var_nc ( ncrid , var_name ( 23 ), dtemp_max , idoy ) call get_var_nc ( ncrid , var_name ( 24 ), dtemp_min , idoy ) call get_var_nc ( ncrid , var_name ( 25 ), KBDI , idoy ) call get_var_nc ( ncrid , var_name ( 26 ), D_MacArthur , idoy ) call get_var_nc ( ncrid , var_name ( 27 ), FFDI , idoy ) call get_var_nc ( ncrid , var_name ( 28 ), DSLR , idoy ) call get_var_nc ( ncrid , var_name ( 29 ), last_precip , idoy ) endif casamet % Tairkspin (:, idoy ) = tairk casamet % cgppspin (:, idoy ) = cgpp casamet % crmplantspin_1 (:, idoy ) = crmplant (:, 1 ) casamet % crmplantspin_2 (:, idoy ) = crmplant (:, 2 ) casamet % crmplantspin_3 (:, idoy ) = crmplant (:, 3 ) casamet % Tsoilspin_1 (:, idoy ) = tsoil (:, 1 ) casamet % Tsoilspin_2 (:, idoy ) = tsoil (:, 2 ) casamet % Tsoilspin_3 (:, idoy ) = tsoil (:, 3 ) casamet % Tsoilspin_4 (:, idoy ) = tsoil (:, 4 ) casamet % Tsoilspin_5 (:, idoy ) = tsoil (:, 5 ) casamet % Tsoilspin_6 (:, idoy ) = tsoil (:, 6 ) casamet % moistspin_1 (:, idoy ) = moist (:, 1 ) casamet % moistspin_2 (:, idoy ) = moist (:, 2 ) casamet % moistspin_3 (:, idoy ) = moist (:, 3 ) casamet % moistspin_4 (:, idoy ) = moist (:, 4 ) casamet % moistspin_5 (:, idoy ) = moist (:, 5 ) casamet % moistspin_6 (:, idoy ) = moist (:, 6 ) phen % phasespin (:, idoy ) = int ( phenphase ) phen % doyphasespin_1 (:, idoy ) = int ( phendoyphase1 ) phen % doyphasespin_2 (:, idoy ) = int ( phendoyphase2 ) phen % doyphasespin_3 (:, idoy ) = int ( phendoyphase3 ) phen % doyphasespin_4 (:, idoy ) = int ( phendoyphase4 ) casamet % mtempspin (:, idoy ) = mtemp casamet % frecspin (:, idoy ) = frec if ( icycle > 1 ) casaflux % Nmindep = Ndep if ( icycle > 2 ) casaflux % Pdep = Pdep ! 13C if ( cable_user % c13o2 ) then casamet % cAn12spin (:, idoy ) = cAn12 casamet % cAn13spin (:, idoy ) = cAn13 endif !blaze if ( cable_user % call_blaze ) then casamet % dprecip_spin (:, idoy ) = dprecip casamet % aprecip_av20_spin (:, idoy ) = aprecip_av20 casamet % du10_max_spin (:, idoy ) = du10_max casamet % drhum_spin (:, idoy ) = drhum casamet % dtemp_max_spin (:, idoy ) = dtemp_max casamet % dtemp_min_spin (:, idoy ) = dtemp_min casamet % KBDI_spin (:, idoy ) = KBDI casamet % D_MacArthur_spin (:, idoy ) = D_MacArthur casamet % FFDI_spin (:, idoy ) = FFDI casamet % DSLR_spin (:, idoy ) = int ( DSLR ) casamet % last_precip_spin (:, idoy ) = last_precip endif end do else !vh ! code below is redundant since this subroutine is always called with allatonce = .T. call get_var_nc ( ncrid , var_name ( 3 ), tairk , ncall ) call get_var_nc ( ncrid , var_name ( 4 ), tsoil , ncall , ms ) call get_var_nc ( ncrid , var_name ( 5 ), moist , ncall , ms ) call get_var_nc ( ncrid , var_name ( 6 ), cgpp , ncall ) call get_var_nc ( ncrid , var_name ( 7 ), crmplant , ncall , mplant ) call get_var_nc ( ncrid , var_name ( 8 ), phenphase , ncall ) call get_var_nc ( ncrid , var_name ( 9 ), phendoyphase1 , ncall ) call get_var_nc ( ncrid , var_name ( 10 ), phendoyphase2 , ncall ) call get_var_nc ( ncrid , var_name ( 11 ), phendoyphase3 , ncall ) call get_var_nc ( ncrid , var_name ( 12 ), phendoyphase4 , ncall ) call get_var_nc ( ncrid , var_name ( 13 ), mtemp , ncall ) call get_var_nc ( ncrid , var_name ( 14 ), frec , ncall ) if ( icycle > 1 ) CALL get_var_nc ( ncrid , var_name ( 15 ), Ndep , ncall ) if ( icycle > 2 ) CALL get_var_nc ( ncrid , var_name ( 16 ), Pdep , ncall ) ! 13C if ( cable_user % c13o2 ) then call get_var_nc ( ncrid , var_name ( 17 ), cAn12 , ncall ) call get_var_nc ( ncrid , var_name ( 18 ), cAn13 , ncall ) endif ! blaze if ( cable_user % call_blaze ) then call get_var_nc ( ncrid , var_name ( 19 ), dprecip , ncall ) call get_var_nc ( ncrid , var_name ( 20 ), aprecip_av20 , ncall ) call get_var_nc ( ncrid , var_name ( 21 ), du10_max , ncall ) call get_var_nc ( ncrid , var_name ( 22 ), drhum , ncall ) call get_var_nc ( ncrid , var_name ( 23 ), dtemp_max , ncall ) call get_var_nc ( ncrid , var_name ( 24 ), dtemp_min , ncall ) call get_var_nc ( ncrid , var_name ( 25 ), KBDI , ncall ) call get_var_nc ( ncrid , var_name ( 26 ), D_MacArthur , ncall ) call get_var_nc ( ncrid , var_name ( 27 ), FFDI , ncall ) call get_var_nc ( ncrid , var_name ( 28 ), DSLR , ncall ) call get_var_nc ( ncrid , var_name ( 29 ), last_precip , ncall ) endif casamet % tairk = tairk casaflux % cgpp = cgpp casaflux % crmplant = crmplant casamet % tsoil = tsoil casamet % moist = moist phen % phase = int ( phenphase ) phen % doyphase (:, 1 ) = int ( phendoyphase1 ) phen % doyphase (:, 2 ) = int ( phendoyphase2 ) phen % doyphase (:, 3 ) = int ( phendoyphase3 ) phen % doyphase (:, 4 ) = int ( phendoyphase4 ) climate % qtemp_max_last_year = real ( mtemp ) climate % frec = real ( frec ) if ( icycle > 1 ) casaflux % Nmindep = Ndep if ( icycle > 2 ) casaflux % Pdep = Pdep ! 13C if ( cable_user % c13o2 ) then c13o2flux % cAn12 = cAn12 c13o2flux % cAn = cAn13 endif !blaze if ( cable_user % call_blaze ) then !MCJK - I think this is wrong. ! The code in allatonce writes to casamet. ! A comment states that this code is always called with allatonce. climate % dprecip = real ( dprecip ) climate % aprecip_av20 = real ( aprecip_av20 ) climate % du10_max = real ( du10_max ) climate % drhum = real ( drhum ) climate % dtemp_max = real ( dtemp_max ) climate % dtemp_min = real ( dtemp_min ) climate % KBDI = real ( KBDI ) climate % D_MacArthur = real ( D_MacArthur ) climate % FFDI = real ( FFDI ) climate % DSLR = int ( DSLR ) climate % last_precip = real ( last_precip ) endif endif ! allatonce if ( allatonce . or . ( ncall . eq . kend )) then ncok = nf90_close ( ncrid ) ncrid = - 1 if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'closing ' , ncfile ) endif #endif end subroutine read_casa_dump SUBROUTINE write_casa_dump ( ncfile , casamet , casaflux , phen , climate , c13o2flux , n_call , kend ) USE netcdf USE cable_def_types_mod , ONLY : r_2 , ms , mp , climate_type USE cable_common_module , ONLY : cable_user #ifndef UM_BUILD USE cable_diag_module , ONLY : def_dims , def_vars , & put_var_nc , stderr_nc #endif USE casavariable , ONLY : CASA_MET , CASA_FLUX USE casadimension , ONLY : mplant , icycle USE phenvariable ! 13C use cable_c13o2_def , only : c13o2_flux use netcdf IMPLICIT NONE INTEGER , INTENT ( in ) :: & n_call , & ! this timestep # kend ! final timestep of run TYPE ( casa_flux ), INTENT ( IN ) :: casaflux TYPE ( casa_met ), INTENT ( IN ) :: casamet TYPE ( phen_variable ), INTENT ( IN ) :: phen TYPE ( climate_type ), INTENT ( IN ) :: climate ! climate variables ! 13C type ( c13o2_flux ), intent ( in ) :: c13o2flux !number of instances. dummied here and so=1 !integer :: inst =1 !netcdf IDs/ names CHARACTER ( len =* ) :: ncfile INTEGER , PARAMETER :: num_vars = 29 INTEGER , PARAMETER :: num_dims = 3 INTEGER , SAVE :: ncid ! netcdf file ID !vars CHARACTER ( len =* ), DIMENSION ( num_vars ), PARAMETER :: & var_name = ( / & \"lat          \" , & \"lon          \" , & \"casamet_tairk\" , & \"tsoil        \" , & \"moist        \" , & \"cgpp         \" , & \"crmplant     \" , & \"phenphase    \" , & \"phendoyphase1\" , & \"phendoyphase2\" , & \"phendoyphase3\" , & \"phendoyphase4\" , & \"mtemp        \" , & \"frec         \" , & \"Ndep         \" , & \"Pdep         \" , & \"cAn12        \" , & \"cAn13        \" , & \"dprecip      \" , & \"aprecip_av20 \" , & \"du10_max     \" , & \"drhum        \" , & \"dtemp_max    \" , & \"dtemp_min    \" , & \"KBDI         \" , & \"D_MacArthur  \" , & \"FFDI         \" , & \"DSLR         \" , & \"last_precip  \" & / ) INTEGER , DIMENSION ( num_vars ) :: varID ! (1) tvair, (2) pmb !dims CHARACTER ( len =* ), DIMENSION ( num_dims ), PARAMETER :: & dim_name = ( / \"pnt \" , & \"soil\" , & \"time\" / ) INTEGER , PARAMETER :: soil_dim = 6 INTEGER , DIMENSION ( num_dims ) :: & dimID ! (1) x, (2) y, (3) time INTEGER , DIMENSION ( num_dims ) :: & !x,y generally lat/lon BUT for single site = 1,1 dim_len = ( /- 1 , soil_dim , - 1 / ) ! (1) mp, (2) soil, (3) time [re-set] !local only INTEGER :: ncok !ncdf return status real ( r_2 ), dimension ( mp ) :: zeros ! END header #ifndef UM_BUILD dim_len ( 1 ) = mp dim_len ( num_dims ) = NF90_unlimited zeros = 0.0_r_2 IF ( n_call == 1 ) THEN ! create netCDF dataset: enter define mode #ifdef __NETCDF3__ ncok = nf90_create ( TRIM ( ncfile ), ior ( nf90_clobber , nf90_64bit_offset ), ncid ) #else ncok = nf90_create ( TRIM ( ncfile ), ior ( nf90_clobber , ior ( nf90_netcdf4 , nf90_classic_model )), ncid ) #endif IF ( ncok /= nf90_noerr ) CALL stderr_nc ( ncok , 'ncdf creating ' , trim ( ncfile )) ! define dimensions: from name and length CALL def_dims ( num_dims , ncid , dimID , dim_len , dim_name ) ! define variables: from name, type, dims CALL def_vars ( ncid , nf90_float , dimID , var_name , varID ) ! define variable attributes !CLN LATER!             CALL def_var_atts( ncfile, ncid, varID ) ncok = nf90_enddef ( ncid ) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'end def mode' , ncfile ) CALL put_var_nc ( ncid , var_name ( 1 ), REAL ( casamet % lat )) CALL put_var_nc ( ncid , var_name ( 2 ), REAL ( casamet % lon )) ENDIF CALL put_var_nc ( ncid , var_name ( 3 ), casamet % tairk , n_call ) CALL put_var_nc ( ncid , var_name ( 4 ), casamet % tsoil , n_call , ms ) CALL put_var_nc ( ncid , var_name ( 5 ), casamet % moist , n_call , ms ) CALL put_var_nc ( ncid , var_name ( 6 ), casaflux % cgpp , n_call ) CALL put_var_nc ( ncid , var_name ( 7 ), casaflux % crmplant , n_call , mplant ) CALL put_var_nc ( ncid , var_name ( 8 ), real ( phen % phase , r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 9 ), real ( phen % doyphase (:, 1 ), r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 10 ), real ( phen % doyphase (:, 2 ), r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 11 ), real ( phen % doyphase (:, 3 ), r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 12 ), real ( phen % doyphase (:, 4 ), r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 13 ), real ( climate % qtemp_max_last_year , r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 14 ), real ( climate % frec , r_2 ), n_call ) if ( icycle > 1 ) then CALL put_var_nc ( ncid , var_name ( 15 ), casaflux % Nmindep , n_call ) else CALL put_var_nc ( ncid , var_name ( 15 ), zeros , n_call ) endif if ( icycle > 2 ) then CALL put_var_nc ( ncid , var_name ( 16 ), casaflux % Pdep , n_call ) else CALL put_var_nc ( ncid , var_name ( 16 ), zeros , n_call ) endif ! 13C if ( cable_user % c13o2 ) then CALL put_var_nc ( ncid , var_name ( 17 ), c13o2flux % cAn12 , n_call ) CALL put_var_nc ( ncid , var_name ( 18 ), c13o2flux % cAn , n_call ) else CALL put_var_nc ( ncid , var_name ( 17 ), zeros , n_call ) CALL put_var_nc ( ncid , var_name ( 18 ), zeros , n_call ) endif ! BLAZE if ( cable_user % call_blaze ) then CALL put_var_nc ( ncid , var_name ( 19 ), real ( climate % dprecip , r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 20 ), real ( climate % aprecip_av20 , r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 21 ), real ( climate % du10_max , r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 22 ), real ( climate % drhum , r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 23 ), real ( climate % dtemp_max , r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 24 ), real ( climate % dtemp_min , r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 25 ), real ( climate % KBDI , r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 26 ), real ( climate % D_MacArthur , r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 27 ), real ( climate % FFDI , r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 28 ), real ( climate % DSLR , r_2 ), n_call ) CALL put_var_nc ( ncid , var_name ( 29 ), real ( climate % last_precip , r_2 ), n_call ) else CALL put_var_nc ( ncid , var_name ( 19 ), zeros , n_call ) CALL put_var_nc ( ncid , var_name ( 20 ), zeros , n_call ) CALL put_var_nc ( ncid , var_name ( 21 ), zeros , n_call ) CALL put_var_nc ( ncid , var_name ( 22 ), zeros , n_call ) CALL put_var_nc ( ncid , var_name ( 23 ), zeros , n_call ) CALL put_var_nc ( ncid , var_name ( 24 ), zeros , n_call ) CALL put_var_nc ( ncid , var_name ( 25 ), zeros , n_call ) CALL put_var_nc ( ncid , var_name ( 26 ), zeros , n_call ) CALL put_var_nc ( ncid , var_name ( 27 ), zeros , n_call ) CALL put_var_nc ( ncid , var_name ( 28 ), zeros , n_call ) CALL put_var_nc ( ncid , var_name ( 29 ), zeros , n_call ) endif IF ( n_call == kend ) then ncok = nf90_close ( ncid ) ! close: save new netCDF dataset ncid = - 1 endif #endif END SUBROUTINE write_casa_dump SUBROUTINE casa_feedback ( ktau , veg , casabiome , casapool , casamet , climate , ktauday ) USE cable_def_types_mod USE casadimension USE casaparm USE casavariable USE casa_cnp_module , ONLY : vcmax_np USE cable_common_module , ONLY : CABLE_USER USE cable_data_module , ONLY : icanopy_type USE cable_optimise_JV_module USE cable_adjust_JV_gm_module #ifdef __MPI__ use mpi , only : MPI_Abort #endif IMPLICIT NONE INTEGER , INTENT ( IN ) :: ktau ! integration step number TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( IN ) :: casapool TYPE ( casa_met ), INTENT ( IN ) :: casamet TYPE ( climate_type ), INTENT ( IN ) :: climate ! climate variables INTEGER , INTENT ( IN ) :: ktauday ! number of time steps per day TYPE ( icanopy_type ) :: PHOTO ! local variables integer np , ivt real ( r_2 ), dimension ( mp ) :: ncleafx , npleafx , pleafx , nleafx ! local variables ! real, dimension(17) ::  xnslope ! !ASKJK - what are these hard-coded parameters? Why hard-coded? ! data xnslope/0.80,1.00,2.00,1.00,1.00,1.00,0.50,1.00,0.34,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00/ real :: relcostJCi real , dimension ( mp ) :: relcostJ , Nefftmp real , save , dimension ( 17 ) :: vcmaxx ! last updated vcmaxx real , dimension ( mp ) :: vcmax_ref ! vcmax25 at gmmax25 real , dimension ( mp ) :: bjvci ! Ci-based Jmax/Vcmax ratio real :: gm_vcmax_slope ! slope between gmmax25 and Vcmax25 ((mol m-2 s-1) / (umol m-2 s-1)) real , parameter :: effc4 = 2000 0.0 ! Vc=effc4*Ci*Vcmax (see Bonan et al. 2011, JGR 116) #ifdef __MPI__ integer :: ierr #endif ! first initialize CALL point2constants ( PHOTO ) ncleafx (:) = casabiome % ratioNCplantmax ( veg % iveg (:), leaf ) npleafx (:) = casabiome % ratioNPplantmin ( veg % iveg (:), leaf ) if ( cable_user % acclimate_photosyn ) then veg % bjv (:) = 2.56 - 0.0375 * climate % mtemp_max20 (:) - 0.0202 * ( climate % mtemp (:) - climate % mtemp_max20 (:)) else veg % bjv (:) = PHOTO % bjvref ! 1.8245 at Tgrowth=15degC and Thome=25degC Kumarathunge et al. 2019, acclimises endif DO np = 1 , mp ivt = veg % iveg ( np ) IF ( casamet % iveg2 ( np ) /= icewater & . AND . casamet % glai ( np ) > casabiome % glaimin ( ivt ) & . AND . casapool % cplant ( np , leaf ) > 0.0_r_2 ) THEN IF ( icycle > 1 . AND . casapool % cplant ( np , leaf ) > 0.0_r_2 ) THEN ncleafx ( np ) = MIN ( casabiome % ratioNCplantmax ( ivt , leaf ), & MAX ( casabiome % ratioNCplantmin ( ivt , leaf ), & casapool % nplant ( np , leaf ) / casapool % cplant ( np , leaf ))) ENDIF IF ( icycle > 2 . AND . casapool % pplant ( np , leaf ) > 0.0 ) THEN npleafx ( np ) = MIN ( casabiome % ratioNPplantmax ( ivt , leaf ), MAX ( casabiome % ratioNPplantmin ( ivt , leaf ), & casapool % nplant ( np , leaf ) / casapool % pplant ( np , leaf ) ) ) ENDIF ENDIF IF ( TRIM ( cable_user % vcmax ). eq . 'standard' ) then IF ( casamet % glai ( np ) > casabiome % glaimin ( ivt )) THEN IF ( ivt /= 2 ) THEN veg % vcmax ( np ) = real ( casabiome % nintercept ( ivt ) & + casabiome % nslope ( ivt ) * ncleafx ( np ) / casabiome % sla ( ivt )) * 1.0e-6 ELSE IF ( casapool % nplant ( np , leaf ) > 0.0_r_2 . AND . casapool % pplant ( np , leaf ) > 0.0_r_2 ) THEN veg % vcmax ( np ) = real ( casabiome % nintercept ( ivt ) & + casabiome % nslope ( ivt ) * ( 0.4_r_2 + 9.0_r_2 / npleafx ( np )) & * ncleafx ( np ) / casabiome % sla ( ivt )) * 1.0e-6 ELSE veg % vcmax ( np ) = real ( casabiome % nintercept ( ivt ) & + casabiome % nslope ( ivt ) * ncleafx ( np ) / casabiome % sla ( ivt )) * 1.0e-6 ENDIF ENDIF ENDIF veg % ejmax = veg % bjv * veg % vcmax veg % c4kci = effc4 * veg % vcmax elseif ( TRIM ( cable_user % vcmax ). eq . 'Walker2014' ) then ! Walker, A. P. et al.: The relationship of leaf photosynthetic traits - Vcmax and Jmax - !   to leaf nitrogen, leaf phosphorus, and specific leaf area: a meta-analysis and modeling study, !   Ecology and Evolution, 4, 3218-3235, 2014. ! veg%vcmax(np) = exp(3.946 + 0.921*log(nleafx(np)) + 0.121*log(pleafx(np)) + & !      0.282*log(pleafx(np))*log(nleafx(np))) * 1.0e-6 nleafx ( np ) = ncleafx ( np ) / casabiome % sla ( ivt ) ! leaf N in g N m-2 leaf pleafx ( np ) = nleafx ( np ) / npleafx ( np ) ! leaf P in g P m-2 leaf if ( ivt . EQ . 7 . OR . ivt . EQ . 10 ) then ! special for C4 grass: scale value from  parameter file veg % vcmax ( np ) = real ( casabiome % vcmax_scalar ( ivt )) * 1.0e-5 veg % ejmax ( np ) = 2.0 * veg % vcmax ( np ) ! not used for C4 elseif ( ivt . eq . 1 ) then ! account here for spring recovery veg % vcmax ( np ) = real ( vcmax_np ( nleafx ( np ), pleafx ( np )) * & casabiome % vcmax_scalar ( ivt ) * real ( climate % frec ( np ), r_2 ) ) veg % ejmax ( np ) = veg % bjv ( np ) * veg % vcmax ( np ) else veg % vcmax ( np ) = real ( vcmax_np ( nleafx ( np ), pleafx ( np )) * & casabiome % vcmax_scalar ( ivt ) ) veg % ejmax ( np ) = veg % bjv ( np ) * veg % vcmax ( np ) endif veg % c4kci ( np ) = effc4 * veg % vcmax ( np ) ! not used for C3 plants ! adjust Vcmax and Jmax accounting for gm if ( cable_user % explicit_gm ) then ! establish a relationship between gmmax and Vcmax if ( ivt . EQ . 7 . OR . ivt . EQ . 10 ) then ! no changes for C4 plants vcmax_ref ( np ) = veg % vcmax ( np ) else ! Vcmax_ref as Vcmax with mean nutrient concentrations ! nleafx = ncleafx/sla ! ncleafx = (casabiome%ratioNCplantmin(ivt,leaf) + casabiome%ratioNCplantmax(ivt,leaf)) / 2.0_r_2 if ( icycle > 1 ) then vcmax_ref ( np ) = real ( & vcmax_np ( & ( ( casabiome % ratioNCplantmin ( ivt , leaf ) + & casabiome % ratioNCplantmax ( ivt , leaf )) / 2.0_r_2 ) / & casabiome % sla ( ivt ), pleafx ( np ) ) * & casabiome % vcmax_scalar ( ivt ) ) endif if ( icycle > 2 ) then ! pleaf = nleafx / npleafx ! npleafx = casabiome%ratioNPplantmin(ivt,leaf) + casabiome%ratioNPplantmax(ivt,leaf)) / 2.0_r_2 vcmax_ref ( np ) = real ( & vcmax_np ( & ( ( casabiome % ratioNCplantmin ( ivt , leaf ) + & casabiome % ratioNCplantmax ( ivt , leaf )) / 2.0_r_2 ) / & casabiome % sla ( ivt ), & ( ( casabiome % ratioNCplantmin ( ivt , leaf ) + & casabiome % ratioNCplantmax ( ivt , leaf )) / 2.0_r_2 ) / & casabiome % sla ( ivt ) / & ( casabiome % ratioNPplantmin ( ivt , leaf ) + & casabiome % ratioNPplantmax ( ivt , leaf )) / 2.0_r_2 ) * & casabiome % vcmax_scalar ( ivt ) ) endif endif ! slopes from database as presented in Knauer et al. 2019, GCB if ( ivt . EQ . 1 . OR . ivt . EQ . 3 ) then gm_vcmax_slope = 0.0035e6_r_2 else gm_vcmax_slope = 0.0020e6_r_2 endif veg % gm ( np ) = veg % gmmax ( np ) + & gm_vcmax_slope * ( veg % vcmax ( np ) - vcmax_ref ( np )) !if (.not. veg%is_read_gmLUT) then  ! not working !if (ABS(vcmaxx(np) - veg%vcmax(np)) .GT. 1.0E-08 .OR. ktau==1) then if ( ktau == 1 ) then ! C4 plants: first time step only because Vcmax does not change with N call adjust_k_Collatz ( veg , np ) endif ! adjust parameters if ( len ( trim ( cable_user % gm_LUT_file )) . gt . 1 ) then call find_Vcmax_Jmax_LUT ( veg , np , LUT_VcmaxJmax , LUT_gm , & LUT_vcmax , LUT_Rd ) else ! no LUT, adjustment using An-Ci curves if ( ( abs ( vcmaxx ( ivt ) - veg % vcmax ( np )) > 5.0E-08 ) . OR . & ( ktau < ktauday ) ) then vcmaxx ( ivt ) = veg % vcmax ( np ) ! The approach by Sun et al. 2014 is replaced with a subroutine ! based on Knauer et al. 2019, GCB call adjust_JV_gm ( veg , np ) endif endif ! recalculate bjvref bjvci ( np ) = veg % bjv ( np ) ! temporarily save Ci-based bjv veg % bjv ( np ) = veg % ejmaxcc ( np ) / veg % vcmaxcc ( np ) ! recalculate relcost_J in a way that Neff is the same with ! finite (explicit) and infinite (implicit) gm if ( coord ) then relcostJCi = PHOTO % relcostJ_coord else relcostJCi = PHOTO % relcostJ_optim endif Nefftmp ( np ) = veg % vcmax ( np ) + relcostJCi * bjvci ( np ) * & veg % vcmax ( np ) / 4.0 relcostJ ( np ) = 1.0 / ( veg % bjv ( np ) * veg % vcmaxcc ( np ) / 4.0 ) * & ( Nefftmp ( np ) - veg % vcmaxcc ( np )) else ! infinite gm if ( coord ) then relcostJ (:) = PHOTO % relcostJ_coord else relcostJ (:) = PHOTO % relcostJ_optim endif endif else ! cable_user%vcmax .eq. 'standard' or 'Walker2014' write ( * , * ) 'invalid vcmax flag' #ifdef __MPI__ call MPI_Abort ( 0 , 91 , ierr ) ! Do not know comm nor rank here #else stop 91 #endif endif ! cable_user%vcmax ENDDO ! np=1, mp ! JK: whole routine is now called once per day ! if (mod(ktau, ktauday) ==1) then if ( cable_user % coordinate_photosyn ) then CALL optimise_JV ( veg , climate , ktauday , veg % bjv , relcostJ ) else if ( cable_user % explicit_gm ) then veg % vcmax_shade = veg % vcmaxcc veg % ejmax_shade = veg % ejmaxcc veg % vcmax_sun = veg % vcmaxcc veg % ejmax_sun = veg % ejmaxcc else veg % vcmax_shade = veg % vcmax veg % ejmax_shade = veg % ejmax veg % vcmax_sun = veg % vcmax veg % ejmax_sun = veg % ejmax endif endif END SUBROUTINE casa_feedback SUBROUTINE sumcflux ( ktau , kstart , dels , canopy , & sum_flux , casaflux , l_vcmaxFeedbk ) USE cable_def_types_mod USE cable_carbon_module USE casadimension USE casaparm USE casavariable IMPLICIT NONE INTEGER , INTENT ( IN ) :: ktau ! integration step number INTEGER , INTENT ( IN ) :: kstart ! starting value of ktau !  INTEGER, INTENT(IN)    :: mvtype  ! Number of veg types !  INTEGER, INTENT(IN)    :: mstype ! Number of soil types REAL , INTENT ( IN ) :: dels ! time setp size (s) TYPE ( canopy_type ), INTENT ( INOUT ) :: canopy TYPE ( sum_flux_type ), INTENT ( INOUT ) :: sum_flux TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux LOGICAL , INTENT ( IN ) :: l_vcmaxFeedbk ! using prognostic Vcmax !   if(icycle<=0) then !     these are executed in cbm !      CALL soilcarb(soil, ssoil, veg, bgc, met, canopy) !      CALL carbon_pl(dels, soil, ssoil, veg, canopy, bgc) !   else if ( icycle > 0 ) then canopy % frp (:) = real (( casaflux % crmplant (:, wood ) + casaflux % crmplant (:, froot ) + & casaflux % crgplant (:)) / 8640 0.0_r_2 ) canopy % frs (:) = real ( casaflux % Crsoil (:) / 8640 0.0_r_2 ) canopy % frpw (:) = real ( casaflux % crmplant (:, wood ) / 8640 0.0_r_2 ) canopy % frpr (:) = real ( casaflux % crmplant (:, froot ) / 8640 0.0_r_2 ) endif if ( ktau == kstart ) then sum_flux % sumpn = canopy % fpn * dels sum_flux % sumrd = canopy % frday * dels sum_flux % dsumpn = canopy % fpn * dels sum_flux % dsumrd = canopy % frday * dels sum_flux % sumrpw = canopy % frpw * dels sum_flux % sumrpr = canopy % frpr * dels sum_flux % sumrp = canopy % frp * dels sum_flux % dsumrp = canopy % frp * dels ! canopy%frs set in soilcarb sum_flux % sumrs = canopy % frs * dels else sum_flux % sumpn = sum_flux % sumpn + canopy % fpn * dels sum_flux % sumrd = sum_flux % sumrd + canopy % frday * dels sum_flux % dsumpn = sum_flux % dsumpn + canopy % fpn * dels sum_flux % dsumrd = sum_flux % dsumrd + canopy % frday * dels sum_flux % sumrpw = sum_flux % sumrpw + canopy % frpw * dels sum_flux % sumrpr = sum_flux % sumrpr + canopy % frpr * dels sum_flux % sumrp = sum_flux % sumrp + canopy % frp * dels sum_flux % dsumrp = sum_flux % dsumrp + canopy % frp * dels ! canopy%frs set in soilcarb sum_flux % sumrs = sum_flux % sumrs + canopy % frs * dels endif ! Set net ecosystem exchange after adjustments to frs: canopy % fnpp = - 1.0 * canopy % fpn - canopy % frp IF ( icycle <= 1 ) THEN canopy % fnee = canopy % fpn + canopy % frs + canopy % frp ELSE IF ( l_vcmaxFeedbk ) THEN canopy % fnee = canopy % fpn + canopy % frs + canopy % frp & + real ( casaflux % clabloss (:) / 8640 0.0_r_2 ) ELSE canopy % fnee = real (( casaflux % Crsoil - casaflux % cnpp + & casaflux % clabloss ) / 8640 0.0_r_2 ) ENDIF ENDIF END SUBROUTINE sumcflux SUBROUTINE totcnppools ( kloop , veg , casamet , casapool , bmcplant , bmnplant , bmpplant , bmclitter , bmnlitter , bmplitter , & bmcsoil , bmnsoil , bmpsoil , bmnsoilmin , bmpsoillab , bmpsoilsorb , bmpsoilocc , bmarea ) ! this subroutine is temporary, and its needs to be modified for multiple tiles within a cell USE cable_def_types_mod USE casadimension USE casaparm USE casavariable IMPLICIT NONE INTEGER , INTENT ( IN ) :: kloop TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg ! vegetation parameters TYPE ( casa_pool ), INTENT ( IN ) :: casapool TYPE ( casa_met ), INTENT ( IN ) :: casamet real , dimension ( 5 , mvtype , mplant ) :: bmcplant , bmnplant , bmpplant real , dimension ( 5 , mvtype , mlitter ) :: bmclitter , bmnlitter , bmplitter real , dimension ( 5 , mvtype , msoil ) :: bmcsoil , bmnsoil , bmpsoil real , dimension ( 5 , mvtype ) :: bmnsoilmin , bmpsoillab , bmpsoilsorb , bmpsoilocc real , dimension ( mvtype ) :: bmarea ! local variables INTEGER npt , nvt bmcplant ( kloop ,:,:) = 0.0 bmnplant ( kloop ,:,:) = 0.0 bmpplant ( kloop ,:,:) = 0.0 bmclitter ( kloop ,:,:) = 0.0 bmnlitter ( kloop ,:,:) = 0.0 bmplitter ( kloop ,:,:) = 0.0 bmcsoil ( kloop ,:,:) = 0.0 bmnsoil ( kloop ,:,:) = 0.0 bmpsoil ( kloop ,:,:) = 0.0 bmnsoilmin ( kloop ,:) = 0.0 bmpsoillab ( kloop ,:) = 0.0 bmpsoilsorb ( kloop ,:) = 0.0 bmpsoilocc ( kloop ,:) = 0.0 bmarea (:) = 0.0 do npt = 1 , mp nvt = veg % iveg ( npt ) bmcplant ( kloop , nvt ,:) = bmcplant ( kloop , nvt ,:) + real ( casapool % cplant ( npt ,:) * casamet % areacell ( npt )) bmnplant ( kloop , nvt ,:) = bmnplant ( kloop , nvt ,:) + real ( casapool % nplant ( npt ,:) * casamet % areacell ( npt )) bmpplant ( kloop , nvt ,:) = bmpplant ( kloop , nvt ,:) + real ( casapool % pplant ( npt ,:) * casamet % areacell ( npt )) bmclitter ( kloop , nvt ,:) = bmclitter ( kloop , nvt ,:) + real ( casapool % clitter ( npt ,:) * casamet % areacell ( npt )) bmnlitter ( kloop , nvt ,:) = bmnlitter ( kloop , nvt ,:) + real ( casapool % nlitter ( npt ,:) * casamet % areacell ( npt )) bmplitter ( kloop , nvt ,:) = bmplitter ( kloop , nvt ,:) + real ( casapool % plitter ( npt ,:) * casamet % areacell ( npt )) bmcsoil ( kloop , nvt ,:) = bmcsoil ( kloop , nvt ,:) + real ( casapool % csoil ( npt ,:) * casamet % areacell ( npt )) bmnsoil ( kloop , nvt ,:) = bmnsoil ( kloop , nvt ,:) + real ( casapool % nsoil ( npt ,:) * casamet % areacell ( npt )) bmpsoil ( kloop , nvt ,:) = bmpsoil ( kloop , nvt ,:) + real ( casapool % psoil ( npt ,:) * casamet % areacell ( npt )) bmnsoilmin ( kloop , nvt ) = bmnsoilmin ( kloop , nvt ) + real ( casapool % nsoilmin ( npt ) * casamet % areacell ( npt )) bmpsoillab ( kloop , nvt ) = bmpsoillab ( kloop , nvt ) + real ( casapool % psoillab ( npt ) * casamet % areacell ( npt )) bmpsoilsorb ( kloop , nvt ) = bmpsoilsorb ( kloop , nvt ) + real ( casapool % psoilsorb ( npt ) * casamet % areacell ( npt )) bmpsoilocc ( kloop , nvt ) = bmpsoilocc ( kloop , nvt ) + real ( casapool % psoilocc ( npt ) * casamet % areacell ( npt )) bmarea ( nvt ) = bmarea ( nvt ) + real ( casamet % areacell ( npt )) enddo do nvt = 1 , mvtype bmcplant ( kloop , nvt ,:) = bmcplant ( kloop , nvt ,:) / bmarea ( nvt ) bmnplant ( kloop , nvt ,:) = bmnplant ( kloop , nvt ,:) / bmarea ( nvt ) bmpplant ( kloop , nvt ,:) = bmpplant ( kloop , nvt ,:) / bmarea ( nvt ) bmclitter ( kloop , nvt ,:) = bmclitter ( kloop , nvt ,:) / bmarea ( nvt ) bmnlitter ( kloop , nvt ,:) = bmnlitter ( kloop , nvt ,:) / bmarea ( nvt ) bmplitter ( kloop , nvt ,:) = bmplitter ( kloop , nvt ,:) / bmarea ( nvt ) bmcsoil ( kloop , nvt ,:) = bmcsoil ( kloop , nvt ,:) / bmarea ( nvt ) bmnsoil ( kloop , nvt ,:) = bmnsoil ( kloop , nvt ,:) / bmarea ( nvt ) bmpsoil ( kloop , nvt ,:) = bmpsoil ( kloop , nvt ,:) / bmarea ( nvt ) bmnsoilmin ( kloop , nvt ) = bmnsoilmin ( kloop , nvt ) / bmarea ( nvt ) bmpsoillab ( kloop , nvt ) = bmpsoillab ( kloop , nvt ) / bmarea ( nvt ) bmpsoilsorb ( kloop , nvt ) = bmpsoilsorb ( kloop , nvt ) / bmarea ( nvt ) bmpsoilocc ( kloop , nvt ) = bmpsoilocc ( kloop , nvt ) / bmarea ( nvt ) enddo END SUBROUTINE totcnppools SUBROUTINE analyticpool ( veg , soil , casabiome , casapool , & casaflux , casamet , casabal , & avgcleaf2met , avgcleaf2str , avgcroot2met , avgcroot2str , avgcwood2cwd , & avgnleaf2met , avgnleaf2str , avgnroot2met , avgnroot2str , avgnwood2cwd , & avgpleaf2met , avgpleaf2str , avgproot2met , avgproot2str , avgpwood2cwd , & avgcnpp , & avgxkNlimiting , avgxklitter , avgxksoil , & avgratioNCsoilmic , avgratioNCsoilslow , avgratioNCsoilpass , & avgnsoilmin , avgpsoillab , avgpsoilsorb , avgpsoilocc , & avg_c13leaf2met , avg_c13leaf2str , avg_c13root2met , & avg_c13root2str , avg_c13wood2cwd , c13o2pools ) USE cable_def_types_mod USE cable_carbon_module USE casadimension USE casaparm USE casavariable use cable_common_module , only : cable_user ! 13C use cable_c13o2_def , only : c13o2_pool implicit none type ( veg_parameter_type ), intent ( in ) :: veg ! vegetation parameters type ( soil_parameter_type ), intent ( in ) :: soil ! soil parameters type ( casa_biome ), intent ( in ) :: casabiome type ( casa_pool ), intent ( inout ) :: casapool type ( casa_flux ), intent ( inout ) :: casaflux type ( casa_met ), intent ( in ) :: casamet type ( casa_balance ), intent ( inout ) :: casabal real ( r_2 ), dimension ( mp ), intent ( in ) :: avgcleaf2met , avgcleaf2str , avgcroot2met , avgcroot2str , avgcwood2cwd real ( r_2 ), dimension ( mp ), intent ( in ) :: avgnleaf2met , avgnleaf2str , avgnroot2met , avgnroot2str , avgnwood2cwd real ( r_2 ), dimension ( mp ), intent ( in ) :: avgpleaf2met , avgpleaf2str , avgproot2met , avgproot2str , avgpwood2cwd real ( r_2 ), dimension ( mp ), intent ( in ) :: avgcnpp real ( r_2 ), dimension ( mp ), intent ( in ) :: avgxkNlimiting , avgxklitter , avgxksoil real ( r_2 ), dimension ( mp ), intent ( in ) :: avgratioNCsoilmic , avgratioNCsoilslow , avgratioNCsoilpass real ( r_2 ), dimension ( mp ), intent ( in ) :: avgnsoilmin , avgpsoillab , avgpsoilsorb , avgpsoilocc real ( r_2 ), dimension ( mp ), intent ( in ) :: avg_c13leaf2met , avg_c13leaf2str real ( r_2 ), dimension ( mp ), intent ( in ) :: avg_c13root2met , avg_c13root2str , avg_c13wood2cwd ! 13C type ( c13o2_pool ), intent ( inout ) :: c13o2pools ! local variables real ( r_2 ), dimension ( mso ) :: Psorder , xPsoil50 ! , Pweasoil real ( r_2 ), dimension ( mso ) :: fracPlab , fracPocc ! , fracPsorb, fracPorg real ( r_2 ), dimension ( mp ) :: totPsoil integer :: npt ! Soiltype     soilnumber soil P(g P/m2) ! Alfisol     1       61.3 ! Andisol     2       103.9 ! Aridisol    3       92.8 ! Entisol     4       136.9 ! Gellisol    5       98.2 ! Histosol    6       107.6 ! Inceptisol  7       84.1 ! Mollisol    8       110.1 ! Oxisol      9       35.4 ! Spodosol    10      41.0 ! Ultisol     11      51.5 ! Vertisol    12      190.6 data Psorder / 6 1.3_r_2 , 10 3.9_r_2 , 9 2.8_r_2 , 13 6.9_r_2 , 9 8.2_r_2 , 10 7.6_r_2 , 8 4.1_r_2 , & 11 0.1_r_2 , 3 5.4_r_2 , 4 1.0_r_2 , 5 1.5_r_2 , 19 0.6_r_2 / ! data Pweasoil/0.05_r_2, 0.04_r_2, 0.03_r_2, 0.02_r_2, 0.01_r_2, 0.009_r_2, 0.008_r_2, & !      0.007_r_2, 0.006_r_2, 0.005_r_2, 0.004_r_2, 0.003_r_2/ data fracPlab / 0.08_r_2 , 0.08_r_2 , 0.10_r_2 , 0.02_r_2 , 0.08_r_2 , 0.08_r_2 , 0.08_r_2 , & 0.06_r_2 , 0.02_r_2 , 0.05_r_2 , 0.09_r_2 , 0.05_r_2 / ! data fracPsorb/0.32_r_2, 0.37_r_2, 0.57_r_2, 0.67_r_2, 0.37_r_2, 0.37_r_2, 0.37_r_2, & !      0.32_r_2, 0.24_r_2, 0.22_r_2, 0.21_r_2, 0.38_r_2/ data fracPocc / 0.36_r_2 , 0.38_r_2 , 0.25_r_2 , 0.26_r_2 , 0.38_r_2 , 0.38_r_2 , 0.38_r_2 , & 0.44_r_2 , 0.38_r_2 , 0.38_r_2 , 0.37_r_2 , 0.45_r_2 / ! data fracPorg/0.25_r_2, 0.17_r_2, 0.08_r_2, 0.05_r_2, 0.17_r_2, 0.17_r_2, 0.17_r_2, & !      0.18_r_2, 0.36_r_2, 0.35_r_2, 0.34_r_2, 0.12_r_2/ data xPsoil50 / 7.6_r_2 , 4.1_r_2 , 4.2_r_2 , 3.4_r_2 , 4.1_r_2 , 4.1_r_2 , 4.8_r_2 , 4.1_r_2 , & 6.9_r_2 , 6.9_r_2 , 6.9_r_2 , 1.7_r_2 / ! compute the mean litter input in g(C, N and P)/day from plant pools casaflux % fromLtoS = 0.0_r_2 casaflux % fromStoS = 0.0_r_2 casabal % sumcbal (:) = 0.0_r_2 casabal % sumnbal (:) = 0.0_r_2 casabal % sumpbal (:) = 0.0_r_2 do npt = 1 , mp if (( casamet % iveg2 ( npt ) /= icewater ) . and . ( avgcnpp ( npt ) > 0.0_r_2 )) then casaflux % fromLtoS ( npt , mic , metb ) = 0.45_r_2 ! metb -> mic casaflux % fromLtoS ( npt , mic , str ) = 0.45_r_2 * ( 1.0_r_2 - casabiome % fracLigninplant ( veg % iveg ( npt ), leaf )) ! str -> mic casaflux % fromLtoS ( npt , slow , str ) = 0.7_r_2 * casabiome % fracLigninplant ( veg % iveg ( npt ), leaf ) ! str -> slow casaflux % fromLtoS ( npt , mic , cwd ) = 0.40_r_2 * ( 1.0_r_2 - casabiome % fracLigninplant ( veg % iveg ( npt ), wood )) ! CWD -> fmic casaflux % fromLtoS ( npt , slow , cwd ) = 0.7_r_2 * casabiome % fracLigninplant ( veg % iveg ( npt ), wood ) ! CWD -> slow !! set the following two backflow to set (see Bolker 199x) !    casaflux%fromStoS(npt,mic,slow)  = 0.45_r_2 * (0.997_r_2 - 0.009_r_2 *soil%clay(npt)) !    casaflux%fromStoS(npt,mic,pass)  = 0.45_r_2 casaflux % fromStoS ( npt , slow , mic ) = ( 0.85_r_2 - 0.68_r_2 * ( soil % clay ( npt ) + soil % silt ( npt ))) & * ( 0.997_r_2 - 0.032_r_2 * soil % clay ( npt )) casaflux % fromStoS ( npt , pass , mic ) = ( 0.85_r_2 - 0.68_r_2 * ( soil % clay ( npt ) + soil % silt ( npt ))) & * ( 0.003_r_2 + 0.032_r_2 * soil % clay ( npt )) casaflux % fromStoS ( npt , pass , slow ) = 0.45_r_2 * ( 0.003_r_2 + 0.009_r_2 * soil % clay ( npt ) ) casaflux % klitter ( npt , metb ) = avgxkNlimiting ( npt ) * avgxklitter ( npt ) * casabiome % litterrate ( veg % iveg ( npt ), metb ) casaflux % klitter ( npt , str ) = avgxkNlimiting ( npt ) * avgxklitter ( npt ) * casabiome % litterrate ( veg % iveg ( npt ), str ) * & exp ( - 3.0_r_2 * casabiome % fracLigninplant ( veg % iveg ( npt ), leaf )) casaflux % klitter ( npt , cwd ) = avgxkNlimiting ( npt ) * avgxklitter ( npt ) * casabiome % litterrate ( veg % iveg ( npt ), cwd ) casaflux % ksoil ( npt , mic ) = avgxksoil ( npt ) * casabiome % soilrate ( veg % iveg ( npt ), mic ) * & ( 1.0_r_2 - 0.75_r_2 * ( soil % silt ( npt ) + soil % clay ( npt ))) casaflux % ksoil ( npt , slow ) = avgxksoil ( npt ) * casabiome % soilrate ( veg % iveg ( npt ), slow ) casaflux % ksoil ( npt , pass ) = avgxksoil ( npt ) * casabiome % soilrate ( veg % iveg ( npt ), pass ) if ( veg % iveg ( npt ) == cropland ) then ! for cultivated land type casaflux % ksoil ( npt , mic ) = casaflux % ksoil ( npt , mic ) * 1.25_r_2 casaflux % ksoil ( npt , slow ) = casaflux % ksoil ( npt , slow ) * 1.5_r_2 casaflux % ksoil ( npt , pass ) = casaflux % ksoil ( npt , pass ) * 1.5_r_2 endif endif enddo do npt = 1 , mp if (( casamet % iveg2 ( npt ) /= icewater ) . and . ( avgcnpp ( npt ) > 0.0_r_2 )) then ! MC - Do first P then N and then C so that each equilibrium solution uses the incoming pools not updated yet if ( icycle <= 2 ) then totpsoil ( npt ) = psorder ( casamet % isorder ( npt )) * xpsoil50 ( casamet % isorder ( npt )) ! casapool%plitter(npt,:)= casapool%Nlitter(npt,:)/casapool%ratioNPlitter(npt,:) ! casapool%psoil(npt,:)  = casapool%Nsoil(npt,:)/casapool%ratioNPsoil(npt,:) ! why is this commented here but used in UM casapool % plitter ( npt ,:) = casapool % ratioPClitter ( npt ,:) * casapool % Clitter ( npt ,:) casapool % psoil ( npt ,:) = casapool % ratioPCsoil ( npt ,:) * casapool % Csoil ( npt ,:) casapool % psoillab ( npt ) = totpsoil ( npt ) * fracpLab ( casamet % isorder ( npt )) casapool % psoilsorb ( npt ) = casaflux % psorbmax ( npt ) * casapool % psoillab ( npt ) / & ( casaflux % kmlabp ( npt ) + casapool % psoillab ( npt )) casapool % psoilocc ( npt ) = totpsoil ( npt ) * fracPocc ( casamet % isorder ( npt )) else ! compute the steady-state litter and soil P pools ! casapool%plitter(npt,metb) = (avgpleaf2met(npt)+avgproot2met(npt))/casaflux%klitter(npt,metb) ! casapool%plitter(npt,str) = (avgpleaf2str(npt)+avgproot2str(npt))/casaflux%klitter(npt,str) ! casapool%plitter(npt,cwd) = (avgpwood2cwd(npt))/casaflux%klitter(npt,cwd) ! casapool%psoil(npt,mic) = (casaflux%fromLtoS(npt,mic,metb)*casaflux%klitter(npt,metb)*casapool%clitter(npt,metb) & !      +casaflux%fromLtoS(npt,mic,str) *casaflux%klitter(npt,str)*casapool%clitter(npt,str)  & !      +casaflux%fromLtoS(npt,mic,cwd) *casaflux%klitter(npt,cwd)*casapool%clitter(npt,cwd) ) & !      * (casapool%ratioNCsoil(npt,mic)/casapool%ratioNPsoil(npt,mic))/casaflux%ksoil(npt,mic) ! casapool%psoil(npt,slow) = (casaflux%fromLtoS(npt,slow,metb)*casaflux%klitter(npt,metb)*casapool%clitter(npt,metb) & !      + casaflux%fromLtoS(npt,slow,str)*casaflux%klitter(npt,str)*casapool%clitter(npt,str) & !      + casaflux%fromLtoS(npt,slow,cwd)*casaflux%klitter(npt,cwd)*casapool%clitter(npt,cwd) & !      + casaflux%fromStoS(npt,slow,mic) *casaflux%ksoil(npt,mic) *casapool%csoil(npt,mic)  ) & !      * (casapool%ratioNCsoil(npt,slow)/casapool%ratioNPsoil(npt,slow))/casaflux%ksoil(npt,slow) ! casapool%psoil(npt,pass) = (casaflux%fromStoS(npt,pass,mic) *casaflux%ksoil(npt,mic) *casapool%csoil(npt,mic) & !      +casaflux%fromStoS(npt,pass,slow)*casaflux%ksoil(npt,slow)*casapool%csoil(npt,slow) ) & !      *  (casapool%ratioNCsoil(npt,pass)/casapool%ratioNPsoil(npt,pass))/casaflux%ksoil(npt,pass) casapool % plitter ( npt , metb ) = ( avgpleaf2met ( npt ) + avgproot2met ( npt )) / casaflux % klitter ( npt , metb ) casapool % plitter ( npt , str ) = ( avgpleaf2str ( npt ) + avgproot2str ( npt )) / casaflux % klitter ( npt , str ) casapool % plitter ( npt , cwd ) = avgpwood2cwd ( npt ) / casaflux % klitter ( npt , cwd ) casapool % psoil ( npt , pass ) = ( casaflux % fromStoS ( npt , pass , mic ) * casaflux % ksoil ( npt , mic ) * & casapool % Nsoil ( npt , mic ) + & casaflux % fromStoS ( npt , pass , slow ) * casaflux % ksoil ( npt , slow ) * casapool % Nsoil ( npt , slow )) / & casapool % ratioNPsoil ( npt , pass ) / casaflux % ksoil ( npt , pass ) casapool % psoil ( npt , slow ) = ( casaflux % fromLtoS ( npt , slow , metb ) * casaflux % klitter ( npt , metb ) * & casapool % Nlitter ( npt , metb ) + & casaflux % fromLtoS ( npt , slow , str ) * casaflux % klitter ( npt , str ) * casapool % Nlitter ( npt , str ) + & casaflux % fromLtoS ( npt , slow , cwd ) * casaflux % klitter ( npt , cwd ) * casapool % Nlitter ( npt , cwd ) + & casaflux % fromStoS ( npt , slow , mic ) * casaflux % ksoil ( npt , mic ) * casapool % Nsoil ( npt , mic )) / & casapool % ratioNPsoil ( npt , slow ) / casaflux % ksoil ( npt , slow ) casapool % psoil ( npt , mic ) = ( casaflux % fromLtoS ( npt , mic , metb ) * casaflux % klitter ( npt , metb ) * & casapool % Nlitter ( npt , metb ) + & casaflux % fromLtoS ( npt , mic , str ) * casaflux % klitter ( npt , str ) * casapool % Nlitter ( npt , str ) + & casaflux % fromLtoS ( npt , mic , cwd ) * casaflux % klitter ( npt , cwd ) * casapool % Nlitter ( npt , cwd )) / & casapool % ratioNPsoil ( npt , mic ) / casaflux % ksoil ( npt , mic ) ! assign the mineral pools casapool % psoillab ( npt ) = avgpsoillab ( npt ) casapool % psoilsorb ( npt ) = avgPsoilsorb ( npt ) casapool % psoilocc ( npt ) = avgPsoilocc ( npt ) endif ! icycle<=2 if ( icycle <= 1 ) then casapool % nlitter ( npt ,:) = casapool % ratioNClitter ( npt ,:) * casapool % Clitter ( npt ,:) casapool % nsoil ( npt ,:) = casapool % ratioNCsoil ( npt ,:) * casapool % Csoil ( npt ,:) casapool % nsoilmin ( npt ) = 2.0_r_2 casabal % sumnbal ( npt ) = 0.0_r_2 else ! compute steady-state litter and soil N pool sizes casapool % nlitter ( npt , metb ) = ( avgnleaf2met ( npt ) + avgnroot2met ( npt )) / casaflux % klitter ( npt , metb ) casapool % nlitter ( npt , str ) = ( avgnleaf2str ( npt ) + avgnroot2str ( npt )) / casaflux % klitter ( npt , str ) casapool % nlitter ( npt , cwd ) = avgnwood2cwd ( npt ) / casaflux % klitter ( npt , cwd ) casapool % nsoil ( npt , pass ) = ( casaflux % fromStoS ( npt , pass , mic ) * casaflux % ksoil ( npt , mic ) * & casapool % csoil ( npt , mic ) + & casaflux % fromStoS ( npt , pass , slow ) * casaflux % ksoil ( npt , slow ) * casapool % csoil ( npt , slow )) * & avgratioNCsoilpass ( npt ) / casaflux % ksoil ( npt , pass ) casapool % nsoil ( npt , slow ) = ( casaflux % fromLtoS ( npt , slow , metb ) * casaflux % klitter ( npt , metb ) * & casapool % clitter ( npt , metb ) + & casaflux % fromLtoS ( npt , slow , str ) * casaflux % klitter ( npt , str ) * casapool % clitter ( npt , str ) + & casaflux % fromLtoS ( npt , slow , cwd ) * casaflux % klitter ( npt , cwd ) * casapool % clitter ( npt , cwd ) + & casaflux % fromStoS ( npt , slow , mic ) * casaflux % ksoil ( npt , mic ) * casapool % csoil ( npt , mic )) * & avgratioNCsoilslow ( npt ) / casaflux % ksoil ( npt , slow ) casapool % nsoil ( npt , mic ) = ( casaflux % fromLtoS ( npt , mic , metb ) * casaflux % klitter ( npt , metb ) * & casapool % clitter ( npt , metb ) + & casaflux % fromLtoS ( npt , mic , str ) * casaflux % klitter ( npt , str ) * casapool % clitter ( npt , str ) + & casaflux % fromLtoS ( npt , mic , cwd ) * casaflux % klitter ( npt , cwd ) * casapool % clitter ( npt , cwd )) * & avgratioNCsoilmic ( npt ) / casaflux % ksoil ( npt , mic ) casapool % Nsoilmin ( npt ) = avgnsoilmin ( npt ) endif ! icycle<=1 ! compute steady-state litter and soil C pool sizes casapool % clitter ( npt , metb ) = ( avgcleaf2met ( npt ) + avgcroot2met ( npt )) / casaflux % klitter ( npt , metb ) casapool % clitter ( npt , str ) = ( avgcleaf2str ( npt ) + avgcroot2str ( npt )) / casaflux % klitter ( npt , str ) casapool % clitter ( npt , cwd ) = avgcwood2cwd ( npt ) / casaflux % klitter ( npt , cwd ) ! MC - Changed the order so that SS is calculated with old pools instead of already !      updated mic and slow pools. !      Before, first mic then slow then pass were updated, where slow uses the mic pool and !      pass uses the mic and slow pools. !      Now we do: pass, slow, mic so that they are using the not-yet updated pools. casapool % csoil ( npt , pass ) = ( casaflux % fromStoS ( npt , pass , mic ) * casaflux % ksoil ( npt , mic ) * & casapool % csoil ( npt , mic ) + & casaflux % fromStoS ( npt , pass , slow ) * casaflux % ksoil ( npt , slow ) * casapool % csoil ( npt , slow )) / & casaflux % ksoil ( npt , pass ) casapool % csoil ( npt , slow ) = ( casaflux % fromLtoS ( npt , slow , metb ) * casaflux % klitter ( npt , metb ) * & casapool % clitter ( npt , metb ) + & casaflux % fromLtoS ( npt , slow , str ) * casaflux % klitter ( npt , str ) * casapool % clitter ( npt , str ) + & casaflux % fromLtoS ( npt , slow , cwd ) * casaflux % klitter ( npt , cwd ) * casapool % clitter ( npt , cwd ) + & casaflux % fromStoS ( npt , slow , mic ) * casaflux % ksoil ( npt , mic ) * casapool % csoil ( npt , mic )) / & casaflux % ksoil ( npt , slow ) casapool % csoil ( npt , mic ) = ( casaflux % fromLtoS ( npt , mic , metb ) * casaflux % klitter ( npt , metb ) * & casapool % clitter ( npt , metb ) + & casaflux % fromLtoS ( npt , mic , str ) * casaflux % klitter ( npt , str ) * casapool % clitter ( npt , str ) + & casaflux % fromLtoS ( npt , mic , cwd ) * casaflux % klitter ( npt , cwd ) * casapool % clitter ( npt , cwd )) / & casaflux % ksoil ( npt , mic ) casabal % clitterlast ( npt ,:) = casapool % clitter ( npt ,:) casabal % csoillast ( npt ,:) = casapool % csoil ( npt ,:) ! 13C if ( cable_user % c13o2 ) then c13o2pools % clitter ( npt , metb ) = ( avg_c13leaf2met ( npt ) + avg_c13root2met ( npt ) ) / casaflux % klitter ( npt , metb ) c13o2pools % clitter ( npt , str ) = ( avg_c13leaf2str ( npt ) + avg_c13root2str ( npt ) ) / casaflux % klitter ( npt , str ) c13o2pools % clitter ( npt , cwd ) = avg_c13wood2cwd ( npt ) / casaflux % klitter ( npt , cwd ) c13o2pools % csoil ( npt , pass ) = & ( casaflux % fromStoS ( npt , pass , mic ) * casaflux % ksoil ( npt , mic ) * c13o2pools % csoil ( npt , mic ) + & casaflux % fromStoS ( npt , pass , slow ) * casaflux % ksoil ( npt , slow ) * c13o2pools % csoil ( npt , slow ) ) / & casaflux % ksoil ( npt , pass ) c13o2pools % csoil ( npt , slow ) = & ( casaflux % fromLtoS ( npt , slow , metb ) * casaflux % klitter ( npt , metb ) * c13o2pools % clitter ( npt , metb ) + & casaflux % fromLtoS ( npt , slow , str ) * casaflux % klitter ( npt , str ) * c13o2pools % clitter ( npt , str ) + & casaflux % fromLtoS ( npt , slow , cwd ) * casaflux % klitter ( npt , cwd ) * c13o2pools % clitter ( npt , cwd ) + & casaflux % fromStoS ( npt , slow , mic ) * casaflux % ksoil ( npt , mic ) * c13o2pools % csoil ( npt , mic ) ) / & casaflux % ksoil ( npt , slow ) c13o2pools % csoil ( npt , mic ) = & ( casaflux % fromLtoS ( npt , mic , metb ) * casaflux % klitter ( npt , metb ) * c13o2pools % clitter ( npt , metb ) + & casaflux % fromLtoS ( npt , mic , str ) * casaflux % klitter ( npt , str ) * c13o2pools % clitter ( npt , str ) + & casaflux % fromLtoS ( npt , mic , cwd ) * casaflux % klitter ( npt , cwd ) * c13o2pools % clitter ( npt , cwd ) ) / & casaflux % ksoil ( npt , mic ) endif ! 13C endif ! casamet%iveg2/=icewater .and. avgcnpp>0.0 enddo ! npt=1, mp END SUBROUTINE analyticpool end module casa_cable","tags":"","loc":"sourcefile/casa_cable.f90.html"}]}